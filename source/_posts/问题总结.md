---
abbrlink: 1
---
#### String str = "i" 和String str = new String("1")一样吗？

不一样，因为内存的分配方式不一样。String str = "i"的方式JVM会将其分配到常量池中，而String str = new String("i")JVM会将其分配到堆内存中。

#### 20.谈谈你对多态的理解？

多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源代码，就可以让引用变量绑定到各种不同的对象上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。

Java中的hashCode方法就是根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的字段等）映射成一个数值
所以有：
如果两个对象的equals()是true, 那么这两个对象的hashCode就一定相等。
列如：a.equals(b)==true 就一定会有 a.hashCode()==b.hashCode();
反之，两个对象的hashCode相同，他们不一定会equals()==true

注意：
有些设计需要重写equals(),重写equals（）时，最好同时重写hashCode（）
因为在HashSet、HashMap以及HashTable这些中，一般是先判断列表中是否有hashCode，如果有才会用equals（）判断是否相等的。
hashCode没有重写，如果在第一步判断就失败了，equals（）就不会判断了。
所以：
equals方法和hashCode方法始终在逻辑上保持一致性

结论：
如果两个对象相等，那么他们的hashCode一定相同
如果两个对象的hashCode不相同，那么两个对象就一定不相等
如果两个对象的hashCode相同，两个对象也不一定相等。



![image-20220809152704697](C:\Users\USE66\AppData\Roaming\Typora\typora-user-images\image-20220809152704697.png)

类加载机制其实就是虚拟机把Class文件加载到内存，并对数据进行校验，转换解析和初始化，形成可以被虚拟机直接使用的Java类型，即为java.lang.Class

装载

1通过一个类的**全限定名**获取这个类的二进制字节流

2将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构

3在Java堆中生成一个代表这个类的java.lang.Class对象，作为我们方法区的数据访问入口

链接

1验证：保证我们加载的类的正确性

​	文件格式验证

​	元数据验证

​	字节码验证

​	符号引用验证

2 准备：为类的静态变量分配内存，并为其初始化为当前类型的默认值

private static int a = 1; 那么他在准备阶段 a = 0；

3解析

把类中的符号引用（文件内部的引用关系）转换成直接引用（内存中的引用关系）

初始化

1执行到class init方法，为静态变量赋值。初始化静态代码块，初始化当前类的父类

### JVM 内存结构

##### 栈 存放基础类型以及对堆的对象引用（线程私有）--碗 吃自己碗里的

##### 堆 存放对象 （线程共有） --锅 大家一起吃

##### 程序计数器 记录当前指令执行的位置   --存档

##### 方法区 存放运行时常量池，类信息

##### 本地方法 栈 其他语言编写的，由java运行的
