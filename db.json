{"meta":{"version":1,"warehouse":"4.0.1"},"models":{"Asset":[{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/universe.css","path":"css/universe.css","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/algolia.svg","path":"img/algolia.svg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/chuyin.jpg","path":"img/chuyin.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/patrick.jpg","path":"img/patrick.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/top.jpg","path":"img/top.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/xiangxia.jpg","path":"img/xiangxia.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/zhizhuxia.jpg","path":"img/zhizhuxia.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/universe.js","path":"js/universe.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_data/bangumis.json","hash":"6b101840916949a75ce859928fc16050b96f65a2","modified":1657004448709},{"_id":"source/_data/link.yml","hash":"6aaf04b5c920e403bea8f82e4b3f4d719760e6df","modified":1640339199386},{"_id":"source/about/index.md","hash":"f3673520a3ae57c5010d730ea56b939de74b93a0","modified":1640599080945},{"_id":"source/_posts/Kafka.md","hash":"e7a231a27b563bd3f2c3130fe9ee1850e214ea7c","modified":1658367592408},{"_id":"source/_posts/MarkdownPad 2  操作指南.md","hash":"b2d1bef4122c7e418b490e75c5cb056961a70740","modified":1656650318436},{"_id":"source/_posts/Spring是什么.md","hash":"84f1d2311ee3602d78fb07e4d9b4818c50631a99","modified":1658368825904},{"_id":"source/_posts/以管理员身份在当前目录打开命令行窗口.md","hash":"ee27484b22d021b43977ed249bd1746527504ccf","modified":1656650879774},{"_id":"source/_posts/服务器重装.md","hash":"0e81e343beae0e5110af1c18fefac7fdbe3d35f2","modified":1658477671867},{"_id":"source/_posts/软件开发方法.md","hash":"ac876b48ede10bd14b50c606566e3def5a67e355","modified":1658288815411},{"_id":"source/_posts/重装云服务器之Hexo迁移.md","hash":"f22a8a91e627cb8f89621c14a7b0faeb455207f0","modified":1658478672792},{"_id":"source/_posts/问题整理.md","hash":"98602508f5a52a969e0e5eb72f32eec2460dc059","modified":1657000905850},{"_id":"source/bangumis/index.md","hash":"7f0b9efdd0e30072d741345fd2bdc32b0cf00727","modified":1657004295305},{"_id":"source/categories/index.md","hash":"e68eb92377fe2e8c46c46487e76e9db45b91f166","modified":1640144496960},{"_id":"source/gameboy/index.md","hash":"290a3bf20ac563689199e332601b8d8d2db84182","modified":1657009198245},{"_id":"source/tags/index.md","hash":"6be8a6da63ced1cf4346a97f8bd3ec3ebd96fcd9","modified":1640144518823},{"_id":"source/link/index.md","hash":"914491b51ccf54400e78e4eea4ff15b6144fb29f","modified":1640339151512},{"_id":"source/_posts/Kafka/QQ截图20220110112502.png","hash":"7e4836ec4abccc0c5c18a5bf858e3fdb1071aa82","modified":1654842601000},{"_id":"source/_posts/Kafka/QQ截图20220110122844.png","hash":"228b3667de9f648b494b946ea0befb75ac089f9f","modified":1654842601000},{"_id":"source/_posts/Kafka/QQ截图20220110125233.png","hash":"752a98bf9028ed3555ead503e76a8d65decb3320","modified":1654842601000},{"_id":"source/_posts/Kafka/QQ截图20220110125413.png","hash":"1ec2d87a6d8182707f2351b32b470fd64fd414e7","modified":1654842601000},{"_id":"source/_posts/Kafka/QQ截图20220110134554.png","hash":"ac05987c6f30b2a6f91600695f2a4a4aced0f0e3","modified":1654842601000},{"_id":"source/_posts/Kafka/QQ截图20220110134734.png","hash":"d1e9122ec94650af9454923a9c86ee43d96d425d","modified":1654842601000},{"_id":"source/_posts/Kafka/QQ截图20220110142708.png","hash":"e02d654fc4054e77eb9c397d9ce0cc75717479ae","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210922100205.png","hash":"79b77be85311284ee8105e2863cd10826362ad5c","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210924134715.png","hash":"c9f37d69c172ec7db1daf1140f21915620fa839c","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210922100407.png","hash":"ec835e1a86a86d812c4beafd8de9f2d1dbb1b95c","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210924135030.png","hash":"20ebac7e62956a3547fb82c3185814684e67902f","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210924135616.png","hash":"19adbae926293738c27362edad959ef6a24d6718","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210924141013.png","hash":"784a8938074942ebf6d4ef773b98d17da95a8d3a","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210927092027.png","hash":"7d38c3c9951a64516b1e6e61f2d42fac8112a410","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210927092145.png","hash":"948a658169fc57bf893cb5180f943e30684b805e","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210927092451.png","hash":"8f43a7d97fb3c8742d29745b216964fe46bafe30","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210927092755.png","hash":"ee01b1c95f52040fc7ee6bc4d3946806f7ab82ee","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210927102059.png","hash":"2ade7c5d567f01b80be2b80803600e136ddad50d","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210927112345.png","hash":"e314d4c9a492ebc3230f6bd82a5b01785b152d16","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210927112358.png","hash":"e513766020b35edab177639b6b0acbad2050e74d","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210927112511.png","hash":"1606797614b492b0729928b85e46bd6f0e01a032","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210927113126.png","hash":"f17966bba19024284a4710967ee21011df19e817","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210927113242.png","hash":"4df782d382149457d9b3c2e5dce72036c1216084","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210927113307.png","hash":"2a3fd9fffae968007ab8d225ee625117b021db2d","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210927113948.png","hash":"93c433b05e0d18a5f56c08a67f511c396baa6385","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210927114022.png","hash":"7ebb968d723bad4dc92eba1aec678fc7cfe2666f","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210927114130.png","hash":"e8c0e6d445a1da9696e8a4a013a8ab8b43532a6a","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210927114141.png","hash":"4aafffdcd1f8d3f38f620631c5ef06a151ec54ac","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210928085936.png","hash":"4b16325ae95be541b890bf9bdd7e17b459b6b405","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210928090112.png","hash":"0cc05dfdf33b2fb9a200e5a0bfcd68bd490ac1f0","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210928090249.png","hash":"df056533ff4eb5954c1b0505da55d2ae75bc0f1c","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210928090331.png","hash":"4669666837e96d2cef30f02adc83b249da1ef2ec","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210928090903.png","hash":"3d8522ccf6ba7f96fda390b3c6de5d72d656dfd2","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210928090930.png","hash":"829cd5a43f763ae5f6b86e13a96d0ac934abceb5","modified":1654842601000},{"_id":"source/_posts/yuque/Shell脚本.md","hash":"37a715d6376044da1a473c18da6dec5ed5544a2e","modified":1657000265112},{"_id":"source/_posts/rocketmq/QQ截图20220208101908.png","hash":"320e06be004bfa6bc419b808d2d63d53cc01a767","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208102000.png","hash":"b74a6cc2506ec2d91a0c99eb42644d48c7f2552d","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208104611.png","hash":"5e9510120be99d9bbb67ade2cd3ca6fe36588d62","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208104741.png","hash":"6aab9b97948359c44377ef7cc75804a645ec70c2","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208110201.png","hash":"892668e09dbece38a85c5722efebf5f405841dec","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208110311.png","hash":"7cced357d6b9cbcd736ab5991de83b20d6203628","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208110807.png","hash":"fcd992f97e37054b320b4aa6a463ec21c379c984","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208110900.png","hash":"3b32b81cd22cd89575e1a8ba23d2f95c542a2159","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208110924.png","hash":"9118c8d2627491a5d817e4e4f3df94986e29f951","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208111536.png","hash":"8e7e60334f3915d524b9f97726a33af538d1e8da","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208111646.png","hash":"9a16a3bc8d1af28dcd8825c6526e1f5f110dafcb","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208111700.png","hash":"104c298bb66f568e810acdfdcfbf27f9779f9971","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208111724.png","hash":"2e1115acd643419c02dc3ad33ac3a1874e72ed75","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208111822.png","hash":"20d116e7ea5fa7a33e1402ace8b8879cdd5a1a87","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208113559.png","hash":"56e32636da4078ac6d0ba8b32dfcb8a3c69b238b","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208113758.png","hash":"ebf380e02441900df93a5efccc9acdbc933fe08b","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208121758.png","hash":"412376981092caf186a914d98c8ef9c6f01503ac","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208122608.png","hash":"c769c5a357acef8e775ff50c6e92807f035b54fb","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208123848.png","hash":"f2c649f8df07450f7c31b13a2312aea27aaea244","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208124241.png","hash":"0f231bd4ef647c1e288f6a368faa383e1fc00033","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208134454.png","hash":"9254d5e13d305a8e43ef45eaa67fdebe5c8d81ae","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208134538.png","hash":"29e6759e1f901e5da5803ff677326e8cb45be230","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208135939.png","hash":"2560c7d1fee965a1ef250bea20398a406721849d","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208135949.png","hash":"70dcd0a43c7f27ea38906f7972e599a423b3c0f3","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208140054.png","hash":"23b8cc6fcd0d0a1284b83e897d14382da013e00e","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208140159.png","hash":"ce96b78ccc004c6d5dac7b50b4f129e9259f4a5c","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208140740.png","hash":"a82d2d898a355bf88b7965266c432c0dab6b5292","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208141053.png","hash":"4a35680061195f4da3ca112715661a020cac0364","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208141304.png","hash":"641c1810909368fd38a161b9762c3ca52e33cead","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208142527.png","hash":"016cc40f2aad4f29ceecfa6186a7de0fe698445a","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208142630.png","hash":"80621d1cb48579a22ac152587a20f688f69cadf9","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208142708.png","hash":"fabd55b79889a6e0a5984a7c0bb7ab9f884b4faf","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208142814.png","hash":"b5b3c320c4b16f6ab91ea71d0cc96f1589fa7aa6","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208143050.png","hash":"52eb34f368b90ea383e2b49378e7d562c4052db9","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208143107.png","hash":"87ddccca38df9af09ec25d3cca3bb0c9e8606c1e","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208144842.png","hash":"baf039ec65c508d83c99cd71bea23ff7582c49f8","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208145933.png","hash":"f88ab33215a13f29b44853e4ece118961ffc64c1","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208150004.png","hash":"10061db8b628f81622b9ed29468bbd423e23334f","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208150023.png","hash":"f88b113a6c3c5c72c0206c9e12ed706c5116b2f9","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208152144.png","hash":"b619d45b7b0b12eaafcda85d32b0b2d8c09191ae","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208152224.png","hash":"139ed1a4050b00c178e2df6c3c27388e708cd4b4","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208152417.png","hash":"fbcfaf2f733a129eb29b20faf8787d4ead4d0838","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208153410.png","hash":"0d880a8b7d24f809d4d8ccdb8f3d20bcb5294d6a","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208153523.png","hash":"f83b665175538761c7de12db05a1a5b40909556d","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208153545.png","hash":"e4b65756ea0517137edf05e4f4c8000281490573","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208153635.png","hash":"6982236dda82789c7c48a1ec9da5ed397f9c7ce4","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208154429.png","hash":"608c3ed29541e9f6cea0043bf8258756635c77c2","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208154545.png","hash":"4f05a3f12288f6424369e6830c50af7b49abdd6a","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208155046.png","hash":"6652f15b4e9b0203ab159ffbf36d86dfc8802894","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208160513.png","hash":"42ddae550092b03cfd4dc90dd921fbb1ee77a620","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208160544.png","hash":"1805ed9dce23ddbbbd272d28f724b4ca9aec1715","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208163740.png","hash":"8d3fbb2fa006a9aaeda336937a8a5e1266dca053","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208163826.png","hash":"4bbed34ed92f5b7a8b14c86c5da28819c4ee30f2","modified":1654842601000},{"_id":"source/_posts/rabbitmq.md","hash":"b31cf9aaf699cd92e3cc56602f51741477cecb23","modified":1658368115534},{"_id":"source/_posts/redis/QQ截图20210924134937.png","hash":"3713d70470170f38e173490c422ed0584a44fe39","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210924135855.png","hash":"8c8bf064160f4e8857d8e38e9cd10aa990791b46","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210924135915.png","hash":"46b2bf2e31b33b7df9dddf3aa7f60c6a4465632e","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210924135957.png","hash":"e01495dd5d8ab84b5efcfebbfc99c23eee0b13ea","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210924141532.png","hash":"ae1e319a3eb2e36de727025882c8cda5f92e9d18","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210927092007.png","hash":"196d8faf3b0d1e9082979c4b7fb27fc76eea19ef","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210927094518.png","hash":"02c3f5deac024de3e90f8bea1cb37032aaa1e09d","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210927110129.png","hash":"403d47cccf5885eb17fa9d91ab2e92604e223c49","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210927110152.png","hash":"1d15b2161916d238ea39df7763d8091493358946","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210927111724.png","hash":"157fdbbe9d806b35524a68a49892e884cf2b2206","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210927112441.png","hash":"02f80618a986ace4e2bab56a5cccb17fa03e901b","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210927113113.png","hash":"4a1dcf49b56ca94e394cca00a014700f8ae36eca","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210927113849.png","hash":"2c04dd9af95e155bf047265ec44192783f4d6887","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210928085838.png","hash":"9aa610a5cfec8c490d566dd53a293eb95d63c546","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210928085902.png","hash":"10577ddb6f8506dea45878021538e06fcb4062cc","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210928090032.png","hash":"0114ce100337904ac22a3a73b9ee7e6165788635","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210928091310.png","hash":"c19d06f534c7789da8eb200e8cb4562577e60d7d","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208103522.png","hash":"60f529ce9e263f3fe77988ce51f3b252f4f3735e","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208105007.png","hash":"4194bae8de9a198add7542742a848936a7fd1306","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208105040.png","hash":"894e23c75d44798f9759d4334b28b361bff473a1","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208110713.png","hash":"3a7d4f151cac6d6f1f8397e418ec4923fb8f6149","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208110738.png","hash":"878fdfe8c8aab63c5481ccafe9ea543133837e48","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208110821.png","hash":"c8c3703ea7823385c3894eb5d00c5605ba363560","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208111000.png","hash":"d1fb5b546edb3a42ff92016a607a8427c1e7b69c","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208111351.png","hash":"c49fbff339ecd8dba7724539b9edc77c460d250b","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208111255.png","hash":"265f1cf18c3060dd81e03f6bd0be683a9aa2c455","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208111755.png","hash":"c87d234f70218f505dcd5d0892c52147e7e99c9c","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208122057.png","hash":"c9c46513d5ab98219d2770adee1e98d67bd40891","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208122113.png","hash":"64fcb371ddc2717e5f4a2e2a14f6e20f937b691d","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208124258.png","hash":"6e6a7ac35edc3ceec820283c9f58321de33960b8","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208133814.png","hash":"3dda9a04783901496f5b8280372269f21c2d8cb4","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208134157.png","hash":"929c894d34045cdd4c1d5d79252aef54dfc94a40","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208134415.png","hash":"915bd01337e9ded8fcd3929ffbdd22e9a6d7da73","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208141005.png","hash":"a1931055c5b5ac98618d198cf99e6685f2168dfb","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208141202.png","hash":"697f77802ad96775d9cc1c06ba8b3eb333ee09e4","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208142905.png","hash":"28b1c32f1d7d7362412fb499e4b8331e94ae38d1","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208143837.png","hash":"51b6ebf7411da387864bb466757a6e1e99997976","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208152040.png","hash":"8beccab9fe37c6447ab942fa74e1f2b365d59fb3","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208155359.png","hash":"dd43a7b3493acdee2499d9fe1f7c83b124b6bff1","modified":1654842601000},{"_id":"source/_posts/redis.md","hash":"1b0677eedc9704c897bda7c32b108314543f7581","modified":1658368741371},{"_id":"source/_posts/rocketmq.md","hash":"b897ed42b5fe5f1785183cdcf71dbb9a8074beb8","modified":1658367995803},{"_id":"source/_posts/Kafka/QQ截图20220110133849.png","hash":"d18c2379b86ebd390b7931e3dcf547b528f23602","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210924140800.png","hash":"892b8097ee95e84e737c45d1511a7a3a75ba9871","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210924140055.png","hash":"0275c2b6570bb83824491b9229e0174a19d0653b","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210924140819.png","hash":"2dddbb874a9696323b5437fbe018b900646f3084","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210924140847.png","hash":"f66e3b594814dfda59e3b23465604b6c7d0732a3","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210924140901.png","hash":"4bb451fd15f21490e0ed9c4efe531429685838b2","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210924144835.png","hash":"4674dfc232213a21ded5f7f2b3958061f6308d0a","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210927092233.png","hash":"bb40f8dae8768ea1d987d605dfb3f7a1d3a67701","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210927102035.png","hash":"2d23602db78bd7195237f13646ec451b23412a2d","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210927111622.png","hash":"8ff10cbe1e82a467f7e3d9c2e1029cdfc45ec0f1","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210927112007.png","hash":"baeaae9a8bc7052fba1ef31f4318280c68ac6ffc","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208103828.png","hash":"43c8b77ff05c95ac77d1ba68c0e094078bbb6468","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208111020.png","hash":"f8227295e3c56dd30e6e9c0bfccea873c0bf0f7f","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208143940.png","hash":"972dc7c367e1d0949bd97ad17f246cdf3df7f9d9","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208163646.png","hash":"7bb41bf3cef0888c7987db708dd1d90d1b60e5a8","modified":1654842601000},{"_id":"source/_posts/redis/QQ截图20210924140833.png","hash":"aa2bf27d19b878984e52427670f87d71a025cb96","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208104018.png","hash":"4cb1cd56032ed5f8fd9f1927bd9ce6a84333c5e7","modified":1654842601000},{"_id":"source/_posts/rocketmq/QQ截图20220208134355.png","hash":"749511934eca15ca8733f2a180eab08c5206fbf1","modified":1654842601000},{"_id":"themes/butterfly/README.md","hash":"0f0eaee9c30ef1e9aed588fbb3e8263401348b55","modified":1640150645680},{"_id":"themes/butterfly/LICENSE","hash":"c8bc7df08db9dd3b39c2c2259a163a36cf2f6808","modified":1640150645680},{"_id":"themes/butterfly/README_CN.md","hash":"70ec43a8aa0776b5a0a2a6b6009dd253fa3679eb","modified":1640150645680},{"_id":"themes/butterfly/_config.yml","hash":"d9593b423071020f7b970dd932128be03b9ad3e3","modified":1640150645681},{"_id":"themes/butterfly/package.json","hash":"6a5ddc166980502757c1413b5e04a3a8a91c0a48","modified":1640150645716},{"_id":"themes/butterfly/.github/stale.yml","hash":"7a131b8aa4936fbcedea3517299e1cdc1bcbcaab","modified":1640150645679},{"_id":"themes/butterfly/languages/default.yml","hash":"b9dbdb20bd1f1c7ca8a8f38635bdc4ed8bb1d44c","modified":1640150645682},{"_id":"themes/butterfly/languages/en.yml","hash":"fd1c1211c8f166d089a7697872185a81182d92e1","modified":1640150645682},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"46685048a05b419ed9c72cf31bd6e5efef7524f2","modified":1640150645682},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"736bec8eeb3a29d0d43669d81f1fa686e02be18e","modified":1640150645683},{"_id":"themes/butterfly/layout/archive.pug","hash":"2d5bf4b1755f89898c579c18d601be83d2bc8ebd","modified":1640150645683},{"_id":"themes/butterfly/layout/category.pug","hash":"5ac3cd8172088843cec03175c612a9c85f49cf2e","modified":1640150645684},{"_id":"themes/butterfly/layout/index.pug","hash":"648dcbdb3d145a710de81c909e000e8664d2ac9c","modified":1640150645715},{"_id":"themes/butterfly/layout/page.pug","hash":"cae76ce64c114fd192b5da5a7d14aa0240df2f06","modified":1640150645716},{"_id":"themes/butterfly/layout/tag.pug","hash":"4bb5efc6dabdf1626685bf6771aaa1467155ae86","modified":1640150645716},{"_id":"themes/butterfly/layout/post.pug","hash":"8f2f13c9ae099dd83827ce3dbac5abc8d7d5bde3","modified":1640150645716},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.md","hash":"0b7979a908ebe8c350d73b6731f0be3e29d401c2","modified":1640150645678},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/custom.md","hash":"b41123ce5f0ccfa9e06a68b9f3cb59ba040a049a","modified":1640150645678},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.md","hash":"205a69ba038cf76affcdc1f39d88a8cb8079fc12","modified":1640150645679},{"_id":"themes/butterfly/.github/workflows/publish.yml","hash":"e320b40c051bae1549156cd5ea4a51383cf78598","modified":1640150645679},{"_id":"themes/butterfly/layout/includes/404.pug","hash":"3cdc5e32d0f1e5866bcf86f94a0d76aaf7142937","modified":1640150645684},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"a1ca58fdff74b890cade94479f8f0eb9ce7e5e73","modified":1640150645684},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"e65a87db69b83b4a7d34c70f83966439ea848ed4","modified":1657004078693},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"f4dcc0a596eb9801c4d3c033d018d0abb413c8e5","modified":1640150645685},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"f2e1d8a05d2e409c4804f67a98f5f59f527d6627","modified":1640150645691},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"bb1847f45e713cc88b1c0a97035ec01f0209c995","modified":1640150645694},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"66b14189a1913119ff5927c0b933b5c73fb37f48","modified":1640150645695},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"9b5243385f7a90e0103c25c531a1e7f2f1884c15","modified":1640150645695},{"_id":"themes/butterfly/scripts/events/404.js","hash":"f1d1c378356b776e9b2a8411e6dca88dc8c3245c","modified":1640150645717},{"_id":"themes/butterfly/scripts/events/init.js","hash":"5803aa55d9c21e51ea64c1ae50c9b602979aaee2","modified":1640150645717},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"1e1da036fae593be7e2cc502f0a5cbeb2e7881d1","modified":1640150645717},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"98ef86305b8d2ad9dbab969715e1ac93b407f036","modified":1640150645717},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"bd29f20fad3d3fab600940e7a6dc9a803943cb33","modified":1640150645718},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"8cb7ef368cc2ac7f4a13c2959908b1574e572acf","modified":1640150645721},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"7ffbe625f184116e442648c8416ea58614a1cef8","modified":1640150645722},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"eb019da8c190923e759d2fd7cb846281eef8594e","modified":1640150645722},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"7641adb0d520c5ff29dd36fc1fb8617c52ecc9fb","modified":1640150645722},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"551f1b8edc973bd8afc5cce2eae546f002fa84c3","modified":1640150645722},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"829229b0074b332ba779e159219eb2466612ff6e","modified":1640150645722},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"420ba8b11e7316b4c09eb301d39814bc9bae9f90","modified":1640150645722},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"08ea00791bd4738952234cb5d8360e119df6f875","modified":1640150645723},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"4f712b4ea383b59a3122683db1d54c04a79ccc5d","modified":1640150645718},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"376e1884ea764404c38b1e73b16de0358ece519e","modified":1640150645718},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"98ab13a60413d68bd9d02d54d121c66a6d4634d2","modified":1640150645719},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"384de3c04809ec5fa996e8aa0628f770cd4bff3e","modified":1640150645719},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"26dd1900e68a3e10a5cf3f3484a93139a0f1340e","modified":1640150645721},{"_id":"themes/butterfly/source/css/index.styl","hash":"c7924868adcb046b46498626a9223c7a7b3f2e30","modified":1640150645740},{"_id":"themes/butterfly/source/css/universe.css","hash":"db13c7ed03c86d365a39f6612415eae585e7ae81","modified":1657005330456},{"_id":"themes/butterfly/source/css/var.styl","hash":"31198af95fecc6819d3b2cb7ef03988ef67257da","modified":1640150645740},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1640150645740},{"_id":"themes/butterfly/source/img/algolia.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1640150645741},{"_id":"themes/butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1640150645741},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1640150645742},{"_id":"themes/butterfly/source/img/patrick.jpg","hash":"eca6b5bf8de1c2842364b50c2d3080e30c766cc1","modified":1637301354076},{"_id":"themes/butterfly/source/js/main.js","hash":"53c6df70de6e7949b102ab06fd0cd53b9b39b01c","modified":1640150645742},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"4db1170be7a9360e2c5399d281b979da730df2a3","modified":1640150645744},{"_id":"themes/butterfly/source/js/universe.js","hash":"ea22ec4b15698ad46493cf57cb3809cfae4bbf3d","modified":1657007006310},{"_id":"themes/butterfly/source/js/utils.js","hash":"1b8bf1e6d50fa8ffe2aff7548b141cab72540ba0","modified":1640150645744},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"07380718ed3af19a7e64b30e8c13726fe5983947","modified":1640150645685},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"903d12250ce70713dd5b8ac7e1f7a20fe15eb815","modified":1640150645685},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"3ca9d9cdfd6e61df1d5b07de40f34349cda7a7c7","modified":1640150645686},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"f29123e603cbbcc6ce277d4e8f600ba67498077c","modified":1640150645686},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"73c04d62055840545112dd12d73807835ca62347","modified":1640150645686},{"_id":"themes/butterfly/layout/includes/head/noscript.pug","hash":"72efaa09ff60843567458bd54152e06f0cb2757e","modified":1640150645687},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"d6556d5396eb0e10ea0ec10158779c21dc78f738","modified":1640150645687},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"6dc2c9b85df9ab4f5b554305339fd80a90a6cf43","modified":1640150645688},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"5168caadc4cf541f5d6676a9c5e8ae47a948f9ad","modified":1640150645688},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"3a2797d2744607ba6cdb5a02853851957c0f7e29","modified":1640150645688},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"4d52000cae1fce333329c382dac6c9a21ad0b195","modified":1640150645689},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"419807903e5586b8804b1f8f17cea97bd05f0b17","modified":1640150645689},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"7677911bd3f43edaf8230eea02f60a248eee9934","modified":1640150645689},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"631ec7000fd4d6cfa2de118ee02ad8a42ffb34f5","modified":1640150645690},{"_id":"themes/butterfly/layout/includes/loading/loading-js.pug","hash":"2e1ab0c2ca59a1ff5a5ba9b6ef60f3e34af5430c","modified":1640150645691},{"_id":"themes/butterfly/layout/includes/loading/loading.pug","hash":"dd8e6813976be64e80eba6562b54e74527ab306d","modified":1640150645692},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"971038debf539333b1687b4a1d87cf4fc965a846","modified":1640150645692},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"dcccb1425fabcf12a1bed955518b0e7b1054cab0","modified":1640150645692},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"95924d28d71b28769963529f82b376a9dc731fad","modified":1640150645693},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"f5ea1e10a169aeb98e42b19ac084c4eb27693b46","modified":1640150645693},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"9aa743b1f6fb7fafabee38f9204ce9c8f1be7f9a","modified":1640150645693},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"62dc2e683d56ddc9b588abc44dc1cfb778a2c68f","modified":1640150645694},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"6ec54b77e3a90e148e66e317e5bb6c89624fddca","modified":1640150645694},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"c762732e200ff2627bc046af5f170b3269343341","modified":1640150645695},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"bee06b3f01fa1f0d8fa08c154234b452da425101","modified":1640150645696},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"4c3da5a89b4e6fd3ab527f5c6d27790359d57f71","modified":1640150645703},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"d06dafe7faf3a2e328ef62f26166a51ffe7a5579","modified":1640150645708},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"ad59dcce32e4e67066303a1ffd1dd95874d9953e","modified":1640150645708},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"2448b243ded58aa1d5fc22fd115e6d06b636f9fd","modified":1640150645708},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"4a2ea9fe59f1dc8cb4f4f6a28cf24a40fc300254","modified":1640150645711},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"a8312b527493dabbadbb1280760168d3bc909a3b","modified":1640150645711},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"2b3c5966fd19a1eb355fe3202d6616f81064a624","modified":1657005915033},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"73d33b6930e7944187a4b3403daf25d27077a2dd","modified":1640150645712},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"6c3449a44ae1a80f71dd4d9d6a85cec1781ceff1","modified":1640150645712},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"1dba77d250eeebfb6e293d504352c7e9ea31980b","modified":1640150645712},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"66e383b4ef374951eb87dd1bf4cdb7a667193fb5","modified":1640150645713},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"0f1a5c356c1ffd47ff49e153226e2d670dc61057","modified":1640150645713},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"0b5c165664f9f8691551fc5ff435b40e7f73c737","modified":1640150645714},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"471b20e71a19db1f5115727082e5188200c49383","modified":1640150645714},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"9755cac8424dc578e9ec07dbcaa429fddbedd392","modified":1640150645714},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"7b5ae404a1205546b7de4be42291315cf918f2b3","modified":1640150645714},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"62adef7998fb9bebc5891a49472cfea944a1bf7a","modified":1640150645715},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"e4c39101d7087066a86f7743985a53d6a246470b","modified":1640150645715},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"f9de9db2a49ac4d5447660ab159171ac5c228e3c","modified":1640150645723},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"03164bca4546707543828cb2a41bc672b77bfa5a","modified":1640150645724},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"2e8e391b211b2416d3c9430ab5361659c073f348","modified":1640150645724},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"f25415a436100688248fef0ad90e3d4397627833","modified":1640150645726},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"f27ad7b5d781c98bcac5c12c2d70b69b830e0374","modified":1640150645727},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"23ea60f8becc91f6e9f6cfb1cbfd25689c263b9c","modified":1640150645727},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"8e6c9a2c1881985e4b2ae14ef1bdfdbb1bc83b37","modified":1640150645727},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"dd71e34edece4e06b59e941fb3cc5ad9a3ad09cf","modified":1640150645728},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"bfc4b9d8df66593c11c9ae78899f54e69785ca90","modified":1640150645728},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"db7fe645662d87be4f8dfc08e55bbe1a3734bf93","modified":1640150645729},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"807f18717c29b5c41de6fc600a69a80ce8b7a19c","modified":1640150645728},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"814729d1d71f4326623a4f34b621bf0421503103","modified":1640150645729},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"8c4e08c8a63dacdfb2a733a0d0035fa97c7f5e9e","modified":1640150645729},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"4ae98e703440b616d2a36da139bda844c94d425e","modified":1640150645730},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"a00ad74074513a1c7f6e02977b8fa778beaa2108","modified":1640150645730},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"191ce31ce0f2b1d22a64225801a88cee6054f574","modified":1640150645730},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"943aa34c83c87d0225db65ae90621870472972fa","modified":1640150645731},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"8489722684aa9b4baa38386f4d4b39f4dbd60113","modified":1640150645731},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"89a6cb63a97cc08675319c403e4a89391f6ab401","modified":1640150645731},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"190b85de3e686393e45869d12464995f23b304dc","modified":1640150645732},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"87c576a3361f30eefafec27a872ad76e9fbb2765","modified":1640150645732},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"ca1d3a885a85a91fcd6f7b55fca96cafb6a1b0a3","modified":1640150645732},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"48ad198d0ea97a25db4d2a3e587a16ef41617c0b","modified":1640150645733},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"0da09b1811a776106ca66c56be6e2a396dca5680","modified":1640150645733},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"5e5c1d6d104cc15314ae365d0da7cb07334a6457","modified":1640150645733},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"26e26797b3175498e20b2a8bf1679d3ed9fac5a6","modified":1640150645734},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"25ac939fc57346de07ba9e15a1a760b492baefd7","modified":1640150645734},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"e65ed98056e6c91e622f94bad5283d00fdb22142","modified":1640150645735},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"fa2985afd08556b25f5f1a01bc1a7c76b294a962","modified":1640150645735},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"c3369a14f4111c098d0177036ca57df6deb59d72","modified":1640150645735},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"aa0728c556af75f5d66ecd44fa207722d474c26d","modified":1640150645736},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"6c12a03e26ca5d538537d472657d3d03a7fcbb87","modified":1640150645736},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"56691537c7f06c2cf1ffa1509a328f506d938ee8","modified":1640150645736},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"5a873d01fabebcf7ddf7a6b1c2e2e5e2714097f4","modified":1640150645737},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"c91609b7f431cacecc3718ae2fb7403c55f8267a","modified":1640150645737},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"75a5c15c7029197ec5cffd27f7c5455891c946c9","modified":1640150645737},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"8520674768dd0b1837f947892e8402b192a4f9c1","modified":1640150645738},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"8549829fb7d3c21cd9e119884962e8c463a4a267","modified":1640150645740},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"a19f12257b14f70806a0c3cb0e9df1090f36e919","modified":1640150645743},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"54378d52d275e4ab84173bb02e17ea02ae46e55f","modified":1640150645744},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"4eebb2d94ca75809ef0cf32d70f13e9bf1e87091","modified":1640150645696},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"f4d21dcbc3b00eed9b1f604e132c4c6811a0a059","modified":1640150645696},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"a18415004d03c0a1783eccac522fbcb6ce0ea1f1","modified":1640150645696},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"896dc0b7480151562c5717771e3000c5a7fc1b16","modified":1640150645697},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"eb2d840fa42de3ec7a7fda0eaa30246d52f543e2","modified":1640150645697},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"f3db5c5e738e097a191dc0de59c61d3e1444f7c3","modified":1640150645697},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"b741b5e942481d779a8a1fe94c45154a62a6b748","modified":1640150645698},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"f3f6eaecbcf9352342e259f4a5a3ad7160f31fc9","modified":1640150645698},{"_id":"themes/butterfly/layout/includes/third-party/chat/gitter.pug","hash":"794ce3911f17d354b7196deb8c36d191afac63fb","modified":1640150645699},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"e5af55cdb87d1ffd3d8702bc77097159acf95b54","modified":1640150645698},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"bb467bb22f3d0775b33f9eacbfc086ecb7831e78","modified":1640150645699},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"cd7ab4a776be93eea96a6f6fd0a547977fbe1ea3","modified":1640150645699},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"d5f81fd5443a1b09efb165b5f4447a35949d14ad","modified":1640150645700},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"50126b2e841b01584b8b65b2f834038e3997b694","modified":1640150645700},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"0bf6a47e804fb793b40f82690a24816b902edd41","modified":1640150645700},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"0254203aae73e70b90dfce6ec4f9c9d3be9ac9f8","modified":1640150645700},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"e877c98949873a62659db7501d19eb3d66650b51","modified":1640150645701},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"d97403cdd58c759cfd1752dd85aa4a0f9b73dc46","modified":1640150645701},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"589f8503f264d4fda971c8daf2028f45c4f2867b","modified":1640150645702},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"afffc4ac8ce93d39dcc892bd518805cf33531244","modified":1640150645702},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"1c7e9fe86b7d7ef18cc876dfce19263fd4e73066","modified":1640150645702},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"8290994cf1ee2faff60214ff245cf513fbbe94aa","modified":1640150645703},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"0bf1c53b914443c66be5077ff09cfc218f111e11","modified":1640150645703},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"2afa4c21dd19890f47fb568cfb0d90efb676a253","modified":1640150645704},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"266caf985dc0703ff81b871b8f8d206f57db6e79","modified":1640150645705},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"87e40f0c315407ab88571a2b3450d640f15c96bc","modified":1640150645705},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"faf1113de12d6db0486572d7e99b03cbd0c4a896","modified":1640150645705},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"8890becd8220c57db2c7451409710942c103a7f4","modified":1640150645706},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"0ad766ae491e6fcba2ef3d136a7af6158cd4153e","modified":1640150645706},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"16cf05cf9649322da57e9b8d316573bb65f8d8d8","modified":1640150645706},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"767c38e3dfa0097b0dc1fdfd0df292c16f757d05","modified":1640150645707},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"83103bad0db195bce095330c4a84e7529bbd40dd","modified":1640150645708},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"a3d43cc360666b5b9730e8bb9e5c8fd940ae5b3d","modified":1640150645707},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"ff3727c3ec698ec61a28c55cbc8c8508f0efb0a0","modified":1640150645709},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"1c06e60b120c946c1856904848ceba6ab58d1f82","modified":1640150645709},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"fbcf94ecdca30bed7cfc4f4ec08b200579c2614e","modified":1640150645709},{"_id":"themes/butterfly/layout/includes/third-party/share/add-this.pug","hash":"8b4034e53ca5bf85097f681a6e76a53ce685c205","modified":1640150645710},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"fbac21a6c5924fb2f8d1190fd634105fdbc603d4","modified":1640150645710},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"4898a09d8e67fb358ffd74b3a1f0014f555dd856","modified":1640150645710},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"7e9a7347dd8ca4c33c564fb62512743b6012bb2d","modified":1640150645711},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"b0916c8c7d15b67b55cb1618be8370870fedbf42","modified":1640150645725},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"b74c61f6e15b422e9d2df23133552bbd1b5fe513","modified":1640150645725},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"4d71aab9082c67d3ee52ad58dfc3c1c9b41f2ab1","modified":1640150645726},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"1309292f1c8c53d96cd7333507b106bcc24ca8fc","modified":1640150645725},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"0b8aea62d1550113e1fcc237fae1b03743190208","modified":1640150645726},{"_id":"themes/butterfly/source/img/top.jpg","hash":"ea81f246872557f836d7002f3a0e29e5e3a1f9c2","modified":1639379304286},{"_id":"themes/butterfly/source/img/xiangxia.jpg","hash":"75a8784371da88054901c02094e5580f5f35d99c","modified":1638335220859},{"_id":"themes/butterfly/source/img/zhizhuxia.jpg","hash":"18eef26032a678318ff40aa1ffb9c206a906debd","modified":1638335113787},{"_id":"themes/butterfly/source/img/chuyin.jpg","hash":"eb618b48c4667105855341ce0b1fc44ee68445c6","modified":1638334939797},{"_id":"public/404.html","hash":"641d8750984389883a96e38d7f44ad1f0256482c","modified":1658478869965},{"_id":"public/about/index.html","hash":"876816d4eb14b2271c9fb2f5a3c2820bda49f072","modified":1658478869965},{"_id":"public/bangumis/index.html","hash":"0fb5ea2eb24b8467ff5e838d30d35fea1dde9b2c","modified":1658478869965},{"_id":"public/gameboy/index.html","hash":"a1d583f2eb0f332932e60e2726d508a1187c9e7d","modified":1658478869965},{"_id":"public/categories/index.html","hash":"892e0593f81b4950812ad207281d39087f942a39","modified":1658478869965},{"_id":"public/tags/index.html","hash":"b633cd14b7a1a07950af03ef8dd97759ebc82054","modified":1658478869965},{"_id":"public/link/index.html","hash":"53400d131ace327cde4b0a6afd459c180afb83fb","modified":1658478869965},{"_id":"public/2022/07/22/重装云服务器之Hexo迁移/index.html","hash":"df3789652d05592b6698279ab37c9078617879e4","modified":1658478693190},{"_id":"public/2022/07/22/服务器重装/index.html","hash":"62ef8bd7f2849f3d33e69f1dcd803e8d80bddc5e","modified":1658478693190},{"_id":"public/2022/07/19/redis/index.html","hash":"ce806c5b9b03d2f382f275b9410a5d1036ff6b08","modified":1658478693190},{"_id":"public/2022/07/10/Kafka/index.html","hash":"a1a332f854f22065ad573a61d2c2623379659103","modified":1658478693190},{"_id":"public/2022/07/09/rabbitmq/index.html","hash":"11c38cd7409a300d85edbbf35f4ad5e95bb8eb96","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/index.html","hash":"63c126c308cb3d7fd20b642b67b0d37445835dfd","modified":1658478693190},{"_id":"public/2022/07/05/问题整理/index.html","hash":"f0b1175af86085b09cfe80390235c41aff3f4b3d","modified":1658478693190},{"_id":"public/2022/07/05/yuque/Shell脚本/index.html","hash":"d46a477346c5c2c02e0ca02315f432c6f5a46f00","modified":1658478693190},{"_id":"public/2022/06/30/软件开发方法/index.html","hash":"7943e73cd1b209fc19a3716ef8bd78e480b2c533","modified":1658478693190},{"_id":"public/2022/06/08/Spring是什么/index.html","hash":"a2ac5923142f2f2f17f69bee4f51eec5d730242f","modified":1658478693190},{"_id":"public/2021/12/24/以管理员身份在当前目录打开命令行窗口/index.html","hash":"39830db907c76bf32aa5e79f59ae42af4a79fe8d","modified":1658478693190},{"_id":"public/2021/12/22/MarkdownPad 2  操作指南/index.html","hash":"521c1743d0a226b6e7a842853dc7976ca6b6ac33","modified":1658478693190},{"_id":"public/archives/index.html","hash":"0f61b226c4bcbb68224d5f06b6ac3063b71b0b42","modified":1658478869965},{"_id":"public/archives/page/2/index.html","hash":"467044c02d1a854316fa4bfbbeb7ec398cc3fad3","modified":1658478869965},{"_id":"public/archives/2021/index.html","hash":"89cb1c63e632f76d5e1f25b1b2b4cd5a7edcf34a","modified":1658478869965},{"_id":"public/archives/2021/12/index.html","hash":"6f46434c1665b428ad894cdb0ab704e1e21a31ba","modified":1658478869965},{"_id":"public/archives/2022/index.html","hash":"74a556fa17a2dbae599ba6a5609c7def3fe57008","modified":1658478869965},{"_id":"public/archives/2022/06/index.html","hash":"3d5c9be54f0f65cb770935f0bad91f26f690962a","modified":1658478869965},{"_id":"public/archives/2022/07/index.html","hash":"2ea371b1a90293d0dd969ebd3d2008c2b95e3e1c","modified":1658478869965},{"_id":"public/categories/消息中间件/index.html","hash":"259a2ec8a9bf81ae1e18ef62fa1f914c98f704ad","modified":1658478869965},{"_id":"public/categories/工具/index.html","hash":"e31fa40fc801f90b66cfd83a800752aa8110c9bb","modified":1658478869965},{"_id":"public/categories/面试/index.html","hash":"c756acdb6130d3e41023db70e04c17c7d0315da3","modified":1658478869965},{"_id":"public/categories/NoSQL/index.html","hash":"f781703258e2440c019686946eb11f58b70ce7e8","modified":1658478869965},{"_id":"public/categories/MySql/index.html","hash":"25e593a180d6f4a0d73eacab9815bd62649cc509","modified":1658478869965},{"_id":"public/categories/架构，学习笔记/index.html","hash":"90c586ed677a4f667cb78de77380ec46dc563d53","modified":1658478869965},{"_id":"public/categories/Hexo/index.html","hash":"ff9eab9cecb77f5bde2bbc2a0c8f876923944890","modified":1658478869965},{"_id":"public/categories/问题/index.html","hash":"84164ea707a9aafc67a55647beca0bfb1ab2dfdc","modified":1658478869965},{"_id":"public/tags/mq/index.html","hash":"2ef7d56e98abbfa74b122bd2f46b50ac080fd992","modified":1658478869965},{"_id":"public/tags/消息中间件/index.html","hash":"720b6704aee7262ac46a8a381bf8d48e94dd8441","modified":1658478869965},{"_id":"public/tags/markdown/index.html","hash":"f8e7e7fb1f95171f07faca6dbf9f3f625da5e4a0","modified":1658478869965},{"_id":"public/tags/blog/index.html","hash":"5d2d1fb684fa94944dd8a253515661a4034a0d38","modified":1658478869965},{"_id":"public/tags/spring/index.html","hash":"4269389054e3d52d0107c4a7ca68ce93ffe5aef6","modified":1658478869965},{"_id":"public/tags/面试/index.html","hash":"27cadf494767b7052b87d487b6e2304cfbc82cf7","modified":1658478869965},{"_id":"public/tags/Redis/index.html","hash":"6e198bc202a4fb8cb5c9ca277cf505bed2ca035d","modified":1658478869965},{"_id":"public/tags/NoSQL/index.html","hash":"042b8e749720d0f9d71ea96b256eb8daa7393069","modified":1658478869965},{"_id":"public/tags/bat/index.html","hash":"aeb18682e6ddef9a841b6f4f998c3e2a6000ebe1","modified":1658478869965},{"_id":"public/tags/windows/index.html","hash":"5ec54b88e88df38c0d12da31d1c8eec827901de7","modified":1658478869965},{"_id":"public/tags/云/index.html","hash":"ff0b736bda3e8f59d00b4e4a91ce40056b21d33a","modified":1658478869965},{"_id":"public/tags/MySql/index.html","hash":"d463ddf781be588719b4a2570a5b0d8bee4f17b1","modified":1658478869965},{"_id":"public/tags/Hexo/index.html","hash":"8425b970ccdac88a6249342d340df241b69e3507","modified":1658478869965},{"_id":"public/index.html","hash":"2b43b61e6f3f1f85f047c3381dd116cc5b084a54","modified":1658478869965},{"_id":"public/page/2/index.html","hash":"dc8cd0ebf63acfa98b99a21c32c5e24eb6917638","modified":1658478869965},{"_id":"public/img/algolia.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1658478693190},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1658478693190},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1658478693190},{"_id":"public/img/patrick.jpg","hash":"eca6b5bf8de1c2842364b50c2d3080e30c766cc1","modified":1658478693190},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1658478693190},{"_id":"public/2022/07/10/Kafka/QQ截图20220110112502.png","hash":"7e4836ec4abccc0c5c18a5bf858e3fdb1071aa82","modified":1658478693190},{"_id":"public/2022/07/10/Kafka/QQ截图20220110122844.png","hash":"228b3667de9f648b494b946ea0befb75ac089f9f","modified":1658478693190},{"_id":"public/2022/07/10/Kafka/QQ截图20220110125233.png","hash":"752a98bf9028ed3555ead503e76a8d65decb3320","modified":1658478693190},{"_id":"public/2022/07/10/Kafka/QQ截图20220110125413.png","hash":"1ec2d87a6d8182707f2351b32b470fd64fd414e7","modified":1658478693190},{"_id":"public/2022/07/10/Kafka/QQ截图20220110134554.png","hash":"ac05987c6f30b2a6f91600695f2a4a4aced0f0e3","modified":1658478693190},{"_id":"public/2022/07/10/Kafka/QQ截图20220110134734.png","hash":"d1e9122ec94650af9454923a9c86ee43d96d425d","modified":1658478693190},{"_id":"public/2022/07/10/Kafka/QQ截图20220110142708.png","hash":"e02d654fc4054e77eb9c397d9ce0cc75717479ae","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210922100205.png","hash":"79b77be85311284ee8105e2863cd10826362ad5c","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210922100407.png","hash":"ec835e1a86a86d812c4beafd8de9f2d1dbb1b95c","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210924134715.png","hash":"c9f37d69c172ec7db1daf1140f21915620fa839c","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210924135030.png","hash":"20ebac7e62956a3547fb82c3185814684e67902f","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210924135616.png","hash":"19adbae926293738c27362edad959ef6a24d6718","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210924141013.png","hash":"784a8938074942ebf6d4ef773b98d17da95a8d3a","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210927092027.png","hash":"7d38c3c9951a64516b1e6e61f2d42fac8112a410","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210927092145.png","hash":"948a658169fc57bf893cb5180f943e30684b805e","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210927092451.png","hash":"8f43a7d97fb3c8742d29745b216964fe46bafe30","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210927092755.png","hash":"ee01b1c95f52040fc7ee6bc4d3946806f7ab82ee","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210927102059.png","hash":"2ade7c5d567f01b80be2b80803600e136ddad50d","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210927112345.png","hash":"e314d4c9a492ebc3230f6bd82a5b01785b152d16","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210927112358.png","hash":"e513766020b35edab177639b6b0acbad2050e74d","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210927112511.png","hash":"1606797614b492b0729928b85e46bd6f0e01a032","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210927113126.png","hash":"f17966bba19024284a4710967ee21011df19e817","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210927113242.png","hash":"4df782d382149457d9b3c2e5dce72036c1216084","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210927113307.png","hash":"2a3fd9fffae968007ab8d225ee625117b021db2d","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210927113948.png","hash":"93c433b05e0d18a5f56c08a67f511c396baa6385","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210927114022.png","hash":"7ebb968d723bad4dc92eba1aec678fc7cfe2666f","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210927114130.png","hash":"e8c0e6d445a1da9696e8a4a013a8ab8b43532a6a","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210927114141.png","hash":"4aafffdcd1f8d3f38f620631c5ef06a151ec54ac","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210928085936.png","hash":"4b16325ae95be541b890bf9bdd7e17b459b6b405","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210928090249.png","hash":"df056533ff4eb5954c1b0505da55d2ae75bc0f1c","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210928090112.png","hash":"0cc05dfdf33b2fb9a200e5a0bfcd68bd490ac1f0","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210928090331.png","hash":"4669666837e96d2cef30f02adc83b249da1ef2ec","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210928090903.png","hash":"3d8522ccf6ba7f96fda390b3c6de5d72d656dfd2","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210928090930.png","hash":"829cd5a43f763ae5f6b86e13a96d0ac934abceb5","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208101908.png","hash":"320e06be004bfa6bc419b808d2d63d53cc01a767","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208102000.png","hash":"b74a6cc2506ec2d91a0c99eb42644d48c7f2552d","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208104611.png","hash":"5e9510120be99d9bbb67ade2cd3ca6fe36588d62","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208104741.png","hash":"6aab9b97948359c44377ef7cc75804a645ec70c2","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208110201.png","hash":"892668e09dbece38a85c5722efebf5f405841dec","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208110311.png","hash":"7cced357d6b9cbcd736ab5991de83b20d6203628","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208110807.png","hash":"fcd992f97e37054b320b4aa6a463ec21c379c984","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208110900.png","hash":"3b32b81cd22cd89575e1a8ba23d2f95c542a2159","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208110924.png","hash":"9118c8d2627491a5d817e4e4f3df94986e29f951","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208111536.png","hash":"8e7e60334f3915d524b9f97726a33af538d1e8da","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208111646.png","hash":"9a16a3bc8d1af28dcd8825c6526e1f5f110dafcb","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208111700.png","hash":"104c298bb66f568e810acdfdcfbf27f9779f9971","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208111724.png","hash":"2e1115acd643419c02dc3ad33ac3a1874e72ed75","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208111822.png","hash":"20d116e7ea5fa7a33e1402ace8b8879cdd5a1a87","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208113559.png","hash":"56e32636da4078ac6d0ba8b32dfcb8a3c69b238b","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208113758.png","hash":"ebf380e02441900df93a5efccc9acdbc933fe08b","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208121758.png","hash":"412376981092caf186a914d98c8ef9c6f01503ac","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208122608.png","hash":"c769c5a357acef8e775ff50c6e92807f035b54fb","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208123848.png","hash":"f2c649f8df07450f7c31b13a2312aea27aaea244","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208124241.png","hash":"0f231bd4ef647c1e288f6a368faa383e1fc00033","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208134454.png","hash":"9254d5e13d305a8e43ef45eaa67fdebe5c8d81ae","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208134538.png","hash":"29e6759e1f901e5da5803ff677326e8cb45be230","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208135939.png","hash":"2560c7d1fee965a1ef250bea20398a406721849d","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208135949.png","hash":"70dcd0a43c7f27ea38906f7972e599a423b3c0f3","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208140054.png","hash":"23b8cc6fcd0d0a1284b83e897d14382da013e00e","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208140159.png","hash":"ce96b78ccc004c6d5dac7b50b4f129e9259f4a5c","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208140740.png","hash":"a82d2d898a355bf88b7965266c432c0dab6b5292","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208141053.png","hash":"4a35680061195f4da3ca112715661a020cac0364","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208141304.png","hash":"641c1810909368fd38a161b9762c3ca52e33cead","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208142527.png","hash":"016cc40f2aad4f29ceecfa6186a7de0fe698445a","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208142630.png","hash":"80621d1cb48579a22ac152587a20f688f69cadf9","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208142708.png","hash":"fabd55b79889a6e0a5984a7c0bb7ab9f884b4faf","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208142814.png","hash":"b5b3c320c4b16f6ab91ea71d0cc96f1589fa7aa6","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208143050.png","hash":"52eb34f368b90ea383e2b49378e7d562c4052db9","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208143107.png","hash":"87ddccca38df9af09ec25d3cca3bb0c9e8606c1e","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208144842.png","hash":"baf039ec65c508d83c99cd71bea23ff7582c49f8","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208145933.png","hash":"f88ab33215a13f29b44853e4ece118961ffc64c1","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208150004.png","hash":"10061db8b628f81622b9ed29468bbd423e23334f","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208150023.png","hash":"f88b113a6c3c5c72c0206c9e12ed706c5116b2f9","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208152144.png","hash":"b619d45b7b0b12eaafcda85d32b0b2d8c09191ae","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208152224.png","hash":"139ed1a4050b00c178e2df6c3c27388e708cd4b4","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208152417.png","hash":"fbcfaf2f733a129eb29b20faf8787d4ead4d0838","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208153410.png","hash":"0d880a8b7d24f809d4d8ccdb8f3d20bcb5294d6a","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208153523.png","hash":"f83b665175538761c7de12db05a1a5b40909556d","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208153545.png","hash":"e4b65756ea0517137edf05e4f4c8000281490573","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208153635.png","hash":"6982236dda82789c7c48a1ec9da5ed397f9c7ce4","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208154429.png","hash":"608c3ed29541e9f6cea0043bf8258756635c77c2","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208154545.png","hash":"4f05a3f12288f6424369e6830c50af7b49abdd6a","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208155046.png","hash":"6652f15b4e9b0203ab159ffbf36d86dfc8802894","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208160513.png","hash":"42ddae550092b03cfd4dc90dd921fbb1ee77a620","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208160544.png","hash":"1805ed9dce23ddbbbd272d28f724b4ca9aec1715","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208163740.png","hash":"8d3fbb2fa006a9aaeda336937a8a5e1266dca053","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208163826.png","hash":"4bbed34ed92f5b7a8b14c86c5da28819c4ee30f2","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210924134937.png","hash":"3713d70470170f38e173490c422ed0584a44fe39","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210924135855.png","hash":"8c8bf064160f4e8857d8e38e9cd10aa990791b46","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210924135915.png","hash":"46b2bf2e31b33b7df9dddf3aa7f60c6a4465632e","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210924135957.png","hash":"e01495dd5d8ab84b5efcfebbfc99c23eee0b13ea","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210924141532.png","hash":"ae1e319a3eb2e36de727025882c8cda5f92e9d18","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210927092007.png","hash":"196d8faf3b0d1e9082979c4b7fb27fc76eea19ef","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210927094518.png","hash":"02c3f5deac024de3e90f8bea1cb37032aaa1e09d","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210927110129.png","hash":"403d47cccf5885eb17fa9d91ab2e92604e223c49","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210927110152.png","hash":"1d15b2161916d238ea39df7763d8091493358946","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210927111724.png","hash":"157fdbbe9d806b35524a68a49892e884cf2b2206","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210927112441.png","hash":"02f80618a986ace4e2bab56a5cccb17fa03e901b","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210927113113.png","hash":"4a1dcf49b56ca94e394cca00a014700f8ae36eca","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210927113849.png","hash":"2c04dd9af95e155bf047265ec44192783f4d6887","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210928085838.png","hash":"9aa610a5cfec8c490d566dd53a293eb95d63c546","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210928085902.png","hash":"10577ddb6f8506dea45878021538e06fcb4062cc","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210928090032.png","hash":"0114ce100337904ac22a3a73b9ee7e6165788635","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210928091310.png","hash":"c19d06f534c7789da8eb200e8cb4562577e60d7d","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208103522.png","hash":"60f529ce9e263f3fe77988ce51f3b252f4f3735e","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208105007.png","hash":"4194bae8de9a198add7542742a848936a7fd1306","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208105040.png","hash":"894e23c75d44798f9759d4334b28b361bff473a1","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208110713.png","hash":"3a7d4f151cac6d6f1f8397e418ec4923fb8f6149","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208110738.png","hash":"878fdfe8c8aab63c5481ccafe9ea543133837e48","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208110821.png","hash":"c8c3703ea7823385c3894eb5d00c5605ba363560","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208111000.png","hash":"d1fb5b546edb3a42ff92016a607a8427c1e7b69c","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208111255.png","hash":"265f1cf18c3060dd81e03f6bd0be683a9aa2c455","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208111351.png","hash":"c49fbff339ecd8dba7724539b9edc77c460d250b","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208111755.png","hash":"c87d234f70218f505dcd5d0892c52147e7e99c9c","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208122057.png","hash":"c9c46513d5ab98219d2770adee1e98d67bd40891","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208122113.png","hash":"64fcb371ddc2717e5f4a2e2a14f6e20f937b691d","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208124258.png","hash":"6e6a7ac35edc3ceec820283c9f58321de33960b8","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208133814.png","hash":"3dda9a04783901496f5b8280372269f21c2d8cb4","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208134157.png","hash":"929c894d34045cdd4c1d5d79252aef54dfc94a40","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208134415.png","hash":"915bd01337e9ded8fcd3929ffbdd22e9a6d7da73","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208141005.png","hash":"a1931055c5b5ac98618d198cf99e6685f2168dfb","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208141202.png","hash":"697f77802ad96775d9cc1c06ba8b3eb333ee09e4","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208142905.png","hash":"28b1c32f1d7d7362412fb499e4b8331e94ae38d1","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208143837.png","hash":"51b6ebf7411da387864bb466757a6e1e99997976","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208152040.png","hash":"8beccab9fe37c6447ab942fa74e1f2b365d59fb3","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208155359.png","hash":"dd43a7b3493acdee2499d9fe1f7c83b124b6bff1","modified":1658478693190},{"_id":"public/css/universe.css","hash":"71bb9b0ad21f6c754c45706168ea0dbf5861ca32","modified":1658478693190},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1658478693190},{"_id":"public/js/utils.js","hash":"8319b59c26ce8cd2b0ae7d030c4912215148fa92","modified":1658478693190},{"_id":"public/js/universe.js","hash":"fb0de0b3d7842d41b46dd113723dc77f82a4d530","modified":1658478693190},{"_id":"public/js/search/algolia.js","hash":"65b45e61586f7e66c3f338370bfd9daadd71a4b7","modified":1658478693190},{"_id":"public/js/search/local-search.js","hash":"b1429e9f80ef6b9a77434819ffb87d90bdad25e8","modified":1658478693190},{"_id":"public/css/index.css","hash":"ca8b23468c5fe2c888ba2c8ad01ae741262d58d1","modified":1658478693190},{"_id":"public/js/main.js","hash":"b244f28124a46d7f1e8ef76ba6e925289691f93b","modified":1658478693190},{"_id":"public/js/tw_cn.js","hash":"00053ce73210274b3679f42607edef1206eebc68","modified":1658478693190},{"_id":"public/2022/07/10/Kafka/QQ截图20220110133849.png","hash":"d18c2379b86ebd390b7931e3dcf547b528f23602","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210924140055.png","hash":"0275c2b6570bb83824491b9229e0174a19d0653b","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210924140800.png","hash":"892b8097ee95e84e737c45d1511a7a3a75ba9871","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210924140819.png","hash":"2dddbb874a9696323b5437fbe018b900646f3084","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210924140847.png","hash":"f66e3b594814dfda59e3b23465604b6c7d0732a3","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210924140901.png","hash":"4bb451fd15f21490e0ed9c4efe531429685838b2","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210924144835.png","hash":"4674dfc232213a21ded5f7f2b3958061f6308d0a","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210927092233.png","hash":"bb40f8dae8768ea1d987d605dfb3f7a1d3a67701","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210927102035.png","hash":"2d23602db78bd7195237f13646ec451b23412a2d","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210927111622.png","hash":"8ff10cbe1e82a467f7e3d9c2e1029cdfc45ec0f1","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210927112007.png","hash":"baeaae9a8bc7052fba1ef31f4318280c68ac6ffc","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208103828.png","hash":"43c8b77ff05c95ac77d1ba68c0e094078bbb6468","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208111020.png","hash":"f8227295e3c56dd30e6e9c0bfccea873c0bf0f7f","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208143940.png","hash":"972dc7c367e1d0949bd97ad17f246cdf3df7f9d9","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208163646.png","hash":"7bb41bf3cef0888c7987db708dd1d90d1b60e5a8","modified":1658478693190},{"_id":"public/2022/07/19/redis/QQ截图20210924140833.png","hash":"aa2bf27d19b878984e52427670f87d71a025cb96","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208134355.png","hash":"749511934eca15ca8733f2a180eab08c5206fbf1","modified":1658478693190},{"_id":"public/2022/07/08/rocketmq/QQ截图20220208104018.png","hash":"4cb1cd56032ed5f8fd9f1927bd9ce6a84333c5e7","modified":1658478693190},{"_id":"public/img/top.jpg","hash":"ea81f246872557f836d7002f3a0e29e5e3a1f9c2","modified":1658478693190},{"_id":"public/img/xiangxia.jpg","hash":"75a8784371da88054901c02094e5580f5f35d99c","modified":1658478693190},{"_id":"public/img/zhizhuxia.jpg","hash":"18eef26032a678318ff40aa1ffb9c206a906debd","modified":1658478693190},{"_id":"public/img/chuyin.jpg","hash":"eb618b48c4667105855341ce0b1fc44ee68445c6","modified":1658478693190}],"Category":[{"name":"消息中间件","_id":"cl5w7e73s0004igvugk9tat14"},{"name":"工具","_id":"cl5w7e73z000cigvu6dj1f4hs"},{"name":"面试","_id":"cl5w7e748000pigvu99tj4b2e"},{"name":"NoSQL","_id":"cl5w7e74b000xigvu7ery4myn"},{"name":"MySql","_id":"cl5w7e74d0014igvu4lgf2045"},{"name":"架构，学习笔记","_id":"cl5w7e74e001aigvu2xxh6c7l"},{"name":"Hexo","_id":"cl5w7e74f001figvu0d4d96qp"},{"name":"问题","_id":"cl5w7e74g001higvu79l4caff"}],"Data":[{"_id":"bangumis","data":{"wantWatch":[],"watching":[{"title":"凡人修仙传","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/70d11dfab23a3ee81ccf64f18efa139416a633ff.jpg@220w_280h.webp","totalCount":"未完结","id":28223043,"follow":"615.7 万","view":"8.9 亿","danmaku":"490.9 万","coin":"1186.9 万","score":9.7,"des":"看机智的凡人小子韩立如何稳健发展、步步为营，战魔道、夺至宝、驰骋星海、快意恩仇，成为纵横三界的强者。他日仙界重相逢，一声道友尽沧桑。..."},{"title":"恋爱游戏世界对路人角色很不友好","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/c9723d8c77d881a8debba2852d580e97826b43d0.png@220w_280h.webp","totalCount":"全12话","id":28237300,"follow":"151.2 万","view":"5120.4 万","danmaku":"40.6 万","coin":"24.5 万","score":9.1,"des":"从现代日本转生到“恋爱游戏”世界的里昂，发现这里女尊男卑，对男性很不友好。身为路人角色的他，为了摆脱自己因地位低下而被肆意决定的人生，决定活用从游戏中得到的知识，保持路人角色的身份，取得“失落物品”来..."},{"title":"魔法纪录 魔法少女小圆外传 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/9eef1df9ab157be52d2c4d70d3500442f00cafc3.png@220w_280h.webp","totalCount":"全12话","id":28234642,"follow":"237.1 万","view":"907.6 万","danmaku":"5.0 万","coin":"4.9 万","score":7.7,"des":"愿望的代价，究竟是希望还是绝望——。"},{"title":"小林家的龙女仆 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/847e9dbb6876fb37a30199a5c88910704976d45b.png@220w_280h.webp","totalCount":"全13话","id":28234613,"follow":"855.7 万","view":"1.1 亿","danmaku":"49.0 万","coin":"69.0 万","score":9.6,"des":"那位不可思议的龙女仆再度登场！\n因为各种奇妙的原因而作为小林家的女仆而工作中的龙·托尔。\n偶尔（胡说，是经常）给亲爱的小林添麻烦，总算是融入了人类社会，成为了一个完美的（骗人，也就还行）女仆。\n同样是..."},{"title":"国王排名","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/376d7e69a667bcb1c0b934a4e35e07e7fa23110b.png@220w_280h.webp","totalCount":"全23话","id":28235154,"follow":"927.7 万","view":"4.8 亿","danmaku":"250.1 万","coin":"260.9 万","score":7,"des":"国家的丰饶、麾下勇者的数量、\n以及国王本人如何像勇者一般强大，\n这些要素的综合排名，便是所谓的“国王排名”。\n主人公波吉是国王排名第七名的伯斯王治下王国的第一王子。\n但是波吉却生来又聋又哑，贫弱到挥不..."},{"title":"阿松 第三季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0212baa8898d0c819c7fb84015e95b8fca621435.png@220w_280h.webp","totalCount":"全25话","id":28229892,"follow":"67.6 万","view":"938.0 万","danmaku":"13.0 万","coin":"5.4 万","score":9.6,"des":"日本最有名的六胞胎的传说，第三次开幕！！这次会有怎样意想不到的新展开！？..."},{"title":"命运-冠位指定 冠位时间神殿所罗门","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0e094b798388da19a4feffa6a6dabc1dc1dc90cd.jpg@220w_280h.webp","totalCount":"全1话","id":28236225,"follow":"525.5 万","view":"1220.0 万","danmaku":"8.9 万","coin":"15.1 万","score":8.5,"des":"在经过七个特异点的大战后，\n人理存续保障机关迦勒底，终于到达了圣杯探索的最终地点——终局特异点 冠位时间神殿所罗门。\n他们要击败身为罪魁祸首的魔术王所罗门，夺回未来。\n在开战的前一刻，一行人各自度过了..."},{"title":"JOJO的奇妙冒险 星尘远征军","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/47c0108259355d6d2c517ed97f6b90fb777f844f.png@220w_280h.webp","totalCount":"全24话","id":28223481,"follow":"444.2 万","view":"1.5 亿","danmaku":"463.4 万","coin":"45.7 万","score":9.8,"des":"时为1987年，乔瑟夫·乔斯达与“柱之男”们之间的死战后过了50年……乔瑟夫为了为了帮助“被恶灵附身了”的外孙子·空条承太郎而来到了日本。原来那并不是恶灵而是幽波纹（替身）。替身突然出现的原因在于，从..."},{"title":"JOJO的奇妙冒险 星尘远征军 埃及篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f6709b76e88f50aa132d1e09e2d8de9663a09b3e.png@220w_280h.webp","totalCount":"全24话","id":28223483,"follow":"421.9 万","view":"1.3 亿","danmaku":"468.7 万","coin":"44.3 万","score":9.9,"des":"在乔斯达家的宿敌·迪奥（DIO）复活的影响下，一位年轻人——空条承太郎，得到了名为“幽波纹（替身）”的能力。为了拯救因迪奥的诅咒而倒下的母亲荷莉，空条承太郎与外祖父·乔瑟夫以及伙伴们，一起为了打倒迪奥..."},{"title":"JOJO的奇妙冒险 不灭钻石","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/6a04c87e990ab74cd8d555ef45a863de0993b161.png@220w_280h.webp","totalCount":"全39话","id":140552,"follow":"302.3 万","view":"2.1 亿","danmaku":"813.8 万","coin":"55.9 万","score":9.8,"des":"在埃及与宿敌DIO的死斗之后过了11年。1999年，空条承太郎为了与祖父乔瑟夫·乔斯达的私生子东方仗助见面，而来到了日本M县S市杜王町。但，仗助却持有与承太郎相同的特殊能力“替身”。之后，以承太郎的来..."},{"title":"命运-冠位嘉年华","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/c660976f4502a544d990a882ae62194b57753a71.png@220w_280h.webp","totalCount":"全2话","id":28234639,"follow":"479.8 万","view":"862.4 万","danmaku":"4.1 万","coin":"9.1 万","score":9.8,"des":"一起庆祝吧！为了这奇迹般的嘉年华！"},{"title":"伍六七","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/b69e26d9e50514f3fa99eac9ab5aabf2a6e28c88.jpg@220w_280h.webp","totalCount":"全13话","id":6360,"follow":"585.8 万","view":"3.3 亿","danmaku":"227.1 万","coin":"191.8 万","score":9.8,"des":"在某个小岛上，有一个可以伪装成任何东西的廉价刺客，名叫伍六七。平时看上去是个理发师，其实背地里却做着刺客生意。热爱理发事业，喜欢给人剪头发，善用剪刀——剪刀也是他的刺杀武器。由于初入刺客行当，行情十分..."},{"title":"命运-冠位指定 -月光／失落之室-","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3fa5fd2b7afae827b0bf150d7f0cbfc54eda1ff2.png@220w_280h.webp","totalCount":"全1话","id":28234950,"follow":"483.3 万","view":"551.2 万","danmaku":9696,"coin":"2.9 万","score":9.5,"des":"失落之室——。\n这是一个可以看到被夺去亦或是遗失之物的地方。\n这是位于迦勒底被遗忘的角落，不属于任何人的地方。..."},{"title":"致不灭的你","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/1ae94fbb35d8e23bb84926b694509f8b057f96e6.png@220w_280h.webp","totalCount":"全20话","id":28233896,"follow":"476.3 万","view":"1.3 亿","danmaku":"140.1 万","coin":"95.0 万","score":9.6,"des":"本剧讲述了一个情节跌宕、场面宏大的奇幻故事，通过拥有不灭之身的主人公“不死”来探索人生哲理。\n不死起初是一个被投放到人世间的“球”。\n\n它具有“幻化为刺激源形态的能力”和“死后重生的能力”。\n\n先后从..."},{"title":"来自新世界","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/aaa60f9cb17fb4a38df464f1064ca9623e0769cc.jpg@220w_280h.webp","totalCount":"全25话","id":1598,"follow":"115.9 万","view":"1540.9 万","danmaku":"76.3 万","coin":"5.7 万","score":9.5,"des":"1000年后的日本，孩子们不断地消失，只存在想象中的恐怖动物与人类展开殊死战争。反乌托邦式的未来超级社会“新世界”，是口吐真言凭藉“咒力”就能移动物体的人类，与有着等同于普通人智力的生物“妖鼠”共存的..."},{"title":"转生成蜘蛛又怎样！","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f0796e37abac25ba2aa9f23120646aaa9a3d5ea7.png@220w_280h.webp","totalCount":"全24话","id":28231809,"follow":"600.0 万","view":"3.7 亿","danmaku":"190.3 万","coin":"164.6 万","score":7.8,"des":"曾经是一名女高中生的“我”，突然转生变成了幻想世界中的蜘蛛魔物。\n而且，出生地点还是各种凶恶魔物所盘踞的大迷宫。\n“我”以人类的智慧和非同寻常的积极心态为武器，使用蜘蛛的丝网以及陷阱打倒比自己等级高得..."},{"title":"装甲重拳/MEGALOBOX 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/e14dc4a935397fc074c7a12d9520225615209025.png@220w_280h.webp","totalCount":"全13话","id":28233916,"follow":"244.9 万","view":"3435.4 万","danmaku":"19.7 万","coin":"53.1 万","score":9.9,"des":"再一次，为梦想而活——\n\n将肉体与“装甲技术”融合的究极格斗技“装甲拳击”。\n在决出其顶点之人的大会“重拳之巅”上，身穿装甲用自己肉身挑战一切的拳击手“JOE”。\n\n从最下层的比赛开始仅仅花了三个月就..."},{"title":"机动战士高达SEED HD","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/855c88677267d707ebfe4040403692ff2c0938f0.png@220w_280h.webp","totalCount":"全48话","id":497,"follow":"54.8 万","view":"4044.4 万","danmaku":"114.4 万","coin":"6.0 万","score":9.6,"des":"《机动战士高达SEED》是高达系列在2002年至2003年度放映的动画。续作为《机动战士高达SEED Destiny》在2004年播放。因各具魅力的角色，明星云集的声优阵容和高度商业化的宣传而受到较低..."},{"title":"夏目友人帐 唤石者与怪异的访客","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6cf43708b779cde84ad285ff4e3a080de98df0af.png@220w_280h.webp","totalCount":"全1话","id":28234316,"follow":"567.1 万","view":"1374.8 万","danmaku":"18.1 万","coin":"17.9 万","score":9.9,"des":"本作由【唤石者】与【怪异的访客】两个人气短篇集锦而成。讲述生来便能看见各种妖怪的夏目，与自称保镖的猫咪老师一同邂逅的一系列温暖故事。\n【唤石者】一天夏目在森林中遇到一只小妖怪——密实。密实称自己肩负「..."},{"title":"Fate/Grand Order ‐First Order‐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/b75c55d209d156c8631f5ceb21e5c52c834dbb60.jpg@220w_280h.webp","totalCount":"全1话","id":5747,"follow":"250.9 万","view":"3329.7 万","danmaku":"76.7 万","coin":"10.7 万","score":8.3,"des":"【2016年12月31日bilibili独播】2015年。示巴所观测到的未来领域毫无前兆地消失。根据计算，发现——不，是证明了人类将于2017年灭绝。人理延续保障机构·迦勒底将“无法观测的领域”假定为..."},{"title":"伍六七之玄武国篇","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/00843865ea13702eccc4efd64c313fd4c8029c6b.jpg@220w_280h.webp","totalCount":"全10话","id":28232253,"follow":"999.4 万","view":"4.0 亿","danmaku":"177.7 万","coin":"385.3 万","score":9.8,"des":"为了保护小鸡岛居民和这里平静的生活，伍六七和他的伙伴大保和小飞开启了去往玄武国的冒险旅程，去寻找身世的真相和解救小岛的办法，等待他们的又将是更多的未知与奇遇。..."},{"title":"堀与宫村","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/039c4e0b14e27c7a9e5cce2f20a6efd3c8909401.png@220w_280h.webp","totalCount":"全13话","id":28231840,"follow":"695.2 万","view":"2.2 亿","danmaku":"242.1 万","coin":"361.4 万","score":9.8,"des":"不论是谁，都会有不想被人知道的一面。\n\n在学校中漂亮大方、成绩优秀的人气女生堀，私下却打扮土气、忙于家务和照顾弟弟。\n在学校中是阴暗宅男形象的宫村，生活中却是打扮时尚、带耳钉的帅气男生。\n因为一次特别..."},{"title":"奇蛋物语 / WONDER EGG PRIORITY","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/10e0bbc1047b2c45f0f881de334a6f3bfb42a3b6.png@220w_280h.webp","totalCount":"全12话","id":28231851,"follow":"254.9 万","view":"4686.8 万","danmaku":"47.6 万","coin":"65.5 万","score":9.7,"des":"14岁少女·大户爱在深夜散步的途中，\n随着神秘声音的指引，获得了一枚「蛋」。\n\n「如果想要改变世界的话」\n「那么就在现在做出选择」\n「请相信自己——」\n「打破这枚蛋——」\n\n而在打破「蛋」之后，等待着..."},{"title":"Re：从零开始的异世界生活 第二季 后半","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/4f3edbede7fc0bdb52842075cf8faaa1c5953eaa.png@220w_280h.webp","totalCount":"全12话","id":28232073,"follow":"849.9 万","view":"9308.1 万","danmaku":"108.1 万","coin":"230.1 万","score":9.9,"des":"我一定会拯救你。\n在打倒了魔女教大罪司教「怠惰」担当——培提其乌斯·罗曼尼康帝之后，菜月昴和爱蜜莉雅又得以重新开始。\n克服了艰难的诀别，两人终于和解，然而这只是新一轮风波的序幕。\n超乎想象的绝境危机，..."},{"title":"灰与幻想的格林姆迦尔","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/7fb4945f864e9e988212b7d20f206df2677053f8.jpg@220w_280h.webp","totalCount":"全12话","id":106512,"follow":"172.0 万","view":"2343.4 万","danmaku":"63.8 万","coin":"18.3 万","score":9.8,"des":"电视动画《灰与幻想的格林姆迦尔》改编自日本轻小说家十文字青原作白井锐利插画的同名轻小说。\n我们为什么要这么做…？\n哈尔希洛回过神来，才发现自己身处在黑暗当中，他完全不知道自己人在何处，也不明白这个地方..."},{"title":"龙与虎","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/144910805f172d16c5f544f43939a05d8ca20576.jpg@220w_280h.webp","totalCount":"全26话","id":1672,"follow":"336.9 万","view":"6671.9 万","danmaku":"511.9 万","coin":"61.5 万","score":9.7,"des":"樱花飞舞的四月，全新的高中二年级，新的班级……\n眼神凶恶的普通男孩——高须龙儿，遇上了众人害怕、凶暴残忍的“掌中老虎”逢坂大河，还知道了她不欲为人知的秘密。这就是龙虎相争爱与战斗的序幕。\n再加上总是笑..."},{"title":"机动战士高达 铁血的奥尔芬斯 第一季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/f84a80d731d0431c00903d8951fd66623d8237f7.png@220w_280h.webp","totalCount":"全25话","id":4310042,"follow":"62.4 万","view":"2318.6 万","danmaku":"52.2 万","coin":"5.4 万","score":9.5,"des":"主人公三日月·奥古斯，从所属的民间警备公司克律塞安保公司（下称CGS）那里，接受了对少女库德莉亚·蓝那·伯恩斯坦的护卫任务。但CGS受到了摘取反叛之芽的武力组织加拉尔霍恩的袭击，于是在把三日月当做诱饵..."},{"title":"机动战士高达00 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1d7a969e8f1045739c596de89a963e30475aff0e.jpg@220w_280h.webp","totalCount":"全25话","id":1193,"follow":"37.2 万","view":"2458.1 万","danmaku":"61.4 万","coin":"4.1 万","score":9.8,"des":"天人与联合国军的最终决战后过了四年。建立地球联邦政府的人类，为了追求更进一步的国家间之统合，以及人类意识的统一，在联合正规军之外，设立了独立治安维持部队“A-Laws”，目的为对所有危害联合的势力与主..."},{"title":"机动战士高达00","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/35b11bf59eb3fd12f0387951510a5d722d7435e5.jpg@220w_280h.webp","totalCount":"全25话","id":1192,"follow":"62.1 万","view":"2465.5 万","danmaku":"53.6 万","coin":"4.6 万","score":9.7,"des":"在西历2307年，虽然化石燃料枯竭了，但是人类得到了截然不同的新型能源。三台巨大的轨道升降机以及伴随它们的大规模的太阳光发电系统。但是能得到这个系统恩惠的，只有一部分大国和其同盟国而已。\n拥有三台轨道..."},{"title":"Re：从零开始的异世界生活 第二季 前半","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f2425cbdb07cc93bd0d3ba1c0099bfe78f5dc58a.png@220w_280h.webp","totalCount":"全13话","id":28229233,"follow":"774.2 万","view":"1.3 亿","danmaku":"201.4 万","coin":"126.7 万","score":9.7,"des":"我一定会拯救你。\n在打倒了魔女教大罪司教「怠惰」担当——培提其乌斯·罗曼尼康帝之后，菜月昴和爱蜜莉雅又得以重新开始。\n克服了艰难的诀别，两人终于和解，然而这只是新一轮风波的序幕。\n超乎想象的绝境危机，..."},{"title":"超级小白","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3d3e8257d22596f5d3e4395ca759bd1e0fe9b873.jpg@220w_280h.webp","totalCount":"全48话","id":28222671,"follow":"27.4 万","view":"978.0 万","danmaku":"3.6 万","coin":"3.6 万","score":9.6,"des":"为了阻止企图霸占世界的黑暗势力，野原家的普通小狗——小白接肩负重大使命，变身成为了守护世界的“超级小白”。小白将要面对的不仅是发明狗，还有其他意想不到的对手。当然，面对邪恶势力，小白也有着令人惊讶的超..."},{"title":"Re：从零开始的异世界生活 新编集版","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3c125e1aad08643e3eff2fb7d45e740c1a052725.png@220w_280h.webp","totalCount":"全13话","id":28224394,"follow":"631.1 万","view":"7674.2 万","danmaku":"166.2 万","coin":"51.1 万","score":9.6,"des":"在从便利商店回家的路上，突然被异世界召唤的少年菜月昴。在无法依靠任何东西的异世界，无力的少年手唯一的力量……那是“死去然后重新开始”的力量。为了守护最重要的人们，为了取回确实存在着又无可替代的时间，少..."},{"title":"因为太怕痛就全点防御力了","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/8021d3f6b0df6dbba6d32f76eb9cfe2531e166c4.png@220w_280h.webp","totalCount":"全12话","id":28224137,"follow":"620.6 万","view":"2.3 亿","danmaku":"326.8 万","coin":"103.8 万","score":9,"des":"主角本条枫在好友白峰理沙推荐下开始游玩游戏“NewWorld Online”，创建了名为“梅普露”的角色。然而作为游戏初学者，梅普露选择了不受欢迎的大盾当武器，同时因为怕痛而把所有状态点加到防御力的极..."},{"title":"冰海战记","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/c30401817895e67399094b4e669785a104270cdf.jpg@220w_280h.webp","totalCount":"全24话","id":28220475,"follow":"174.4 万","view":"4893.8 万","danmaku":"48.7 万","coin":"36.7 万","score":9.8,"des":"公元10世纪末期，出现了在世界各地出没的最强民族。被讴歌为最强战士的托尔兹，其子托尔芬幼时便生活在战场上，并向往着梦幻大陆“文兰”。这是一个发生在激荡时代的，真正的英雄物语。..."},{"title":"齐木楠雄的灾难 始动篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ba59822eded39b5254fb01448a7f1502101d5624.png@220w_280h.webp","totalCount":"全6话","id":28223748,"follow":"372.4 万","view":"3054.5 万","danmaku":"20.0 万","coin":"17.8 万","score":9.8,"des":"在电视剧中堪称帅气的超能力，对于高中生齐木楠雄来说只是招致灾难的元凶。作为新动画系列展开的楠雄的日常又会如何！？..."},{"title":"OVERLORD Ⅱ","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/851f979c8ebcc7583a43abd4b786c4e2e66b746b.jpg@220w_280h.webp","totalCount":"全13话","id":8792,"follow":"539.3 万","view":"3.8 亿","danmaku":"413.9 万","coin":"114.1 万","score":9.6,"des":"时为2138年。曾卷起一大风潮的虚拟现实体感型网络游戏《YGGDRASIL》即将迎来停服。玩家飞鼠在曾经以同伴和荣华自傲的根据地纳萨力克地下大坟墓，独自一人安静等待着那一刻。但是，不料发生了结束时间已..."},{"title":"夏目友人帐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/99c549494d9425f6455bd45a151f4d26397d6151.png@220w_280h.webp","totalCount":"全13话","id":1660,"follow":"324.0 万","view":"4975.2 万","danmaku":"278.7 万","coin":"15.5 万","score":9.8,"des":"夏目贵志生来拥有强大的灵力，能感知平常人所无法接触的妖怪神明的存在。因父母双亡，他多年间辗转于互相推卸责任的亲戚之间，又受到同龄人的欺负，未曾与任何人深交，造成性格一定程度上的孤僻。夏目本性和善，对于..."}],"watched":[{"title":"装甲重拳/MEGALOBOX","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0c44785cb5d25cc9f648800d251f21a2e236bb8a.png@220w_280h.webp","totalCount":"全13话","id":79472,"follow":"221.9 万","view":"6162.0 万","danmaku":"48.6 万","coin":"32.9 万","score":9.8,"des":"将肉体与“装甲技术”融合的究极格斗技——“MEGALOBOX”，将自己的全部赌在上面的男人们的热血战斗开始！\n今天也立于未认可地区的赌博比赛赛场上的MEGALO拳击手“JNK DOG”。虽然具备实力，..."},{"title":"超能力女儿","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/152c536f8ecaad8f3d7d568d33da81c963a4a722.png@220w_280h.webp","totalCount":"全12话","id":78352,"follow":"293.8 万","view":"9252.2 万","danmaku":"98.5 万","coin":"35.4 万","score":9.6,"des":"支持着芦川组的年轻智力型黑道新田义史，过着被喜欢的壶所包围的悠然自得单身生活。但某一天，随着装在神秘物体里的少女雏来到他家，他的生活为之一变。他被能使用念动力的雏所胁迫，迫不得已开始和她同居！\n容易暴..."},{"title":"OVERLORD Ⅲ","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/dd7a9d0a0bee32b1f43c2656398d8463d12b3069.jpg@220w_280h.webp","totalCount":"全13话","id":102252,"follow":"551.6 万","view":"4.0 亿","danmaku":"399.7 万","coin":"129.2 万","score":9.4,"des":"时间为2138年。曾卷起一大风潮的虚拟现实体感型网络游戏《YGGDRASIL》即将迎来停服。玩家飞鼠在曾经以同伴和荣华自傲的根据地纳萨力克地下大坟墓，独自一人安静等待着那一刻。\n但是，不料发生了“过了..."},{"title":"路人超能100 第一次灵能咨询所员工旅游～舒缓心灵的疗愈之旅~（OVA2）","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/1271324d51634b68980704731987724a1afc60aa.jpg@220w_280h.webp","totalCount":"全1话","id":28222715,"follow":"318.8 万","view":"520.7 万","danmaku":"3.6 万","coin":"4.6 万","score":9.8,"des":"由原作ONE老师担任原案的完全新作OVA！「灵能咨询所」一行人，龙套与灵幻、小酒窝以及新同伴芹泽的目的地，正是缟马县深山中鲜为人知的温泉·疣神温泉。因为灵幻接受了旅馆老板娘的委托，「弄清温泉的恐怖传闻..."},{"title":"少女终末旅行","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1431ca5bb2f7143062e3df8f21b8448cf8cccc13.jpg@220w_280h.webp","totalCount":"全12话","id":6463,"follow":"239.8 万","view":"3714.7 万","danmaku":"100.7 万","coin":"37.2 万","score":9.8,"des":"本作舞台在人类繁华的文明迎来终结的很久以后，人类基本灭绝，甚至生物都不再存在的末日世界。复杂够高的都市成为迷宫般的废墟，得不到维护的机械渐渐停止运转。连何时终结了，何时开始终结的思考都不复存在的这个世..."},{"title":"齐木楠雄的灾难（日播&精选版）","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/eb4f17335f48951945fb9da47e6ee0bc65fa2fbb.jpg@220w_280h.webp","totalCount":"全120话","id":5070,"follow":"187.0 万","view":"2.3 亿","danmaku":"130.7 万","coin":"32.7 万","score":9.6,"des":"高中生·齐木楠雄是超能力者。心灵感应、念动力、透视、预知、瞬间移动、千里眼等，不论任何事情都自由自在。但这任谁都羡慕不已的最强能力，实际上对于本人而言是引来灾难的不幸元凶。因此，他在别人面前封印了超能..."},{"title":"比宇宙更远的地方","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/c9eca3cbc386c63b27461074b8b218898cb7440e.jpg@220w_280h.webp","totalCount":"全13话","id":13032,"follow":"156.0 万","view":"2298.0 万","danmaku":"45.9 万","coin":"23.9 万","score":9.8,"des":"无论何时，我们的第一步总是从好奇心开始。\n不曾看过的风景，不曾听过的声音，不曾闻过的味道，不曾摸过的质感，不曾尝过的食物，以及不曾感受过的澎湃。\n为了重拾不知何时忘却的记忆碎片和不知何时舍弃的感动的旅..."},{"title":"OVERLORD","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/b8e72ea69e57e0b7ac85d8b4d366554fd866df1a.jpg@220w_280h.webp","totalCount":"全13话","id":2576,"follow":"626.2 万","view":"4.1 亿","danmaku":"385.2 万","coin":"84.4 万","score":9.6,"des":"作品主要讲述了某天，一款曾经掀起过大热潮的VRMMORPG「YGGDRASIL」停止了运营。游戏原本会停止一切服务，但过了结束时间后，玩家们却发现不能退出，NPC也产生了各自的思想。现实世界中喜爱电玩..."},{"title":"路人超能100 II(灵能百分百 第二季)","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/216e1bdaf88244215a13b1154116805ee9adbe07.png@220w_280h.webp","totalCount":"全13话","id":4762734,"follow":"284.9 万","view":"1.0 亿","danmaku":"97.8 万","coin":"56.1 万","score":9.9,"des":"当有什么东西达到“100”的时候，就会爆发的少年·路人（龙套）。外表极其普通——不如说是不起眼。不擅长迎合气氛的他，实际上拥有着强力的超能力。盯上了这样的他的能力，而接连现身的伪灵能力者以及宗教团体、..."},{"title":"多罗罗","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3fc16a667502cbff226e585eb660a96a20c7458c.png@220w_280h.webp","totalCount":"全24话","id":4312482,"follow":"452.1 万","view":"1.8 亿","danmaku":"143.9 万","coin":"73.9 万","score":9.4,"des":"他们向着命运抗争，在那尽头等待他们的是人心，还是业障。\n时值乱世。\n名为景光的醍醐将军，向某个寺庙殿堂中的12尊魔神像祈求早日结束战乱。\n作为代价，他的嫡子在出生时就失去了身体的某些部位，被丢弃在河流..."},{"title":"魔法少女小圆","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/7fcaa0e98b561611538ae4deba7949cec4ca39a8.png@220w_280h.webp","totalCount":"全12话","id":2539,"follow":"218.7 万","view":"4199.0 万","danmaku":"201.5 万","coin":"20.0 万","score":9.8,"des":"就读初中二年级的鹿目圆，过着平凡幸福的生活。神秘转学生晓美焰的出现，开始让小圆的命运有了巨大转变。某日一只名为丘比的神秘生物，希望小圆能够与它签订魔法契约，成为“魔法少女”以对抗邪恶的魔女保护世界。正..."}]}},{"_id":"link","data":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}],"Page":[{"title":"关于","date":"2021-12-24T08:36:12.000Z","type":"about","_content":">  我是一个半路出家的程序员，希望以写博客的方式，记录自己的编程学习生涯。以让自己坚持编程下去。\n\n![avatar](/img/patrick.jpg)<br>\n\n\n\n    世上只有一种英雄主义，就是再认清生活的真相之后依然热爱生活。\t\t\t\t\t\t\t\t--罗曼罗兰\n<p align=\"right\"><font face=\"黑体\" size=2>2021/12/27 17:00:45 </font></p>","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2021-12-24 16:36:12\ntype: \"about\"\n---\n>  我是一个半路出家的程序员，希望以写博客的方式，记录自己的编程学习生涯。以让自己坚持编程下去。\n\n![avatar](/img/patrick.jpg)<br>\n\n\n\n    世上只有一种英雄主义，就是再认清生活的真相之后依然热爱生活。\t\t\t\t\t\t\t\t--罗曼罗兰\n<p align=\"right\"><font face=\"黑体\" size=2>2021/12/27 17:00:45 </font></p>","updated":"2021-12-27T09:58:00.945Z","path":"about/index.html","comments":1,"layout":"page","_id":"cl5w7e73i0000igvu3uqb8mel","content":"<blockquote>\n<p> 我是一个半路出家的程序员，希望以写博客的方式，记录自己的编程学习生涯。以让自己坚持编程下去。</p>\n</blockquote>\n<p><img src=\"/img/patrick.jpg\" alt=\"avatar\"><br></p>\n<pre><code>世上只有一种英雄主义，就是再认清生活的真相之后依然热爱生活。                                --罗曼罗兰\n</code></pre>\n<p align=\"right\"><font face=\"黑体\" size=\"2\">2021/12/27 17:00:45 </font></p>","site":{"data":{"bangumis":{"wantWatch":[],"watching":[{"title":"凡人修仙传","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/70d11dfab23a3ee81ccf64f18efa139416a633ff.jpg@220w_280h.webp","totalCount":"未完结","id":28223043,"follow":"615.7 万","view":"8.9 亿","danmaku":"490.9 万","coin":"1186.9 万","score":9.7,"des":"看机智的凡人小子韩立如何稳健发展、步步为营，战魔道、夺至宝、驰骋星海、快意恩仇，成为纵横三界的强者。他日仙界重相逢，一声道友尽沧桑。..."},{"title":"恋爱游戏世界对路人角色很不友好","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/c9723d8c77d881a8debba2852d580e97826b43d0.png@220w_280h.webp","totalCount":"全12话","id":28237300,"follow":"151.2 万","view":"5120.4 万","danmaku":"40.6 万","coin":"24.5 万","score":9.1,"des":"从现代日本转生到“恋爱游戏”世界的里昂，发现这里女尊男卑，对男性很不友好。身为路人角色的他，为了摆脱自己因地位低下而被肆意决定的人生，决定活用从游戏中得到的知识，保持路人角色的身份，取得“失落物品”来..."},{"title":"魔法纪录 魔法少女小圆外传 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/9eef1df9ab157be52d2c4d70d3500442f00cafc3.png@220w_280h.webp","totalCount":"全12话","id":28234642,"follow":"237.1 万","view":"907.6 万","danmaku":"5.0 万","coin":"4.9 万","score":7.7,"des":"愿望的代价，究竟是希望还是绝望——。"},{"title":"小林家的龙女仆 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/847e9dbb6876fb37a30199a5c88910704976d45b.png@220w_280h.webp","totalCount":"全13话","id":28234613,"follow":"855.7 万","view":"1.1 亿","danmaku":"49.0 万","coin":"69.0 万","score":9.6,"des":"那位不可思议的龙女仆再度登场！\n因为各种奇妙的原因而作为小林家的女仆而工作中的龙·托尔。\n偶尔（胡说，是经常）给亲爱的小林添麻烦，总算是融入了人类社会，成为了一个完美的（骗人，也就还行）女仆。\n同样是..."},{"title":"国王排名","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/376d7e69a667bcb1c0b934a4e35e07e7fa23110b.png@220w_280h.webp","totalCount":"全23话","id":28235154,"follow":"927.7 万","view":"4.8 亿","danmaku":"250.1 万","coin":"260.9 万","score":7,"des":"国家的丰饶、麾下勇者的数量、\n以及国王本人如何像勇者一般强大，\n这些要素的综合排名，便是所谓的“国王排名”。\n主人公波吉是国王排名第七名的伯斯王治下王国的第一王子。\n但是波吉却生来又聋又哑，贫弱到挥不..."},{"title":"阿松 第三季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0212baa8898d0c819c7fb84015e95b8fca621435.png@220w_280h.webp","totalCount":"全25话","id":28229892,"follow":"67.6 万","view":"938.0 万","danmaku":"13.0 万","coin":"5.4 万","score":9.6,"des":"日本最有名的六胞胎的传说，第三次开幕！！这次会有怎样意想不到的新展开！？..."},{"title":"命运-冠位指定 冠位时间神殿所罗门","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0e094b798388da19a4feffa6a6dabc1dc1dc90cd.jpg@220w_280h.webp","totalCount":"全1话","id":28236225,"follow":"525.5 万","view":"1220.0 万","danmaku":"8.9 万","coin":"15.1 万","score":8.5,"des":"在经过七个特异点的大战后，\n人理存续保障机关迦勒底，终于到达了圣杯探索的最终地点——终局特异点 冠位时间神殿所罗门。\n他们要击败身为罪魁祸首的魔术王所罗门，夺回未来。\n在开战的前一刻，一行人各自度过了..."},{"title":"JOJO的奇妙冒险 星尘远征军","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/47c0108259355d6d2c517ed97f6b90fb777f844f.png@220w_280h.webp","totalCount":"全24话","id":28223481,"follow":"444.2 万","view":"1.5 亿","danmaku":"463.4 万","coin":"45.7 万","score":9.8,"des":"时为1987年，乔瑟夫·乔斯达与“柱之男”们之间的死战后过了50年……乔瑟夫为了为了帮助“被恶灵附身了”的外孙子·空条承太郎而来到了日本。原来那并不是恶灵而是幽波纹（替身）。替身突然出现的原因在于，从..."},{"title":"JOJO的奇妙冒险 星尘远征军 埃及篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f6709b76e88f50aa132d1e09e2d8de9663a09b3e.png@220w_280h.webp","totalCount":"全24话","id":28223483,"follow":"421.9 万","view":"1.3 亿","danmaku":"468.7 万","coin":"44.3 万","score":9.9,"des":"在乔斯达家的宿敌·迪奥（DIO）复活的影响下，一位年轻人——空条承太郎，得到了名为“幽波纹（替身）”的能力。为了拯救因迪奥的诅咒而倒下的母亲荷莉，空条承太郎与外祖父·乔瑟夫以及伙伴们，一起为了打倒迪奥..."},{"title":"JOJO的奇妙冒险 不灭钻石","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/6a04c87e990ab74cd8d555ef45a863de0993b161.png@220w_280h.webp","totalCount":"全39话","id":140552,"follow":"302.3 万","view":"2.1 亿","danmaku":"813.8 万","coin":"55.9 万","score":9.8,"des":"在埃及与宿敌DIO的死斗之后过了11年。1999年，空条承太郎为了与祖父乔瑟夫·乔斯达的私生子东方仗助见面，而来到了日本M县S市杜王町。但，仗助却持有与承太郎相同的特殊能力“替身”。之后，以承太郎的来..."},{"title":"命运-冠位嘉年华","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/c660976f4502a544d990a882ae62194b57753a71.png@220w_280h.webp","totalCount":"全2话","id":28234639,"follow":"479.8 万","view":"862.4 万","danmaku":"4.1 万","coin":"9.1 万","score":9.8,"des":"一起庆祝吧！为了这奇迹般的嘉年华！"},{"title":"伍六七","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/b69e26d9e50514f3fa99eac9ab5aabf2a6e28c88.jpg@220w_280h.webp","totalCount":"全13话","id":6360,"follow":"585.8 万","view":"3.3 亿","danmaku":"227.1 万","coin":"191.8 万","score":9.8,"des":"在某个小岛上，有一个可以伪装成任何东西的廉价刺客，名叫伍六七。平时看上去是个理发师，其实背地里却做着刺客生意。热爱理发事业，喜欢给人剪头发，善用剪刀——剪刀也是他的刺杀武器。由于初入刺客行当，行情十分..."},{"title":"命运-冠位指定 -月光／失落之室-","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3fa5fd2b7afae827b0bf150d7f0cbfc54eda1ff2.png@220w_280h.webp","totalCount":"全1话","id":28234950,"follow":"483.3 万","view":"551.2 万","danmaku":9696,"coin":"2.9 万","score":9.5,"des":"失落之室——。\n这是一个可以看到被夺去亦或是遗失之物的地方。\n这是位于迦勒底被遗忘的角落，不属于任何人的地方。..."},{"title":"致不灭的你","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/1ae94fbb35d8e23bb84926b694509f8b057f96e6.png@220w_280h.webp","totalCount":"全20话","id":28233896,"follow":"476.3 万","view":"1.3 亿","danmaku":"140.1 万","coin":"95.0 万","score":9.6,"des":"本剧讲述了一个情节跌宕、场面宏大的奇幻故事，通过拥有不灭之身的主人公“不死”来探索人生哲理。\n不死起初是一个被投放到人世间的“球”。\n\n它具有“幻化为刺激源形态的能力”和“死后重生的能力”。\n\n先后从..."},{"title":"来自新世界","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/aaa60f9cb17fb4a38df464f1064ca9623e0769cc.jpg@220w_280h.webp","totalCount":"全25话","id":1598,"follow":"115.9 万","view":"1540.9 万","danmaku":"76.3 万","coin":"5.7 万","score":9.5,"des":"1000年后的日本，孩子们不断地消失，只存在想象中的恐怖动物与人类展开殊死战争。反乌托邦式的未来超级社会“新世界”，是口吐真言凭藉“咒力”就能移动物体的人类，与有着等同于普通人智力的生物“妖鼠”共存的..."},{"title":"转生成蜘蛛又怎样！","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f0796e37abac25ba2aa9f23120646aaa9a3d5ea7.png@220w_280h.webp","totalCount":"全24话","id":28231809,"follow":"600.0 万","view":"3.7 亿","danmaku":"190.3 万","coin":"164.6 万","score":7.8,"des":"曾经是一名女高中生的“我”，突然转生变成了幻想世界中的蜘蛛魔物。\n而且，出生地点还是各种凶恶魔物所盘踞的大迷宫。\n“我”以人类的智慧和非同寻常的积极心态为武器，使用蜘蛛的丝网以及陷阱打倒比自己等级高得..."},{"title":"装甲重拳/MEGALOBOX 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/e14dc4a935397fc074c7a12d9520225615209025.png@220w_280h.webp","totalCount":"全13话","id":28233916,"follow":"244.9 万","view":"3435.4 万","danmaku":"19.7 万","coin":"53.1 万","score":9.9,"des":"再一次，为梦想而活——\n\n将肉体与“装甲技术”融合的究极格斗技“装甲拳击”。\n在决出其顶点之人的大会“重拳之巅”上，身穿装甲用自己肉身挑战一切的拳击手“JOE”。\n\n从最下层的比赛开始仅仅花了三个月就..."},{"title":"机动战士高达SEED HD","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/855c88677267d707ebfe4040403692ff2c0938f0.png@220w_280h.webp","totalCount":"全48话","id":497,"follow":"54.8 万","view":"4044.4 万","danmaku":"114.4 万","coin":"6.0 万","score":9.6,"des":"《机动战士高达SEED》是高达系列在2002年至2003年度放映的动画。续作为《机动战士高达SEED Destiny》在2004年播放。因各具魅力的角色，明星云集的声优阵容和高度商业化的宣传而受到较低..."},{"title":"夏目友人帐 唤石者与怪异的访客","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6cf43708b779cde84ad285ff4e3a080de98df0af.png@220w_280h.webp","totalCount":"全1话","id":28234316,"follow":"567.1 万","view":"1374.8 万","danmaku":"18.1 万","coin":"17.9 万","score":9.9,"des":"本作由【唤石者】与【怪异的访客】两个人气短篇集锦而成。讲述生来便能看见各种妖怪的夏目，与自称保镖的猫咪老师一同邂逅的一系列温暖故事。\n【唤石者】一天夏目在森林中遇到一只小妖怪——密实。密实称自己肩负「..."},{"title":"Fate/Grand Order ‐First Order‐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/b75c55d209d156c8631f5ceb21e5c52c834dbb60.jpg@220w_280h.webp","totalCount":"全1话","id":5747,"follow":"250.9 万","view":"3329.7 万","danmaku":"76.7 万","coin":"10.7 万","score":8.3,"des":"【2016年12月31日bilibili独播】2015年。示巴所观测到的未来领域毫无前兆地消失。根据计算，发现——不，是证明了人类将于2017年灭绝。人理延续保障机构·迦勒底将“无法观测的领域”假定为..."},{"title":"伍六七之玄武国篇","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/00843865ea13702eccc4efd64c313fd4c8029c6b.jpg@220w_280h.webp","totalCount":"全10话","id":28232253,"follow":"999.4 万","view":"4.0 亿","danmaku":"177.7 万","coin":"385.3 万","score":9.8,"des":"为了保护小鸡岛居民和这里平静的生活，伍六七和他的伙伴大保和小飞开启了去往玄武国的冒险旅程，去寻找身世的真相和解救小岛的办法，等待他们的又将是更多的未知与奇遇。..."},{"title":"堀与宫村","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/039c4e0b14e27c7a9e5cce2f20a6efd3c8909401.png@220w_280h.webp","totalCount":"全13话","id":28231840,"follow":"695.2 万","view":"2.2 亿","danmaku":"242.1 万","coin":"361.4 万","score":9.8,"des":"不论是谁，都会有不想被人知道的一面。\n\n在学校中漂亮大方、成绩优秀的人气女生堀，私下却打扮土气、忙于家务和照顾弟弟。\n在学校中是阴暗宅男形象的宫村，生活中却是打扮时尚、带耳钉的帅气男生。\n因为一次特别..."},{"title":"奇蛋物语 / WONDER EGG PRIORITY","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/10e0bbc1047b2c45f0f881de334a6f3bfb42a3b6.png@220w_280h.webp","totalCount":"全12话","id":28231851,"follow":"254.9 万","view":"4686.8 万","danmaku":"47.6 万","coin":"65.5 万","score":9.7,"des":"14岁少女·大户爱在深夜散步的途中，\n随着神秘声音的指引，获得了一枚「蛋」。\n\n「如果想要改变世界的话」\n「那么就在现在做出选择」\n「请相信自己——」\n「打破这枚蛋——」\n\n而在打破「蛋」之后，等待着..."},{"title":"Re：从零开始的异世界生活 第二季 后半","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/4f3edbede7fc0bdb52842075cf8faaa1c5953eaa.png@220w_280h.webp","totalCount":"全12话","id":28232073,"follow":"849.9 万","view":"9308.1 万","danmaku":"108.1 万","coin":"230.1 万","score":9.9,"des":"我一定会拯救你。\n在打倒了魔女教大罪司教「怠惰」担当——培提其乌斯·罗曼尼康帝之后，菜月昴和爱蜜莉雅又得以重新开始。\n克服了艰难的诀别，两人终于和解，然而这只是新一轮风波的序幕。\n超乎想象的绝境危机，..."},{"title":"灰与幻想的格林姆迦尔","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/7fb4945f864e9e988212b7d20f206df2677053f8.jpg@220w_280h.webp","totalCount":"全12话","id":106512,"follow":"172.0 万","view":"2343.4 万","danmaku":"63.8 万","coin":"18.3 万","score":9.8,"des":"电视动画《灰与幻想的格林姆迦尔》改编自日本轻小说家十文字青原作白井锐利插画的同名轻小说。\n我们为什么要这么做…？\n哈尔希洛回过神来，才发现自己身处在黑暗当中，他完全不知道自己人在何处，也不明白这个地方..."},{"title":"龙与虎","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/144910805f172d16c5f544f43939a05d8ca20576.jpg@220w_280h.webp","totalCount":"全26话","id":1672,"follow":"336.9 万","view":"6671.9 万","danmaku":"511.9 万","coin":"61.5 万","score":9.7,"des":"樱花飞舞的四月，全新的高中二年级，新的班级……\n眼神凶恶的普通男孩——高须龙儿，遇上了众人害怕、凶暴残忍的“掌中老虎”逢坂大河，还知道了她不欲为人知的秘密。这就是龙虎相争爱与战斗的序幕。\n再加上总是笑..."},{"title":"机动战士高达 铁血的奥尔芬斯 第一季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/f84a80d731d0431c00903d8951fd66623d8237f7.png@220w_280h.webp","totalCount":"全25话","id":4310042,"follow":"62.4 万","view":"2318.6 万","danmaku":"52.2 万","coin":"5.4 万","score":9.5,"des":"主人公三日月·奥古斯，从所属的民间警备公司克律塞安保公司（下称CGS）那里，接受了对少女库德莉亚·蓝那·伯恩斯坦的护卫任务。但CGS受到了摘取反叛之芽的武力组织加拉尔霍恩的袭击，于是在把三日月当做诱饵..."},{"title":"机动战士高达00 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1d7a969e8f1045739c596de89a963e30475aff0e.jpg@220w_280h.webp","totalCount":"全25话","id":1193,"follow":"37.2 万","view":"2458.1 万","danmaku":"61.4 万","coin":"4.1 万","score":9.8,"des":"天人与联合国军的最终决战后过了四年。建立地球联邦政府的人类，为了追求更进一步的国家间之统合，以及人类意识的统一，在联合正规军之外，设立了独立治安维持部队“A-Laws”，目的为对所有危害联合的势力与主..."},{"title":"机动战士高达00","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/35b11bf59eb3fd12f0387951510a5d722d7435e5.jpg@220w_280h.webp","totalCount":"全25话","id":1192,"follow":"62.1 万","view":"2465.5 万","danmaku":"53.6 万","coin":"4.6 万","score":9.7,"des":"在西历2307年，虽然化石燃料枯竭了，但是人类得到了截然不同的新型能源。三台巨大的轨道升降机以及伴随它们的大规模的太阳光发电系统。但是能得到这个系统恩惠的，只有一部分大国和其同盟国而已。\n拥有三台轨道..."},{"title":"Re：从零开始的异世界生活 第二季 前半","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f2425cbdb07cc93bd0d3ba1c0099bfe78f5dc58a.png@220w_280h.webp","totalCount":"全13话","id":28229233,"follow":"774.2 万","view":"1.3 亿","danmaku":"201.4 万","coin":"126.7 万","score":9.7,"des":"我一定会拯救你。\n在打倒了魔女教大罪司教「怠惰」担当——培提其乌斯·罗曼尼康帝之后，菜月昴和爱蜜莉雅又得以重新开始。\n克服了艰难的诀别，两人终于和解，然而这只是新一轮风波的序幕。\n超乎想象的绝境危机，..."},{"title":"超级小白","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3d3e8257d22596f5d3e4395ca759bd1e0fe9b873.jpg@220w_280h.webp","totalCount":"全48话","id":28222671,"follow":"27.4 万","view":"978.0 万","danmaku":"3.6 万","coin":"3.6 万","score":9.6,"des":"为了阻止企图霸占世界的黑暗势力，野原家的普通小狗——小白接肩负重大使命，变身成为了守护世界的“超级小白”。小白将要面对的不仅是发明狗，还有其他意想不到的对手。当然，面对邪恶势力，小白也有着令人惊讶的超..."},{"title":"Re：从零开始的异世界生活 新编集版","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3c125e1aad08643e3eff2fb7d45e740c1a052725.png@220w_280h.webp","totalCount":"全13话","id":28224394,"follow":"631.1 万","view":"7674.2 万","danmaku":"166.2 万","coin":"51.1 万","score":9.6,"des":"在从便利商店回家的路上，突然被异世界召唤的少年菜月昴。在无法依靠任何东西的异世界，无力的少年手唯一的力量……那是“死去然后重新开始”的力量。为了守护最重要的人们，为了取回确实存在着又无可替代的时间，少..."},{"title":"因为太怕痛就全点防御力了","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/8021d3f6b0df6dbba6d32f76eb9cfe2531e166c4.png@220w_280h.webp","totalCount":"全12话","id":28224137,"follow":"620.6 万","view":"2.3 亿","danmaku":"326.8 万","coin":"103.8 万","score":9,"des":"主角本条枫在好友白峰理沙推荐下开始游玩游戏“NewWorld Online”，创建了名为“梅普露”的角色。然而作为游戏初学者，梅普露选择了不受欢迎的大盾当武器，同时因为怕痛而把所有状态点加到防御力的极..."},{"title":"冰海战记","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/c30401817895e67399094b4e669785a104270cdf.jpg@220w_280h.webp","totalCount":"全24话","id":28220475,"follow":"174.4 万","view":"4893.8 万","danmaku":"48.7 万","coin":"36.7 万","score":9.8,"des":"公元10世纪末期，出现了在世界各地出没的最强民族。被讴歌为最强战士的托尔兹，其子托尔芬幼时便生活在战场上，并向往着梦幻大陆“文兰”。这是一个发生在激荡时代的，真正的英雄物语。..."},{"title":"齐木楠雄的灾难 始动篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ba59822eded39b5254fb01448a7f1502101d5624.png@220w_280h.webp","totalCount":"全6话","id":28223748,"follow":"372.4 万","view":"3054.5 万","danmaku":"20.0 万","coin":"17.8 万","score":9.8,"des":"在电视剧中堪称帅气的超能力，对于高中生齐木楠雄来说只是招致灾难的元凶。作为新动画系列展开的楠雄的日常又会如何！？..."},{"title":"OVERLORD Ⅱ","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/851f979c8ebcc7583a43abd4b786c4e2e66b746b.jpg@220w_280h.webp","totalCount":"全13话","id":8792,"follow":"539.3 万","view":"3.8 亿","danmaku":"413.9 万","coin":"114.1 万","score":9.6,"des":"时为2138年。曾卷起一大风潮的虚拟现实体感型网络游戏《YGGDRASIL》即将迎来停服。玩家飞鼠在曾经以同伴和荣华自傲的根据地纳萨力克地下大坟墓，独自一人安静等待着那一刻。但是，不料发生了结束时间已..."},{"title":"夏目友人帐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/99c549494d9425f6455bd45a151f4d26397d6151.png@220w_280h.webp","totalCount":"全13话","id":1660,"follow":"324.0 万","view":"4975.2 万","danmaku":"278.7 万","coin":"15.5 万","score":9.8,"des":"夏目贵志生来拥有强大的灵力，能感知平常人所无法接触的妖怪神明的存在。因父母双亡，他多年间辗转于互相推卸责任的亲戚之间，又受到同龄人的欺负，未曾与任何人深交，造成性格一定程度上的孤僻。夏目本性和善，对于..."}],"watched":[{"title":"装甲重拳/MEGALOBOX","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0c44785cb5d25cc9f648800d251f21a2e236bb8a.png@220w_280h.webp","totalCount":"全13话","id":79472,"follow":"221.9 万","view":"6162.0 万","danmaku":"48.6 万","coin":"32.9 万","score":9.8,"des":"将肉体与“装甲技术”融合的究极格斗技——“MEGALOBOX”，将自己的全部赌在上面的男人们的热血战斗开始！\n今天也立于未认可地区的赌博比赛赛场上的MEGALO拳击手“JNK DOG”。虽然具备实力，..."},{"title":"超能力女儿","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/152c536f8ecaad8f3d7d568d33da81c963a4a722.png@220w_280h.webp","totalCount":"全12话","id":78352,"follow":"293.8 万","view":"9252.2 万","danmaku":"98.5 万","coin":"35.4 万","score":9.6,"des":"支持着芦川组的年轻智力型黑道新田义史，过着被喜欢的壶所包围的悠然自得单身生活。但某一天，随着装在神秘物体里的少女雏来到他家，他的生活为之一变。他被能使用念动力的雏所胁迫，迫不得已开始和她同居！\n容易暴..."},{"title":"OVERLORD Ⅲ","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/dd7a9d0a0bee32b1f43c2656398d8463d12b3069.jpg@220w_280h.webp","totalCount":"全13话","id":102252,"follow":"551.6 万","view":"4.0 亿","danmaku":"399.7 万","coin":"129.2 万","score":9.4,"des":"时间为2138年。曾卷起一大风潮的虚拟现实体感型网络游戏《YGGDRASIL》即将迎来停服。玩家飞鼠在曾经以同伴和荣华自傲的根据地纳萨力克地下大坟墓，独自一人安静等待着那一刻。\n但是，不料发生了“过了..."},{"title":"路人超能100 第一次灵能咨询所员工旅游～舒缓心灵的疗愈之旅~（OVA2）","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/1271324d51634b68980704731987724a1afc60aa.jpg@220w_280h.webp","totalCount":"全1话","id":28222715,"follow":"318.8 万","view":"520.7 万","danmaku":"3.6 万","coin":"4.6 万","score":9.8,"des":"由原作ONE老师担任原案的完全新作OVA！「灵能咨询所」一行人，龙套与灵幻、小酒窝以及新同伴芹泽的目的地，正是缟马县深山中鲜为人知的温泉·疣神温泉。因为灵幻接受了旅馆老板娘的委托，「弄清温泉的恐怖传闻..."},{"title":"少女终末旅行","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1431ca5bb2f7143062e3df8f21b8448cf8cccc13.jpg@220w_280h.webp","totalCount":"全12话","id":6463,"follow":"239.8 万","view":"3714.7 万","danmaku":"100.7 万","coin":"37.2 万","score":9.8,"des":"本作舞台在人类繁华的文明迎来终结的很久以后，人类基本灭绝，甚至生物都不再存在的末日世界。复杂够高的都市成为迷宫般的废墟，得不到维护的机械渐渐停止运转。连何时终结了，何时开始终结的思考都不复存在的这个世..."},{"title":"齐木楠雄的灾难（日播&精选版）","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/eb4f17335f48951945fb9da47e6ee0bc65fa2fbb.jpg@220w_280h.webp","totalCount":"全120话","id":5070,"follow":"187.0 万","view":"2.3 亿","danmaku":"130.7 万","coin":"32.7 万","score":9.6,"des":"高中生·齐木楠雄是超能力者。心灵感应、念动力、透视、预知、瞬间移动、千里眼等，不论任何事情都自由自在。但这任谁都羡慕不已的最强能力，实际上对于本人而言是引来灾难的不幸元凶。因此，他在别人面前封印了超能..."},{"title":"比宇宙更远的地方","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/c9eca3cbc386c63b27461074b8b218898cb7440e.jpg@220w_280h.webp","totalCount":"全13话","id":13032,"follow":"156.0 万","view":"2298.0 万","danmaku":"45.9 万","coin":"23.9 万","score":9.8,"des":"无论何时，我们的第一步总是从好奇心开始。\n不曾看过的风景，不曾听过的声音，不曾闻过的味道，不曾摸过的质感，不曾尝过的食物，以及不曾感受过的澎湃。\n为了重拾不知何时忘却的记忆碎片和不知何时舍弃的感动的旅..."},{"title":"OVERLORD","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/b8e72ea69e57e0b7ac85d8b4d366554fd866df1a.jpg@220w_280h.webp","totalCount":"全13话","id":2576,"follow":"626.2 万","view":"4.1 亿","danmaku":"385.2 万","coin":"84.4 万","score":9.6,"des":"作品主要讲述了某天，一款曾经掀起过大热潮的VRMMORPG「YGGDRASIL」停止了运营。游戏原本会停止一切服务，但过了结束时间后，玩家们却发现不能退出，NPC也产生了各自的思想。现实世界中喜爱电玩..."},{"title":"路人超能100 II(灵能百分百 第二季)","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/216e1bdaf88244215a13b1154116805ee9adbe07.png@220w_280h.webp","totalCount":"全13话","id":4762734,"follow":"284.9 万","view":"1.0 亿","danmaku":"97.8 万","coin":"56.1 万","score":9.9,"des":"当有什么东西达到“100”的时候，就会爆发的少年·路人（龙套）。外表极其普通——不如说是不起眼。不擅长迎合气氛的他，实际上拥有着强力的超能力。盯上了这样的他的能力，而接连现身的伪灵能力者以及宗教团体、..."},{"title":"多罗罗","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3fc16a667502cbff226e585eb660a96a20c7458c.png@220w_280h.webp","totalCount":"全24话","id":4312482,"follow":"452.1 万","view":"1.8 亿","danmaku":"143.9 万","coin":"73.9 万","score":9.4,"des":"他们向着命运抗争，在那尽头等待他们的是人心，还是业障。\n时值乱世。\n名为景光的醍醐将军，向某个寺庙殿堂中的12尊魔神像祈求早日结束战乱。\n作为代价，他的嫡子在出生时就失去了身体的某些部位，被丢弃在河流..."},{"title":"魔法少女小圆","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/7fcaa0e98b561611538ae4deba7949cec4ca39a8.png@220w_280h.webp","totalCount":"全12话","id":2539,"follow":"218.7 万","view":"4199.0 万","danmaku":"201.5 万","coin":"20.0 万","score":9.8,"des":"就读初中二年级的鹿目圆，过着平凡幸福的生活。神秘转学生晓美焰的出现，开始让小圆的命运有了巨大转变。某日一只名为丘比的神秘生物，希望小圆能够与它签订魔法契约，成为“魔法少女”以对抗邪恶的魔女保护世界。正..."}]},"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"http://rebp38war.bkt.clouddn.com/img/v2-358cb55f001519e6e76bb920008839da_r.jpg","excerpt":"","more":"<blockquote>\n<p> 我是一个半路出家的程序员，希望以写博客的方式，记录自己的编程学习生涯。以让自己坚持编程下去。</p>\n</blockquote>\n<p><img src=\"/img/patrick.jpg\" alt=\"avatar\"><br></p>\n<pre><code>世上只有一种英雄主义，就是再认清生活的真相之后依然热爱生活。                                --罗曼罗兰\n</code></pre>\n<p align=\"right\"><font face=\"黑体\" size=\"2\">2021/12/27 17:00:45 </font></p>"},{"title":"bangumis","date":"2022-07-05T06:57:36.000Z","type":"bangumis","_content":"","source":"bangumis/index.md","raw":"---\ntitle: bangumis\ndate: 2022-07-05 14:57:36\ntype: \"bangumis\"\n---\n","updated":"2022-07-05T06:58:15.305Z","path":"bangumis/index.html","comments":1,"layout":"page","_id":"cl5w7e73p0002igvu0ehdg74f","content":"","site":{"data":{"bangumis":{"wantWatch":[],"watching":[{"title":"凡人修仙传","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/70d11dfab23a3ee81ccf64f18efa139416a633ff.jpg@220w_280h.webp","totalCount":"未完结","id":28223043,"follow":"615.7 万","view":"8.9 亿","danmaku":"490.9 万","coin":"1186.9 万","score":9.7,"des":"看机智的凡人小子韩立如何稳健发展、步步为营，战魔道、夺至宝、驰骋星海、快意恩仇，成为纵横三界的强者。他日仙界重相逢，一声道友尽沧桑。..."},{"title":"恋爱游戏世界对路人角色很不友好","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/c9723d8c77d881a8debba2852d580e97826b43d0.png@220w_280h.webp","totalCount":"全12话","id":28237300,"follow":"151.2 万","view":"5120.4 万","danmaku":"40.6 万","coin":"24.5 万","score":9.1,"des":"从现代日本转生到“恋爱游戏”世界的里昂，发现这里女尊男卑，对男性很不友好。身为路人角色的他，为了摆脱自己因地位低下而被肆意决定的人生，决定活用从游戏中得到的知识，保持路人角色的身份，取得“失落物品”来..."},{"title":"魔法纪录 魔法少女小圆外传 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/9eef1df9ab157be52d2c4d70d3500442f00cafc3.png@220w_280h.webp","totalCount":"全12话","id":28234642,"follow":"237.1 万","view":"907.6 万","danmaku":"5.0 万","coin":"4.9 万","score":7.7,"des":"愿望的代价，究竟是希望还是绝望——。"},{"title":"小林家的龙女仆 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/847e9dbb6876fb37a30199a5c88910704976d45b.png@220w_280h.webp","totalCount":"全13话","id":28234613,"follow":"855.7 万","view":"1.1 亿","danmaku":"49.0 万","coin":"69.0 万","score":9.6,"des":"那位不可思议的龙女仆再度登场！\n因为各种奇妙的原因而作为小林家的女仆而工作中的龙·托尔。\n偶尔（胡说，是经常）给亲爱的小林添麻烦，总算是融入了人类社会，成为了一个完美的（骗人，也就还行）女仆。\n同样是..."},{"title":"国王排名","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/376d7e69a667bcb1c0b934a4e35e07e7fa23110b.png@220w_280h.webp","totalCount":"全23话","id":28235154,"follow":"927.7 万","view":"4.8 亿","danmaku":"250.1 万","coin":"260.9 万","score":7,"des":"国家的丰饶、麾下勇者的数量、\n以及国王本人如何像勇者一般强大，\n这些要素的综合排名，便是所谓的“国王排名”。\n主人公波吉是国王排名第七名的伯斯王治下王国的第一王子。\n但是波吉却生来又聋又哑，贫弱到挥不..."},{"title":"阿松 第三季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0212baa8898d0c819c7fb84015e95b8fca621435.png@220w_280h.webp","totalCount":"全25话","id":28229892,"follow":"67.6 万","view":"938.0 万","danmaku":"13.0 万","coin":"5.4 万","score":9.6,"des":"日本最有名的六胞胎的传说，第三次开幕！！这次会有怎样意想不到的新展开！？..."},{"title":"命运-冠位指定 冠位时间神殿所罗门","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0e094b798388da19a4feffa6a6dabc1dc1dc90cd.jpg@220w_280h.webp","totalCount":"全1话","id":28236225,"follow":"525.5 万","view":"1220.0 万","danmaku":"8.9 万","coin":"15.1 万","score":8.5,"des":"在经过七个特异点的大战后，\n人理存续保障机关迦勒底，终于到达了圣杯探索的最终地点——终局特异点 冠位时间神殿所罗门。\n他们要击败身为罪魁祸首的魔术王所罗门，夺回未来。\n在开战的前一刻，一行人各自度过了..."},{"title":"JOJO的奇妙冒险 星尘远征军","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/47c0108259355d6d2c517ed97f6b90fb777f844f.png@220w_280h.webp","totalCount":"全24话","id":28223481,"follow":"444.2 万","view":"1.5 亿","danmaku":"463.4 万","coin":"45.7 万","score":9.8,"des":"时为1987年，乔瑟夫·乔斯达与“柱之男”们之间的死战后过了50年……乔瑟夫为了为了帮助“被恶灵附身了”的外孙子·空条承太郎而来到了日本。原来那并不是恶灵而是幽波纹（替身）。替身突然出现的原因在于，从..."},{"title":"JOJO的奇妙冒险 星尘远征军 埃及篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f6709b76e88f50aa132d1e09e2d8de9663a09b3e.png@220w_280h.webp","totalCount":"全24话","id":28223483,"follow":"421.9 万","view":"1.3 亿","danmaku":"468.7 万","coin":"44.3 万","score":9.9,"des":"在乔斯达家的宿敌·迪奥（DIO）复活的影响下，一位年轻人——空条承太郎，得到了名为“幽波纹（替身）”的能力。为了拯救因迪奥的诅咒而倒下的母亲荷莉，空条承太郎与外祖父·乔瑟夫以及伙伴们，一起为了打倒迪奥..."},{"title":"JOJO的奇妙冒险 不灭钻石","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/6a04c87e990ab74cd8d555ef45a863de0993b161.png@220w_280h.webp","totalCount":"全39话","id":140552,"follow":"302.3 万","view":"2.1 亿","danmaku":"813.8 万","coin":"55.9 万","score":9.8,"des":"在埃及与宿敌DIO的死斗之后过了11年。1999年，空条承太郎为了与祖父乔瑟夫·乔斯达的私生子东方仗助见面，而来到了日本M县S市杜王町。但，仗助却持有与承太郎相同的特殊能力“替身”。之后，以承太郎的来..."},{"title":"命运-冠位嘉年华","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/c660976f4502a544d990a882ae62194b57753a71.png@220w_280h.webp","totalCount":"全2话","id":28234639,"follow":"479.8 万","view":"862.4 万","danmaku":"4.1 万","coin":"9.1 万","score":9.8,"des":"一起庆祝吧！为了这奇迹般的嘉年华！"},{"title":"伍六七","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/b69e26d9e50514f3fa99eac9ab5aabf2a6e28c88.jpg@220w_280h.webp","totalCount":"全13话","id":6360,"follow":"585.8 万","view":"3.3 亿","danmaku":"227.1 万","coin":"191.8 万","score":9.8,"des":"在某个小岛上，有一个可以伪装成任何东西的廉价刺客，名叫伍六七。平时看上去是个理发师，其实背地里却做着刺客生意。热爱理发事业，喜欢给人剪头发，善用剪刀——剪刀也是他的刺杀武器。由于初入刺客行当，行情十分..."},{"title":"命运-冠位指定 -月光／失落之室-","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3fa5fd2b7afae827b0bf150d7f0cbfc54eda1ff2.png@220w_280h.webp","totalCount":"全1话","id":28234950,"follow":"483.3 万","view":"551.2 万","danmaku":9696,"coin":"2.9 万","score":9.5,"des":"失落之室——。\n这是一个可以看到被夺去亦或是遗失之物的地方。\n这是位于迦勒底被遗忘的角落，不属于任何人的地方。..."},{"title":"致不灭的你","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/1ae94fbb35d8e23bb84926b694509f8b057f96e6.png@220w_280h.webp","totalCount":"全20话","id":28233896,"follow":"476.3 万","view":"1.3 亿","danmaku":"140.1 万","coin":"95.0 万","score":9.6,"des":"本剧讲述了一个情节跌宕、场面宏大的奇幻故事，通过拥有不灭之身的主人公“不死”来探索人生哲理。\n不死起初是一个被投放到人世间的“球”。\n\n它具有“幻化为刺激源形态的能力”和“死后重生的能力”。\n\n先后从..."},{"title":"来自新世界","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/aaa60f9cb17fb4a38df464f1064ca9623e0769cc.jpg@220w_280h.webp","totalCount":"全25话","id":1598,"follow":"115.9 万","view":"1540.9 万","danmaku":"76.3 万","coin":"5.7 万","score":9.5,"des":"1000年后的日本，孩子们不断地消失，只存在想象中的恐怖动物与人类展开殊死战争。反乌托邦式的未来超级社会“新世界”，是口吐真言凭藉“咒力”就能移动物体的人类，与有着等同于普通人智力的生物“妖鼠”共存的..."},{"title":"转生成蜘蛛又怎样！","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f0796e37abac25ba2aa9f23120646aaa9a3d5ea7.png@220w_280h.webp","totalCount":"全24话","id":28231809,"follow":"600.0 万","view":"3.7 亿","danmaku":"190.3 万","coin":"164.6 万","score":7.8,"des":"曾经是一名女高中生的“我”，突然转生变成了幻想世界中的蜘蛛魔物。\n而且，出生地点还是各种凶恶魔物所盘踞的大迷宫。\n“我”以人类的智慧和非同寻常的积极心态为武器，使用蜘蛛的丝网以及陷阱打倒比自己等级高得..."},{"title":"装甲重拳/MEGALOBOX 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/e14dc4a935397fc074c7a12d9520225615209025.png@220w_280h.webp","totalCount":"全13话","id":28233916,"follow":"244.9 万","view":"3435.4 万","danmaku":"19.7 万","coin":"53.1 万","score":9.9,"des":"再一次，为梦想而活——\n\n将肉体与“装甲技术”融合的究极格斗技“装甲拳击”。\n在决出其顶点之人的大会“重拳之巅”上，身穿装甲用自己肉身挑战一切的拳击手“JOE”。\n\n从最下层的比赛开始仅仅花了三个月就..."},{"title":"机动战士高达SEED HD","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/855c88677267d707ebfe4040403692ff2c0938f0.png@220w_280h.webp","totalCount":"全48话","id":497,"follow":"54.8 万","view":"4044.4 万","danmaku":"114.4 万","coin":"6.0 万","score":9.6,"des":"《机动战士高达SEED》是高达系列在2002年至2003年度放映的动画。续作为《机动战士高达SEED Destiny》在2004年播放。因各具魅力的角色，明星云集的声优阵容和高度商业化的宣传而受到较低..."},{"title":"夏目友人帐 唤石者与怪异的访客","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6cf43708b779cde84ad285ff4e3a080de98df0af.png@220w_280h.webp","totalCount":"全1话","id":28234316,"follow":"567.1 万","view":"1374.8 万","danmaku":"18.1 万","coin":"17.9 万","score":9.9,"des":"本作由【唤石者】与【怪异的访客】两个人气短篇集锦而成。讲述生来便能看见各种妖怪的夏目，与自称保镖的猫咪老师一同邂逅的一系列温暖故事。\n【唤石者】一天夏目在森林中遇到一只小妖怪——密实。密实称自己肩负「..."},{"title":"Fate/Grand Order ‐First Order‐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/b75c55d209d156c8631f5ceb21e5c52c834dbb60.jpg@220w_280h.webp","totalCount":"全1话","id":5747,"follow":"250.9 万","view":"3329.7 万","danmaku":"76.7 万","coin":"10.7 万","score":8.3,"des":"【2016年12月31日bilibili独播】2015年。示巴所观测到的未来领域毫无前兆地消失。根据计算，发现——不，是证明了人类将于2017年灭绝。人理延续保障机构·迦勒底将“无法观测的领域”假定为..."},{"title":"伍六七之玄武国篇","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/00843865ea13702eccc4efd64c313fd4c8029c6b.jpg@220w_280h.webp","totalCount":"全10话","id":28232253,"follow":"999.4 万","view":"4.0 亿","danmaku":"177.7 万","coin":"385.3 万","score":9.8,"des":"为了保护小鸡岛居民和这里平静的生活，伍六七和他的伙伴大保和小飞开启了去往玄武国的冒险旅程，去寻找身世的真相和解救小岛的办法，等待他们的又将是更多的未知与奇遇。..."},{"title":"堀与宫村","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/039c4e0b14e27c7a9e5cce2f20a6efd3c8909401.png@220w_280h.webp","totalCount":"全13话","id":28231840,"follow":"695.2 万","view":"2.2 亿","danmaku":"242.1 万","coin":"361.4 万","score":9.8,"des":"不论是谁，都会有不想被人知道的一面。\n\n在学校中漂亮大方、成绩优秀的人气女生堀，私下却打扮土气、忙于家务和照顾弟弟。\n在学校中是阴暗宅男形象的宫村，生活中却是打扮时尚、带耳钉的帅气男生。\n因为一次特别..."},{"title":"奇蛋物语 / WONDER EGG PRIORITY","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/10e0bbc1047b2c45f0f881de334a6f3bfb42a3b6.png@220w_280h.webp","totalCount":"全12话","id":28231851,"follow":"254.9 万","view":"4686.8 万","danmaku":"47.6 万","coin":"65.5 万","score":9.7,"des":"14岁少女·大户爱在深夜散步的途中，\n随着神秘声音的指引，获得了一枚「蛋」。\n\n「如果想要改变世界的话」\n「那么就在现在做出选择」\n「请相信自己——」\n「打破这枚蛋——」\n\n而在打破「蛋」之后，等待着..."},{"title":"Re：从零开始的异世界生活 第二季 后半","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/4f3edbede7fc0bdb52842075cf8faaa1c5953eaa.png@220w_280h.webp","totalCount":"全12话","id":28232073,"follow":"849.9 万","view":"9308.1 万","danmaku":"108.1 万","coin":"230.1 万","score":9.9,"des":"我一定会拯救你。\n在打倒了魔女教大罪司教「怠惰」担当——培提其乌斯·罗曼尼康帝之后，菜月昴和爱蜜莉雅又得以重新开始。\n克服了艰难的诀别，两人终于和解，然而这只是新一轮风波的序幕。\n超乎想象的绝境危机，..."},{"title":"灰与幻想的格林姆迦尔","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/7fb4945f864e9e988212b7d20f206df2677053f8.jpg@220w_280h.webp","totalCount":"全12话","id":106512,"follow":"172.0 万","view":"2343.4 万","danmaku":"63.8 万","coin":"18.3 万","score":9.8,"des":"电视动画《灰与幻想的格林姆迦尔》改编自日本轻小说家十文字青原作白井锐利插画的同名轻小说。\n我们为什么要这么做…？\n哈尔希洛回过神来，才发现自己身处在黑暗当中，他完全不知道自己人在何处，也不明白这个地方..."},{"title":"龙与虎","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/144910805f172d16c5f544f43939a05d8ca20576.jpg@220w_280h.webp","totalCount":"全26话","id":1672,"follow":"336.9 万","view":"6671.9 万","danmaku":"511.9 万","coin":"61.5 万","score":9.7,"des":"樱花飞舞的四月，全新的高中二年级，新的班级……\n眼神凶恶的普通男孩——高须龙儿，遇上了众人害怕、凶暴残忍的“掌中老虎”逢坂大河，还知道了她不欲为人知的秘密。这就是龙虎相争爱与战斗的序幕。\n再加上总是笑..."},{"title":"机动战士高达 铁血的奥尔芬斯 第一季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/f84a80d731d0431c00903d8951fd66623d8237f7.png@220w_280h.webp","totalCount":"全25话","id":4310042,"follow":"62.4 万","view":"2318.6 万","danmaku":"52.2 万","coin":"5.4 万","score":9.5,"des":"主人公三日月·奥古斯，从所属的民间警备公司克律塞安保公司（下称CGS）那里，接受了对少女库德莉亚·蓝那·伯恩斯坦的护卫任务。但CGS受到了摘取反叛之芽的武力组织加拉尔霍恩的袭击，于是在把三日月当做诱饵..."},{"title":"机动战士高达00 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1d7a969e8f1045739c596de89a963e30475aff0e.jpg@220w_280h.webp","totalCount":"全25话","id":1193,"follow":"37.2 万","view":"2458.1 万","danmaku":"61.4 万","coin":"4.1 万","score":9.8,"des":"天人与联合国军的最终决战后过了四年。建立地球联邦政府的人类，为了追求更进一步的国家间之统合，以及人类意识的统一，在联合正规军之外，设立了独立治安维持部队“A-Laws”，目的为对所有危害联合的势力与主..."},{"title":"机动战士高达00","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/35b11bf59eb3fd12f0387951510a5d722d7435e5.jpg@220w_280h.webp","totalCount":"全25话","id":1192,"follow":"62.1 万","view":"2465.5 万","danmaku":"53.6 万","coin":"4.6 万","score":9.7,"des":"在西历2307年，虽然化石燃料枯竭了，但是人类得到了截然不同的新型能源。三台巨大的轨道升降机以及伴随它们的大规模的太阳光发电系统。但是能得到这个系统恩惠的，只有一部分大国和其同盟国而已。\n拥有三台轨道..."},{"title":"Re：从零开始的异世界生活 第二季 前半","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f2425cbdb07cc93bd0d3ba1c0099bfe78f5dc58a.png@220w_280h.webp","totalCount":"全13话","id":28229233,"follow":"774.2 万","view":"1.3 亿","danmaku":"201.4 万","coin":"126.7 万","score":9.7,"des":"我一定会拯救你。\n在打倒了魔女教大罪司教「怠惰」担当——培提其乌斯·罗曼尼康帝之后，菜月昴和爱蜜莉雅又得以重新开始。\n克服了艰难的诀别，两人终于和解，然而这只是新一轮风波的序幕。\n超乎想象的绝境危机，..."},{"title":"超级小白","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3d3e8257d22596f5d3e4395ca759bd1e0fe9b873.jpg@220w_280h.webp","totalCount":"全48话","id":28222671,"follow":"27.4 万","view":"978.0 万","danmaku":"3.6 万","coin":"3.6 万","score":9.6,"des":"为了阻止企图霸占世界的黑暗势力，野原家的普通小狗——小白接肩负重大使命，变身成为了守护世界的“超级小白”。小白将要面对的不仅是发明狗，还有其他意想不到的对手。当然，面对邪恶势力，小白也有着令人惊讶的超..."},{"title":"Re：从零开始的异世界生活 新编集版","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3c125e1aad08643e3eff2fb7d45e740c1a052725.png@220w_280h.webp","totalCount":"全13话","id":28224394,"follow":"631.1 万","view":"7674.2 万","danmaku":"166.2 万","coin":"51.1 万","score":9.6,"des":"在从便利商店回家的路上，突然被异世界召唤的少年菜月昴。在无法依靠任何东西的异世界，无力的少年手唯一的力量……那是“死去然后重新开始”的力量。为了守护最重要的人们，为了取回确实存在着又无可替代的时间，少..."},{"title":"因为太怕痛就全点防御力了","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/8021d3f6b0df6dbba6d32f76eb9cfe2531e166c4.png@220w_280h.webp","totalCount":"全12话","id":28224137,"follow":"620.6 万","view":"2.3 亿","danmaku":"326.8 万","coin":"103.8 万","score":9,"des":"主角本条枫在好友白峰理沙推荐下开始游玩游戏“NewWorld Online”，创建了名为“梅普露”的角色。然而作为游戏初学者，梅普露选择了不受欢迎的大盾当武器，同时因为怕痛而把所有状态点加到防御力的极..."},{"title":"冰海战记","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/c30401817895e67399094b4e669785a104270cdf.jpg@220w_280h.webp","totalCount":"全24话","id":28220475,"follow":"174.4 万","view":"4893.8 万","danmaku":"48.7 万","coin":"36.7 万","score":9.8,"des":"公元10世纪末期，出现了在世界各地出没的最强民族。被讴歌为最强战士的托尔兹，其子托尔芬幼时便生活在战场上，并向往着梦幻大陆“文兰”。这是一个发生在激荡时代的，真正的英雄物语。..."},{"title":"齐木楠雄的灾难 始动篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ba59822eded39b5254fb01448a7f1502101d5624.png@220w_280h.webp","totalCount":"全6话","id":28223748,"follow":"372.4 万","view":"3054.5 万","danmaku":"20.0 万","coin":"17.8 万","score":9.8,"des":"在电视剧中堪称帅气的超能力，对于高中生齐木楠雄来说只是招致灾难的元凶。作为新动画系列展开的楠雄的日常又会如何！？..."},{"title":"OVERLORD Ⅱ","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/851f979c8ebcc7583a43abd4b786c4e2e66b746b.jpg@220w_280h.webp","totalCount":"全13话","id":8792,"follow":"539.3 万","view":"3.8 亿","danmaku":"413.9 万","coin":"114.1 万","score":9.6,"des":"时为2138年。曾卷起一大风潮的虚拟现实体感型网络游戏《YGGDRASIL》即将迎来停服。玩家飞鼠在曾经以同伴和荣华自傲的根据地纳萨力克地下大坟墓，独自一人安静等待着那一刻。但是，不料发生了结束时间已..."},{"title":"夏目友人帐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/99c549494d9425f6455bd45a151f4d26397d6151.png@220w_280h.webp","totalCount":"全13话","id":1660,"follow":"324.0 万","view":"4975.2 万","danmaku":"278.7 万","coin":"15.5 万","score":9.8,"des":"夏目贵志生来拥有强大的灵力，能感知平常人所无法接触的妖怪神明的存在。因父母双亡，他多年间辗转于互相推卸责任的亲戚之间，又受到同龄人的欺负，未曾与任何人深交，造成性格一定程度上的孤僻。夏目本性和善，对于..."}],"watched":[{"title":"装甲重拳/MEGALOBOX","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0c44785cb5d25cc9f648800d251f21a2e236bb8a.png@220w_280h.webp","totalCount":"全13话","id":79472,"follow":"221.9 万","view":"6162.0 万","danmaku":"48.6 万","coin":"32.9 万","score":9.8,"des":"将肉体与“装甲技术”融合的究极格斗技——“MEGALOBOX”，将自己的全部赌在上面的男人们的热血战斗开始！\n今天也立于未认可地区的赌博比赛赛场上的MEGALO拳击手“JNK DOG”。虽然具备实力，..."},{"title":"超能力女儿","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/152c536f8ecaad8f3d7d568d33da81c963a4a722.png@220w_280h.webp","totalCount":"全12话","id":78352,"follow":"293.8 万","view":"9252.2 万","danmaku":"98.5 万","coin":"35.4 万","score":9.6,"des":"支持着芦川组的年轻智力型黑道新田义史，过着被喜欢的壶所包围的悠然自得单身生活。但某一天，随着装在神秘物体里的少女雏来到他家，他的生活为之一变。他被能使用念动力的雏所胁迫，迫不得已开始和她同居！\n容易暴..."},{"title":"OVERLORD Ⅲ","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/dd7a9d0a0bee32b1f43c2656398d8463d12b3069.jpg@220w_280h.webp","totalCount":"全13话","id":102252,"follow":"551.6 万","view":"4.0 亿","danmaku":"399.7 万","coin":"129.2 万","score":9.4,"des":"时间为2138年。曾卷起一大风潮的虚拟现实体感型网络游戏《YGGDRASIL》即将迎来停服。玩家飞鼠在曾经以同伴和荣华自傲的根据地纳萨力克地下大坟墓，独自一人安静等待着那一刻。\n但是，不料发生了“过了..."},{"title":"路人超能100 第一次灵能咨询所员工旅游～舒缓心灵的疗愈之旅~（OVA2）","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/1271324d51634b68980704731987724a1afc60aa.jpg@220w_280h.webp","totalCount":"全1话","id":28222715,"follow":"318.8 万","view":"520.7 万","danmaku":"3.6 万","coin":"4.6 万","score":9.8,"des":"由原作ONE老师担任原案的完全新作OVA！「灵能咨询所」一行人，龙套与灵幻、小酒窝以及新同伴芹泽的目的地，正是缟马县深山中鲜为人知的温泉·疣神温泉。因为灵幻接受了旅馆老板娘的委托，「弄清温泉的恐怖传闻..."},{"title":"少女终末旅行","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1431ca5bb2f7143062e3df8f21b8448cf8cccc13.jpg@220w_280h.webp","totalCount":"全12话","id":6463,"follow":"239.8 万","view":"3714.7 万","danmaku":"100.7 万","coin":"37.2 万","score":9.8,"des":"本作舞台在人类繁华的文明迎来终结的很久以后，人类基本灭绝，甚至生物都不再存在的末日世界。复杂够高的都市成为迷宫般的废墟，得不到维护的机械渐渐停止运转。连何时终结了，何时开始终结的思考都不复存在的这个世..."},{"title":"齐木楠雄的灾难（日播&精选版）","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/eb4f17335f48951945fb9da47e6ee0bc65fa2fbb.jpg@220w_280h.webp","totalCount":"全120话","id":5070,"follow":"187.0 万","view":"2.3 亿","danmaku":"130.7 万","coin":"32.7 万","score":9.6,"des":"高中生·齐木楠雄是超能力者。心灵感应、念动力、透视、预知、瞬间移动、千里眼等，不论任何事情都自由自在。但这任谁都羡慕不已的最强能力，实际上对于本人而言是引来灾难的不幸元凶。因此，他在别人面前封印了超能..."},{"title":"比宇宙更远的地方","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/c9eca3cbc386c63b27461074b8b218898cb7440e.jpg@220w_280h.webp","totalCount":"全13话","id":13032,"follow":"156.0 万","view":"2298.0 万","danmaku":"45.9 万","coin":"23.9 万","score":9.8,"des":"无论何时，我们的第一步总是从好奇心开始。\n不曾看过的风景，不曾听过的声音，不曾闻过的味道，不曾摸过的质感，不曾尝过的食物，以及不曾感受过的澎湃。\n为了重拾不知何时忘却的记忆碎片和不知何时舍弃的感动的旅..."},{"title":"OVERLORD","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/b8e72ea69e57e0b7ac85d8b4d366554fd866df1a.jpg@220w_280h.webp","totalCount":"全13话","id":2576,"follow":"626.2 万","view":"4.1 亿","danmaku":"385.2 万","coin":"84.4 万","score":9.6,"des":"作品主要讲述了某天，一款曾经掀起过大热潮的VRMMORPG「YGGDRASIL」停止了运营。游戏原本会停止一切服务，但过了结束时间后，玩家们却发现不能退出，NPC也产生了各自的思想。现实世界中喜爱电玩..."},{"title":"路人超能100 II(灵能百分百 第二季)","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/216e1bdaf88244215a13b1154116805ee9adbe07.png@220w_280h.webp","totalCount":"全13话","id":4762734,"follow":"284.9 万","view":"1.0 亿","danmaku":"97.8 万","coin":"56.1 万","score":9.9,"des":"当有什么东西达到“100”的时候，就会爆发的少年·路人（龙套）。外表极其普通——不如说是不起眼。不擅长迎合气氛的他，实际上拥有着强力的超能力。盯上了这样的他的能力，而接连现身的伪灵能力者以及宗教团体、..."},{"title":"多罗罗","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3fc16a667502cbff226e585eb660a96a20c7458c.png@220w_280h.webp","totalCount":"全24话","id":4312482,"follow":"452.1 万","view":"1.8 亿","danmaku":"143.9 万","coin":"73.9 万","score":9.4,"des":"他们向着命运抗争，在那尽头等待他们的是人心，还是业障。\n时值乱世。\n名为景光的醍醐将军，向某个寺庙殿堂中的12尊魔神像祈求早日结束战乱。\n作为代价，他的嫡子在出生时就失去了身体的某些部位，被丢弃在河流..."},{"title":"魔法少女小圆","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/7fcaa0e98b561611538ae4deba7949cec4ca39a8.png@220w_280h.webp","totalCount":"全12话","id":2539,"follow":"218.7 万","view":"4199.0 万","danmaku":"201.5 万","coin":"20.0 万","score":9.8,"des":"就读初中二年级的鹿目圆，过着平凡幸福的生活。神秘转学生晓美焰的出现，开始让小圆的命运有了巨大转变。某日一只名为丘比的神秘生物，希望小圆能够与它签订魔法契约，成为“魔法少女”以对抗邪恶的魔女保护世界。正..."}]},"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"http://rebp38war.bkt.clouddn.com/img/v2-0ae647a31329c6851d322f313b75ffaf_r.jpg","excerpt":"","more":""},{"title":"gameboy","date":"2022-07-05T08:15:04.000Z","type":"gameboy","_content":"\njs编写的在线GBA模拟器</br>\n\n[http://120.48.107.220:7878/](http://120.48.107.220:7878/ \"GBA\")</br>\n后续有时间改造一下","source":"gameboy/index.md","raw":"---\ntitle: gameboy\ndate: 2022-07-05 16:15:04\ntype: \"gameboy\"\n---\n\njs编写的在线GBA模拟器</br>\n\n[http://120.48.107.220:7878/](http://120.48.107.220:7878/ \"GBA\")</br>\n后续有时间改造一下","updated":"2022-07-05T08:19:58.245Z","path":"gameboy/index.html","comments":1,"layout":"page","_id":"cl5w7e73u0006igvu2h6r6mbu","content":"<p>js编写的在线GBA模拟器<br></p>\n<p><a href=\"http://120.48.107.220:7878/\" title=\"GBA\">http://120.48.107.220:7878/</a><br><br>后续有时间改造一下</p>\n","site":{"data":{"bangumis":{"wantWatch":[],"watching":[{"title":"凡人修仙传","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/70d11dfab23a3ee81ccf64f18efa139416a633ff.jpg@220w_280h.webp","totalCount":"未完结","id":28223043,"follow":"615.7 万","view":"8.9 亿","danmaku":"490.9 万","coin":"1186.9 万","score":9.7,"des":"看机智的凡人小子韩立如何稳健发展、步步为营，战魔道、夺至宝、驰骋星海、快意恩仇，成为纵横三界的强者。他日仙界重相逢，一声道友尽沧桑。..."},{"title":"恋爱游戏世界对路人角色很不友好","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/c9723d8c77d881a8debba2852d580e97826b43d0.png@220w_280h.webp","totalCount":"全12话","id":28237300,"follow":"151.2 万","view":"5120.4 万","danmaku":"40.6 万","coin":"24.5 万","score":9.1,"des":"从现代日本转生到“恋爱游戏”世界的里昂，发现这里女尊男卑，对男性很不友好。身为路人角色的他，为了摆脱自己因地位低下而被肆意决定的人生，决定活用从游戏中得到的知识，保持路人角色的身份，取得“失落物品”来..."},{"title":"魔法纪录 魔法少女小圆外传 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/9eef1df9ab157be52d2c4d70d3500442f00cafc3.png@220w_280h.webp","totalCount":"全12话","id":28234642,"follow":"237.1 万","view":"907.6 万","danmaku":"5.0 万","coin":"4.9 万","score":7.7,"des":"愿望的代价，究竟是希望还是绝望——。"},{"title":"小林家的龙女仆 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/847e9dbb6876fb37a30199a5c88910704976d45b.png@220w_280h.webp","totalCount":"全13话","id":28234613,"follow":"855.7 万","view":"1.1 亿","danmaku":"49.0 万","coin":"69.0 万","score":9.6,"des":"那位不可思议的龙女仆再度登场！\n因为各种奇妙的原因而作为小林家的女仆而工作中的龙·托尔。\n偶尔（胡说，是经常）给亲爱的小林添麻烦，总算是融入了人类社会，成为了一个完美的（骗人，也就还行）女仆。\n同样是..."},{"title":"国王排名","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/376d7e69a667bcb1c0b934a4e35e07e7fa23110b.png@220w_280h.webp","totalCount":"全23话","id":28235154,"follow":"927.7 万","view":"4.8 亿","danmaku":"250.1 万","coin":"260.9 万","score":7,"des":"国家的丰饶、麾下勇者的数量、\n以及国王本人如何像勇者一般强大，\n这些要素的综合排名，便是所谓的“国王排名”。\n主人公波吉是国王排名第七名的伯斯王治下王国的第一王子。\n但是波吉却生来又聋又哑，贫弱到挥不..."},{"title":"阿松 第三季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0212baa8898d0c819c7fb84015e95b8fca621435.png@220w_280h.webp","totalCount":"全25话","id":28229892,"follow":"67.6 万","view":"938.0 万","danmaku":"13.0 万","coin":"5.4 万","score":9.6,"des":"日本最有名的六胞胎的传说，第三次开幕！！这次会有怎样意想不到的新展开！？..."},{"title":"命运-冠位指定 冠位时间神殿所罗门","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0e094b798388da19a4feffa6a6dabc1dc1dc90cd.jpg@220w_280h.webp","totalCount":"全1话","id":28236225,"follow":"525.5 万","view":"1220.0 万","danmaku":"8.9 万","coin":"15.1 万","score":8.5,"des":"在经过七个特异点的大战后，\n人理存续保障机关迦勒底，终于到达了圣杯探索的最终地点——终局特异点 冠位时间神殿所罗门。\n他们要击败身为罪魁祸首的魔术王所罗门，夺回未来。\n在开战的前一刻，一行人各自度过了..."},{"title":"JOJO的奇妙冒险 星尘远征军","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/47c0108259355d6d2c517ed97f6b90fb777f844f.png@220w_280h.webp","totalCount":"全24话","id":28223481,"follow":"444.2 万","view":"1.5 亿","danmaku":"463.4 万","coin":"45.7 万","score":9.8,"des":"时为1987年，乔瑟夫·乔斯达与“柱之男”们之间的死战后过了50年……乔瑟夫为了为了帮助“被恶灵附身了”的外孙子·空条承太郎而来到了日本。原来那并不是恶灵而是幽波纹（替身）。替身突然出现的原因在于，从..."},{"title":"JOJO的奇妙冒险 星尘远征军 埃及篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f6709b76e88f50aa132d1e09e2d8de9663a09b3e.png@220w_280h.webp","totalCount":"全24话","id":28223483,"follow":"421.9 万","view":"1.3 亿","danmaku":"468.7 万","coin":"44.3 万","score":9.9,"des":"在乔斯达家的宿敌·迪奥（DIO）复活的影响下，一位年轻人——空条承太郎，得到了名为“幽波纹（替身）”的能力。为了拯救因迪奥的诅咒而倒下的母亲荷莉，空条承太郎与外祖父·乔瑟夫以及伙伴们，一起为了打倒迪奥..."},{"title":"JOJO的奇妙冒险 不灭钻石","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/6a04c87e990ab74cd8d555ef45a863de0993b161.png@220w_280h.webp","totalCount":"全39话","id":140552,"follow":"302.3 万","view":"2.1 亿","danmaku":"813.8 万","coin":"55.9 万","score":9.8,"des":"在埃及与宿敌DIO的死斗之后过了11年。1999年，空条承太郎为了与祖父乔瑟夫·乔斯达的私生子东方仗助见面，而来到了日本M县S市杜王町。但，仗助却持有与承太郎相同的特殊能力“替身”。之后，以承太郎的来..."},{"title":"命运-冠位嘉年华","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/c660976f4502a544d990a882ae62194b57753a71.png@220w_280h.webp","totalCount":"全2话","id":28234639,"follow":"479.8 万","view":"862.4 万","danmaku":"4.1 万","coin":"9.1 万","score":9.8,"des":"一起庆祝吧！为了这奇迹般的嘉年华！"},{"title":"伍六七","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/b69e26d9e50514f3fa99eac9ab5aabf2a6e28c88.jpg@220w_280h.webp","totalCount":"全13话","id":6360,"follow":"585.8 万","view":"3.3 亿","danmaku":"227.1 万","coin":"191.8 万","score":9.8,"des":"在某个小岛上，有一个可以伪装成任何东西的廉价刺客，名叫伍六七。平时看上去是个理发师，其实背地里却做着刺客生意。热爱理发事业，喜欢给人剪头发，善用剪刀——剪刀也是他的刺杀武器。由于初入刺客行当，行情十分..."},{"title":"命运-冠位指定 -月光／失落之室-","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3fa5fd2b7afae827b0bf150d7f0cbfc54eda1ff2.png@220w_280h.webp","totalCount":"全1话","id":28234950,"follow":"483.3 万","view":"551.2 万","danmaku":9696,"coin":"2.9 万","score":9.5,"des":"失落之室——。\n这是一个可以看到被夺去亦或是遗失之物的地方。\n这是位于迦勒底被遗忘的角落，不属于任何人的地方。..."},{"title":"致不灭的你","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/1ae94fbb35d8e23bb84926b694509f8b057f96e6.png@220w_280h.webp","totalCount":"全20话","id":28233896,"follow":"476.3 万","view":"1.3 亿","danmaku":"140.1 万","coin":"95.0 万","score":9.6,"des":"本剧讲述了一个情节跌宕、场面宏大的奇幻故事，通过拥有不灭之身的主人公“不死”来探索人生哲理。\n不死起初是一个被投放到人世间的“球”。\n\n它具有“幻化为刺激源形态的能力”和“死后重生的能力”。\n\n先后从..."},{"title":"来自新世界","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/aaa60f9cb17fb4a38df464f1064ca9623e0769cc.jpg@220w_280h.webp","totalCount":"全25话","id":1598,"follow":"115.9 万","view":"1540.9 万","danmaku":"76.3 万","coin":"5.7 万","score":9.5,"des":"1000年后的日本，孩子们不断地消失，只存在想象中的恐怖动物与人类展开殊死战争。反乌托邦式的未来超级社会“新世界”，是口吐真言凭藉“咒力”就能移动物体的人类，与有着等同于普通人智力的生物“妖鼠”共存的..."},{"title":"转生成蜘蛛又怎样！","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f0796e37abac25ba2aa9f23120646aaa9a3d5ea7.png@220w_280h.webp","totalCount":"全24话","id":28231809,"follow":"600.0 万","view":"3.7 亿","danmaku":"190.3 万","coin":"164.6 万","score":7.8,"des":"曾经是一名女高中生的“我”，突然转生变成了幻想世界中的蜘蛛魔物。\n而且，出生地点还是各种凶恶魔物所盘踞的大迷宫。\n“我”以人类的智慧和非同寻常的积极心态为武器，使用蜘蛛的丝网以及陷阱打倒比自己等级高得..."},{"title":"装甲重拳/MEGALOBOX 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/e14dc4a935397fc074c7a12d9520225615209025.png@220w_280h.webp","totalCount":"全13话","id":28233916,"follow":"244.9 万","view":"3435.4 万","danmaku":"19.7 万","coin":"53.1 万","score":9.9,"des":"再一次，为梦想而活——\n\n将肉体与“装甲技术”融合的究极格斗技“装甲拳击”。\n在决出其顶点之人的大会“重拳之巅”上，身穿装甲用自己肉身挑战一切的拳击手“JOE”。\n\n从最下层的比赛开始仅仅花了三个月就..."},{"title":"机动战士高达SEED HD","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/855c88677267d707ebfe4040403692ff2c0938f0.png@220w_280h.webp","totalCount":"全48话","id":497,"follow":"54.8 万","view":"4044.4 万","danmaku":"114.4 万","coin":"6.0 万","score":9.6,"des":"《机动战士高达SEED》是高达系列在2002年至2003年度放映的动画。续作为《机动战士高达SEED Destiny》在2004年播放。因各具魅力的角色，明星云集的声优阵容和高度商业化的宣传而受到较低..."},{"title":"夏目友人帐 唤石者与怪异的访客","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6cf43708b779cde84ad285ff4e3a080de98df0af.png@220w_280h.webp","totalCount":"全1话","id":28234316,"follow":"567.1 万","view":"1374.8 万","danmaku":"18.1 万","coin":"17.9 万","score":9.9,"des":"本作由【唤石者】与【怪异的访客】两个人气短篇集锦而成。讲述生来便能看见各种妖怪的夏目，与自称保镖的猫咪老师一同邂逅的一系列温暖故事。\n【唤石者】一天夏目在森林中遇到一只小妖怪——密实。密实称自己肩负「..."},{"title":"Fate/Grand Order ‐First Order‐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/b75c55d209d156c8631f5ceb21e5c52c834dbb60.jpg@220w_280h.webp","totalCount":"全1话","id":5747,"follow":"250.9 万","view":"3329.7 万","danmaku":"76.7 万","coin":"10.7 万","score":8.3,"des":"【2016年12月31日bilibili独播】2015年。示巴所观测到的未来领域毫无前兆地消失。根据计算，发现——不，是证明了人类将于2017年灭绝。人理延续保障机构·迦勒底将“无法观测的领域”假定为..."},{"title":"伍六七之玄武国篇","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/00843865ea13702eccc4efd64c313fd4c8029c6b.jpg@220w_280h.webp","totalCount":"全10话","id":28232253,"follow":"999.4 万","view":"4.0 亿","danmaku":"177.7 万","coin":"385.3 万","score":9.8,"des":"为了保护小鸡岛居民和这里平静的生活，伍六七和他的伙伴大保和小飞开启了去往玄武国的冒险旅程，去寻找身世的真相和解救小岛的办法，等待他们的又将是更多的未知与奇遇。..."},{"title":"堀与宫村","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/039c4e0b14e27c7a9e5cce2f20a6efd3c8909401.png@220w_280h.webp","totalCount":"全13话","id":28231840,"follow":"695.2 万","view":"2.2 亿","danmaku":"242.1 万","coin":"361.4 万","score":9.8,"des":"不论是谁，都会有不想被人知道的一面。\n\n在学校中漂亮大方、成绩优秀的人气女生堀，私下却打扮土气、忙于家务和照顾弟弟。\n在学校中是阴暗宅男形象的宫村，生活中却是打扮时尚、带耳钉的帅气男生。\n因为一次特别..."},{"title":"奇蛋物语 / WONDER EGG PRIORITY","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/10e0bbc1047b2c45f0f881de334a6f3bfb42a3b6.png@220w_280h.webp","totalCount":"全12话","id":28231851,"follow":"254.9 万","view":"4686.8 万","danmaku":"47.6 万","coin":"65.5 万","score":9.7,"des":"14岁少女·大户爱在深夜散步的途中，\n随着神秘声音的指引，获得了一枚「蛋」。\n\n「如果想要改变世界的话」\n「那么就在现在做出选择」\n「请相信自己——」\n「打破这枚蛋——」\n\n而在打破「蛋」之后，等待着..."},{"title":"Re：从零开始的异世界生活 第二季 后半","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/4f3edbede7fc0bdb52842075cf8faaa1c5953eaa.png@220w_280h.webp","totalCount":"全12话","id":28232073,"follow":"849.9 万","view":"9308.1 万","danmaku":"108.1 万","coin":"230.1 万","score":9.9,"des":"我一定会拯救你。\n在打倒了魔女教大罪司教「怠惰」担当——培提其乌斯·罗曼尼康帝之后，菜月昴和爱蜜莉雅又得以重新开始。\n克服了艰难的诀别，两人终于和解，然而这只是新一轮风波的序幕。\n超乎想象的绝境危机，..."},{"title":"灰与幻想的格林姆迦尔","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/7fb4945f864e9e988212b7d20f206df2677053f8.jpg@220w_280h.webp","totalCount":"全12话","id":106512,"follow":"172.0 万","view":"2343.4 万","danmaku":"63.8 万","coin":"18.3 万","score":9.8,"des":"电视动画《灰与幻想的格林姆迦尔》改编自日本轻小说家十文字青原作白井锐利插画的同名轻小说。\n我们为什么要这么做…？\n哈尔希洛回过神来，才发现自己身处在黑暗当中，他完全不知道自己人在何处，也不明白这个地方..."},{"title":"龙与虎","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/144910805f172d16c5f544f43939a05d8ca20576.jpg@220w_280h.webp","totalCount":"全26话","id":1672,"follow":"336.9 万","view":"6671.9 万","danmaku":"511.9 万","coin":"61.5 万","score":9.7,"des":"樱花飞舞的四月，全新的高中二年级，新的班级……\n眼神凶恶的普通男孩——高须龙儿，遇上了众人害怕、凶暴残忍的“掌中老虎”逢坂大河，还知道了她不欲为人知的秘密。这就是龙虎相争爱与战斗的序幕。\n再加上总是笑..."},{"title":"机动战士高达 铁血的奥尔芬斯 第一季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/f84a80d731d0431c00903d8951fd66623d8237f7.png@220w_280h.webp","totalCount":"全25话","id":4310042,"follow":"62.4 万","view":"2318.6 万","danmaku":"52.2 万","coin":"5.4 万","score":9.5,"des":"主人公三日月·奥古斯，从所属的民间警备公司克律塞安保公司（下称CGS）那里，接受了对少女库德莉亚·蓝那·伯恩斯坦的护卫任务。但CGS受到了摘取反叛之芽的武力组织加拉尔霍恩的袭击，于是在把三日月当做诱饵..."},{"title":"机动战士高达00 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1d7a969e8f1045739c596de89a963e30475aff0e.jpg@220w_280h.webp","totalCount":"全25话","id":1193,"follow":"37.2 万","view":"2458.1 万","danmaku":"61.4 万","coin":"4.1 万","score":9.8,"des":"天人与联合国军的最终决战后过了四年。建立地球联邦政府的人类，为了追求更进一步的国家间之统合，以及人类意识的统一，在联合正规军之外，设立了独立治安维持部队“A-Laws”，目的为对所有危害联合的势力与主..."},{"title":"机动战士高达00","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/35b11bf59eb3fd12f0387951510a5d722d7435e5.jpg@220w_280h.webp","totalCount":"全25话","id":1192,"follow":"62.1 万","view":"2465.5 万","danmaku":"53.6 万","coin":"4.6 万","score":9.7,"des":"在西历2307年，虽然化石燃料枯竭了，但是人类得到了截然不同的新型能源。三台巨大的轨道升降机以及伴随它们的大规模的太阳光发电系统。但是能得到这个系统恩惠的，只有一部分大国和其同盟国而已。\n拥有三台轨道..."},{"title":"Re：从零开始的异世界生活 第二季 前半","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f2425cbdb07cc93bd0d3ba1c0099bfe78f5dc58a.png@220w_280h.webp","totalCount":"全13话","id":28229233,"follow":"774.2 万","view":"1.3 亿","danmaku":"201.4 万","coin":"126.7 万","score":9.7,"des":"我一定会拯救你。\n在打倒了魔女教大罪司教「怠惰」担当——培提其乌斯·罗曼尼康帝之后，菜月昴和爱蜜莉雅又得以重新开始。\n克服了艰难的诀别，两人终于和解，然而这只是新一轮风波的序幕。\n超乎想象的绝境危机，..."},{"title":"超级小白","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3d3e8257d22596f5d3e4395ca759bd1e0fe9b873.jpg@220w_280h.webp","totalCount":"全48话","id":28222671,"follow":"27.4 万","view":"978.0 万","danmaku":"3.6 万","coin":"3.6 万","score":9.6,"des":"为了阻止企图霸占世界的黑暗势力，野原家的普通小狗——小白接肩负重大使命，变身成为了守护世界的“超级小白”。小白将要面对的不仅是发明狗，还有其他意想不到的对手。当然，面对邪恶势力，小白也有着令人惊讶的超..."},{"title":"Re：从零开始的异世界生活 新编集版","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3c125e1aad08643e3eff2fb7d45e740c1a052725.png@220w_280h.webp","totalCount":"全13话","id":28224394,"follow":"631.1 万","view":"7674.2 万","danmaku":"166.2 万","coin":"51.1 万","score":9.6,"des":"在从便利商店回家的路上，突然被异世界召唤的少年菜月昴。在无法依靠任何东西的异世界，无力的少年手唯一的力量……那是“死去然后重新开始”的力量。为了守护最重要的人们，为了取回确实存在着又无可替代的时间，少..."},{"title":"因为太怕痛就全点防御力了","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/8021d3f6b0df6dbba6d32f76eb9cfe2531e166c4.png@220w_280h.webp","totalCount":"全12话","id":28224137,"follow":"620.6 万","view":"2.3 亿","danmaku":"326.8 万","coin":"103.8 万","score":9,"des":"主角本条枫在好友白峰理沙推荐下开始游玩游戏“NewWorld Online”，创建了名为“梅普露”的角色。然而作为游戏初学者，梅普露选择了不受欢迎的大盾当武器，同时因为怕痛而把所有状态点加到防御力的极..."},{"title":"冰海战记","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/c30401817895e67399094b4e669785a104270cdf.jpg@220w_280h.webp","totalCount":"全24话","id":28220475,"follow":"174.4 万","view":"4893.8 万","danmaku":"48.7 万","coin":"36.7 万","score":9.8,"des":"公元10世纪末期，出现了在世界各地出没的最强民族。被讴歌为最强战士的托尔兹，其子托尔芬幼时便生活在战场上，并向往着梦幻大陆“文兰”。这是一个发生在激荡时代的，真正的英雄物语。..."},{"title":"齐木楠雄的灾难 始动篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ba59822eded39b5254fb01448a7f1502101d5624.png@220w_280h.webp","totalCount":"全6话","id":28223748,"follow":"372.4 万","view":"3054.5 万","danmaku":"20.0 万","coin":"17.8 万","score":9.8,"des":"在电视剧中堪称帅气的超能力，对于高中生齐木楠雄来说只是招致灾难的元凶。作为新动画系列展开的楠雄的日常又会如何！？..."},{"title":"OVERLORD Ⅱ","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/851f979c8ebcc7583a43abd4b786c4e2e66b746b.jpg@220w_280h.webp","totalCount":"全13话","id":8792,"follow":"539.3 万","view":"3.8 亿","danmaku":"413.9 万","coin":"114.1 万","score":9.6,"des":"时为2138年。曾卷起一大风潮的虚拟现实体感型网络游戏《YGGDRASIL》即将迎来停服。玩家飞鼠在曾经以同伴和荣华自傲的根据地纳萨力克地下大坟墓，独自一人安静等待着那一刻。但是，不料发生了结束时间已..."},{"title":"夏目友人帐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/99c549494d9425f6455bd45a151f4d26397d6151.png@220w_280h.webp","totalCount":"全13话","id":1660,"follow":"324.0 万","view":"4975.2 万","danmaku":"278.7 万","coin":"15.5 万","score":9.8,"des":"夏目贵志生来拥有强大的灵力，能感知平常人所无法接触的妖怪神明的存在。因父母双亡，他多年间辗转于互相推卸责任的亲戚之间，又受到同龄人的欺负，未曾与任何人深交，造成性格一定程度上的孤僻。夏目本性和善，对于..."}],"watched":[{"title":"装甲重拳/MEGALOBOX","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0c44785cb5d25cc9f648800d251f21a2e236bb8a.png@220w_280h.webp","totalCount":"全13话","id":79472,"follow":"221.9 万","view":"6162.0 万","danmaku":"48.6 万","coin":"32.9 万","score":9.8,"des":"将肉体与“装甲技术”融合的究极格斗技——“MEGALOBOX”，将自己的全部赌在上面的男人们的热血战斗开始！\n今天也立于未认可地区的赌博比赛赛场上的MEGALO拳击手“JNK DOG”。虽然具备实力，..."},{"title":"超能力女儿","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/152c536f8ecaad8f3d7d568d33da81c963a4a722.png@220w_280h.webp","totalCount":"全12话","id":78352,"follow":"293.8 万","view":"9252.2 万","danmaku":"98.5 万","coin":"35.4 万","score":9.6,"des":"支持着芦川组的年轻智力型黑道新田义史，过着被喜欢的壶所包围的悠然自得单身生活。但某一天，随着装在神秘物体里的少女雏来到他家，他的生活为之一变。他被能使用念动力的雏所胁迫，迫不得已开始和她同居！\n容易暴..."},{"title":"OVERLORD Ⅲ","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/dd7a9d0a0bee32b1f43c2656398d8463d12b3069.jpg@220w_280h.webp","totalCount":"全13话","id":102252,"follow":"551.6 万","view":"4.0 亿","danmaku":"399.7 万","coin":"129.2 万","score":9.4,"des":"时间为2138年。曾卷起一大风潮的虚拟现实体感型网络游戏《YGGDRASIL》即将迎来停服。玩家飞鼠在曾经以同伴和荣华自傲的根据地纳萨力克地下大坟墓，独自一人安静等待着那一刻。\n但是，不料发生了“过了..."},{"title":"路人超能100 第一次灵能咨询所员工旅游～舒缓心灵的疗愈之旅~（OVA2）","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/1271324d51634b68980704731987724a1afc60aa.jpg@220w_280h.webp","totalCount":"全1话","id":28222715,"follow":"318.8 万","view":"520.7 万","danmaku":"3.6 万","coin":"4.6 万","score":9.8,"des":"由原作ONE老师担任原案的完全新作OVA！「灵能咨询所」一行人，龙套与灵幻、小酒窝以及新同伴芹泽的目的地，正是缟马县深山中鲜为人知的温泉·疣神温泉。因为灵幻接受了旅馆老板娘的委托，「弄清温泉的恐怖传闻..."},{"title":"少女终末旅行","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1431ca5bb2f7143062e3df8f21b8448cf8cccc13.jpg@220w_280h.webp","totalCount":"全12话","id":6463,"follow":"239.8 万","view":"3714.7 万","danmaku":"100.7 万","coin":"37.2 万","score":9.8,"des":"本作舞台在人类繁华的文明迎来终结的很久以后，人类基本灭绝，甚至生物都不再存在的末日世界。复杂够高的都市成为迷宫般的废墟，得不到维护的机械渐渐停止运转。连何时终结了，何时开始终结的思考都不复存在的这个世..."},{"title":"齐木楠雄的灾难（日播&精选版）","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/eb4f17335f48951945fb9da47e6ee0bc65fa2fbb.jpg@220w_280h.webp","totalCount":"全120话","id":5070,"follow":"187.0 万","view":"2.3 亿","danmaku":"130.7 万","coin":"32.7 万","score":9.6,"des":"高中生·齐木楠雄是超能力者。心灵感应、念动力、透视、预知、瞬间移动、千里眼等，不论任何事情都自由自在。但这任谁都羡慕不已的最强能力，实际上对于本人而言是引来灾难的不幸元凶。因此，他在别人面前封印了超能..."},{"title":"比宇宙更远的地方","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/c9eca3cbc386c63b27461074b8b218898cb7440e.jpg@220w_280h.webp","totalCount":"全13话","id":13032,"follow":"156.0 万","view":"2298.0 万","danmaku":"45.9 万","coin":"23.9 万","score":9.8,"des":"无论何时，我们的第一步总是从好奇心开始。\n不曾看过的风景，不曾听过的声音，不曾闻过的味道，不曾摸过的质感，不曾尝过的食物，以及不曾感受过的澎湃。\n为了重拾不知何时忘却的记忆碎片和不知何时舍弃的感动的旅..."},{"title":"OVERLORD","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/b8e72ea69e57e0b7ac85d8b4d366554fd866df1a.jpg@220w_280h.webp","totalCount":"全13话","id":2576,"follow":"626.2 万","view":"4.1 亿","danmaku":"385.2 万","coin":"84.4 万","score":9.6,"des":"作品主要讲述了某天，一款曾经掀起过大热潮的VRMMORPG「YGGDRASIL」停止了运营。游戏原本会停止一切服务，但过了结束时间后，玩家们却发现不能退出，NPC也产生了各自的思想。现实世界中喜爱电玩..."},{"title":"路人超能100 II(灵能百分百 第二季)","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/216e1bdaf88244215a13b1154116805ee9adbe07.png@220w_280h.webp","totalCount":"全13话","id":4762734,"follow":"284.9 万","view":"1.0 亿","danmaku":"97.8 万","coin":"56.1 万","score":9.9,"des":"当有什么东西达到“100”的时候，就会爆发的少年·路人（龙套）。外表极其普通——不如说是不起眼。不擅长迎合气氛的他，实际上拥有着强力的超能力。盯上了这样的他的能力，而接连现身的伪灵能力者以及宗教团体、..."},{"title":"多罗罗","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3fc16a667502cbff226e585eb660a96a20c7458c.png@220w_280h.webp","totalCount":"全24话","id":4312482,"follow":"452.1 万","view":"1.8 亿","danmaku":"143.9 万","coin":"73.9 万","score":9.4,"des":"他们向着命运抗争，在那尽头等待他们的是人心，还是业障。\n时值乱世。\n名为景光的醍醐将军，向某个寺庙殿堂中的12尊魔神像祈求早日结束战乱。\n作为代价，他的嫡子在出生时就失去了身体的某些部位，被丢弃在河流..."},{"title":"魔法少女小圆","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/7fcaa0e98b561611538ae4deba7949cec4ca39a8.png@220w_280h.webp","totalCount":"全12话","id":2539,"follow":"218.7 万","view":"4199.0 万","danmaku":"201.5 万","coin":"20.0 万","score":9.8,"des":"就读初中二年级的鹿目圆，过着平凡幸福的生活。神秘转学生晓美焰的出现，开始让小圆的命运有了巨大转变。某日一只名为丘比的神秘生物，希望小圆能够与它签订魔法契约，成为“魔法少女”以对抗邪恶的魔女保护世界。正..."}]},"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"http://rebp38war.bkt.clouddn.com/img/v2-376062e6eaa322512fae11c68de08493_r.jpg","excerpt":"","more":"<p>js编写的在线GBA模拟器<br></p>\n<p><a href=\"http://120.48.107.220:7878/\" title=\"GBA\">http://120.48.107.220:7878/</a><br><br>后续有时间改造一下</p>\n"},{"title":"分类","date":"2021-12-22T03:41:02.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2021-12-22 11:41:02\ntype: \"categories\"\n---\n","updated":"2021-12-22T03:41:36.960Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cl5w7e73v0008igvua9qpbwjn","content":"","site":{"data":{"bangumis":{"wantWatch":[],"watching":[{"title":"凡人修仙传","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/70d11dfab23a3ee81ccf64f18efa139416a633ff.jpg@220w_280h.webp","totalCount":"未完结","id":28223043,"follow":"615.7 万","view":"8.9 亿","danmaku":"490.9 万","coin":"1186.9 万","score":9.7,"des":"看机智的凡人小子韩立如何稳健发展、步步为营，战魔道、夺至宝、驰骋星海、快意恩仇，成为纵横三界的强者。他日仙界重相逢，一声道友尽沧桑。..."},{"title":"恋爱游戏世界对路人角色很不友好","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/c9723d8c77d881a8debba2852d580e97826b43d0.png@220w_280h.webp","totalCount":"全12话","id":28237300,"follow":"151.2 万","view":"5120.4 万","danmaku":"40.6 万","coin":"24.5 万","score":9.1,"des":"从现代日本转生到“恋爱游戏”世界的里昂，发现这里女尊男卑，对男性很不友好。身为路人角色的他，为了摆脱自己因地位低下而被肆意决定的人生，决定活用从游戏中得到的知识，保持路人角色的身份，取得“失落物品”来..."},{"title":"魔法纪录 魔法少女小圆外传 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/9eef1df9ab157be52d2c4d70d3500442f00cafc3.png@220w_280h.webp","totalCount":"全12话","id":28234642,"follow":"237.1 万","view":"907.6 万","danmaku":"5.0 万","coin":"4.9 万","score":7.7,"des":"愿望的代价，究竟是希望还是绝望——。"},{"title":"小林家的龙女仆 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/847e9dbb6876fb37a30199a5c88910704976d45b.png@220w_280h.webp","totalCount":"全13话","id":28234613,"follow":"855.7 万","view":"1.1 亿","danmaku":"49.0 万","coin":"69.0 万","score":9.6,"des":"那位不可思议的龙女仆再度登场！\n因为各种奇妙的原因而作为小林家的女仆而工作中的龙·托尔。\n偶尔（胡说，是经常）给亲爱的小林添麻烦，总算是融入了人类社会，成为了一个完美的（骗人，也就还行）女仆。\n同样是..."},{"title":"国王排名","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/376d7e69a667bcb1c0b934a4e35e07e7fa23110b.png@220w_280h.webp","totalCount":"全23话","id":28235154,"follow":"927.7 万","view":"4.8 亿","danmaku":"250.1 万","coin":"260.9 万","score":7,"des":"国家的丰饶、麾下勇者的数量、\n以及国王本人如何像勇者一般强大，\n这些要素的综合排名，便是所谓的“国王排名”。\n主人公波吉是国王排名第七名的伯斯王治下王国的第一王子。\n但是波吉却生来又聋又哑，贫弱到挥不..."},{"title":"阿松 第三季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0212baa8898d0c819c7fb84015e95b8fca621435.png@220w_280h.webp","totalCount":"全25话","id":28229892,"follow":"67.6 万","view":"938.0 万","danmaku":"13.0 万","coin":"5.4 万","score":9.6,"des":"日本最有名的六胞胎的传说，第三次开幕！！这次会有怎样意想不到的新展开！？..."},{"title":"命运-冠位指定 冠位时间神殿所罗门","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0e094b798388da19a4feffa6a6dabc1dc1dc90cd.jpg@220w_280h.webp","totalCount":"全1话","id":28236225,"follow":"525.5 万","view":"1220.0 万","danmaku":"8.9 万","coin":"15.1 万","score":8.5,"des":"在经过七个特异点的大战后，\n人理存续保障机关迦勒底，终于到达了圣杯探索的最终地点——终局特异点 冠位时间神殿所罗门。\n他们要击败身为罪魁祸首的魔术王所罗门，夺回未来。\n在开战的前一刻，一行人各自度过了..."},{"title":"JOJO的奇妙冒险 星尘远征军","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/47c0108259355d6d2c517ed97f6b90fb777f844f.png@220w_280h.webp","totalCount":"全24话","id":28223481,"follow":"444.2 万","view":"1.5 亿","danmaku":"463.4 万","coin":"45.7 万","score":9.8,"des":"时为1987年，乔瑟夫·乔斯达与“柱之男”们之间的死战后过了50年……乔瑟夫为了为了帮助“被恶灵附身了”的外孙子·空条承太郎而来到了日本。原来那并不是恶灵而是幽波纹（替身）。替身突然出现的原因在于，从..."},{"title":"JOJO的奇妙冒险 星尘远征军 埃及篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f6709b76e88f50aa132d1e09e2d8de9663a09b3e.png@220w_280h.webp","totalCount":"全24话","id":28223483,"follow":"421.9 万","view":"1.3 亿","danmaku":"468.7 万","coin":"44.3 万","score":9.9,"des":"在乔斯达家的宿敌·迪奥（DIO）复活的影响下，一位年轻人——空条承太郎，得到了名为“幽波纹（替身）”的能力。为了拯救因迪奥的诅咒而倒下的母亲荷莉，空条承太郎与外祖父·乔瑟夫以及伙伴们，一起为了打倒迪奥..."},{"title":"JOJO的奇妙冒险 不灭钻石","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/6a04c87e990ab74cd8d555ef45a863de0993b161.png@220w_280h.webp","totalCount":"全39话","id":140552,"follow":"302.3 万","view":"2.1 亿","danmaku":"813.8 万","coin":"55.9 万","score":9.8,"des":"在埃及与宿敌DIO的死斗之后过了11年。1999年，空条承太郎为了与祖父乔瑟夫·乔斯达的私生子东方仗助见面，而来到了日本M县S市杜王町。但，仗助却持有与承太郎相同的特殊能力“替身”。之后，以承太郎的来..."},{"title":"命运-冠位嘉年华","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/c660976f4502a544d990a882ae62194b57753a71.png@220w_280h.webp","totalCount":"全2话","id":28234639,"follow":"479.8 万","view":"862.4 万","danmaku":"4.1 万","coin":"9.1 万","score":9.8,"des":"一起庆祝吧！为了这奇迹般的嘉年华！"},{"title":"伍六七","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/b69e26d9e50514f3fa99eac9ab5aabf2a6e28c88.jpg@220w_280h.webp","totalCount":"全13话","id":6360,"follow":"585.8 万","view":"3.3 亿","danmaku":"227.1 万","coin":"191.8 万","score":9.8,"des":"在某个小岛上，有一个可以伪装成任何东西的廉价刺客，名叫伍六七。平时看上去是个理发师，其实背地里却做着刺客生意。热爱理发事业，喜欢给人剪头发，善用剪刀——剪刀也是他的刺杀武器。由于初入刺客行当，行情十分..."},{"title":"命运-冠位指定 -月光／失落之室-","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3fa5fd2b7afae827b0bf150d7f0cbfc54eda1ff2.png@220w_280h.webp","totalCount":"全1话","id":28234950,"follow":"483.3 万","view":"551.2 万","danmaku":9696,"coin":"2.9 万","score":9.5,"des":"失落之室——。\n这是一个可以看到被夺去亦或是遗失之物的地方。\n这是位于迦勒底被遗忘的角落，不属于任何人的地方。..."},{"title":"致不灭的你","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/1ae94fbb35d8e23bb84926b694509f8b057f96e6.png@220w_280h.webp","totalCount":"全20话","id":28233896,"follow":"476.3 万","view":"1.3 亿","danmaku":"140.1 万","coin":"95.0 万","score":9.6,"des":"本剧讲述了一个情节跌宕、场面宏大的奇幻故事，通过拥有不灭之身的主人公“不死”来探索人生哲理。\n不死起初是一个被投放到人世间的“球”。\n\n它具有“幻化为刺激源形态的能力”和“死后重生的能力”。\n\n先后从..."},{"title":"来自新世界","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/aaa60f9cb17fb4a38df464f1064ca9623e0769cc.jpg@220w_280h.webp","totalCount":"全25话","id":1598,"follow":"115.9 万","view":"1540.9 万","danmaku":"76.3 万","coin":"5.7 万","score":9.5,"des":"1000年后的日本，孩子们不断地消失，只存在想象中的恐怖动物与人类展开殊死战争。反乌托邦式的未来超级社会“新世界”，是口吐真言凭藉“咒力”就能移动物体的人类，与有着等同于普通人智力的生物“妖鼠”共存的..."},{"title":"转生成蜘蛛又怎样！","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f0796e37abac25ba2aa9f23120646aaa9a3d5ea7.png@220w_280h.webp","totalCount":"全24话","id":28231809,"follow":"600.0 万","view":"3.7 亿","danmaku":"190.3 万","coin":"164.6 万","score":7.8,"des":"曾经是一名女高中生的“我”，突然转生变成了幻想世界中的蜘蛛魔物。\n而且，出生地点还是各种凶恶魔物所盘踞的大迷宫。\n“我”以人类的智慧和非同寻常的积极心态为武器，使用蜘蛛的丝网以及陷阱打倒比自己等级高得..."},{"title":"装甲重拳/MEGALOBOX 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/e14dc4a935397fc074c7a12d9520225615209025.png@220w_280h.webp","totalCount":"全13话","id":28233916,"follow":"244.9 万","view":"3435.4 万","danmaku":"19.7 万","coin":"53.1 万","score":9.9,"des":"再一次，为梦想而活——\n\n将肉体与“装甲技术”融合的究极格斗技“装甲拳击”。\n在决出其顶点之人的大会“重拳之巅”上，身穿装甲用自己肉身挑战一切的拳击手“JOE”。\n\n从最下层的比赛开始仅仅花了三个月就..."},{"title":"机动战士高达SEED HD","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/855c88677267d707ebfe4040403692ff2c0938f0.png@220w_280h.webp","totalCount":"全48话","id":497,"follow":"54.8 万","view":"4044.4 万","danmaku":"114.4 万","coin":"6.0 万","score":9.6,"des":"《机动战士高达SEED》是高达系列在2002年至2003年度放映的动画。续作为《机动战士高达SEED Destiny》在2004年播放。因各具魅力的角色，明星云集的声优阵容和高度商业化的宣传而受到较低..."},{"title":"夏目友人帐 唤石者与怪异的访客","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6cf43708b779cde84ad285ff4e3a080de98df0af.png@220w_280h.webp","totalCount":"全1话","id":28234316,"follow":"567.1 万","view":"1374.8 万","danmaku":"18.1 万","coin":"17.9 万","score":9.9,"des":"本作由【唤石者】与【怪异的访客】两个人气短篇集锦而成。讲述生来便能看见各种妖怪的夏目，与自称保镖的猫咪老师一同邂逅的一系列温暖故事。\n【唤石者】一天夏目在森林中遇到一只小妖怪——密实。密实称自己肩负「..."},{"title":"Fate/Grand Order ‐First Order‐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/b75c55d209d156c8631f5ceb21e5c52c834dbb60.jpg@220w_280h.webp","totalCount":"全1话","id":5747,"follow":"250.9 万","view":"3329.7 万","danmaku":"76.7 万","coin":"10.7 万","score":8.3,"des":"【2016年12月31日bilibili独播】2015年。示巴所观测到的未来领域毫无前兆地消失。根据计算，发现——不，是证明了人类将于2017年灭绝。人理延续保障机构·迦勒底将“无法观测的领域”假定为..."},{"title":"伍六七之玄武国篇","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/00843865ea13702eccc4efd64c313fd4c8029c6b.jpg@220w_280h.webp","totalCount":"全10话","id":28232253,"follow":"999.4 万","view":"4.0 亿","danmaku":"177.7 万","coin":"385.3 万","score":9.8,"des":"为了保护小鸡岛居民和这里平静的生活，伍六七和他的伙伴大保和小飞开启了去往玄武国的冒险旅程，去寻找身世的真相和解救小岛的办法，等待他们的又将是更多的未知与奇遇。..."},{"title":"堀与宫村","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/039c4e0b14e27c7a9e5cce2f20a6efd3c8909401.png@220w_280h.webp","totalCount":"全13话","id":28231840,"follow":"695.2 万","view":"2.2 亿","danmaku":"242.1 万","coin":"361.4 万","score":9.8,"des":"不论是谁，都会有不想被人知道的一面。\n\n在学校中漂亮大方、成绩优秀的人气女生堀，私下却打扮土气、忙于家务和照顾弟弟。\n在学校中是阴暗宅男形象的宫村，生活中却是打扮时尚、带耳钉的帅气男生。\n因为一次特别..."},{"title":"奇蛋物语 / WONDER EGG PRIORITY","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/10e0bbc1047b2c45f0f881de334a6f3bfb42a3b6.png@220w_280h.webp","totalCount":"全12话","id":28231851,"follow":"254.9 万","view":"4686.8 万","danmaku":"47.6 万","coin":"65.5 万","score":9.7,"des":"14岁少女·大户爱在深夜散步的途中，\n随着神秘声音的指引，获得了一枚「蛋」。\n\n「如果想要改变世界的话」\n「那么就在现在做出选择」\n「请相信自己——」\n「打破这枚蛋——」\n\n而在打破「蛋」之后，等待着..."},{"title":"Re：从零开始的异世界生活 第二季 后半","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/4f3edbede7fc0bdb52842075cf8faaa1c5953eaa.png@220w_280h.webp","totalCount":"全12话","id":28232073,"follow":"849.9 万","view":"9308.1 万","danmaku":"108.1 万","coin":"230.1 万","score":9.9,"des":"我一定会拯救你。\n在打倒了魔女教大罪司教「怠惰」担当——培提其乌斯·罗曼尼康帝之后，菜月昴和爱蜜莉雅又得以重新开始。\n克服了艰难的诀别，两人终于和解，然而这只是新一轮风波的序幕。\n超乎想象的绝境危机，..."},{"title":"灰与幻想的格林姆迦尔","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/7fb4945f864e9e988212b7d20f206df2677053f8.jpg@220w_280h.webp","totalCount":"全12话","id":106512,"follow":"172.0 万","view":"2343.4 万","danmaku":"63.8 万","coin":"18.3 万","score":9.8,"des":"电视动画《灰与幻想的格林姆迦尔》改编自日本轻小说家十文字青原作白井锐利插画的同名轻小说。\n我们为什么要这么做…？\n哈尔希洛回过神来，才发现自己身处在黑暗当中，他完全不知道自己人在何处，也不明白这个地方..."},{"title":"龙与虎","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/144910805f172d16c5f544f43939a05d8ca20576.jpg@220w_280h.webp","totalCount":"全26话","id":1672,"follow":"336.9 万","view":"6671.9 万","danmaku":"511.9 万","coin":"61.5 万","score":9.7,"des":"樱花飞舞的四月，全新的高中二年级，新的班级……\n眼神凶恶的普通男孩——高须龙儿，遇上了众人害怕、凶暴残忍的“掌中老虎”逢坂大河，还知道了她不欲为人知的秘密。这就是龙虎相争爱与战斗的序幕。\n再加上总是笑..."},{"title":"机动战士高达 铁血的奥尔芬斯 第一季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/f84a80d731d0431c00903d8951fd66623d8237f7.png@220w_280h.webp","totalCount":"全25话","id":4310042,"follow":"62.4 万","view":"2318.6 万","danmaku":"52.2 万","coin":"5.4 万","score":9.5,"des":"主人公三日月·奥古斯，从所属的民间警备公司克律塞安保公司（下称CGS）那里，接受了对少女库德莉亚·蓝那·伯恩斯坦的护卫任务。但CGS受到了摘取反叛之芽的武力组织加拉尔霍恩的袭击，于是在把三日月当做诱饵..."},{"title":"机动战士高达00 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1d7a969e8f1045739c596de89a963e30475aff0e.jpg@220w_280h.webp","totalCount":"全25话","id":1193,"follow":"37.2 万","view":"2458.1 万","danmaku":"61.4 万","coin":"4.1 万","score":9.8,"des":"天人与联合国军的最终决战后过了四年。建立地球联邦政府的人类，为了追求更进一步的国家间之统合，以及人类意识的统一，在联合正规军之外，设立了独立治安维持部队“A-Laws”，目的为对所有危害联合的势力与主..."},{"title":"机动战士高达00","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/35b11bf59eb3fd12f0387951510a5d722d7435e5.jpg@220w_280h.webp","totalCount":"全25话","id":1192,"follow":"62.1 万","view":"2465.5 万","danmaku":"53.6 万","coin":"4.6 万","score":9.7,"des":"在西历2307年，虽然化石燃料枯竭了，但是人类得到了截然不同的新型能源。三台巨大的轨道升降机以及伴随它们的大规模的太阳光发电系统。但是能得到这个系统恩惠的，只有一部分大国和其同盟国而已。\n拥有三台轨道..."},{"title":"Re：从零开始的异世界生活 第二季 前半","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f2425cbdb07cc93bd0d3ba1c0099bfe78f5dc58a.png@220w_280h.webp","totalCount":"全13话","id":28229233,"follow":"774.2 万","view":"1.3 亿","danmaku":"201.4 万","coin":"126.7 万","score":9.7,"des":"我一定会拯救你。\n在打倒了魔女教大罪司教「怠惰」担当——培提其乌斯·罗曼尼康帝之后，菜月昴和爱蜜莉雅又得以重新开始。\n克服了艰难的诀别，两人终于和解，然而这只是新一轮风波的序幕。\n超乎想象的绝境危机，..."},{"title":"超级小白","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3d3e8257d22596f5d3e4395ca759bd1e0fe9b873.jpg@220w_280h.webp","totalCount":"全48话","id":28222671,"follow":"27.4 万","view":"978.0 万","danmaku":"3.6 万","coin":"3.6 万","score":9.6,"des":"为了阻止企图霸占世界的黑暗势力，野原家的普通小狗——小白接肩负重大使命，变身成为了守护世界的“超级小白”。小白将要面对的不仅是发明狗，还有其他意想不到的对手。当然，面对邪恶势力，小白也有着令人惊讶的超..."},{"title":"Re：从零开始的异世界生活 新编集版","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3c125e1aad08643e3eff2fb7d45e740c1a052725.png@220w_280h.webp","totalCount":"全13话","id":28224394,"follow":"631.1 万","view":"7674.2 万","danmaku":"166.2 万","coin":"51.1 万","score":9.6,"des":"在从便利商店回家的路上，突然被异世界召唤的少年菜月昴。在无法依靠任何东西的异世界，无力的少年手唯一的力量……那是“死去然后重新开始”的力量。为了守护最重要的人们，为了取回确实存在着又无可替代的时间，少..."},{"title":"因为太怕痛就全点防御力了","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/8021d3f6b0df6dbba6d32f76eb9cfe2531e166c4.png@220w_280h.webp","totalCount":"全12话","id":28224137,"follow":"620.6 万","view":"2.3 亿","danmaku":"326.8 万","coin":"103.8 万","score":9,"des":"主角本条枫在好友白峰理沙推荐下开始游玩游戏“NewWorld Online”，创建了名为“梅普露”的角色。然而作为游戏初学者，梅普露选择了不受欢迎的大盾当武器，同时因为怕痛而把所有状态点加到防御力的极..."},{"title":"冰海战记","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/c30401817895e67399094b4e669785a104270cdf.jpg@220w_280h.webp","totalCount":"全24话","id":28220475,"follow":"174.4 万","view":"4893.8 万","danmaku":"48.7 万","coin":"36.7 万","score":9.8,"des":"公元10世纪末期，出现了在世界各地出没的最强民族。被讴歌为最强战士的托尔兹，其子托尔芬幼时便生活在战场上，并向往着梦幻大陆“文兰”。这是一个发生在激荡时代的，真正的英雄物语。..."},{"title":"齐木楠雄的灾难 始动篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ba59822eded39b5254fb01448a7f1502101d5624.png@220w_280h.webp","totalCount":"全6话","id":28223748,"follow":"372.4 万","view":"3054.5 万","danmaku":"20.0 万","coin":"17.8 万","score":9.8,"des":"在电视剧中堪称帅气的超能力，对于高中生齐木楠雄来说只是招致灾难的元凶。作为新动画系列展开的楠雄的日常又会如何！？..."},{"title":"OVERLORD Ⅱ","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/851f979c8ebcc7583a43abd4b786c4e2e66b746b.jpg@220w_280h.webp","totalCount":"全13话","id":8792,"follow":"539.3 万","view":"3.8 亿","danmaku":"413.9 万","coin":"114.1 万","score":9.6,"des":"时为2138年。曾卷起一大风潮的虚拟现实体感型网络游戏《YGGDRASIL》即将迎来停服。玩家飞鼠在曾经以同伴和荣华自傲的根据地纳萨力克地下大坟墓，独自一人安静等待着那一刻。但是，不料发生了结束时间已..."},{"title":"夏目友人帐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/99c549494d9425f6455bd45a151f4d26397d6151.png@220w_280h.webp","totalCount":"全13话","id":1660,"follow":"324.0 万","view":"4975.2 万","danmaku":"278.7 万","coin":"15.5 万","score":9.8,"des":"夏目贵志生来拥有强大的灵力，能感知平常人所无法接触的妖怪神明的存在。因父母双亡，他多年间辗转于互相推卸责任的亲戚之间，又受到同龄人的欺负，未曾与任何人深交，造成性格一定程度上的孤僻。夏目本性和善，对于..."}],"watched":[{"title":"装甲重拳/MEGALOBOX","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0c44785cb5d25cc9f648800d251f21a2e236bb8a.png@220w_280h.webp","totalCount":"全13话","id":79472,"follow":"221.9 万","view":"6162.0 万","danmaku":"48.6 万","coin":"32.9 万","score":9.8,"des":"将肉体与“装甲技术”融合的究极格斗技——“MEGALOBOX”，将自己的全部赌在上面的男人们的热血战斗开始！\n今天也立于未认可地区的赌博比赛赛场上的MEGALO拳击手“JNK DOG”。虽然具备实力，..."},{"title":"超能力女儿","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/152c536f8ecaad8f3d7d568d33da81c963a4a722.png@220w_280h.webp","totalCount":"全12话","id":78352,"follow":"293.8 万","view":"9252.2 万","danmaku":"98.5 万","coin":"35.4 万","score":9.6,"des":"支持着芦川组的年轻智力型黑道新田义史，过着被喜欢的壶所包围的悠然自得单身生活。但某一天，随着装在神秘物体里的少女雏来到他家，他的生活为之一变。他被能使用念动力的雏所胁迫，迫不得已开始和她同居！\n容易暴..."},{"title":"OVERLORD Ⅲ","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/dd7a9d0a0bee32b1f43c2656398d8463d12b3069.jpg@220w_280h.webp","totalCount":"全13话","id":102252,"follow":"551.6 万","view":"4.0 亿","danmaku":"399.7 万","coin":"129.2 万","score":9.4,"des":"时间为2138年。曾卷起一大风潮的虚拟现实体感型网络游戏《YGGDRASIL》即将迎来停服。玩家飞鼠在曾经以同伴和荣华自傲的根据地纳萨力克地下大坟墓，独自一人安静等待着那一刻。\n但是，不料发生了“过了..."},{"title":"路人超能100 第一次灵能咨询所员工旅游～舒缓心灵的疗愈之旅~（OVA2）","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/1271324d51634b68980704731987724a1afc60aa.jpg@220w_280h.webp","totalCount":"全1话","id":28222715,"follow":"318.8 万","view":"520.7 万","danmaku":"3.6 万","coin":"4.6 万","score":9.8,"des":"由原作ONE老师担任原案的完全新作OVA！「灵能咨询所」一行人，龙套与灵幻、小酒窝以及新同伴芹泽的目的地，正是缟马县深山中鲜为人知的温泉·疣神温泉。因为灵幻接受了旅馆老板娘的委托，「弄清温泉的恐怖传闻..."},{"title":"少女终末旅行","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1431ca5bb2f7143062e3df8f21b8448cf8cccc13.jpg@220w_280h.webp","totalCount":"全12话","id":6463,"follow":"239.8 万","view":"3714.7 万","danmaku":"100.7 万","coin":"37.2 万","score":9.8,"des":"本作舞台在人类繁华的文明迎来终结的很久以后，人类基本灭绝，甚至生物都不再存在的末日世界。复杂够高的都市成为迷宫般的废墟，得不到维护的机械渐渐停止运转。连何时终结了，何时开始终结的思考都不复存在的这个世..."},{"title":"齐木楠雄的灾难（日播&精选版）","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/eb4f17335f48951945fb9da47e6ee0bc65fa2fbb.jpg@220w_280h.webp","totalCount":"全120话","id":5070,"follow":"187.0 万","view":"2.3 亿","danmaku":"130.7 万","coin":"32.7 万","score":9.6,"des":"高中生·齐木楠雄是超能力者。心灵感应、念动力、透视、预知、瞬间移动、千里眼等，不论任何事情都自由自在。但这任谁都羡慕不已的最强能力，实际上对于本人而言是引来灾难的不幸元凶。因此，他在别人面前封印了超能..."},{"title":"比宇宙更远的地方","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/c9eca3cbc386c63b27461074b8b218898cb7440e.jpg@220w_280h.webp","totalCount":"全13话","id":13032,"follow":"156.0 万","view":"2298.0 万","danmaku":"45.9 万","coin":"23.9 万","score":9.8,"des":"无论何时，我们的第一步总是从好奇心开始。\n不曾看过的风景，不曾听过的声音，不曾闻过的味道，不曾摸过的质感，不曾尝过的食物，以及不曾感受过的澎湃。\n为了重拾不知何时忘却的记忆碎片和不知何时舍弃的感动的旅..."},{"title":"OVERLORD","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/b8e72ea69e57e0b7ac85d8b4d366554fd866df1a.jpg@220w_280h.webp","totalCount":"全13话","id":2576,"follow":"626.2 万","view":"4.1 亿","danmaku":"385.2 万","coin":"84.4 万","score":9.6,"des":"作品主要讲述了某天，一款曾经掀起过大热潮的VRMMORPG「YGGDRASIL」停止了运营。游戏原本会停止一切服务，但过了结束时间后，玩家们却发现不能退出，NPC也产生了各自的思想。现实世界中喜爱电玩..."},{"title":"路人超能100 II(灵能百分百 第二季)","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/216e1bdaf88244215a13b1154116805ee9adbe07.png@220w_280h.webp","totalCount":"全13话","id":4762734,"follow":"284.9 万","view":"1.0 亿","danmaku":"97.8 万","coin":"56.1 万","score":9.9,"des":"当有什么东西达到“100”的时候，就会爆发的少年·路人（龙套）。外表极其普通——不如说是不起眼。不擅长迎合气氛的他，实际上拥有着强力的超能力。盯上了这样的他的能力，而接连现身的伪灵能力者以及宗教团体、..."},{"title":"多罗罗","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3fc16a667502cbff226e585eb660a96a20c7458c.png@220w_280h.webp","totalCount":"全24话","id":4312482,"follow":"452.1 万","view":"1.8 亿","danmaku":"143.9 万","coin":"73.9 万","score":9.4,"des":"他们向着命运抗争，在那尽头等待他们的是人心，还是业障。\n时值乱世。\n名为景光的醍醐将军，向某个寺庙殿堂中的12尊魔神像祈求早日结束战乱。\n作为代价，他的嫡子在出生时就失去了身体的某些部位，被丢弃在河流..."},{"title":"魔法少女小圆","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/7fcaa0e98b561611538ae4deba7949cec4ca39a8.png@220w_280h.webp","totalCount":"全12话","id":2539,"follow":"218.7 万","view":"4199.0 万","danmaku":"201.5 万","coin":"20.0 万","score":9.8,"des":"就读初中二年级的鹿目圆，过着平凡幸福的生活。神秘转学生晓美焰的出现，开始让小圆的命运有了巨大转变。某日一只名为丘比的神秘生物，希望小圆能够与它签订魔法契约，成为“魔法少女”以对抗邪恶的魔女保护世界。正..."}]},"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"http://rebp38war.bkt.clouddn.com/img/v2-b006882f4ae03db43db5dd9a4bda19e5_r.jpg","excerpt":"","more":""},{"title":"标签","date":"2021-12-22T03:30:55.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2021-12-22 11:30:55\ntype: \"tags\"\n---\n","updated":"2021-12-22T03:41:58.823Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cl5w7e73y000aigvuas2230d9","content":"","site":{"data":{"bangumis":{"wantWatch":[],"watching":[{"title":"凡人修仙传","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/70d11dfab23a3ee81ccf64f18efa139416a633ff.jpg@220w_280h.webp","totalCount":"未完结","id":28223043,"follow":"615.7 万","view":"8.9 亿","danmaku":"490.9 万","coin":"1186.9 万","score":9.7,"des":"看机智的凡人小子韩立如何稳健发展、步步为营，战魔道、夺至宝、驰骋星海、快意恩仇，成为纵横三界的强者。他日仙界重相逢，一声道友尽沧桑。..."},{"title":"恋爱游戏世界对路人角色很不友好","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/c9723d8c77d881a8debba2852d580e97826b43d0.png@220w_280h.webp","totalCount":"全12话","id":28237300,"follow":"151.2 万","view":"5120.4 万","danmaku":"40.6 万","coin":"24.5 万","score":9.1,"des":"从现代日本转生到“恋爱游戏”世界的里昂，发现这里女尊男卑，对男性很不友好。身为路人角色的他，为了摆脱自己因地位低下而被肆意决定的人生，决定活用从游戏中得到的知识，保持路人角色的身份，取得“失落物品”来..."},{"title":"魔法纪录 魔法少女小圆外传 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/9eef1df9ab157be52d2c4d70d3500442f00cafc3.png@220w_280h.webp","totalCount":"全12话","id":28234642,"follow":"237.1 万","view":"907.6 万","danmaku":"5.0 万","coin":"4.9 万","score":7.7,"des":"愿望的代价，究竟是希望还是绝望——。"},{"title":"小林家的龙女仆 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/847e9dbb6876fb37a30199a5c88910704976d45b.png@220w_280h.webp","totalCount":"全13话","id":28234613,"follow":"855.7 万","view":"1.1 亿","danmaku":"49.0 万","coin":"69.0 万","score":9.6,"des":"那位不可思议的龙女仆再度登场！\n因为各种奇妙的原因而作为小林家的女仆而工作中的龙·托尔。\n偶尔（胡说，是经常）给亲爱的小林添麻烦，总算是融入了人类社会，成为了一个完美的（骗人，也就还行）女仆。\n同样是..."},{"title":"国王排名","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/376d7e69a667bcb1c0b934a4e35e07e7fa23110b.png@220w_280h.webp","totalCount":"全23话","id":28235154,"follow":"927.7 万","view":"4.8 亿","danmaku":"250.1 万","coin":"260.9 万","score":7,"des":"国家的丰饶、麾下勇者的数量、\n以及国王本人如何像勇者一般强大，\n这些要素的综合排名，便是所谓的“国王排名”。\n主人公波吉是国王排名第七名的伯斯王治下王国的第一王子。\n但是波吉却生来又聋又哑，贫弱到挥不..."},{"title":"阿松 第三季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0212baa8898d0c819c7fb84015e95b8fca621435.png@220w_280h.webp","totalCount":"全25话","id":28229892,"follow":"67.6 万","view":"938.0 万","danmaku":"13.0 万","coin":"5.4 万","score":9.6,"des":"日本最有名的六胞胎的传说，第三次开幕！！这次会有怎样意想不到的新展开！？..."},{"title":"命运-冠位指定 冠位时间神殿所罗门","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0e094b798388da19a4feffa6a6dabc1dc1dc90cd.jpg@220w_280h.webp","totalCount":"全1话","id":28236225,"follow":"525.5 万","view":"1220.0 万","danmaku":"8.9 万","coin":"15.1 万","score":8.5,"des":"在经过七个特异点的大战后，\n人理存续保障机关迦勒底，终于到达了圣杯探索的最终地点——终局特异点 冠位时间神殿所罗门。\n他们要击败身为罪魁祸首的魔术王所罗门，夺回未来。\n在开战的前一刻，一行人各自度过了..."},{"title":"JOJO的奇妙冒险 星尘远征军","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/47c0108259355d6d2c517ed97f6b90fb777f844f.png@220w_280h.webp","totalCount":"全24话","id":28223481,"follow":"444.2 万","view":"1.5 亿","danmaku":"463.4 万","coin":"45.7 万","score":9.8,"des":"时为1987年，乔瑟夫·乔斯达与“柱之男”们之间的死战后过了50年……乔瑟夫为了为了帮助“被恶灵附身了”的外孙子·空条承太郎而来到了日本。原来那并不是恶灵而是幽波纹（替身）。替身突然出现的原因在于，从..."},{"title":"JOJO的奇妙冒险 星尘远征军 埃及篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f6709b76e88f50aa132d1e09e2d8de9663a09b3e.png@220w_280h.webp","totalCount":"全24话","id":28223483,"follow":"421.9 万","view":"1.3 亿","danmaku":"468.7 万","coin":"44.3 万","score":9.9,"des":"在乔斯达家的宿敌·迪奥（DIO）复活的影响下，一位年轻人——空条承太郎，得到了名为“幽波纹（替身）”的能力。为了拯救因迪奥的诅咒而倒下的母亲荷莉，空条承太郎与外祖父·乔瑟夫以及伙伴们，一起为了打倒迪奥..."},{"title":"JOJO的奇妙冒险 不灭钻石","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/6a04c87e990ab74cd8d555ef45a863de0993b161.png@220w_280h.webp","totalCount":"全39话","id":140552,"follow":"302.3 万","view":"2.1 亿","danmaku":"813.8 万","coin":"55.9 万","score":9.8,"des":"在埃及与宿敌DIO的死斗之后过了11年。1999年，空条承太郎为了与祖父乔瑟夫·乔斯达的私生子东方仗助见面，而来到了日本M县S市杜王町。但，仗助却持有与承太郎相同的特殊能力“替身”。之后，以承太郎的来..."},{"title":"命运-冠位嘉年华","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/c660976f4502a544d990a882ae62194b57753a71.png@220w_280h.webp","totalCount":"全2话","id":28234639,"follow":"479.8 万","view":"862.4 万","danmaku":"4.1 万","coin":"9.1 万","score":9.8,"des":"一起庆祝吧！为了这奇迹般的嘉年华！"},{"title":"伍六七","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/b69e26d9e50514f3fa99eac9ab5aabf2a6e28c88.jpg@220w_280h.webp","totalCount":"全13话","id":6360,"follow":"585.8 万","view":"3.3 亿","danmaku":"227.1 万","coin":"191.8 万","score":9.8,"des":"在某个小岛上，有一个可以伪装成任何东西的廉价刺客，名叫伍六七。平时看上去是个理发师，其实背地里却做着刺客生意。热爱理发事业，喜欢给人剪头发，善用剪刀——剪刀也是他的刺杀武器。由于初入刺客行当，行情十分..."},{"title":"命运-冠位指定 -月光／失落之室-","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3fa5fd2b7afae827b0bf150d7f0cbfc54eda1ff2.png@220w_280h.webp","totalCount":"全1话","id":28234950,"follow":"483.3 万","view":"551.2 万","danmaku":9696,"coin":"2.9 万","score":9.5,"des":"失落之室——。\n这是一个可以看到被夺去亦或是遗失之物的地方。\n这是位于迦勒底被遗忘的角落，不属于任何人的地方。..."},{"title":"致不灭的你","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/1ae94fbb35d8e23bb84926b694509f8b057f96e6.png@220w_280h.webp","totalCount":"全20话","id":28233896,"follow":"476.3 万","view":"1.3 亿","danmaku":"140.1 万","coin":"95.0 万","score":9.6,"des":"本剧讲述了一个情节跌宕、场面宏大的奇幻故事，通过拥有不灭之身的主人公“不死”来探索人生哲理。\n不死起初是一个被投放到人世间的“球”。\n\n它具有“幻化为刺激源形态的能力”和“死后重生的能力”。\n\n先后从..."},{"title":"来自新世界","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/aaa60f9cb17fb4a38df464f1064ca9623e0769cc.jpg@220w_280h.webp","totalCount":"全25话","id":1598,"follow":"115.9 万","view":"1540.9 万","danmaku":"76.3 万","coin":"5.7 万","score":9.5,"des":"1000年后的日本，孩子们不断地消失，只存在想象中的恐怖动物与人类展开殊死战争。反乌托邦式的未来超级社会“新世界”，是口吐真言凭藉“咒力”就能移动物体的人类，与有着等同于普通人智力的生物“妖鼠”共存的..."},{"title":"转生成蜘蛛又怎样！","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f0796e37abac25ba2aa9f23120646aaa9a3d5ea7.png@220w_280h.webp","totalCount":"全24话","id":28231809,"follow":"600.0 万","view":"3.7 亿","danmaku":"190.3 万","coin":"164.6 万","score":7.8,"des":"曾经是一名女高中生的“我”，突然转生变成了幻想世界中的蜘蛛魔物。\n而且，出生地点还是各种凶恶魔物所盘踞的大迷宫。\n“我”以人类的智慧和非同寻常的积极心态为武器，使用蜘蛛的丝网以及陷阱打倒比自己等级高得..."},{"title":"装甲重拳/MEGALOBOX 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/e14dc4a935397fc074c7a12d9520225615209025.png@220w_280h.webp","totalCount":"全13话","id":28233916,"follow":"244.9 万","view":"3435.4 万","danmaku":"19.7 万","coin":"53.1 万","score":9.9,"des":"再一次，为梦想而活——\n\n将肉体与“装甲技术”融合的究极格斗技“装甲拳击”。\n在决出其顶点之人的大会“重拳之巅”上，身穿装甲用自己肉身挑战一切的拳击手“JOE”。\n\n从最下层的比赛开始仅仅花了三个月就..."},{"title":"机动战士高达SEED HD","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/855c88677267d707ebfe4040403692ff2c0938f0.png@220w_280h.webp","totalCount":"全48话","id":497,"follow":"54.8 万","view":"4044.4 万","danmaku":"114.4 万","coin":"6.0 万","score":9.6,"des":"《机动战士高达SEED》是高达系列在2002年至2003年度放映的动画。续作为《机动战士高达SEED Destiny》在2004年播放。因各具魅力的角色，明星云集的声优阵容和高度商业化的宣传而受到较低..."},{"title":"夏目友人帐 唤石者与怪异的访客","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6cf43708b779cde84ad285ff4e3a080de98df0af.png@220w_280h.webp","totalCount":"全1话","id":28234316,"follow":"567.1 万","view":"1374.8 万","danmaku":"18.1 万","coin":"17.9 万","score":9.9,"des":"本作由【唤石者】与【怪异的访客】两个人气短篇集锦而成。讲述生来便能看见各种妖怪的夏目，与自称保镖的猫咪老师一同邂逅的一系列温暖故事。\n【唤石者】一天夏目在森林中遇到一只小妖怪——密实。密实称自己肩负「..."},{"title":"Fate/Grand Order ‐First Order‐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/b75c55d209d156c8631f5ceb21e5c52c834dbb60.jpg@220w_280h.webp","totalCount":"全1话","id":5747,"follow":"250.9 万","view":"3329.7 万","danmaku":"76.7 万","coin":"10.7 万","score":8.3,"des":"【2016年12月31日bilibili独播】2015年。示巴所观测到的未来领域毫无前兆地消失。根据计算，发现——不，是证明了人类将于2017年灭绝。人理延续保障机构·迦勒底将“无法观测的领域”假定为..."},{"title":"伍六七之玄武国篇","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/00843865ea13702eccc4efd64c313fd4c8029c6b.jpg@220w_280h.webp","totalCount":"全10话","id":28232253,"follow":"999.4 万","view":"4.0 亿","danmaku":"177.7 万","coin":"385.3 万","score":9.8,"des":"为了保护小鸡岛居民和这里平静的生活，伍六七和他的伙伴大保和小飞开启了去往玄武国的冒险旅程，去寻找身世的真相和解救小岛的办法，等待他们的又将是更多的未知与奇遇。..."},{"title":"堀与宫村","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/039c4e0b14e27c7a9e5cce2f20a6efd3c8909401.png@220w_280h.webp","totalCount":"全13话","id":28231840,"follow":"695.2 万","view":"2.2 亿","danmaku":"242.1 万","coin":"361.4 万","score":9.8,"des":"不论是谁，都会有不想被人知道的一面。\n\n在学校中漂亮大方、成绩优秀的人气女生堀，私下却打扮土气、忙于家务和照顾弟弟。\n在学校中是阴暗宅男形象的宫村，生活中却是打扮时尚、带耳钉的帅气男生。\n因为一次特别..."},{"title":"奇蛋物语 / WONDER EGG PRIORITY","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/10e0bbc1047b2c45f0f881de334a6f3bfb42a3b6.png@220w_280h.webp","totalCount":"全12话","id":28231851,"follow":"254.9 万","view":"4686.8 万","danmaku":"47.6 万","coin":"65.5 万","score":9.7,"des":"14岁少女·大户爱在深夜散步的途中，\n随着神秘声音的指引，获得了一枚「蛋」。\n\n「如果想要改变世界的话」\n「那么就在现在做出选择」\n「请相信自己——」\n「打破这枚蛋——」\n\n而在打破「蛋」之后，等待着..."},{"title":"Re：从零开始的异世界生活 第二季 后半","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/4f3edbede7fc0bdb52842075cf8faaa1c5953eaa.png@220w_280h.webp","totalCount":"全12话","id":28232073,"follow":"849.9 万","view":"9308.1 万","danmaku":"108.1 万","coin":"230.1 万","score":9.9,"des":"我一定会拯救你。\n在打倒了魔女教大罪司教「怠惰」担当——培提其乌斯·罗曼尼康帝之后，菜月昴和爱蜜莉雅又得以重新开始。\n克服了艰难的诀别，两人终于和解，然而这只是新一轮风波的序幕。\n超乎想象的绝境危机，..."},{"title":"灰与幻想的格林姆迦尔","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/7fb4945f864e9e988212b7d20f206df2677053f8.jpg@220w_280h.webp","totalCount":"全12话","id":106512,"follow":"172.0 万","view":"2343.4 万","danmaku":"63.8 万","coin":"18.3 万","score":9.8,"des":"电视动画《灰与幻想的格林姆迦尔》改编自日本轻小说家十文字青原作白井锐利插画的同名轻小说。\n我们为什么要这么做…？\n哈尔希洛回过神来，才发现自己身处在黑暗当中，他完全不知道自己人在何处，也不明白这个地方..."},{"title":"龙与虎","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/144910805f172d16c5f544f43939a05d8ca20576.jpg@220w_280h.webp","totalCount":"全26话","id":1672,"follow":"336.9 万","view":"6671.9 万","danmaku":"511.9 万","coin":"61.5 万","score":9.7,"des":"樱花飞舞的四月，全新的高中二年级，新的班级……\n眼神凶恶的普通男孩——高须龙儿，遇上了众人害怕、凶暴残忍的“掌中老虎”逢坂大河，还知道了她不欲为人知的秘密。这就是龙虎相争爱与战斗的序幕。\n再加上总是笑..."},{"title":"机动战士高达 铁血的奥尔芬斯 第一季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/f84a80d731d0431c00903d8951fd66623d8237f7.png@220w_280h.webp","totalCount":"全25话","id":4310042,"follow":"62.4 万","view":"2318.6 万","danmaku":"52.2 万","coin":"5.4 万","score":9.5,"des":"主人公三日月·奥古斯，从所属的民间警备公司克律塞安保公司（下称CGS）那里，接受了对少女库德莉亚·蓝那·伯恩斯坦的护卫任务。但CGS受到了摘取反叛之芽的武力组织加拉尔霍恩的袭击，于是在把三日月当做诱饵..."},{"title":"机动战士高达00 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1d7a969e8f1045739c596de89a963e30475aff0e.jpg@220w_280h.webp","totalCount":"全25话","id":1193,"follow":"37.2 万","view":"2458.1 万","danmaku":"61.4 万","coin":"4.1 万","score":9.8,"des":"天人与联合国军的最终决战后过了四年。建立地球联邦政府的人类，为了追求更进一步的国家间之统合，以及人类意识的统一，在联合正规军之外，设立了独立治安维持部队“A-Laws”，目的为对所有危害联合的势力与主..."},{"title":"机动战士高达00","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/35b11bf59eb3fd12f0387951510a5d722d7435e5.jpg@220w_280h.webp","totalCount":"全25话","id":1192,"follow":"62.1 万","view":"2465.5 万","danmaku":"53.6 万","coin":"4.6 万","score":9.7,"des":"在西历2307年，虽然化石燃料枯竭了，但是人类得到了截然不同的新型能源。三台巨大的轨道升降机以及伴随它们的大规模的太阳光发电系统。但是能得到这个系统恩惠的，只有一部分大国和其同盟国而已。\n拥有三台轨道..."},{"title":"Re：从零开始的异世界生活 第二季 前半","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f2425cbdb07cc93bd0d3ba1c0099bfe78f5dc58a.png@220w_280h.webp","totalCount":"全13话","id":28229233,"follow":"774.2 万","view":"1.3 亿","danmaku":"201.4 万","coin":"126.7 万","score":9.7,"des":"我一定会拯救你。\n在打倒了魔女教大罪司教「怠惰」担当——培提其乌斯·罗曼尼康帝之后，菜月昴和爱蜜莉雅又得以重新开始。\n克服了艰难的诀别，两人终于和解，然而这只是新一轮风波的序幕。\n超乎想象的绝境危机，..."},{"title":"超级小白","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3d3e8257d22596f5d3e4395ca759bd1e0fe9b873.jpg@220w_280h.webp","totalCount":"全48话","id":28222671,"follow":"27.4 万","view":"978.0 万","danmaku":"3.6 万","coin":"3.6 万","score":9.6,"des":"为了阻止企图霸占世界的黑暗势力，野原家的普通小狗——小白接肩负重大使命，变身成为了守护世界的“超级小白”。小白将要面对的不仅是发明狗，还有其他意想不到的对手。当然，面对邪恶势力，小白也有着令人惊讶的超..."},{"title":"Re：从零开始的异世界生活 新编集版","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3c125e1aad08643e3eff2fb7d45e740c1a052725.png@220w_280h.webp","totalCount":"全13话","id":28224394,"follow":"631.1 万","view":"7674.2 万","danmaku":"166.2 万","coin":"51.1 万","score":9.6,"des":"在从便利商店回家的路上，突然被异世界召唤的少年菜月昴。在无法依靠任何东西的异世界，无力的少年手唯一的力量……那是“死去然后重新开始”的力量。为了守护最重要的人们，为了取回确实存在着又无可替代的时间，少..."},{"title":"因为太怕痛就全点防御力了","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/8021d3f6b0df6dbba6d32f76eb9cfe2531e166c4.png@220w_280h.webp","totalCount":"全12话","id":28224137,"follow":"620.6 万","view":"2.3 亿","danmaku":"326.8 万","coin":"103.8 万","score":9,"des":"主角本条枫在好友白峰理沙推荐下开始游玩游戏“NewWorld Online”，创建了名为“梅普露”的角色。然而作为游戏初学者，梅普露选择了不受欢迎的大盾当武器，同时因为怕痛而把所有状态点加到防御力的极..."},{"title":"冰海战记","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/c30401817895e67399094b4e669785a104270cdf.jpg@220w_280h.webp","totalCount":"全24话","id":28220475,"follow":"174.4 万","view":"4893.8 万","danmaku":"48.7 万","coin":"36.7 万","score":9.8,"des":"公元10世纪末期，出现了在世界各地出没的最强民族。被讴歌为最强战士的托尔兹，其子托尔芬幼时便生活在战场上，并向往着梦幻大陆“文兰”。这是一个发生在激荡时代的，真正的英雄物语。..."},{"title":"齐木楠雄的灾难 始动篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ba59822eded39b5254fb01448a7f1502101d5624.png@220w_280h.webp","totalCount":"全6话","id":28223748,"follow":"372.4 万","view":"3054.5 万","danmaku":"20.0 万","coin":"17.8 万","score":9.8,"des":"在电视剧中堪称帅气的超能力，对于高中生齐木楠雄来说只是招致灾难的元凶。作为新动画系列展开的楠雄的日常又会如何！？..."},{"title":"OVERLORD Ⅱ","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/851f979c8ebcc7583a43abd4b786c4e2e66b746b.jpg@220w_280h.webp","totalCount":"全13话","id":8792,"follow":"539.3 万","view":"3.8 亿","danmaku":"413.9 万","coin":"114.1 万","score":9.6,"des":"时为2138年。曾卷起一大风潮的虚拟现实体感型网络游戏《YGGDRASIL》即将迎来停服。玩家飞鼠在曾经以同伴和荣华自傲的根据地纳萨力克地下大坟墓，独自一人安静等待着那一刻。但是，不料发生了结束时间已..."},{"title":"夏目友人帐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/99c549494d9425f6455bd45a151f4d26397d6151.png@220w_280h.webp","totalCount":"全13话","id":1660,"follow":"324.0 万","view":"4975.2 万","danmaku":"278.7 万","coin":"15.5 万","score":9.8,"des":"夏目贵志生来拥有强大的灵力，能感知平常人所无法接触的妖怪神明的存在。因父母双亡，他多年间辗转于互相推卸责任的亲戚之间，又受到同龄人的欺负，未曾与任何人深交，造成性格一定程度上的孤僻。夏目本性和善，对于..."}],"watched":[{"title":"装甲重拳/MEGALOBOX","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0c44785cb5d25cc9f648800d251f21a2e236bb8a.png@220w_280h.webp","totalCount":"全13话","id":79472,"follow":"221.9 万","view":"6162.0 万","danmaku":"48.6 万","coin":"32.9 万","score":9.8,"des":"将肉体与“装甲技术”融合的究极格斗技——“MEGALOBOX”，将自己的全部赌在上面的男人们的热血战斗开始！\n今天也立于未认可地区的赌博比赛赛场上的MEGALO拳击手“JNK DOG”。虽然具备实力，..."},{"title":"超能力女儿","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/152c536f8ecaad8f3d7d568d33da81c963a4a722.png@220w_280h.webp","totalCount":"全12话","id":78352,"follow":"293.8 万","view":"9252.2 万","danmaku":"98.5 万","coin":"35.4 万","score":9.6,"des":"支持着芦川组的年轻智力型黑道新田义史，过着被喜欢的壶所包围的悠然自得单身生活。但某一天，随着装在神秘物体里的少女雏来到他家，他的生活为之一变。他被能使用念动力的雏所胁迫，迫不得已开始和她同居！\n容易暴..."},{"title":"OVERLORD Ⅲ","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/dd7a9d0a0bee32b1f43c2656398d8463d12b3069.jpg@220w_280h.webp","totalCount":"全13话","id":102252,"follow":"551.6 万","view":"4.0 亿","danmaku":"399.7 万","coin":"129.2 万","score":9.4,"des":"时间为2138年。曾卷起一大风潮的虚拟现实体感型网络游戏《YGGDRASIL》即将迎来停服。玩家飞鼠在曾经以同伴和荣华自傲的根据地纳萨力克地下大坟墓，独自一人安静等待着那一刻。\n但是，不料发生了“过了..."},{"title":"路人超能100 第一次灵能咨询所员工旅游～舒缓心灵的疗愈之旅~（OVA2）","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/1271324d51634b68980704731987724a1afc60aa.jpg@220w_280h.webp","totalCount":"全1话","id":28222715,"follow":"318.8 万","view":"520.7 万","danmaku":"3.6 万","coin":"4.6 万","score":9.8,"des":"由原作ONE老师担任原案的完全新作OVA！「灵能咨询所」一行人，龙套与灵幻、小酒窝以及新同伴芹泽的目的地，正是缟马县深山中鲜为人知的温泉·疣神温泉。因为灵幻接受了旅馆老板娘的委托，「弄清温泉的恐怖传闻..."},{"title":"少女终末旅行","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1431ca5bb2f7143062e3df8f21b8448cf8cccc13.jpg@220w_280h.webp","totalCount":"全12话","id":6463,"follow":"239.8 万","view":"3714.7 万","danmaku":"100.7 万","coin":"37.2 万","score":9.8,"des":"本作舞台在人类繁华的文明迎来终结的很久以后，人类基本灭绝，甚至生物都不再存在的末日世界。复杂够高的都市成为迷宫般的废墟，得不到维护的机械渐渐停止运转。连何时终结了，何时开始终结的思考都不复存在的这个世..."},{"title":"齐木楠雄的灾难（日播&精选版）","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/eb4f17335f48951945fb9da47e6ee0bc65fa2fbb.jpg@220w_280h.webp","totalCount":"全120话","id":5070,"follow":"187.0 万","view":"2.3 亿","danmaku":"130.7 万","coin":"32.7 万","score":9.6,"des":"高中生·齐木楠雄是超能力者。心灵感应、念动力、透视、预知、瞬间移动、千里眼等，不论任何事情都自由自在。但这任谁都羡慕不已的最强能力，实际上对于本人而言是引来灾难的不幸元凶。因此，他在别人面前封印了超能..."},{"title":"比宇宙更远的地方","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/c9eca3cbc386c63b27461074b8b218898cb7440e.jpg@220w_280h.webp","totalCount":"全13话","id":13032,"follow":"156.0 万","view":"2298.0 万","danmaku":"45.9 万","coin":"23.9 万","score":9.8,"des":"无论何时，我们的第一步总是从好奇心开始。\n不曾看过的风景，不曾听过的声音，不曾闻过的味道，不曾摸过的质感，不曾尝过的食物，以及不曾感受过的澎湃。\n为了重拾不知何时忘却的记忆碎片和不知何时舍弃的感动的旅..."},{"title":"OVERLORD","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/b8e72ea69e57e0b7ac85d8b4d366554fd866df1a.jpg@220w_280h.webp","totalCount":"全13话","id":2576,"follow":"626.2 万","view":"4.1 亿","danmaku":"385.2 万","coin":"84.4 万","score":9.6,"des":"作品主要讲述了某天，一款曾经掀起过大热潮的VRMMORPG「YGGDRASIL」停止了运营。游戏原本会停止一切服务，但过了结束时间后，玩家们却发现不能退出，NPC也产生了各自的思想。现实世界中喜爱电玩..."},{"title":"路人超能100 II(灵能百分百 第二季)","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/216e1bdaf88244215a13b1154116805ee9adbe07.png@220w_280h.webp","totalCount":"全13话","id":4762734,"follow":"284.9 万","view":"1.0 亿","danmaku":"97.8 万","coin":"56.1 万","score":9.9,"des":"当有什么东西达到“100”的时候，就会爆发的少年·路人（龙套）。外表极其普通——不如说是不起眼。不擅长迎合气氛的他，实际上拥有着强力的超能力。盯上了这样的他的能力，而接连现身的伪灵能力者以及宗教团体、..."},{"title":"多罗罗","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3fc16a667502cbff226e585eb660a96a20c7458c.png@220w_280h.webp","totalCount":"全24话","id":4312482,"follow":"452.1 万","view":"1.8 亿","danmaku":"143.9 万","coin":"73.9 万","score":9.4,"des":"他们向着命运抗争，在那尽头等待他们的是人心，还是业障。\n时值乱世。\n名为景光的醍醐将军，向某个寺庙殿堂中的12尊魔神像祈求早日结束战乱。\n作为代价，他的嫡子在出生时就失去了身体的某些部位，被丢弃在河流..."},{"title":"魔法少女小圆","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/7fcaa0e98b561611538ae4deba7949cec4ca39a8.png@220w_280h.webp","totalCount":"全12话","id":2539,"follow":"218.7 万","view":"4199.0 万","danmaku":"201.5 万","coin":"20.0 万","score":9.8,"des":"就读初中二年级的鹿目圆，过着平凡幸福的生活。神秘转学生晓美焰的出现，开始让小圆的命运有了巨大转变。某日一只名为丘比的神秘生物，希望小圆能够与它签订魔法契约，成为“魔法少女”以对抗邪恶的魔女保护世界。正..."}]},"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"http://rebp38war.bkt.clouddn.com/img/v2-376062e6eaa322512fae11c68de08493_r.jpg","excerpt":"","more":""},{"title":"友情链接","date":"2021-12-24T09:45:15.000Z","type":"link","_content":"","source":"link/index.md","raw":"---\ntitle: 友情链接\ndate: 2021-12-24 17:45:15\ntype: \"link\"\n---\n","updated":"2021-12-24T09:45:51.512Z","path":"link/index.html","comments":1,"layout":"page","_id":"cl5w7e740000eigvuacf2hhko","content":"","site":{"data":{"bangumis":{"wantWatch":[],"watching":[{"title":"凡人修仙传","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/70d11dfab23a3ee81ccf64f18efa139416a633ff.jpg@220w_280h.webp","totalCount":"未完结","id":28223043,"follow":"615.7 万","view":"8.9 亿","danmaku":"490.9 万","coin":"1186.9 万","score":9.7,"des":"看机智的凡人小子韩立如何稳健发展、步步为营，战魔道、夺至宝、驰骋星海、快意恩仇，成为纵横三界的强者。他日仙界重相逢，一声道友尽沧桑。..."},{"title":"恋爱游戏世界对路人角色很不友好","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/c9723d8c77d881a8debba2852d580e97826b43d0.png@220w_280h.webp","totalCount":"全12话","id":28237300,"follow":"151.2 万","view":"5120.4 万","danmaku":"40.6 万","coin":"24.5 万","score":9.1,"des":"从现代日本转生到“恋爱游戏”世界的里昂，发现这里女尊男卑，对男性很不友好。身为路人角色的他，为了摆脱自己因地位低下而被肆意决定的人生，决定活用从游戏中得到的知识，保持路人角色的身份，取得“失落物品”来..."},{"title":"魔法纪录 魔法少女小圆外传 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/9eef1df9ab157be52d2c4d70d3500442f00cafc3.png@220w_280h.webp","totalCount":"全12话","id":28234642,"follow":"237.1 万","view":"907.6 万","danmaku":"5.0 万","coin":"4.9 万","score":7.7,"des":"愿望的代价，究竟是希望还是绝望——。"},{"title":"小林家的龙女仆 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/847e9dbb6876fb37a30199a5c88910704976d45b.png@220w_280h.webp","totalCount":"全13话","id":28234613,"follow":"855.7 万","view":"1.1 亿","danmaku":"49.0 万","coin":"69.0 万","score":9.6,"des":"那位不可思议的龙女仆再度登场！\n因为各种奇妙的原因而作为小林家的女仆而工作中的龙·托尔。\n偶尔（胡说，是经常）给亲爱的小林添麻烦，总算是融入了人类社会，成为了一个完美的（骗人，也就还行）女仆。\n同样是..."},{"title":"国王排名","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/376d7e69a667bcb1c0b934a4e35e07e7fa23110b.png@220w_280h.webp","totalCount":"全23话","id":28235154,"follow":"927.7 万","view":"4.8 亿","danmaku":"250.1 万","coin":"260.9 万","score":7,"des":"国家的丰饶、麾下勇者的数量、\n以及国王本人如何像勇者一般强大，\n这些要素的综合排名，便是所谓的“国王排名”。\n主人公波吉是国王排名第七名的伯斯王治下王国的第一王子。\n但是波吉却生来又聋又哑，贫弱到挥不..."},{"title":"阿松 第三季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0212baa8898d0c819c7fb84015e95b8fca621435.png@220w_280h.webp","totalCount":"全25话","id":28229892,"follow":"67.6 万","view":"938.0 万","danmaku":"13.0 万","coin":"5.4 万","score":9.6,"des":"日本最有名的六胞胎的传说，第三次开幕！！这次会有怎样意想不到的新展开！？..."},{"title":"命运-冠位指定 冠位时间神殿所罗门","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0e094b798388da19a4feffa6a6dabc1dc1dc90cd.jpg@220w_280h.webp","totalCount":"全1话","id":28236225,"follow":"525.5 万","view":"1220.0 万","danmaku":"8.9 万","coin":"15.1 万","score":8.5,"des":"在经过七个特异点的大战后，\n人理存续保障机关迦勒底，终于到达了圣杯探索的最终地点——终局特异点 冠位时间神殿所罗门。\n他们要击败身为罪魁祸首的魔术王所罗门，夺回未来。\n在开战的前一刻，一行人各自度过了..."},{"title":"JOJO的奇妙冒险 星尘远征军","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/47c0108259355d6d2c517ed97f6b90fb777f844f.png@220w_280h.webp","totalCount":"全24话","id":28223481,"follow":"444.2 万","view":"1.5 亿","danmaku":"463.4 万","coin":"45.7 万","score":9.8,"des":"时为1987年，乔瑟夫·乔斯达与“柱之男”们之间的死战后过了50年……乔瑟夫为了为了帮助“被恶灵附身了”的外孙子·空条承太郎而来到了日本。原来那并不是恶灵而是幽波纹（替身）。替身突然出现的原因在于，从..."},{"title":"JOJO的奇妙冒险 星尘远征军 埃及篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f6709b76e88f50aa132d1e09e2d8de9663a09b3e.png@220w_280h.webp","totalCount":"全24话","id":28223483,"follow":"421.9 万","view":"1.3 亿","danmaku":"468.7 万","coin":"44.3 万","score":9.9,"des":"在乔斯达家的宿敌·迪奥（DIO）复活的影响下，一位年轻人——空条承太郎，得到了名为“幽波纹（替身）”的能力。为了拯救因迪奥的诅咒而倒下的母亲荷莉，空条承太郎与外祖父·乔瑟夫以及伙伴们，一起为了打倒迪奥..."},{"title":"JOJO的奇妙冒险 不灭钻石","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/6a04c87e990ab74cd8d555ef45a863de0993b161.png@220w_280h.webp","totalCount":"全39话","id":140552,"follow":"302.3 万","view":"2.1 亿","danmaku":"813.8 万","coin":"55.9 万","score":9.8,"des":"在埃及与宿敌DIO的死斗之后过了11年。1999年，空条承太郎为了与祖父乔瑟夫·乔斯达的私生子东方仗助见面，而来到了日本M县S市杜王町。但，仗助却持有与承太郎相同的特殊能力“替身”。之后，以承太郎的来..."},{"title":"命运-冠位嘉年华","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/c660976f4502a544d990a882ae62194b57753a71.png@220w_280h.webp","totalCount":"全2话","id":28234639,"follow":"479.8 万","view":"862.4 万","danmaku":"4.1 万","coin":"9.1 万","score":9.8,"des":"一起庆祝吧！为了这奇迹般的嘉年华！"},{"title":"伍六七","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/b69e26d9e50514f3fa99eac9ab5aabf2a6e28c88.jpg@220w_280h.webp","totalCount":"全13话","id":6360,"follow":"585.8 万","view":"3.3 亿","danmaku":"227.1 万","coin":"191.8 万","score":9.8,"des":"在某个小岛上，有一个可以伪装成任何东西的廉价刺客，名叫伍六七。平时看上去是个理发师，其实背地里却做着刺客生意。热爱理发事业，喜欢给人剪头发，善用剪刀——剪刀也是他的刺杀武器。由于初入刺客行当，行情十分..."},{"title":"命运-冠位指定 -月光／失落之室-","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3fa5fd2b7afae827b0bf150d7f0cbfc54eda1ff2.png@220w_280h.webp","totalCount":"全1话","id":28234950,"follow":"483.3 万","view":"551.2 万","danmaku":9696,"coin":"2.9 万","score":9.5,"des":"失落之室——。\n这是一个可以看到被夺去亦或是遗失之物的地方。\n这是位于迦勒底被遗忘的角落，不属于任何人的地方。..."},{"title":"致不灭的你","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/1ae94fbb35d8e23bb84926b694509f8b057f96e6.png@220w_280h.webp","totalCount":"全20话","id":28233896,"follow":"476.3 万","view":"1.3 亿","danmaku":"140.1 万","coin":"95.0 万","score":9.6,"des":"本剧讲述了一个情节跌宕、场面宏大的奇幻故事，通过拥有不灭之身的主人公“不死”来探索人生哲理。\n不死起初是一个被投放到人世间的“球”。\n\n它具有“幻化为刺激源形态的能力”和“死后重生的能力”。\n\n先后从..."},{"title":"来自新世界","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/aaa60f9cb17fb4a38df464f1064ca9623e0769cc.jpg@220w_280h.webp","totalCount":"全25话","id":1598,"follow":"115.9 万","view":"1540.9 万","danmaku":"76.3 万","coin":"5.7 万","score":9.5,"des":"1000年后的日本，孩子们不断地消失，只存在想象中的恐怖动物与人类展开殊死战争。反乌托邦式的未来超级社会“新世界”，是口吐真言凭藉“咒力”就能移动物体的人类，与有着等同于普通人智力的生物“妖鼠”共存的..."},{"title":"转生成蜘蛛又怎样！","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f0796e37abac25ba2aa9f23120646aaa9a3d5ea7.png@220w_280h.webp","totalCount":"全24话","id":28231809,"follow":"600.0 万","view":"3.7 亿","danmaku":"190.3 万","coin":"164.6 万","score":7.8,"des":"曾经是一名女高中生的“我”，突然转生变成了幻想世界中的蜘蛛魔物。\n而且，出生地点还是各种凶恶魔物所盘踞的大迷宫。\n“我”以人类的智慧和非同寻常的积极心态为武器，使用蜘蛛的丝网以及陷阱打倒比自己等级高得..."},{"title":"装甲重拳/MEGALOBOX 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/e14dc4a935397fc074c7a12d9520225615209025.png@220w_280h.webp","totalCount":"全13话","id":28233916,"follow":"244.9 万","view":"3435.4 万","danmaku":"19.7 万","coin":"53.1 万","score":9.9,"des":"再一次，为梦想而活——\n\n将肉体与“装甲技术”融合的究极格斗技“装甲拳击”。\n在决出其顶点之人的大会“重拳之巅”上，身穿装甲用自己肉身挑战一切的拳击手“JOE”。\n\n从最下层的比赛开始仅仅花了三个月就..."},{"title":"机动战士高达SEED HD","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/855c88677267d707ebfe4040403692ff2c0938f0.png@220w_280h.webp","totalCount":"全48话","id":497,"follow":"54.8 万","view":"4044.4 万","danmaku":"114.4 万","coin":"6.0 万","score":9.6,"des":"《机动战士高达SEED》是高达系列在2002年至2003年度放映的动画。续作为《机动战士高达SEED Destiny》在2004年播放。因各具魅力的角色，明星云集的声优阵容和高度商业化的宣传而受到较低..."},{"title":"夏目友人帐 唤石者与怪异的访客","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6cf43708b779cde84ad285ff4e3a080de98df0af.png@220w_280h.webp","totalCount":"全1话","id":28234316,"follow":"567.1 万","view":"1374.8 万","danmaku":"18.1 万","coin":"17.9 万","score":9.9,"des":"本作由【唤石者】与【怪异的访客】两个人气短篇集锦而成。讲述生来便能看见各种妖怪的夏目，与自称保镖的猫咪老师一同邂逅的一系列温暖故事。\n【唤石者】一天夏目在森林中遇到一只小妖怪——密实。密实称自己肩负「..."},{"title":"Fate/Grand Order ‐First Order‐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/b75c55d209d156c8631f5ceb21e5c52c834dbb60.jpg@220w_280h.webp","totalCount":"全1话","id":5747,"follow":"250.9 万","view":"3329.7 万","danmaku":"76.7 万","coin":"10.7 万","score":8.3,"des":"【2016年12月31日bilibili独播】2015年。示巴所观测到的未来领域毫无前兆地消失。根据计算，发现——不，是证明了人类将于2017年灭绝。人理延续保障机构·迦勒底将“无法观测的领域”假定为..."},{"title":"伍六七之玄武国篇","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/00843865ea13702eccc4efd64c313fd4c8029c6b.jpg@220w_280h.webp","totalCount":"全10话","id":28232253,"follow":"999.4 万","view":"4.0 亿","danmaku":"177.7 万","coin":"385.3 万","score":9.8,"des":"为了保护小鸡岛居民和这里平静的生活，伍六七和他的伙伴大保和小飞开启了去往玄武国的冒险旅程，去寻找身世的真相和解救小岛的办法，等待他们的又将是更多的未知与奇遇。..."},{"title":"堀与宫村","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/039c4e0b14e27c7a9e5cce2f20a6efd3c8909401.png@220w_280h.webp","totalCount":"全13话","id":28231840,"follow":"695.2 万","view":"2.2 亿","danmaku":"242.1 万","coin":"361.4 万","score":9.8,"des":"不论是谁，都会有不想被人知道的一面。\n\n在学校中漂亮大方、成绩优秀的人气女生堀，私下却打扮土气、忙于家务和照顾弟弟。\n在学校中是阴暗宅男形象的宫村，生活中却是打扮时尚、带耳钉的帅气男生。\n因为一次特别..."},{"title":"奇蛋物语 / WONDER EGG PRIORITY","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/10e0bbc1047b2c45f0f881de334a6f3bfb42a3b6.png@220w_280h.webp","totalCount":"全12话","id":28231851,"follow":"254.9 万","view":"4686.8 万","danmaku":"47.6 万","coin":"65.5 万","score":9.7,"des":"14岁少女·大户爱在深夜散步的途中，\n随着神秘声音的指引，获得了一枚「蛋」。\n\n「如果想要改变世界的话」\n「那么就在现在做出选择」\n「请相信自己——」\n「打破这枚蛋——」\n\n而在打破「蛋」之后，等待着..."},{"title":"Re：从零开始的异世界生活 第二季 后半","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/4f3edbede7fc0bdb52842075cf8faaa1c5953eaa.png@220w_280h.webp","totalCount":"全12话","id":28232073,"follow":"849.9 万","view":"9308.1 万","danmaku":"108.1 万","coin":"230.1 万","score":9.9,"des":"我一定会拯救你。\n在打倒了魔女教大罪司教「怠惰」担当——培提其乌斯·罗曼尼康帝之后，菜月昴和爱蜜莉雅又得以重新开始。\n克服了艰难的诀别，两人终于和解，然而这只是新一轮风波的序幕。\n超乎想象的绝境危机，..."},{"title":"灰与幻想的格林姆迦尔","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/7fb4945f864e9e988212b7d20f206df2677053f8.jpg@220w_280h.webp","totalCount":"全12话","id":106512,"follow":"172.0 万","view":"2343.4 万","danmaku":"63.8 万","coin":"18.3 万","score":9.8,"des":"电视动画《灰与幻想的格林姆迦尔》改编自日本轻小说家十文字青原作白井锐利插画的同名轻小说。\n我们为什么要这么做…？\n哈尔希洛回过神来，才发现自己身处在黑暗当中，他完全不知道自己人在何处，也不明白这个地方..."},{"title":"龙与虎","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/144910805f172d16c5f544f43939a05d8ca20576.jpg@220w_280h.webp","totalCount":"全26话","id":1672,"follow":"336.9 万","view":"6671.9 万","danmaku":"511.9 万","coin":"61.5 万","score":9.7,"des":"樱花飞舞的四月，全新的高中二年级，新的班级……\n眼神凶恶的普通男孩——高须龙儿，遇上了众人害怕、凶暴残忍的“掌中老虎”逢坂大河，还知道了她不欲为人知的秘密。这就是龙虎相争爱与战斗的序幕。\n再加上总是笑..."},{"title":"机动战士高达 铁血的奥尔芬斯 第一季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/f84a80d731d0431c00903d8951fd66623d8237f7.png@220w_280h.webp","totalCount":"全25话","id":4310042,"follow":"62.4 万","view":"2318.6 万","danmaku":"52.2 万","coin":"5.4 万","score":9.5,"des":"主人公三日月·奥古斯，从所属的民间警备公司克律塞安保公司（下称CGS）那里，接受了对少女库德莉亚·蓝那·伯恩斯坦的护卫任务。但CGS受到了摘取反叛之芽的武力组织加拉尔霍恩的袭击，于是在把三日月当做诱饵..."},{"title":"机动战士高达00 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1d7a969e8f1045739c596de89a963e30475aff0e.jpg@220w_280h.webp","totalCount":"全25话","id":1193,"follow":"37.2 万","view":"2458.1 万","danmaku":"61.4 万","coin":"4.1 万","score":9.8,"des":"天人与联合国军的最终决战后过了四年。建立地球联邦政府的人类，为了追求更进一步的国家间之统合，以及人类意识的统一，在联合正规军之外，设立了独立治安维持部队“A-Laws”，目的为对所有危害联合的势力与主..."},{"title":"机动战士高达00","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/35b11bf59eb3fd12f0387951510a5d722d7435e5.jpg@220w_280h.webp","totalCount":"全25话","id":1192,"follow":"62.1 万","view":"2465.5 万","danmaku":"53.6 万","coin":"4.6 万","score":9.7,"des":"在西历2307年，虽然化石燃料枯竭了，但是人类得到了截然不同的新型能源。三台巨大的轨道升降机以及伴随它们的大规模的太阳光发电系统。但是能得到这个系统恩惠的，只有一部分大国和其同盟国而已。\n拥有三台轨道..."},{"title":"Re：从零开始的异世界生活 第二季 前半","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f2425cbdb07cc93bd0d3ba1c0099bfe78f5dc58a.png@220w_280h.webp","totalCount":"全13话","id":28229233,"follow":"774.2 万","view":"1.3 亿","danmaku":"201.4 万","coin":"126.7 万","score":9.7,"des":"我一定会拯救你。\n在打倒了魔女教大罪司教「怠惰」担当——培提其乌斯·罗曼尼康帝之后，菜月昴和爱蜜莉雅又得以重新开始。\n克服了艰难的诀别，两人终于和解，然而这只是新一轮风波的序幕。\n超乎想象的绝境危机，..."},{"title":"超级小白","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3d3e8257d22596f5d3e4395ca759bd1e0fe9b873.jpg@220w_280h.webp","totalCount":"全48话","id":28222671,"follow":"27.4 万","view":"978.0 万","danmaku":"3.6 万","coin":"3.6 万","score":9.6,"des":"为了阻止企图霸占世界的黑暗势力，野原家的普通小狗——小白接肩负重大使命，变身成为了守护世界的“超级小白”。小白将要面对的不仅是发明狗，还有其他意想不到的对手。当然，面对邪恶势力，小白也有着令人惊讶的超..."},{"title":"Re：从零开始的异世界生活 新编集版","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3c125e1aad08643e3eff2fb7d45e740c1a052725.png@220w_280h.webp","totalCount":"全13话","id":28224394,"follow":"631.1 万","view":"7674.2 万","danmaku":"166.2 万","coin":"51.1 万","score":9.6,"des":"在从便利商店回家的路上，突然被异世界召唤的少年菜月昴。在无法依靠任何东西的异世界，无力的少年手唯一的力量……那是“死去然后重新开始”的力量。为了守护最重要的人们，为了取回确实存在着又无可替代的时间，少..."},{"title":"因为太怕痛就全点防御力了","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/8021d3f6b0df6dbba6d32f76eb9cfe2531e166c4.png@220w_280h.webp","totalCount":"全12话","id":28224137,"follow":"620.6 万","view":"2.3 亿","danmaku":"326.8 万","coin":"103.8 万","score":9,"des":"主角本条枫在好友白峰理沙推荐下开始游玩游戏“NewWorld Online”，创建了名为“梅普露”的角色。然而作为游戏初学者，梅普露选择了不受欢迎的大盾当武器，同时因为怕痛而把所有状态点加到防御力的极..."},{"title":"冰海战记","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/c30401817895e67399094b4e669785a104270cdf.jpg@220w_280h.webp","totalCount":"全24话","id":28220475,"follow":"174.4 万","view":"4893.8 万","danmaku":"48.7 万","coin":"36.7 万","score":9.8,"des":"公元10世纪末期，出现了在世界各地出没的最强民族。被讴歌为最强战士的托尔兹，其子托尔芬幼时便生活在战场上，并向往着梦幻大陆“文兰”。这是一个发生在激荡时代的，真正的英雄物语。..."},{"title":"齐木楠雄的灾难 始动篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ba59822eded39b5254fb01448a7f1502101d5624.png@220w_280h.webp","totalCount":"全6话","id":28223748,"follow":"372.4 万","view":"3054.5 万","danmaku":"20.0 万","coin":"17.8 万","score":9.8,"des":"在电视剧中堪称帅气的超能力，对于高中生齐木楠雄来说只是招致灾难的元凶。作为新动画系列展开的楠雄的日常又会如何！？..."},{"title":"OVERLORD Ⅱ","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/851f979c8ebcc7583a43abd4b786c4e2e66b746b.jpg@220w_280h.webp","totalCount":"全13话","id":8792,"follow":"539.3 万","view":"3.8 亿","danmaku":"413.9 万","coin":"114.1 万","score":9.6,"des":"时为2138年。曾卷起一大风潮的虚拟现实体感型网络游戏《YGGDRASIL》即将迎来停服。玩家飞鼠在曾经以同伴和荣华自傲的根据地纳萨力克地下大坟墓，独自一人安静等待着那一刻。但是，不料发生了结束时间已..."},{"title":"夏目友人帐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/99c549494d9425f6455bd45a151f4d26397d6151.png@220w_280h.webp","totalCount":"全13话","id":1660,"follow":"324.0 万","view":"4975.2 万","danmaku":"278.7 万","coin":"15.5 万","score":9.8,"des":"夏目贵志生来拥有强大的灵力，能感知平常人所无法接触的妖怪神明的存在。因父母双亡，他多年间辗转于互相推卸责任的亲戚之间，又受到同龄人的欺负，未曾与任何人深交，造成性格一定程度上的孤僻。夏目本性和善，对于..."}],"watched":[{"title":"装甲重拳/MEGALOBOX","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0c44785cb5d25cc9f648800d251f21a2e236bb8a.png@220w_280h.webp","totalCount":"全13话","id":79472,"follow":"221.9 万","view":"6162.0 万","danmaku":"48.6 万","coin":"32.9 万","score":9.8,"des":"将肉体与“装甲技术”融合的究极格斗技——“MEGALOBOX”，将自己的全部赌在上面的男人们的热血战斗开始！\n今天也立于未认可地区的赌博比赛赛场上的MEGALO拳击手“JNK DOG”。虽然具备实力，..."},{"title":"超能力女儿","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/152c536f8ecaad8f3d7d568d33da81c963a4a722.png@220w_280h.webp","totalCount":"全12话","id":78352,"follow":"293.8 万","view":"9252.2 万","danmaku":"98.5 万","coin":"35.4 万","score":9.6,"des":"支持着芦川组的年轻智力型黑道新田义史，过着被喜欢的壶所包围的悠然自得单身生活。但某一天，随着装在神秘物体里的少女雏来到他家，他的生活为之一变。他被能使用念动力的雏所胁迫，迫不得已开始和她同居！\n容易暴..."},{"title":"OVERLORD Ⅲ","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/dd7a9d0a0bee32b1f43c2656398d8463d12b3069.jpg@220w_280h.webp","totalCount":"全13话","id":102252,"follow":"551.6 万","view":"4.0 亿","danmaku":"399.7 万","coin":"129.2 万","score":9.4,"des":"时间为2138年。曾卷起一大风潮的虚拟现实体感型网络游戏《YGGDRASIL》即将迎来停服。玩家飞鼠在曾经以同伴和荣华自傲的根据地纳萨力克地下大坟墓，独自一人安静等待着那一刻。\n但是，不料发生了“过了..."},{"title":"路人超能100 第一次灵能咨询所员工旅游～舒缓心灵的疗愈之旅~（OVA2）","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/1271324d51634b68980704731987724a1afc60aa.jpg@220w_280h.webp","totalCount":"全1话","id":28222715,"follow":"318.8 万","view":"520.7 万","danmaku":"3.6 万","coin":"4.6 万","score":9.8,"des":"由原作ONE老师担任原案的完全新作OVA！「灵能咨询所」一行人，龙套与灵幻、小酒窝以及新同伴芹泽的目的地，正是缟马县深山中鲜为人知的温泉·疣神温泉。因为灵幻接受了旅馆老板娘的委托，「弄清温泉的恐怖传闻..."},{"title":"少女终末旅行","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1431ca5bb2f7143062e3df8f21b8448cf8cccc13.jpg@220w_280h.webp","totalCount":"全12话","id":6463,"follow":"239.8 万","view":"3714.7 万","danmaku":"100.7 万","coin":"37.2 万","score":9.8,"des":"本作舞台在人类繁华的文明迎来终结的很久以后，人类基本灭绝，甚至生物都不再存在的末日世界。复杂够高的都市成为迷宫般的废墟，得不到维护的机械渐渐停止运转。连何时终结了，何时开始终结的思考都不复存在的这个世..."},{"title":"齐木楠雄的灾难（日播&精选版）","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/eb4f17335f48951945fb9da47e6ee0bc65fa2fbb.jpg@220w_280h.webp","totalCount":"全120话","id":5070,"follow":"187.0 万","view":"2.3 亿","danmaku":"130.7 万","coin":"32.7 万","score":9.6,"des":"高中生·齐木楠雄是超能力者。心灵感应、念动力、透视、预知、瞬间移动、千里眼等，不论任何事情都自由自在。但这任谁都羡慕不已的最强能力，实际上对于本人而言是引来灾难的不幸元凶。因此，他在别人面前封印了超能..."},{"title":"比宇宙更远的地方","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/c9eca3cbc386c63b27461074b8b218898cb7440e.jpg@220w_280h.webp","totalCount":"全13话","id":13032,"follow":"156.0 万","view":"2298.0 万","danmaku":"45.9 万","coin":"23.9 万","score":9.8,"des":"无论何时，我们的第一步总是从好奇心开始。\n不曾看过的风景，不曾听过的声音，不曾闻过的味道，不曾摸过的质感，不曾尝过的食物，以及不曾感受过的澎湃。\n为了重拾不知何时忘却的记忆碎片和不知何时舍弃的感动的旅..."},{"title":"OVERLORD","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/b8e72ea69e57e0b7ac85d8b4d366554fd866df1a.jpg@220w_280h.webp","totalCount":"全13话","id":2576,"follow":"626.2 万","view":"4.1 亿","danmaku":"385.2 万","coin":"84.4 万","score":9.6,"des":"作品主要讲述了某天，一款曾经掀起过大热潮的VRMMORPG「YGGDRASIL」停止了运营。游戏原本会停止一切服务，但过了结束时间后，玩家们却发现不能退出，NPC也产生了各自的思想。现实世界中喜爱电玩..."},{"title":"路人超能100 II(灵能百分百 第二季)","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/216e1bdaf88244215a13b1154116805ee9adbe07.png@220w_280h.webp","totalCount":"全13话","id":4762734,"follow":"284.9 万","view":"1.0 亿","danmaku":"97.8 万","coin":"56.1 万","score":9.9,"des":"当有什么东西达到“100”的时候，就会爆发的少年·路人（龙套）。外表极其普通——不如说是不起眼。不擅长迎合气氛的他，实际上拥有着强力的超能力。盯上了这样的他的能力，而接连现身的伪灵能力者以及宗教团体、..."},{"title":"多罗罗","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3fc16a667502cbff226e585eb660a96a20c7458c.png@220w_280h.webp","totalCount":"全24话","id":4312482,"follow":"452.1 万","view":"1.8 亿","danmaku":"143.9 万","coin":"73.9 万","score":9.4,"des":"他们向着命运抗争，在那尽头等待他们的是人心，还是业障。\n时值乱世。\n名为景光的醍醐将军，向某个寺庙殿堂中的12尊魔神像祈求早日结束战乱。\n作为代价，他的嫡子在出生时就失去了身体的某些部位，被丢弃在河流..."},{"title":"魔法少女小圆","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/7fcaa0e98b561611538ae4deba7949cec4ca39a8.png@220w_280h.webp","totalCount":"全12话","id":2539,"follow":"218.7 万","view":"4199.0 万","danmaku":"201.5 万","coin":"20.0 万","score":9.8,"des":"就读初中二年级的鹿目圆，过着平凡幸福的生活。神秘转学生晓美焰的出现，开始让小圆的命运有了巨大转变。某日一只名为丘比的神秘生物，希望小圆能够与它签订魔法契约，成为“魔法少女”以对抗邪恶的魔女保护世界。正..."}]},"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"http://rebp38war.bkt.clouddn.com/img/v2-b006882f4ae03db43db5dd9a4bda19e5_r.jpg","excerpt":"","more":""}],"Post":[{"title":"Kafka","date":"2022-07-10T07:41:22.000Z","cover":"http://rebp38war.bkt.clouddn.com/img/6f79ddbaf6bc4c2d99adc571273d577f.jpeg","_content":"# 消息队列的流派\n\n### 什么是 MQ\n\n>Message Queue（MQ），消息队列中间件。很多人都说：MQ 通过将消息的发送和接收分离来实现应用程序的异步和解偶，这个给人的直觉是——MQ 是异步的，用来解耦的，但是这个只是 MQ 的效果而不是目的。MQ 真正的目的是为了通讯，屏蔽底层复杂的通讯协议，定义了一套应用层的、更加简单的通讯协议。一个分布式系统中两个模块之间通讯要么是HTTP，要么是自己开发的（rpc） TCP，但是这两种协议其实都是原始的协议。HTTP 协议很难实现两端通讯——模块 A 可以调用 B，B 也可以主动调用 A，如果要做到这个两端都要背上WebServer，而且还不支持⻓连接（HTTP 2.0 的库根本找不到）。TCP 就更加原始了，粘包、心跳、私有的协议，想一想头皮就发麻。MQ 所要做的就是在这些协议之上构建一个简单的“协议”——生产者/消费者模型。MQ 带给我的“协议”不是具体的通讯协议，而是更高层次通讯模型。它定义了两个对象——发送数据的叫生产者；接收数据的叫消费者， 提供一个SDK 让我们可以定义自己的生产者和消费者实现消息通讯而无视底层通讯协议\n\n### 有 Broker 的 MQ\n\n>这个流派通常有一台服务器作为 Broker，所有的消息都通过它中转。生产者把消息发送给它就结束自己的任务了，Broker 则把消息主动推送给消费者（或者消费者主动轮询）\n\n### 重 Topic\n\n>kafka、JMS（ActiveMQ）就属于这个流派，生产者会发送 key 和数据到 Broker，由 Broker比较 key 之后决定给哪个消费者。这种模式是我们最常⻅的模式，是我们对 MQ 最多的印象。在这种模式下一个 topic 往往是一个比较大的概念，甚至一个系统中就可能只有一个topic，topic 某种意义上就是 queue，生产者发送 key 相当于说：“hi，把数据放到 key 的队列中”\n\n>如上图所示，Broker 定义了三个队列，key1，key2，key3，生产者发送数据的时候会发送key1 和 data，Broker 在推送数据的时候则推送 data（也可能把 key 带上）。\n\n>虽然架构一样但是 kafka 的性能要比 jms 的性能不知道高到多少倍，所以基本这种类型的MQ 只有 kafka 一种备选方案。如果你需要一条暴力的数据流（在乎性能而非灵活性）那么kafka 是最好的选择\n\n### 轻 Topic\n\n>这种的代表是 RabbitMQ（或者说是 AMQP）。生产者发送 key 和数据，消费者定义订阅的队列，Broker 收到数据之后会通过一定的逻辑计算出 key 对应的队列，然后把数据交给队列\n\n>这种模式下解耦了 key 和 queue，在这种架构中 queue 是非常轻量级的（在 RabbitMQ 中它的上限取决于你的内存），消费者关心的只是自己的 queue；生产者不必关心数据最终给谁只要指定 key 就行了，中间的那层映射在 AMQP 中叫 exchange（交换机）。\n\nAMQP 中有四种 exchange\n\n* Direct exchange：key 就等于 queue\n* Fanout exchange：无视 key，给所有的 queue 都来一份\n* Topic exchange：key 可以用“宽字符”模糊匹配 queue\n* Headers exchange：无视 key，通过查看消息的头部元数据来决定发给那个\n* queue（AMQP 头部元数据非常丰富而且可以自定义）\n\n这种结构的架构给通讯带来了很大的灵活性，我们能想到的通讯方式都可以用这四种exchange 表达出来。如果你需要一个企业数据总线（在乎灵活性）那么 RabbitMQ 绝对的值得一用\n\n### 无 Broker 的 MQ\n\n>无 Broker 的 MQ 的代表是 ZeroMQ。该作者非常睿智，他非常敏锐的意识到——MQ 是更高级的 Socket，它是解决通讯问题的。所以 ZeroMQ 被设计成了一个“库”而不是一个中间件，这种实现也可以达到——没有 Broker 的目的\n\n>节点之间通讯的消息都是发送到彼此的队列中，每个节点都既是生产者又是消费者。ZeroMQ做的事情就是封装出一套类似于 Socket 的 API 可以完成发送数据，读取数据\n\n>ZeroMQ 其实就是一个跨语言的、重量级的 Actor 模型邮箱库。你可以把自己的程序想象成一个 Actor，ZeroMQ 就是提供邮箱功能的库；ZeroMQ 可以实现同一台机器的 RPC 通讯也可以实现不同机器的 TCP、UDP 通讯，如果你需要一个强大的、灵活、野蛮的通讯能力，别犹豫 ZeroMQ\n\n# 一、Kafka介绍\n\n>Kafka是最初由Linkedin公司开发，是一个分布式、支持分区的（partition）、多副本的\n（replica），基于zookeeper协调的分布式消息系统，它的最大的特性就是可以实时的处理\n大量数据以满足各种需求场景：比如基于hadoop的批处理系统、低延迟的实时系统、\nStorm/Spark流式处理引擎，web/nginx日志、访问日志，消息服务等等，用scala语言编\n写，Linkedin于 2010 年贡献给了Apache基金会并成为顶级开源 项目。\n\n## 1.Kafka的使用场景\n\n>日志收集：一个公司可以用Kafka收集各种服务的log，通过kafka以统一接口服务的方式\n开放给各种consumer，例如hadoop、Hbase、Solr等。\n消息系统：解耦和生产者和消费者、缓存消息等。\n用户活动跟踪：Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网⻚、\n搜索、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过\n订阅这些topic来做实时的监控分析，或者装载到hadoop、数据仓库中做离线分析和挖\n掘。\n运营指标：Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产\n各种操作的集中反馈，比如报警和报告。\n\n## 2.Kafka基本概念\n\n>kafka是一个分布式的，分区的消息(官方称之为commit log)服务。它提供一个消息系统应该\n具备的功能，但是确有着独特的设计。可以这样来说，Kafka借鉴了JMS规范的思想，但是确\n并 `没有完全遵循JMS规范。`\n\n首先，让我们来看一下基础的消息(Message)相关术语：\n\n\n名称|解释\n--|:--:\nBroker|消息中间件处理节点，⼀个Kafka节点就是⼀个broker，⼀个或者多个Broker可以组成⼀个Kafka集群\nTopic|Kafka根据topic对消息进⾏归类，发布到Kafka集群的每条消息都需要指定⼀个topic\nProducer|消息⽣产者，向Broker发送消息的客户端\nConsumer|消息消费者，从Broker读取消息的客户端\nConsumerGroup|每个Consumer属于⼀个特定的Consumer Group，⼀条消息可以被多个不同的Consumer Group消费，但是⼀个Consumer Group中只能有⼀个Consumer能够消费该消息\nPartition|物理上的概念，⼀个topic可以分为多个partition，每个partition内部消息是有序的\n\n因此，从一个较高的层面上来看，producer通过网络发送消息到Kafka集群，然后consumer\n来进行消费，如下图：\n![输入图片说明](kafka/QQ截图20220110112502.png \"QQ截图20201229183512.png\")\n\n服务端(brokers)和客户端(producer、consumer)之间通信通过 **TCP协议** 来完成。\n\n# 二、kafka基本使用\n\n## 1.安装前的环境准备\n\n* 安装jdk\n* 安装zk\n* 官网下载kafka的压缩包:http://kafka.apache.org/downloads\n* 解压缩至如下路径\n```shell\n/usr/local/kafka/\n```\n\n* 修改配置文件：/usr/local/kafka/kafka2.11-2.4/config/server.properties\n```shell\n#broker.id属性在kafka集群中必须要是唯一\nbroker.id= 0\n#kafka部署的机器ip和提供服务的端口号\nlisteners=PLAINTEXT://192.168.65.60:9092\n#kafka的消息存储文件\nlog.dir=/usr/local/data/kafka-logs\n#kafka连接zookeeper的地址\nzookeeper.connect= 192.168.65.60:2181\n```\n## 2.启动kafka服务器\n\n进入到bin目录下。使用命令来启动\n```shell\n./kafka-server-start.sh -daemon../config/server.properties\n```\n验证是否启动成功：\n\n进入到zk中的节点看id是 0 的broker有没有存在（上线）\n\n```shell\nls /brokers/ids/\n```\n**server.properties核心配置详解：**\n\nProperty|Default|Description\n--|:--|:--\nbroker.id|0|每个broker都可以⽤⼀个唯⼀的⾮负整数id进⾏标识；这个id可以作为broker的“名字”，你可以选择任意你喜欢的数字作为id，只要id是唯⼀的即可。\nlog.dirs|/tmp/kafka-logs|kafka存放数据的路径。这个路径并不是唯⼀的，可以是多个，路径之间只需要使⽤逗号分隔即可；每当创建新partition时，都会选择在包含最少partitions的路径下进⾏。\nlisteners|PLAINTEXT://192.168.65.60:9092|server接受客户端连接的端⼝，ip配置kafka本机ip即可\nzookeeper.connect|localhost:2181|zooKeeper连接字符串的格式为：hostname:port，此处hostname和port分别是ZooKeeper集群中某个节点的host和port；zookeeper如果是集群，连接⽅式为hostname1:port1, hostname2:port2,hostname3:port3\nlog.retention.hours|168|每个⽇志⽂件删除之前保存的时间。默认数据保存时间对所有topic都⼀样。\nnum.partitions|1|创建topic的默认分区数\ndefault.replication.factor|1|⾃动创建topic的默认副本数量，建议设置为⼤于等于2\nmin.insync.replicas|1|当producer设置acks为-1时，min.insync.replicas指定replicas的最⼩数⽬（必须确认每⼀个repica的写数据都是成功的），如果这个数⽬没有达到，producer发送消息会产⽣异常\ndelete.topic.enable|false|是否允许删除主题\n\n## 3.创建主题topic\n\n>topic是什么概念？topic可以实现消息的分类，不同消费者订阅不同的topic。\n\n![输入图片说明](Kafka/QQ截图20220110122844.png \"QQ截图20201229183512.png\")\n\n执行以下命令创建名为“test”的topic，这个topic只有一个partition，并且备份因子也设置为1\n```shell\n./kafka-topics.sh --create --zookeeper 172.16.253.35:2181 --replication-factor 1 --partitions 1 --topic test\n```\n查看当前kafka内有哪些topic\n```shell\n./kafka-topics.sh --list --zookeeper 172.16.253.35:2181\n```\n## 4.发送消息\n\n>kafka自带了一个producer命令客户端，可以从本地文件中读取内容，或者我们也可以以命令行中直接输入内容，并将这些内容以消息的形式发送到kafka集群中。在默认情况下，每一个行会被当做成一个独立的消息。使用kafka的发送消息的客户端，指定发送到的kafka服务器地址和topic\n\n```shell\n./kafka-console-producer.sh --broker-list 172.16.253.38:9092 --topic test\n```\n## 5.消费消息\n\n对于consumer，kafka同样也携带了一个命令行客户端，会将获取到内容在命令中进行输\n出， **默认是消费最新的消息** 。使用kafka的消费者消息的客户端，从指定kafka服务器的指定\ntopic中消费消息\n\n方式一：从最后一条消息的偏移量+1开始消费\n```shell\n./kafka-console-consumer.sh --bootstrap-server 172.16.253.38:9092 --topic test\n```\n方式二：从头开始消费\n```shell\n./kafka-console-consumer.sh --bootstrap-server 172.16.253.38:9092 --from-beginning --topic test\n```\n\n### 几个注意点：\n\n* 消息会被存储\n* 消息是顺序存储\n* 消息是有偏移量的\n* 消费时可以指明偏移量进行消费\n\n# 三、Kafka中的关键细节\n\n## 1.消息的顺序存储\n\n>消息的发送方会把消息发送到broker中，broker会存储消息，消息是按照发送的顺序进行存储。因此消费者在消费消息时可以指明主题中消息的偏移量。默认情况下，是从最后一个消息的下一个偏移量开始消费。\n\n## 2. 单播消息的实现\n\n>单播消息：一个消费组里 只会有一个消费者能消费到某一个topic中的消息。于是可以创建多个消费者，这些消费者在同一个消费组中。\n```shell\n./kafka-console-consumer.sh --bootstrap-server 10.31.167.10:9092 --consumer-property group.id=testGroup --topic test\n```\n## 3.多播消息的实现\n\n### 在一些业务场景中需要让一条消息被多个消费者消费，那么就可以使用多播模式。\n\nkafka实现多播，只需要让不同的消费者处于不同的消费组即可。\n\n```shell\n./kafka-console-consumer.sh --bootstrap-server 10.31.167.10:9092 --consumer-property group.id=testGroup1 --topic test\n\n./kafka-console-consumer.sh --bootstrap-server 10.31.167.10:9092 --consumer-property group.id=testGroup2 --topic test\n```\n## 4.查看消费组及信息\n``` shell\n# 查看当前主题下有哪些消费组\n./kafka-consumer-groups.sh --bootstrap-server 10.31.167.10:9092 --list\n# 查看消费组中的具体信息：比如当前偏移量、最后一条消息的偏移量、堆积的消息数量\n./kafka-consumer-groups.sh --bootstrap-server 172.16.253.38:9092 --describe --group testGroup\n```\n![输入图片说明](Kafka/QQ截图20220110125233.png \"QQ截图20201229183512.png\")\n* Currennt-offset: 当前消费组的已消费偏移量\n* Log-end-offset: 主题对应分区消息的结束偏移量(HW)\n* Lag: 当前消费组未消费的消息数\n\n# 四、主题、分区的概念\n\n## 1.主题Topic\n\n?主题Topic可以理解成是一个类别的名称。\n\n## 2.partition分区\n![输入图片说明](Kafka/QQ截图20220110125413.png \"QQ截图20201229183512.png\")\n\n>一个主题中的消息量是非常大的，因此可以通过分区的设置，来分布式存储这些消息。比如一个topic创建了 3 个分区。那么topic中的消息就会分别存放在这三个分区中。\n\n### 为一个主题创建多个分区\n```shell\n./kafka-topics.sh --create --zookeeper localhost:2181 --partitions 2 --topic test1\n```\n**可以通过这样的命令查看topic的分区信息**\n```shell\n./kafka-topics.sh --describe --zookeeper localhost:2181 --topic test1\n```\n### 分区的作用：\n\n* 可以分布式存储\n* 可以并行写\n\n实际上是存在data/kafka-logs/test-0 和 test-1中的0000000.log文件中\n\n小细节：\n\n>定期将自己消费分区的offset提交给kafka内部topic：__consumer_offsets，提交过去的\n时候，key是consumerGroupId+topic+分区号，value就是当前offset的值，kafka会定\n期清理topic里的消息，最后就保留最新的那条数据\n因为__consumer_offsets可能会接收高并发的请求，kafka默认给其分配 50 个分区(可以\n通过offsets.topic.num.partitions设置)，这样可以通过加机器的方式抗大并发。\n通过如下公式可以选出consumer消费的offset要提交到__consumer_offsets的哪个分区\n公式：hash(consumerGroupId) % __consumer_offsets主题的分区数\n\n# 五、Kafka集群及副本的概念\n\n## 1.搭建kafka集群， 3 个broker\n\n准备 3 个server.properties文件\n\n每个文件中的这些内容要调整\n\n* server.properties\n```shell\nbroker.id= 0\nlisteners=PLAINTEXT://192.168.65.60:\nlog.dir=/usr/local/data/kafka-logs\n```\n* server1.properties\n```shell\nbroker.id= 1\nlisteners=PLAINTEXT://192.168.65.60:\nlog.dir=/usr/local/data/kafka-logs-\n```\n* server2.properties\n```shell\nbroker.id= 2\nlisteners=PLAINTEXT://192.168.65.60:\nlog.dir=/usr/local/data/kafka-logs-\n```\n### 使用如下命令来启动 3 台服务器\n\n```shell\n./kafka-server-start.sh -daemon../config/server0.properties\n./kafka-server-start.sh -daemon../config/server1.properties\n./kafka-server-start.sh -daemon../config/server2.properties\n```\n\n搭建完后通过查看zk中的/brokers/ids 看是否启动成功\n\n## 2.副本的概念\n\n>副本是对分区的备份。在集群中，不同的副本会被部署在不同的broker上。下面例子：创建 1个主题， 2 个分区、 3 个副本。\n\n```shell\n./kafka-topics.sh --create --zookeeper 172.16.253.35:2181 --replication-factor 3 --partitions 2 --topic my-replicated-topic\n```\n![输入图片说明](Kafka/QQ截图20220110133849.png \"QQ截图20201229183512.png\")\n\n通过查看主题信息，其中的关键数据：\n\n* replicas：当前副本存在的broker节点\n* leader：副本里的概念\n    * 每个partition都有一个broker作为leader。\n    * 消息发送方要把消息发给哪个broker？就看副本的leader是在哪个broker上面。副本里的leader专⻔用来接收消息。\n    * 接收到消息，其他follower通过poll的方式来同步数据。\n* follower：leader处理所有针对这个partition的读写请求，而follower被动复制leader，不提供读写（主要是为了保证多副本数据与消费的一致性），如果leader所在的broker挂掉，那么就会进行新leader的选举，至于怎么选，在之后的controller的概念中介绍。\n\n通过kill掉leader后再查看主题情况\n\n```shell\n# kill掉leader\nps -aux | grep server.properties\nkill 17631\n# 查看topic情况\n./kafka-topics.sh --describe --zookeeper 172.16.253.35:2181 --topic my-replicated-topic\n```\n\nisr：\n可以同步的broker节点和已同步的broker节点，存放在isr集合中。\n\n## 3.broker、主题、分区、副本\n\n* kafka集群中由多个broker组成\n* 一个broker中存放一个topic的不同partition——副本\n\n![输入图片说明](Kafka/QQ截图20220110134554.png \"QQ截图20201229183512.png\")\n\n## 4.kafka集群消息的发送\n```shell\n./kafka-console-producer.sh --broker-list 172.16.253.38:9092,172.16.253.38:9093,172.16.253.38:9094 --topic my-replicated-topic\n```\n\n## 5.kafka集群消息的消费\n```shell\n./kafka-console-consumer.sh --bootstrap-server 172.16.253.38:9092,172.16.253.38:9093,172.16.253.38:9094 --from-beginning --topic my-replicated-topic\n```\n## 6.关于分区消费组消费者的细节\n\n![输入图片说明](Kafka/QQ截图20220110134734.png \"QQ截图20201229183512.png\")\n\n>图中Kafka集群有两个broker，每个broker中有多个partition。一个partition只能被一个消费组里的某一个消费者消费，从而保证消费顺序。Kafka只在partition的范围内保证消息消费的局部顺序性，不能在同一个topic中的多个partition中保证总的消费顺序性。一个消费者可以消费多个partition。\n\n`消费组中消费者的数量不能比一个topic中的partition数量多，否则多出来的消费者消费不到消息。`\n\n# 六、Kafka的Java客户端-生产者\n\n## 1.引入依赖\n```xml\n<dependency>\n    <groupId>org.apache.kafka</groupId>\n    <artifactId>kafka-clients</artifactId>\n    <version>2.4.1</version>\n</dependency>\n```\n## 2.生产者发送消息的基本实现\n\n```java\n#### //消息的发送方\npublic class MyProducer {\n\nprivate final static String TOPIC_NAME = \"my-replicated-topic\";\n\npublic static void main(String[] args) throws ExecutionException,InterruptedException {\nProperties props = new Properties();\nprops.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG,\"10.31.167.10:9092,10.31.167.10:9093,10.31.167.10:9094\");\n//把发送的key从字符串序列化为字节数组\nprops.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG,StringSerializer.class.getName());\n//把发送消息value从字符串序列化为字节数组\nprops.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG,StringSerializer.class.getName());\n\nProducer<String, String> producer = new KafkaProducer<String,String>(props);\n\nOrder order = new Order((long) i, i);\nProducerRecord<String, String> producerRecord = new ProducerRecord<String, String>(TOPIC_NAME, order.getOrderId().toString(), JSON.toJSONString(order));\nRecordMetadata metadata = producer.send(producerRecord).get();\n//=====阻塞=======\nSystem.out.println(\"同步方式发送消息结果：\" + \"topic-\" +metadata.topic() + \"|partition-\"+ metadata.partition() + \"|offset-\" +metadata.offset());\n```\n\n## 3.发送消息到指定分区上\n```java\nProducerRecord<String, String> producerRecord = new ProducerRecord<String, String>(TOPIC_NAME, 0 , order.getOrderId().toString(), JSON.toJSONString(order));\n```\n## 4.未指定分区，则会通过业务key的hash运算，算出消息往哪个分区上发\n```java\n//未指定发送分区，具体发送的分区计算公式：hash(key)%partitionNum\nProducerRecord<String, String> producerRecord = new ProducerRecord<String, String>(TOPIC_NAME, order.getOrderId().toString(), JSON.toJSONString(order));\n```\n## 5.同步发送\n生产者同步发消息，在收到kafka的ack告知发送成功之前一直处于阻塞状态\n\n```java\n//等待消息发送成功的同步阻塞方法\nRecordMetadata metadata = producer.send(producerRecord).get();\nSystem.out.println(\"同步方式发送消息结果：\" + \"topic-\" +metadata.topic() + \"|partition-\"+ metadata.partition() + \"|offset-\" +metadata.offset());\n```\n![输入图片说明](Kafka/QQ截图20220110142708.png \"QQ截图20201229183512.png\")\n## 6.异步发消息\n\n### 生产者发消息，发送完后不用等待broker给回复，直接执行下面的业务逻辑。可以提供callback，让broker异步的调用callback，告知生产者，消息发送的结果\n\n```java\n//要发送 5 条消息\nOrder order = new Order((long) i, i);\n//指定发送分区\nProducerRecord<String, String> producerRecord = new ProducerRecord<String, String>(TOPIC_NAME, 0 , order.getOrderId().toString(),JSON.toJSONString(order));\n//异步回调方式发送消息\nproducer.send(producerRecord, new Callback() {\npublic void onCompletion(RecordMetadata metadata, Exception exception) {\nif (exception != null) {\n    System.err.println(\"发送消息失败：\" +\n    exception.getStackTrace());\n}\nif (metadata != null) {\nSystem.out.println(\"异步方式发送消息结果：\" + \"topic-\" +metadata.topic() + \"|partition-\"+ metadata.partition() + \"|offset-\" + metadata.offset());\n         }\n    }\n});\n```\n\n## 7.关于生产者的ack参数配置\n\n### 在同步发消息的场景下：生产者发动broker上后，ack会有 3 种不同的选择：\n* （ 1 ）acks=0： 表示producer不需要等待任何broker确认收到消息的回复，就可以继续发送下一条消息。性能最高，但是最容易丢消息。\n* （ 2 ）acks=1： 至少要等待leader已经成功将数据写入本地log，但是不需要等待所有follower是否成功写入。就可以继续发送下一条消息。这种情况下，如果follower没有成功备份数据，而此时leader又挂掉，则消息会丢失。\n* （ 3 ）acks=-1或all： 需要等待 min.insync.replicas(默认为 1 ，推荐配置大于等于2) 这个参数配置的副本个数都成功写入日志，这种策略会保证只要有一个备份存活就不会丢失数据。这是最强的数据保证。一般除非是金融级别，或跟钱打交道的场景才会使用这种配置。\n\n### code:\n```java\nprops.put(ProducerConfig.ACKS_CONFIG, \"1\");\n```\n## 8.其他一些细节\n\n* 发送会默认会重试 3 次，每次间隔100ms\n* 发送的消息会先进入到本地缓冲区（32mb），kakfa会跑一个线程，该线程去缓冲区中取16k的数据，发送到kafka，如果到 10 毫秒数据没取满16k，也会发送一次。\n\n# 七、消费者\n\n## 1.消费者消费消息的基本实现\n```java\npublic class MyConsumer {\nprivate final static String TOPIC_NAME = \"my-replicated-topic\";\nprivate final static String CONSUMER_GROUP_NAME = \"testGroup\";\n\npublic static void main(String[] args) {\nProperties props = new Properties();\nprops.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG,\"10.31.167.10:9092,10.31.167.10:9093,10.31.167.10:9094\");\n// 消费分组名\nprops.put(ConsumerConfig.GROUP_ID_CONFIG, CONSUMER_GROUP_NAME);\nprops.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG,StringDeserializer.class.getName());\nprops.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,StringDeserializer.class.getName());\n//创建一个消费者的客户端\nKafkaConsumer<String, String> consumer = new KafkaConsumer<String,String>(props);\n// 消费者订阅主题列表\nconsumer.subscribe(Arrays.asList(TOPIC_NAME));\n\nwhile (true) {\n/*\n* poll() API 是拉取消息的⻓轮询\n*/\nConsumerRecords<String, String> records =consumer.poll(Duration.ofMillis( 1000 ));\nfor (ConsumerRecord<String, String> record : records) {\nSystem.out.printf(\"收到消息：partition = %d,offset = %d, key =%s, value = %s%n\", record.partition(),record.offset(), record.key(), record.value());\n            }\n        }\n    }\n}\n```\n\n## 2.自动提交offset\n\n* 设置自动提交参数 - 默认\n\n```java\n// 是否自动提交offset，默认就是true\nprops.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, \"true\");\n// 自动提交offset的间隔时间\nprops.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG, \"1000\");\n```\n\n消费者poll到消息后默认情况下，会自动向broker的_consumer_offsets主题提交当前主题-分区消费的偏移量。\n\n自动提交会丢消息： 因为如果消费者还没消费完poll下来的消息就自动提交了偏移量，那么此 时消费者挂了，于是下一个消费者会从已提交的offset的下一个位置开始消费消息。之前未被消费的消息就丢失掉了。\n\n## 3.手动提交offset\n\n* 设置手动提交参数\n\n```java\nprops.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, \"false\");\n```\n### 在消费完消息后进行手动提交\n\n* 手动同步提交\n```java\nif (records.count() > 0 ) {\n// 手动同步提交offset，当前线程会阻塞直到offset提交成功\n// 一般使用同步提交，因为提交之后一般也没有什么逻辑代码了\nconsumer.commitSync();\n}\n```\n* 手动异步提交\n```java\nif (records.count() > 0 ) {\n// 手动异步提交offset，当前线程提交offset不会阻塞，可以继续处理后面的程序逻辑\nconsumer.commitAsync(new OffsetCommitCallback() {\n@Override\npublic void onComplete(Map<TopicPartition, OffsetAndMetadata>offsets, Exception exception) {\n            if (exception != null) {\n                System.err.println(\"Commit failed for \" + offsets);\n                System.err.println(\"Commit failed exception: \" +exception.getStackTrace());\n            }\n         }\n    });\n}\n```\n\n## 4.消费者poll消息的过程\n\n* 消费者建立了与broker之间的⻓连接，开始poll消息。\n* 默认一次poll 500条消息\n\n\n```java\nprops.put(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 500 );\n```\n\n可以根据消费速度的快慢来设置，因为如果两次poll的时间如果超出了30s的时间间隔，kafka会认为其消费能力过弱，将其踢出消费组。将分区分配给其他消费者。\n\n可以通过这个值进行设置：\n```java\nprops.put(ConsumerConfig.MAX_POLL_INTERVAL_MS_CONFIG, 30 * 1000 );\n```\n\n如果每隔1s内没有poll到任何消息，则继续去poll消息，循环往复，直到poll到消息。如果超出了1s，则此次⻓轮询结束。\n\n```java\nConsumerRecords<String, String> records =consumer.poll(Duration.ofMillis( 1000 ));\n```\n消费者发送心跳的时间间隔\n\n```java\nprops.put(ConsumerConfig.HEARTBEAT_INTERVAL_MS_CONFIG, 1000 );\n```\n\nkafka如果超过 10 秒没有收到消费者的心跳，则会把消费者踢出消费组，进行rebalance，把分区分配给其他消费者。\n\n```java\nprops.put(ConsumerConfig.SESSION_TIMEOUT_MS_CONFIG, 10 * 1000 );\n```\n## 5.指定分区消费\n```java\nconsumer.assign(Arrays.asList(new TopicPartition(TOPIC_NAME, 0 )));\n```\n## 6.消息回溯消费\n```java\nconsumer.assign(Arrays.asList(new TopicPartition(TOPIC_NAME, 0 )));\nconsumer.seekToBeginning(Arrays.asList(new TopicPartition(TOPIC_NAME,0 )));\n```\n## 7.指定offset消费\n```java\nconsumer.assign(Arrays.asList(new TopicPartition(TOPIC_NAME, 0 )));\nconsumer.seek(new TopicPartition(TOPIC_NAME, 0 ), 10 );\n```\n## 8.从指定时间点消费\n\n```java\nList<PartitionInfo> topicPartitions =consumer.partitionsFor(TOPIC_NAME);\n//从 1 小时前开始消费\nlong fetchDataTime = new Date().getTime() - 1000 * 60 * 60 ;\nMap<TopicPartition, Long> map = new HashMap<>();\nfor (PartitionInfo par : topicPartitions) {\n    map.put(new TopicPartition(TOPIC_NAME, par.partition()),fetchDataTime);\n}\nMap<TopicPartition, OffsetAndTimestamp> parMap =consumer.offsetsForTimes(map);\nfor (Map.Entry<TopicPartition, OffsetAndTimestamp> entry :parMap.entrySet()) {\n    TopicPartition key = entry.getKey();\n    OffsetAndTimestamp value = entry.getValue();\n    if (key == null || value == null) continue;\n    Long offset = value.offset();\n    System.out.println(\"partition-\" + key.partition() +\"|offset-\" + offset);\n    System.out.println();\n    //根据消费里的timestamp确定offset\n    if (value != null) {\n        consumer.assign(Arrays.asList(key));\n        consumer.seek(key, offset);\n    }\n}\n```\n\n## 9.新消费组的消费偏移量\n\n> 当消费主题的是一个新的消费组，或者指定offset的消费方式，offset不存在，那么应该如何消费?\n\n* latest(默认) ：只消费自己启动之后发送到主题的消息\n* earliest：第一次从头开始消费，以后按照消费offset记录继续消费，这个需要区别于consumer.seekToBeginning(每次都从头开始消费)\n```shell\nprops.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n```\n# 八 、Springboot中使用Kafka\n\n## 1.引入依赖\n```xml\n<dependency>\n    <groupId>org.springframework.kafka</groupId>\n    <artifactId>spring-kafka</artifactId>\n</dependency>\n```\n\n## 2.配置文件\n\n```yml\nserver:\n    port: 8080\nspring:\n    kafka:\n        bootstrap-servers: 172.16.253.21: 9093\n        producer: # 生产者\n            retries: 3 # 设置大于 0 的值，则客户端会将发送失败的记录重新发送\n            batch-size: 16384\n            buffer-memory: 33554432\n            acks: 1\n            # 指定消息key和消息体的编解码方式\n            key-serializer: org.apache.kafka.common.serialization.StringSerializer\n            value-serializer: org.apache.kafka.common.serialization.StringSerializer\n        consumer:\n            group-id: default-group\n            enable-auto-commit: false\n            auto-offset-reset: earliest\n            key-deserializer: org.apache.kafka.common.serialization.StringDeserializer\n            value-deserializer: org.apache.kafka.common.serialization.StringDeserializer\n            max-poll-records: 500\n        listener:\n        # 当每一条记录被消费者监听器（ListenerConsumer）处理之后提交\n        # RECORD\n        # 当每一批poll()的数据被消费者监听器（ListenerConsumer）处理之后提交\n        # BATCH\n        # 当每一批poll()的数据被消费者监听器（ListenerConsumer）处理之后，距离上次提交时间大于TIME时提交\n        # TIME\n        # 当每一批poll()的数据被消费者监听器（ListenerConsumer）处理之后，被处理record数量大于等于COUNT时提交\n        # COUNT\n        # TIME | COUNT　有一个条件满足时提交\n        # COUNT_TIME\n        # 当每一批poll()的数据被消费者监听器（ListenerConsumer）处理之后, 手动调用Acknowledgment.acknowledge()后提交\n        # MANUAL\n        # 手动调用Acknowledgment.acknowledge()后立即提交，一般使用这种\n        # MANUAL_IMMEDIATE\n            ack-mode: MANUAL_IMMEDIATE\n    redis:\n        host: 172.16.253.21\n```\n\n## 3.消息生产者\n* 发送消息到指定topic\n\n```java\n@RestController\npublic class KafkaController {\n    private final static String TOPIC_NAME = \"my-replicated-topic\";\n    @Autowired\n    private KafkaTemplate<String, String> kafkaTemplate;\n    @RequestMapping(\"/send\")\n    public void send() {\n        kafkaTemplate.send(TOPIC_NAME, 0 , \"key\", \"this is a msg\");\n    }\n}\n```\n\n## 4.消息消费者\n* 设置消费组，消费指定topic\n```java\n@KafkaListener(topics = \"my-replicated-topic\",groupId = \"MyGroup1\")\npublic void listenGroup(ConsumerRecord<String, String> record,Acknowledgment ack) {\n    String value = record.value();\n    System.out.println(value);\n    System.out.println(record);\n    //手动提交offset\n    ack.acknowledge();\n}\n```\n\n* 设置消费组、多topic、指定分区、指定偏移量消费及设置消费者个数。\n\n```java\n@KafkaListener(groupId = \"testGroup\", topicPartitions = {\n@TopicPartition(topic = \"topic1\", partitions = {\"0\", \"1\"}),\n@TopicPartition(topic = \"topic2\", partitions = \"0\",partitionOffsets = @PartitionOffset(partition = \"1\",initialOffset = \"100\"))}\n,concurrency = \"3\")//concurrency就是同组下的消费者个数，就是并发消费数，建议小于等于分区总数\npublic void listenGroup(ConsumerRecord<String, String> record,Acknowledgment ack) {\n    String value = record.value();\n    System.out.println(value);\n    System.out.println(record);\n    //手动提交offset\n    ack.acknowledge();\n}\n```\n\n# 九、Kafka集群Controller、Rebalance和HW\n\n## 1.Controller\n\n* Kafka集群中的broker在zk中创建临时序号节点，序号最小的节点（最先创建的节点）将作为集群的controller，负责管理整个集群中的所有分区和副本的状态：\n    * 当某个分区的leader副本出现故障时，由控制器负责为该分区选举新的leader副本。\n    * 当检测到某个分区的ISR集合发生变化时，由控制器负责通知所有broker更新其元数据信息。\n    * 当使用kafka-topics.sh脚本为某个topic增加分区数量时，同样还是由控制器负责让新分区被其他节点感知到。\n\n## 2.Rebalance机制\n\n前提是：消费者没有指明分区消费。当消费组里消费者和分区的关系发生变化，那么就会触发rebalance机制。\n\n这个机制会重新调整消费者消费哪个分区。\n\n在触发rebalance机制之前，消费者消费哪个分区有三种策略：\n\n* range：通过公示来计算某个消费者消费哪个分区\n* 轮询：大家轮着消费\n* sticky：在触发了rebalance后，在消费者消费的原分区不变的基础上进行调整。\n\n## 3.HW和LEO\n\n>HW俗称高水位，HighWatermark的缩写，取一个partition对应的ISR中最小的LEO(log-end-offset)作为HW，consumer最多只能消费到HW所在的位置。另外每个replica都有HW,leader和follower各自负责更新自己的HW的状态。对于leader新写入的消息，consumer不能立刻消费，leader会等待该消息被所有ISR中的replicas同步后更新HW，此时消息才能被consumer消费。这样就保证了如果leader所在的broker失效，该消息仍然可以从新选举的leader中获取。\n\n# 十、Kafka线上问题优化\n\n## 1.如何防止消息丢失\n\n* 发送方： ack是 1 或者-1/all 可以防止消息丢失，如果要做到99.9999%，ack设成all，把min.insync.replicas配置成分区备份数\n* 消费方：把自动提交改为手动提交。\n\n## 2.如何防止消息的重复消费\n\n>一条消息被消费者消费多次。如果为了消息的不重复消费，而把生产端的重试机制关闭、消费端的手动提交改成自动提交，这样反而会出现消息丢失，那么可以直接在防治消息丢失的手段上再加上消费消息时的幂等性保证，就能解决消息的重复消费问题。\n\n### 幂等性如何保证：\n\n* mysql 插入业务id作为主键，主键是唯一的，所以一次只能插入一条\n* 使用redis或zk的分布式锁（主流的方案）\n\n## 3.如何做到顺序消费RocketMQ\n\n* 发送方：在发送时将ack不能设置 0 ，关闭重试，使用同步发送，等到发送成功再发送下一条。确保消息是顺序发送的。\n* 接收方：消息是发送到一个分区中，只能有一个消费组的消费者来接收消息。因此，kafka的顺序消费会牺牲掉性能。\n\n## 4.解决消息积压问题\n\n>消息积压会导致很多问题，比如磁盘被打满、生产端发消息导致kafka性能过慢，就容易出现服务雪崩，就需要有相应的手段：\n\n* 方案一：在一个消费者中启动多个线程，让多个线程同时消费。——提升一个消费者的消费能力（增加分区增加消费者）。\n* 方案二：如果方案一还不够的话，这个时候可以启动多个消费者，多个消费者部署在不同的服务器上。其实多个消费者部署在同一服务器上也可以提高消费能力——充分利用服务器的cpu资源。\n* 方案三：让一个消费者去把收到的消息往另外一个topic上发，另一个topic设置多个分区和多个消费者 ，进行具体的业务消费。\n\n## 5.延迟队列\n\n延迟队列的应用场景：在订单创建成功后如果超过 30 分钟没有付款，则需要取消订单，此时可用延时队列来实现\n\n* 创建多个topic，每个topic表示延时的间隔\n    * topic_5s: 延时5s执行的队列\n    * topic_1m: 延时 1 分钟执行的队列\n    * topic_30m: 延时 30 分钟执行的队列\n\n* 消息发送者发送消息到相应的topic，并带上消息的发送时间\n* 消费者订阅相应的topic，消费时轮询消费整个topic中的消息\n    * 如果消息的发送时间，和消费的当前时间超过预设的值，比如 30 分钟\n    * 如果消息的发送时间，和消费的当前时间没有超过预设的值，则不消费当前的offset及之后的offset的所有消息都消费\n    * 下次继续消费该offset处的消息，判断时间是否已满足预设值\n\n# 十一、Kafka-eagle监控平台\n\n## 安装Kafka-eagle\n\n### 官网下载压缩包\n\nhttp://www.kafka-eagle.org/\n\n* 安装jdk\n* 解压缩后修改配置文件 system-config.properties\n\n```shell\n# 配置zk  去掉cluster2\nefak.zk.cluster.alias=cluster1\ncluster1.zk.list=172.16.253.35:2181\n# cluster2.zk.list=xdn10:2181,xdn11:2181,xdn12:2181\n\n# 配置mysql\nkafka.eagle.driver=com.mysql.cj.jdbc.Driver\nkafka.eagle.url=jdbc:mysql://172.16.253.22:3306/ke?useUnicode=true&characterEncoding=UTF-8&zeroDateTimeBehavior=convertToNull\nkafka.eagle.username=root\nkafka.eagle.password= 123456\n```\n\n* 修改/etc/profile\n```\nexport  JAVA_HOME=/usr/local/jdk/jdk1.8.0_191\nCLASSPATH=.:$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar\nexport KE_HOME=/home/aisys/efak-web-2.0.9\nexport PATH=$PATH:$KE_HOME/bin:$JAVA_HOME/bin\n```\n\n* 刷新配置\n```\nsource /etc/profile\n```\n\n* 进入到bin目录，为ke.sh增加可执行的权限\n\n```shell\nchmod +x ke.sh\n```\n\n* 启动kafka-eagle\n```\n./ke.sh start\n```\n\n","source":"_posts/Kafka.md","raw":"---\ntitle: Kafka\ndate: 2022-07-10 15:41:22\ntags: \n - mq\n - 消息中间件\ncategories: 消息中间件\ncover: http://rebp38war.bkt.clouddn.com/img/6f79ddbaf6bc4c2d99adc571273d577f.jpeg\n---\n# 消息队列的流派\n\n### 什么是 MQ\n\n>Message Queue（MQ），消息队列中间件。很多人都说：MQ 通过将消息的发送和接收分离来实现应用程序的异步和解偶，这个给人的直觉是——MQ 是异步的，用来解耦的，但是这个只是 MQ 的效果而不是目的。MQ 真正的目的是为了通讯，屏蔽底层复杂的通讯协议，定义了一套应用层的、更加简单的通讯协议。一个分布式系统中两个模块之间通讯要么是HTTP，要么是自己开发的（rpc） TCP，但是这两种协议其实都是原始的协议。HTTP 协议很难实现两端通讯——模块 A 可以调用 B，B 也可以主动调用 A，如果要做到这个两端都要背上WebServer，而且还不支持⻓连接（HTTP 2.0 的库根本找不到）。TCP 就更加原始了，粘包、心跳、私有的协议，想一想头皮就发麻。MQ 所要做的就是在这些协议之上构建一个简单的“协议”——生产者/消费者模型。MQ 带给我的“协议”不是具体的通讯协议，而是更高层次通讯模型。它定义了两个对象——发送数据的叫生产者；接收数据的叫消费者， 提供一个SDK 让我们可以定义自己的生产者和消费者实现消息通讯而无视底层通讯协议\n\n### 有 Broker 的 MQ\n\n>这个流派通常有一台服务器作为 Broker，所有的消息都通过它中转。生产者把消息发送给它就结束自己的任务了，Broker 则把消息主动推送给消费者（或者消费者主动轮询）\n\n### 重 Topic\n\n>kafka、JMS（ActiveMQ）就属于这个流派，生产者会发送 key 和数据到 Broker，由 Broker比较 key 之后决定给哪个消费者。这种模式是我们最常⻅的模式，是我们对 MQ 最多的印象。在这种模式下一个 topic 往往是一个比较大的概念，甚至一个系统中就可能只有一个topic，topic 某种意义上就是 queue，生产者发送 key 相当于说：“hi，把数据放到 key 的队列中”\n\n>如上图所示，Broker 定义了三个队列，key1，key2，key3，生产者发送数据的时候会发送key1 和 data，Broker 在推送数据的时候则推送 data（也可能把 key 带上）。\n\n>虽然架构一样但是 kafka 的性能要比 jms 的性能不知道高到多少倍，所以基本这种类型的MQ 只有 kafka 一种备选方案。如果你需要一条暴力的数据流（在乎性能而非灵活性）那么kafka 是最好的选择\n\n### 轻 Topic\n\n>这种的代表是 RabbitMQ（或者说是 AMQP）。生产者发送 key 和数据，消费者定义订阅的队列，Broker 收到数据之后会通过一定的逻辑计算出 key 对应的队列，然后把数据交给队列\n\n>这种模式下解耦了 key 和 queue，在这种架构中 queue 是非常轻量级的（在 RabbitMQ 中它的上限取决于你的内存），消费者关心的只是自己的 queue；生产者不必关心数据最终给谁只要指定 key 就行了，中间的那层映射在 AMQP 中叫 exchange（交换机）。\n\nAMQP 中有四种 exchange\n\n* Direct exchange：key 就等于 queue\n* Fanout exchange：无视 key，给所有的 queue 都来一份\n* Topic exchange：key 可以用“宽字符”模糊匹配 queue\n* Headers exchange：无视 key，通过查看消息的头部元数据来决定发给那个\n* queue（AMQP 头部元数据非常丰富而且可以自定义）\n\n这种结构的架构给通讯带来了很大的灵活性，我们能想到的通讯方式都可以用这四种exchange 表达出来。如果你需要一个企业数据总线（在乎灵活性）那么 RabbitMQ 绝对的值得一用\n\n### 无 Broker 的 MQ\n\n>无 Broker 的 MQ 的代表是 ZeroMQ。该作者非常睿智，他非常敏锐的意识到——MQ 是更高级的 Socket，它是解决通讯问题的。所以 ZeroMQ 被设计成了一个“库”而不是一个中间件，这种实现也可以达到——没有 Broker 的目的\n\n>节点之间通讯的消息都是发送到彼此的队列中，每个节点都既是生产者又是消费者。ZeroMQ做的事情就是封装出一套类似于 Socket 的 API 可以完成发送数据，读取数据\n\n>ZeroMQ 其实就是一个跨语言的、重量级的 Actor 模型邮箱库。你可以把自己的程序想象成一个 Actor，ZeroMQ 就是提供邮箱功能的库；ZeroMQ 可以实现同一台机器的 RPC 通讯也可以实现不同机器的 TCP、UDP 通讯，如果你需要一个强大的、灵活、野蛮的通讯能力，别犹豫 ZeroMQ\n\n# 一、Kafka介绍\n\n>Kafka是最初由Linkedin公司开发，是一个分布式、支持分区的（partition）、多副本的\n（replica），基于zookeeper协调的分布式消息系统，它的最大的特性就是可以实时的处理\n大量数据以满足各种需求场景：比如基于hadoop的批处理系统、低延迟的实时系统、\nStorm/Spark流式处理引擎，web/nginx日志、访问日志，消息服务等等，用scala语言编\n写，Linkedin于 2010 年贡献给了Apache基金会并成为顶级开源 项目。\n\n## 1.Kafka的使用场景\n\n>日志收集：一个公司可以用Kafka收集各种服务的log，通过kafka以统一接口服务的方式\n开放给各种consumer，例如hadoop、Hbase、Solr等。\n消息系统：解耦和生产者和消费者、缓存消息等。\n用户活动跟踪：Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网⻚、\n搜索、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过\n订阅这些topic来做实时的监控分析，或者装载到hadoop、数据仓库中做离线分析和挖\n掘。\n运营指标：Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产\n各种操作的集中反馈，比如报警和报告。\n\n## 2.Kafka基本概念\n\n>kafka是一个分布式的，分区的消息(官方称之为commit log)服务。它提供一个消息系统应该\n具备的功能，但是确有着独特的设计。可以这样来说，Kafka借鉴了JMS规范的思想，但是确\n并 `没有完全遵循JMS规范。`\n\n首先，让我们来看一下基础的消息(Message)相关术语：\n\n\n名称|解释\n--|:--:\nBroker|消息中间件处理节点，⼀个Kafka节点就是⼀个broker，⼀个或者多个Broker可以组成⼀个Kafka集群\nTopic|Kafka根据topic对消息进⾏归类，发布到Kafka集群的每条消息都需要指定⼀个topic\nProducer|消息⽣产者，向Broker发送消息的客户端\nConsumer|消息消费者，从Broker读取消息的客户端\nConsumerGroup|每个Consumer属于⼀个特定的Consumer Group，⼀条消息可以被多个不同的Consumer Group消费，但是⼀个Consumer Group中只能有⼀个Consumer能够消费该消息\nPartition|物理上的概念，⼀个topic可以分为多个partition，每个partition内部消息是有序的\n\n因此，从一个较高的层面上来看，producer通过网络发送消息到Kafka集群，然后consumer\n来进行消费，如下图：\n![输入图片说明](kafka/QQ截图20220110112502.png \"QQ截图20201229183512.png\")\n\n服务端(brokers)和客户端(producer、consumer)之间通信通过 **TCP协议** 来完成。\n\n# 二、kafka基本使用\n\n## 1.安装前的环境准备\n\n* 安装jdk\n* 安装zk\n* 官网下载kafka的压缩包:http://kafka.apache.org/downloads\n* 解压缩至如下路径\n```shell\n/usr/local/kafka/\n```\n\n* 修改配置文件：/usr/local/kafka/kafka2.11-2.4/config/server.properties\n```shell\n#broker.id属性在kafka集群中必须要是唯一\nbroker.id= 0\n#kafka部署的机器ip和提供服务的端口号\nlisteners=PLAINTEXT://192.168.65.60:9092\n#kafka的消息存储文件\nlog.dir=/usr/local/data/kafka-logs\n#kafka连接zookeeper的地址\nzookeeper.connect= 192.168.65.60:2181\n```\n## 2.启动kafka服务器\n\n进入到bin目录下。使用命令来启动\n```shell\n./kafka-server-start.sh -daemon../config/server.properties\n```\n验证是否启动成功：\n\n进入到zk中的节点看id是 0 的broker有没有存在（上线）\n\n```shell\nls /brokers/ids/\n```\n**server.properties核心配置详解：**\n\nProperty|Default|Description\n--|:--|:--\nbroker.id|0|每个broker都可以⽤⼀个唯⼀的⾮负整数id进⾏标识；这个id可以作为broker的“名字”，你可以选择任意你喜欢的数字作为id，只要id是唯⼀的即可。\nlog.dirs|/tmp/kafka-logs|kafka存放数据的路径。这个路径并不是唯⼀的，可以是多个，路径之间只需要使⽤逗号分隔即可；每当创建新partition时，都会选择在包含最少partitions的路径下进⾏。\nlisteners|PLAINTEXT://192.168.65.60:9092|server接受客户端连接的端⼝，ip配置kafka本机ip即可\nzookeeper.connect|localhost:2181|zooKeeper连接字符串的格式为：hostname:port，此处hostname和port分别是ZooKeeper集群中某个节点的host和port；zookeeper如果是集群，连接⽅式为hostname1:port1, hostname2:port2,hostname3:port3\nlog.retention.hours|168|每个⽇志⽂件删除之前保存的时间。默认数据保存时间对所有topic都⼀样。\nnum.partitions|1|创建topic的默认分区数\ndefault.replication.factor|1|⾃动创建topic的默认副本数量，建议设置为⼤于等于2\nmin.insync.replicas|1|当producer设置acks为-1时，min.insync.replicas指定replicas的最⼩数⽬（必须确认每⼀个repica的写数据都是成功的），如果这个数⽬没有达到，producer发送消息会产⽣异常\ndelete.topic.enable|false|是否允许删除主题\n\n## 3.创建主题topic\n\n>topic是什么概念？topic可以实现消息的分类，不同消费者订阅不同的topic。\n\n![输入图片说明](Kafka/QQ截图20220110122844.png \"QQ截图20201229183512.png\")\n\n执行以下命令创建名为“test”的topic，这个topic只有一个partition，并且备份因子也设置为1\n```shell\n./kafka-topics.sh --create --zookeeper 172.16.253.35:2181 --replication-factor 1 --partitions 1 --topic test\n```\n查看当前kafka内有哪些topic\n```shell\n./kafka-topics.sh --list --zookeeper 172.16.253.35:2181\n```\n## 4.发送消息\n\n>kafka自带了一个producer命令客户端，可以从本地文件中读取内容，或者我们也可以以命令行中直接输入内容，并将这些内容以消息的形式发送到kafka集群中。在默认情况下，每一个行会被当做成一个独立的消息。使用kafka的发送消息的客户端，指定发送到的kafka服务器地址和topic\n\n```shell\n./kafka-console-producer.sh --broker-list 172.16.253.38:9092 --topic test\n```\n## 5.消费消息\n\n对于consumer，kafka同样也携带了一个命令行客户端，会将获取到内容在命令中进行输\n出， **默认是消费最新的消息** 。使用kafka的消费者消息的客户端，从指定kafka服务器的指定\ntopic中消费消息\n\n方式一：从最后一条消息的偏移量+1开始消费\n```shell\n./kafka-console-consumer.sh --bootstrap-server 172.16.253.38:9092 --topic test\n```\n方式二：从头开始消费\n```shell\n./kafka-console-consumer.sh --bootstrap-server 172.16.253.38:9092 --from-beginning --topic test\n```\n\n### 几个注意点：\n\n* 消息会被存储\n* 消息是顺序存储\n* 消息是有偏移量的\n* 消费时可以指明偏移量进行消费\n\n# 三、Kafka中的关键细节\n\n## 1.消息的顺序存储\n\n>消息的发送方会把消息发送到broker中，broker会存储消息，消息是按照发送的顺序进行存储。因此消费者在消费消息时可以指明主题中消息的偏移量。默认情况下，是从最后一个消息的下一个偏移量开始消费。\n\n## 2. 单播消息的实现\n\n>单播消息：一个消费组里 只会有一个消费者能消费到某一个topic中的消息。于是可以创建多个消费者，这些消费者在同一个消费组中。\n```shell\n./kafka-console-consumer.sh --bootstrap-server 10.31.167.10:9092 --consumer-property group.id=testGroup --topic test\n```\n## 3.多播消息的实现\n\n### 在一些业务场景中需要让一条消息被多个消费者消费，那么就可以使用多播模式。\n\nkafka实现多播，只需要让不同的消费者处于不同的消费组即可。\n\n```shell\n./kafka-console-consumer.sh --bootstrap-server 10.31.167.10:9092 --consumer-property group.id=testGroup1 --topic test\n\n./kafka-console-consumer.sh --bootstrap-server 10.31.167.10:9092 --consumer-property group.id=testGroup2 --topic test\n```\n## 4.查看消费组及信息\n``` shell\n# 查看当前主题下有哪些消费组\n./kafka-consumer-groups.sh --bootstrap-server 10.31.167.10:9092 --list\n# 查看消费组中的具体信息：比如当前偏移量、最后一条消息的偏移量、堆积的消息数量\n./kafka-consumer-groups.sh --bootstrap-server 172.16.253.38:9092 --describe --group testGroup\n```\n![输入图片说明](Kafka/QQ截图20220110125233.png \"QQ截图20201229183512.png\")\n* Currennt-offset: 当前消费组的已消费偏移量\n* Log-end-offset: 主题对应分区消息的结束偏移量(HW)\n* Lag: 当前消费组未消费的消息数\n\n# 四、主题、分区的概念\n\n## 1.主题Topic\n\n?主题Topic可以理解成是一个类别的名称。\n\n## 2.partition分区\n![输入图片说明](Kafka/QQ截图20220110125413.png \"QQ截图20201229183512.png\")\n\n>一个主题中的消息量是非常大的，因此可以通过分区的设置，来分布式存储这些消息。比如一个topic创建了 3 个分区。那么topic中的消息就会分别存放在这三个分区中。\n\n### 为一个主题创建多个分区\n```shell\n./kafka-topics.sh --create --zookeeper localhost:2181 --partitions 2 --topic test1\n```\n**可以通过这样的命令查看topic的分区信息**\n```shell\n./kafka-topics.sh --describe --zookeeper localhost:2181 --topic test1\n```\n### 分区的作用：\n\n* 可以分布式存储\n* 可以并行写\n\n实际上是存在data/kafka-logs/test-0 和 test-1中的0000000.log文件中\n\n小细节：\n\n>定期将自己消费分区的offset提交给kafka内部topic：__consumer_offsets，提交过去的\n时候，key是consumerGroupId+topic+分区号，value就是当前offset的值，kafka会定\n期清理topic里的消息，最后就保留最新的那条数据\n因为__consumer_offsets可能会接收高并发的请求，kafka默认给其分配 50 个分区(可以\n通过offsets.topic.num.partitions设置)，这样可以通过加机器的方式抗大并发。\n通过如下公式可以选出consumer消费的offset要提交到__consumer_offsets的哪个分区\n公式：hash(consumerGroupId) % __consumer_offsets主题的分区数\n\n# 五、Kafka集群及副本的概念\n\n## 1.搭建kafka集群， 3 个broker\n\n准备 3 个server.properties文件\n\n每个文件中的这些内容要调整\n\n* server.properties\n```shell\nbroker.id= 0\nlisteners=PLAINTEXT://192.168.65.60:\nlog.dir=/usr/local/data/kafka-logs\n```\n* server1.properties\n```shell\nbroker.id= 1\nlisteners=PLAINTEXT://192.168.65.60:\nlog.dir=/usr/local/data/kafka-logs-\n```\n* server2.properties\n```shell\nbroker.id= 2\nlisteners=PLAINTEXT://192.168.65.60:\nlog.dir=/usr/local/data/kafka-logs-\n```\n### 使用如下命令来启动 3 台服务器\n\n```shell\n./kafka-server-start.sh -daemon../config/server0.properties\n./kafka-server-start.sh -daemon../config/server1.properties\n./kafka-server-start.sh -daemon../config/server2.properties\n```\n\n搭建完后通过查看zk中的/brokers/ids 看是否启动成功\n\n## 2.副本的概念\n\n>副本是对分区的备份。在集群中，不同的副本会被部署在不同的broker上。下面例子：创建 1个主题， 2 个分区、 3 个副本。\n\n```shell\n./kafka-topics.sh --create --zookeeper 172.16.253.35:2181 --replication-factor 3 --partitions 2 --topic my-replicated-topic\n```\n![输入图片说明](Kafka/QQ截图20220110133849.png \"QQ截图20201229183512.png\")\n\n通过查看主题信息，其中的关键数据：\n\n* replicas：当前副本存在的broker节点\n* leader：副本里的概念\n    * 每个partition都有一个broker作为leader。\n    * 消息发送方要把消息发给哪个broker？就看副本的leader是在哪个broker上面。副本里的leader专⻔用来接收消息。\n    * 接收到消息，其他follower通过poll的方式来同步数据。\n* follower：leader处理所有针对这个partition的读写请求，而follower被动复制leader，不提供读写（主要是为了保证多副本数据与消费的一致性），如果leader所在的broker挂掉，那么就会进行新leader的选举，至于怎么选，在之后的controller的概念中介绍。\n\n通过kill掉leader后再查看主题情况\n\n```shell\n# kill掉leader\nps -aux | grep server.properties\nkill 17631\n# 查看topic情况\n./kafka-topics.sh --describe --zookeeper 172.16.253.35:2181 --topic my-replicated-topic\n```\n\nisr：\n可以同步的broker节点和已同步的broker节点，存放在isr集合中。\n\n## 3.broker、主题、分区、副本\n\n* kafka集群中由多个broker组成\n* 一个broker中存放一个topic的不同partition——副本\n\n![输入图片说明](Kafka/QQ截图20220110134554.png \"QQ截图20201229183512.png\")\n\n## 4.kafka集群消息的发送\n```shell\n./kafka-console-producer.sh --broker-list 172.16.253.38:9092,172.16.253.38:9093,172.16.253.38:9094 --topic my-replicated-topic\n```\n\n## 5.kafka集群消息的消费\n```shell\n./kafka-console-consumer.sh --bootstrap-server 172.16.253.38:9092,172.16.253.38:9093,172.16.253.38:9094 --from-beginning --topic my-replicated-topic\n```\n## 6.关于分区消费组消费者的细节\n\n![输入图片说明](Kafka/QQ截图20220110134734.png \"QQ截图20201229183512.png\")\n\n>图中Kafka集群有两个broker，每个broker中有多个partition。一个partition只能被一个消费组里的某一个消费者消费，从而保证消费顺序。Kafka只在partition的范围内保证消息消费的局部顺序性，不能在同一个topic中的多个partition中保证总的消费顺序性。一个消费者可以消费多个partition。\n\n`消费组中消费者的数量不能比一个topic中的partition数量多，否则多出来的消费者消费不到消息。`\n\n# 六、Kafka的Java客户端-生产者\n\n## 1.引入依赖\n```xml\n<dependency>\n    <groupId>org.apache.kafka</groupId>\n    <artifactId>kafka-clients</artifactId>\n    <version>2.4.1</version>\n</dependency>\n```\n## 2.生产者发送消息的基本实现\n\n```java\n#### //消息的发送方\npublic class MyProducer {\n\nprivate final static String TOPIC_NAME = \"my-replicated-topic\";\n\npublic static void main(String[] args) throws ExecutionException,InterruptedException {\nProperties props = new Properties();\nprops.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG,\"10.31.167.10:9092,10.31.167.10:9093,10.31.167.10:9094\");\n//把发送的key从字符串序列化为字节数组\nprops.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG,StringSerializer.class.getName());\n//把发送消息value从字符串序列化为字节数组\nprops.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG,StringSerializer.class.getName());\n\nProducer<String, String> producer = new KafkaProducer<String,String>(props);\n\nOrder order = new Order((long) i, i);\nProducerRecord<String, String> producerRecord = new ProducerRecord<String, String>(TOPIC_NAME, order.getOrderId().toString(), JSON.toJSONString(order));\nRecordMetadata metadata = producer.send(producerRecord).get();\n//=====阻塞=======\nSystem.out.println(\"同步方式发送消息结果：\" + \"topic-\" +metadata.topic() + \"|partition-\"+ metadata.partition() + \"|offset-\" +metadata.offset());\n```\n\n## 3.发送消息到指定分区上\n```java\nProducerRecord<String, String> producerRecord = new ProducerRecord<String, String>(TOPIC_NAME, 0 , order.getOrderId().toString(), JSON.toJSONString(order));\n```\n## 4.未指定分区，则会通过业务key的hash运算，算出消息往哪个分区上发\n```java\n//未指定发送分区，具体发送的分区计算公式：hash(key)%partitionNum\nProducerRecord<String, String> producerRecord = new ProducerRecord<String, String>(TOPIC_NAME, order.getOrderId().toString(), JSON.toJSONString(order));\n```\n## 5.同步发送\n生产者同步发消息，在收到kafka的ack告知发送成功之前一直处于阻塞状态\n\n```java\n//等待消息发送成功的同步阻塞方法\nRecordMetadata metadata = producer.send(producerRecord).get();\nSystem.out.println(\"同步方式发送消息结果：\" + \"topic-\" +metadata.topic() + \"|partition-\"+ metadata.partition() + \"|offset-\" +metadata.offset());\n```\n![输入图片说明](Kafka/QQ截图20220110142708.png \"QQ截图20201229183512.png\")\n## 6.异步发消息\n\n### 生产者发消息，发送完后不用等待broker给回复，直接执行下面的业务逻辑。可以提供callback，让broker异步的调用callback，告知生产者，消息发送的结果\n\n```java\n//要发送 5 条消息\nOrder order = new Order((long) i, i);\n//指定发送分区\nProducerRecord<String, String> producerRecord = new ProducerRecord<String, String>(TOPIC_NAME, 0 , order.getOrderId().toString(),JSON.toJSONString(order));\n//异步回调方式发送消息\nproducer.send(producerRecord, new Callback() {\npublic void onCompletion(RecordMetadata metadata, Exception exception) {\nif (exception != null) {\n    System.err.println(\"发送消息失败：\" +\n    exception.getStackTrace());\n}\nif (metadata != null) {\nSystem.out.println(\"异步方式发送消息结果：\" + \"topic-\" +metadata.topic() + \"|partition-\"+ metadata.partition() + \"|offset-\" + metadata.offset());\n         }\n    }\n});\n```\n\n## 7.关于生产者的ack参数配置\n\n### 在同步发消息的场景下：生产者发动broker上后，ack会有 3 种不同的选择：\n* （ 1 ）acks=0： 表示producer不需要等待任何broker确认收到消息的回复，就可以继续发送下一条消息。性能最高，但是最容易丢消息。\n* （ 2 ）acks=1： 至少要等待leader已经成功将数据写入本地log，但是不需要等待所有follower是否成功写入。就可以继续发送下一条消息。这种情况下，如果follower没有成功备份数据，而此时leader又挂掉，则消息会丢失。\n* （ 3 ）acks=-1或all： 需要等待 min.insync.replicas(默认为 1 ，推荐配置大于等于2) 这个参数配置的副本个数都成功写入日志，这种策略会保证只要有一个备份存活就不会丢失数据。这是最强的数据保证。一般除非是金融级别，或跟钱打交道的场景才会使用这种配置。\n\n### code:\n```java\nprops.put(ProducerConfig.ACKS_CONFIG, \"1\");\n```\n## 8.其他一些细节\n\n* 发送会默认会重试 3 次，每次间隔100ms\n* 发送的消息会先进入到本地缓冲区（32mb），kakfa会跑一个线程，该线程去缓冲区中取16k的数据，发送到kafka，如果到 10 毫秒数据没取满16k，也会发送一次。\n\n# 七、消费者\n\n## 1.消费者消费消息的基本实现\n```java\npublic class MyConsumer {\nprivate final static String TOPIC_NAME = \"my-replicated-topic\";\nprivate final static String CONSUMER_GROUP_NAME = \"testGroup\";\n\npublic static void main(String[] args) {\nProperties props = new Properties();\nprops.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG,\"10.31.167.10:9092,10.31.167.10:9093,10.31.167.10:9094\");\n// 消费分组名\nprops.put(ConsumerConfig.GROUP_ID_CONFIG, CONSUMER_GROUP_NAME);\nprops.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG,StringDeserializer.class.getName());\nprops.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,StringDeserializer.class.getName());\n//创建一个消费者的客户端\nKafkaConsumer<String, String> consumer = new KafkaConsumer<String,String>(props);\n// 消费者订阅主题列表\nconsumer.subscribe(Arrays.asList(TOPIC_NAME));\n\nwhile (true) {\n/*\n* poll() API 是拉取消息的⻓轮询\n*/\nConsumerRecords<String, String> records =consumer.poll(Duration.ofMillis( 1000 ));\nfor (ConsumerRecord<String, String> record : records) {\nSystem.out.printf(\"收到消息：partition = %d,offset = %d, key =%s, value = %s%n\", record.partition(),record.offset(), record.key(), record.value());\n            }\n        }\n    }\n}\n```\n\n## 2.自动提交offset\n\n* 设置自动提交参数 - 默认\n\n```java\n// 是否自动提交offset，默认就是true\nprops.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, \"true\");\n// 自动提交offset的间隔时间\nprops.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG, \"1000\");\n```\n\n消费者poll到消息后默认情况下，会自动向broker的_consumer_offsets主题提交当前主题-分区消费的偏移量。\n\n自动提交会丢消息： 因为如果消费者还没消费完poll下来的消息就自动提交了偏移量，那么此 时消费者挂了，于是下一个消费者会从已提交的offset的下一个位置开始消费消息。之前未被消费的消息就丢失掉了。\n\n## 3.手动提交offset\n\n* 设置手动提交参数\n\n```java\nprops.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, \"false\");\n```\n### 在消费完消息后进行手动提交\n\n* 手动同步提交\n```java\nif (records.count() > 0 ) {\n// 手动同步提交offset，当前线程会阻塞直到offset提交成功\n// 一般使用同步提交，因为提交之后一般也没有什么逻辑代码了\nconsumer.commitSync();\n}\n```\n* 手动异步提交\n```java\nif (records.count() > 0 ) {\n// 手动异步提交offset，当前线程提交offset不会阻塞，可以继续处理后面的程序逻辑\nconsumer.commitAsync(new OffsetCommitCallback() {\n@Override\npublic void onComplete(Map<TopicPartition, OffsetAndMetadata>offsets, Exception exception) {\n            if (exception != null) {\n                System.err.println(\"Commit failed for \" + offsets);\n                System.err.println(\"Commit failed exception: \" +exception.getStackTrace());\n            }\n         }\n    });\n}\n```\n\n## 4.消费者poll消息的过程\n\n* 消费者建立了与broker之间的⻓连接，开始poll消息。\n* 默认一次poll 500条消息\n\n\n```java\nprops.put(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 500 );\n```\n\n可以根据消费速度的快慢来设置，因为如果两次poll的时间如果超出了30s的时间间隔，kafka会认为其消费能力过弱，将其踢出消费组。将分区分配给其他消费者。\n\n可以通过这个值进行设置：\n```java\nprops.put(ConsumerConfig.MAX_POLL_INTERVAL_MS_CONFIG, 30 * 1000 );\n```\n\n如果每隔1s内没有poll到任何消息，则继续去poll消息，循环往复，直到poll到消息。如果超出了1s，则此次⻓轮询结束。\n\n```java\nConsumerRecords<String, String> records =consumer.poll(Duration.ofMillis( 1000 ));\n```\n消费者发送心跳的时间间隔\n\n```java\nprops.put(ConsumerConfig.HEARTBEAT_INTERVAL_MS_CONFIG, 1000 );\n```\n\nkafka如果超过 10 秒没有收到消费者的心跳，则会把消费者踢出消费组，进行rebalance，把分区分配给其他消费者。\n\n```java\nprops.put(ConsumerConfig.SESSION_TIMEOUT_MS_CONFIG, 10 * 1000 );\n```\n## 5.指定分区消费\n```java\nconsumer.assign(Arrays.asList(new TopicPartition(TOPIC_NAME, 0 )));\n```\n## 6.消息回溯消费\n```java\nconsumer.assign(Arrays.asList(new TopicPartition(TOPIC_NAME, 0 )));\nconsumer.seekToBeginning(Arrays.asList(new TopicPartition(TOPIC_NAME,0 )));\n```\n## 7.指定offset消费\n```java\nconsumer.assign(Arrays.asList(new TopicPartition(TOPIC_NAME, 0 )));\nconsumer.seek(new TopicPartition(TOPIC_NAME, 0 ), 10 );\n```\n## 8.从指定时间点消费\n\n```java\nList<PartitionInfo> topicPartitions =consumer.partitionsFor(TOPIC_NAME);\n//从 1 小时前开始消费\nlong fetchDataTime = new Date().getTime() - 1000 * 60 * 60 ;\nMap<TopicPartition, Long> map = new HashMap<>();\nfor (PartitionInfo par : topicPartitions) {\n    map.put(new TopicPartition(TOPIC_NAME, par.partition()),fetchDataTime);\n}\nMap<TopicPartition, OffsetAndTimestamp> parMap =consumer.offsetsForTimes(map);\nfor (Map.Entry<TopicPartition, OffsetAndTimestamp> entry :parMap.entrySet()) {\n    TopicPartition key = entry.getKey();\n    OffsetAndTimestamp value = entry.getValue();\n    if (key == null || value == null) continue;\n    Long offset = value.offset();\n    System.out.println(\"partition-\" + key.partition() +\"|offset-\" + offset);\n    System.out.println();\n    //根据消费里的timestamp确定offset\n    if (value != null) {\n        consumer.assign(Arrays.asList(key));\n        consumer.seek(key, offset);\n    }\n}\n```\n\n## 9.新消费组的消费偏移量\n\n> 当消费主题的是一个新的消费组，或者指定offset的消费方式，offset不存在，那么应该如何消费?\n\n* latest(默认) ：只消费自己启动之后发送到主题的消息\n* earliest：第一次从头开始消费，以后按照消费offset记录继续消费，这个需要区别于consumer.seekToBeginning(每次都从头开始消费)\n```shell\nprops.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n```\n# 八 、Springboot中使用Kafka\n\n## 1.引入依赖\n```xml\n<dependency>\n    <groupId>org.springframework.kafka</groupId>\n    <artifactId>spring-kafka</artifactId>\n</dependency>\n```\n\n## 2.配置文件\n\n```yml\nserver:\n    port: 8080\nspring:\n    kafka:\n        bootstrap-servers: 172.16.253.21: 9093\n        producer: # 生产者\n            retries: 3 # 设置大于 0 的值，则客户端会将发送失败的记录重新发送\n            batch-size: 16384\n            buffer-memory: 33554432\n            acks: 1\n            # 指定消息key和消息体的编解码方式\n            key-serializer: org.apache.kafka.common.serialization.StringSerializer\n            value-serializer: org.apache.kafka.common.serialization.StringSerializer\n        consumer:\n            group-id: default-group\n            enable-auto-commit: false\n            auto-offset-reset: earliest\n            key-deserializer: org.apache.kafka.common.serialization.StringDeserializer\n            value-deserializer: org.apache.kafka.common.serialization.StringDeserializer\n            max-poll-records: 500\n        listener:\n        # 当每一条记录被消费者监听器（ListenerConsumer）处理之后提交\n        # RECORD\n        # 当每一批poll()的数据被消费者监听器（ListenerConsumer）处理之后提交\n        # BATCH\n        # 当每一批poll()的数据被消费者监听器（ListenerConsumer）处理之后，距离上次提交时间大于TIME时提交\n        # TIME\n        # 当每一批poll()的数据被消费者监听器（ListenerConsumer）处理之后，被处理record数量大于等于COUNT时提交\n        # COUNT\n        # TIME | COUNT　有一个条件满足时提交\n        # COUNT_TIME\n        # 当每一批poll()的数据被消费者监听器（ListenerConsumer）处理之后, 手动调用Acknowledgment.acknowledge()后提交\n        # MANUAL\n        # 手动调用Acknowledgment.acknowledge()后立即提交，一般使用这种\n        # MANUAL_IMMEDIATE\n            ack-mode: MANUAL_IMMEDIATE\n    redis:\n        host: 172.16.253.21\n```\n\n## 3.消息生产者\n* 发送消息到指定topic\n\n```java\n@RestController\npublic class KafkaController {\n    private final static String TOPIC_NAME = \"my-replicated-topic\";\n    @Autowired\n    private KafkaTemplate<String, String> kafkaTemplate;\n    @RequestMapping(\"/send\")\n    public void send() {\n        kafkaTemplate.send(TOPIC_NAME, 0 , \"key\", \"this is a msg\");\n    }\n}\n```\n\n## 4.消息消费者\n* 设置消费组，消费指定topic\n```java\n@KafkaListener(topics = \"my-replicated-topic\",groupId = \"MyGroup1\")\npublic void listenGroup(ConsumerRecord<String, String> record,Acknowledgment ack) {\n    String value = record.value();\n    System.out.println(value);\n    System.out.println(record);\n    //手动提交offset\n    ack.acknowledge();\n}\n```\n\n* 设置消费组、多topic、指定分区、指定偏移量消费及设置消费者个数。\n\n```java\n@KafkaListener(groupId = \"testGroup\", topicPartitions = {\n@TopicPartition(topic = \"topic1\", partitions = {\"0\", \"1\"}),\n@TopicPartition(topic = \"topic2\", partitions = \"0\",partitionOffsets = @PartitionOffset(partition = \"1\",initialOffset = \"100\"))}\n,concurrency = \"3\")//concurrency就是同组下的消费者个数，就是并发消费数，建议小于等于分区总数\npublic void listenGroup(ConsumerRecord<String, String> record,Acknowledgment ack) {\n    String value = record.value();\n    System.out.println(value);\n    System.out.println(record);\n    //手动提交offset\n    ack.acknowledge();\n}\n```\n\n# 九、Kafka集群Controller、Rebalance和HW\n\n## 1.Controller\n\n* Kafka集群中的broker在zk中创建临时序号节点，序号最小的节点（最先创建的节点）将作为集群的controller，负责管理整个集群中的所有分区和副本的状态：\n    * 当某个分区的leader副本出现故障时，由控制器负责为该分区选举新的leader副本。\n    * 当检测到某个分区的ISR集合发生变化时，由控制器负责通知所有broker更新其元数据信息。\n    * 当使用kafka-topics.sh脚本为某个topic增加分区数量时，同样还是由控制器负责让新分区被其他节点感知到。\n\n## 2.Rebalance机制\n\n前提是：消费者没有指明分区消费。当消费组里消费者和分区的关系发生变化，那么就会触发rebalance机制。\n\n这个机制会重新调整消费者消费哪个分区。\n\n在触发rebalance机制之前，消费者消费哪个分区有三种策略：\n\n* range：通过公示来计算某个消费者消费哪个分区\n* 轮询：大家轮着消费\n* sticky：在触发了rebalance后，在消费者消费的原分区不变的基础上进行调整。\n\n## 3.HW和LEO\n\n>HW俗称高水位，HighWatermark的缩写，取一个partition对应的ISR中最小的LEO(log-end-offset)作为HW，consumer最多只能消费到HW所在的位置。另外每个replica都有HW,leader和follower各自负责更新自己的HW的状态。对于leader新写入的消息，consumer不能立刻消费，leader会等待该消息被所有ISR中的replicas同步后更新HW，此时消息才能被consumer消费。这样就保证了如果leader所在的broker失效，该消息仍然可以从新选举的leader中获取。\n\n# 十、Kafka线上问题优化\n\n## 1.如何防止消息丢失\n\n* 发送方： ack是 1 或者-1/all 可以防止消息丢失，如果要做到99.9999%，ack设成all，把min.insync.replicas配置成分区备份数\n* 消费方：把自动提交改为手动提交。\n\n## 2.如何防止消息的重复消费\n\n>一条消息被消费者消费多次。如果为了消息的不重复消费，而把生产端的重试机制关闭、消费端的手动提交改成自动提交，这样反而会出现消息丢失，那么可以直接在防治消息丢失的手段上再加上消费消息时的幂等性保证，就能解决消息的重复消费问题。\n\n### 幂等性如何保证：\n\n* mysql 插入业务id作为主键，主键是唯一的，所以一次只能插入一条\n* 使用redis或zk的分布式锁（主流的方案）\n\n## 3.如何做到顺序消费RocketMQ\n\n* 发送方：在发送时将ack不能设置 0 ，关闭重试，使用同步发送，等到发送成功再发送下一条。确保消息是顺序发送的。\n* 接收方：消息是发送到一个分区中，只能有一个消费组的消费者来接收消息。因此，kafka的顺序消费会牺牲掉性能。\n\n## 4.解决消息积压问题\n\n>消息积压会导致很多问题，比如磁盘被打满、生产端发消息导致kafka性能过慢，就容易出现服务雪崩，就需要有相应的手段：\n\n* 方案一：在一个消费者中启动多个线程，让多个线程同时消费。——提升一个消费者的消费能力（增加分区增加消费者）。\n* 方案二：如果方案一还不够的话，这个时候可以启动多个消费者，多个消费者部署在不同的服务器上。其实多个消费者部署在同一服务器上也可以提高消费能力——充分利用服务器的cpu资源。\n* 方案三：让一个消费者去把收到的消息往另外一个topic上发，另一个topic设置多个分区和多个消费者 ，进行具体的业务消费。\n\n## 5.延迟队列\n\n延迟队列的应用场景：在订单创建成功后如果超过 30 分钟没有付款，则需要取消订单，此时可用延时队列来实现\n\n* 创建多个topic，每个topic表示延时的间隔\n    * topic_5s: 延时5s执行的队列\n    * topic_1m: 延时 1 分钟执行的队列\n    * topic_30m: 延时 30 分钟执行的队列\n\n* 消息发送者发送消息到相应的topic，并带上消息的发送时间\n* 消费者订阅相应的topic，消费时轮询消费整个topic中的消息\n    * 如果消息的发送时间，和消费的当前时间超过预设的值，比如 30 分钟\n    * 如果消息的发送时间，和消费的当前时间没有超过预设的值，则不消费当前的offset及之后的offset的所有消息都消费\n    * 下次继续消费该offset处的消息，判断时间是否已满足预设值\n\n# 十一、Kafka-eagle监控平台\n\n## 安装Kafka-eagle\n\n### 官网下载压缩包\n\nhttp://www.kafka-eagle.org/\n\n* 安装jdk\n* 解压缩后修改配置文件 system-config.properties\n\n```shell\n# 配置zk  去掉cluster2\nefak.zk.cluster.alias=cluster1\ncluster1.zk.list=172.16.253.35:2181\n# cluster2.zk.list=xdn10:2181,xdn11:2181,xdn12:2181\n\n# 配置mysql\nkafka.eagle.driver=com.mysql.cj.jdbc.Driver\nkafka.eagle.url=jdbc:mysql://172.16.253.22:3306/ke?useUnicode=true&characterEncoding=UTF-8&zeroDateTimeBehavior=convertToNull\nkafka.eagle.username=root\nkafka.eagle.password= 123456\n```\n\n* 修改/etc/profile\n```\nexport  JAVA_HOME=/usr/local/jdk/jdk1.8.0_191\nCLASSPATH=.:$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar\nexport KE_HOME=/home/aisys/efak-web-2.0.9\nexport PATH=$PATH:$KE_HOME/bin:$JAVA_HOME/bin\n```\n\n* 刷新配置\n```\nsource /etc/profile\n```\n\n* 进入到bin目录，为ke.sh增加可执行的权限\n\n```shell\nchmod +x ke.sh\n```\n\n* 启动kafka-eagle\n```\n./ke.sh start\n```\n\n","slug":"Kafka","published":1,"updated":"2022-07-21T01:39:52.408Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5w7e73l0001igvu5ht9bjph","content":"<h1 id=\"消息队列的流派\"><a href=\"#消息队列的流派\" class=\"headerlink\" title=\"消息队列的流派\"></a>消息队列的流派</h1><h3 id=\"什么是-MQ\"><a href=\"#什么是-MQ\" class=\"headerlink\" title=\"什么是 MQ\"></a>什么是 MQ</h3><blockquote>\n<p>Message Queue（MQ），消息队列中间件。很多人都说：MQ 通过将消息的发送和接收分离来实现应用程序的异步和解偶，这个给人的直觉是——MQ 是异步的，用来解耦的，但是这个只是 MQ 的效果而不是目的。MQ 真正的目的是为了通讯，屏蔽底层复杂的通讯协议，定义了一套应用层的、更加简单的通讯协议。一个分布式系统中两个模块之间通讯要么是HTTP，要么是自己开发的（rpc） TCP，但是这两种协议其实都是原始的协议。HTTP 协议很难实现两端通讯——模块 A 可以调用 B，B 也可以主动调用 A，如果要做到这个两端都要背上WebServer，而且还不支持⻓连接（HTTP 2.0 的库根本找不到）。TCP 就更加原始了，粘包、心跳、私有的协议，想一想头皮就发麻。MQ 所要做的就是在这些协议之上构建一个简单的“协议”——生产者/消费者模型。MQ 带给我的“协议”不是具体的通讯协议，而是更高层次通讯模型。它定义了两个对象——发送数据的叫生产者；接收数据的叫消费者， 提供一个SDK 让我们可以定义自己的生产者和消费者实现消息通讯而无视底层通讯协议</p>\n</blockquote>\n<h3 id=\"有-Broker-的-MQ\"><a href=\"#有-Broker-的-MQ\" class=\"headerlink\" title=\"有 Broker 的 MQ\"></a>有 Broker 的 MQ</h3><blockquote>\n<p>这个流派通常有一台服务器作为 Broker，所有的消息都通过它中转。生产者把消息发送给它就结束自己的任务了，Broker 则把消息主动推送给消费者（或者消费者主动轮询）</p>\n</blockquote>\n<h3 id=\"重-Topic\"><a href=\"#重-Topic\" class=\"headerlink\" title=\"重 Topic\"></a>重 Topic</h3><blockquote>\n<p>kafka、JMS（ActiveMQ）就属于这个流派，生产者会发送 key 和数据到 Broker，由 Broker比较 key 之后决定给哪个消费者。这种模式是我们最常⻅的模式，是我们对 MQ 最多的印象。在这种模式下一个 topic 往往是一个比较大的概念，甚至一个系统中就可能只有一个topic，topic 某种意义上就是 queue，生产者发送 key 相当于说：“hi，把数据放到 key 的队列中”</p>\n</blockquote>\n<blockquote>\n<p>如上图所示，Broker 定义了三个队列，key1，key2，key3，生产者发送数据的时候会发送key1 和 data，Broker 在推送数据的时候则推送 data（也可能把 key 带上）。</p>\n</blockquote>\n<blockquote>\n<p>虽然架构一样但是 kafka 的性能要比 jms 的性能不知道高到多少倍，所以基本这种类型的MQ 只有 kafka 一种备选方案。如果你需要一条暴力的数据流（在乎性能而非灵活性）那么kafka 是最好的选择</p>\n</blockquote>\n<h3 id=\"轻-Topic\"><a href=\"#轻-Topic\" class=\"headerlink\" title=\"轻 Topic\"></a>轻 Topic</h3><blockquote>\n<p>这种的代表是 RabbitMQ（或者说是 AMQP）。生产者发送 key 和数据，消费者定义订阅的队列，Broker 收到数据之后会通过一定的逻辑计算出 key 对应的队列，然后把数据交给队列</p>\n</blockquote>\n<blockquote>\n<p>这种模式下解耦了 key 和 queue，在这种架构中 queue 是非常轻量级的（在 RabbitMQ 中它的上限取决于你的内存），消费者关心的只是自己的 queue；生产者不必关心数据最终给谁只要指定 key 就行了，中间的那层映射在 AMQP 中叫 exchange（交换机）。</p>\n</blockquote>\n<p>AMQP 中有四种 exchange</p>\n<ul>\n<li>Direct exchange：key 就等于 queue</li>\n<li>Fanout exchange：无视 key，给所有的 queue 都来一份</li>\n<li>Topic exchange：key 可以用“宽字符”模糊匹配 queue</li>\n<li>Headers exchange：无视 key，通过查看消息的头部元数据来决定发给那个</li>\n<li>queue（AMQP 头部元数据非常丰富而且可以自定义）</li>\n</ul>\n<p>这种结构的架构给通讯带来了很大的灵活性，我们能想到的通讯方式都可以用这四种exchange 表达出来。如果你需要一个企业数据总线（在乎灵活性）那么 RabbitMQ 绝对的值得一用</p>\n<h3 id=\"无-Broker-的-MQ\"><a href=\"#无-Broker-的-MQ\" class=\"headerlink\" title=\"无 Broker 的 MQ\"></a>无 Broker 的 MQ</h3><blockquote>\n<p>无 Broker 的 MQ 的代表是 ZeroMQ。该作者非常睿智，他非常敏锐的意识到——MQ 是更高级的 Socket，它是解决通讯问题的。所以 ZeroMQ 被设计成了一个“库”而不是一个中间件，这种实现也可以达到——没有 Broker 的目的</p>\n</blockquote>\n<blockquote>\n<p>节点之间通讯的消息都是发送到彼此的队列中，每个节点都既是生产者又是消费者。ZeroMQ做的事情就是封装出一套类似于 Socket 的 API 可以完成发送数据，读取数据</p>\n</blockquote>\n<blockquote>\n<p>ZeroMQ 其实就是一个跨语言的、重量级的 Actor 模型邮箱库。你可以把自己的程序想象成一个 Actor，ZeroMQ 就是提供邮箱功能的库；ZeroMQ 可以实现同一台机器的 RPC 通讯也可以实现不同机器的 TCP、UDP 通讯，如果你需要一个强大的、灵活、野蛮的通讯能力，别犹豫 ZeroMQ</p>\n</blockquote>\n<h1 id=\"一、Kafka介绍\"><a href=\"#一、Kafka介绍\" class=\"headerlink\" title=\"一、Kafka介绍\"></a>一、Kafka介绍</h1><blockquote>\n<p>Kafka是最初由Linkedin公司开发，是一个分布式、支持分区的（partition）、多副本的<br>（replica），基于zookeeper协调的分布式消息系统，它的最大的特性就是可以实时的处理<br>大量数据以满足各种需求场景：比如基于hadoop的批处理系统、低延迟的实时系统、<br>Storm/Spark流式处理引擎，web/nginx日志、访问日志，消息服务等等，用scala语言编<br>写，Linkedin于 2010 年贡献给了Apache基金会并成为顶级开源 项目。</p>\n</blockquote>\n<h2 id=\"1-Kafka的使用场景\"><a href=\"#1-Kafka的使用场景\" class=\"headerlink\" title=\"1.Kafka的使用场景\"></a>1.Kafka的使用场景</h2><blockquote>\n<p>日志收集：一个公司可以用Kafka收集各种服务的log，通过kafka以统一接口服务的方式<br>开放给各种consumer，例如hadoop、Hbase、Solr等。<br>消息系统：解耦和生产者和消费者、缓存消息等。<br>用户活动跟踪：Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网⻚、<br>搜索、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过<br>订阅这些topic来做实时的监控分析，或者装载到hadoop、数据仓库中做离线分析和挖<br>掘。<br>运营指标：Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产<br>各种操作的集中反馈，比如报警和报告。</p>\n</blockquote>\n<h2 id=\"2-Kafka基本概念\"><a href=\"#2-Kafka基本概念\" class=\"headerlink\" title=\"2.Kafka基本概念\"></a>2.Kafka基本概念</h2><blockquote>\n<p>kafka是一个分布式的，分区的消息(官方称之为commit log)服务。它提供一个消息系统应该<br>具备的功能，但是确有着独特的设计。可以这样来说，Kafka借鉴了JMS规范的思想，但是确<br>并 <code>没有完全遵循JMS规范。</code></p>\n</blockquote>\n<p>首先，让我们来看一下基础的消息(Message)相关术语：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th align=\"center\">解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Broker</td>\n<td align=\"center\">消息中间件处理节点，⼀个Kafka节点就是⼀个broker，⼀个或者多个Broker可以组成⼀个Kafka集群</td>\n</tr>\n<tr>\n<td>Topic</td>\n<td align=\"center\">Kafka根据topic对消息进⾏归类，发布到Kafka集群的每条消息都需要指定⼀个topic</td>\n</tr>\n<tr>\n<td>Producer</td>\n<td align=\"center\">消息⽣产者，向Broker发送消息的客户端</td>\n</tr>\n<tr>\n<td>Consumer</td>\n<td align=\"center\">消息消费者，从Broker读取消息的客户端</td>\n</tr>\n<tr>\n<td>ConsumerGroup</td>\n<td align=\"center\">每个Consumer属于⼀个特定的Consumer Group，⼀条消息可以被多个不同的Consumer Group消费，但是⼀个Consumer Group中只能有⼀个Consumer能够消费该消息</td>\n</tr>\n<tr>\n<td>Partition</td>\n<td align=\"center\">物理上的概念，⼀个topic可以分为多个partition，每个partition内部消息是有序的</td>\n</tr>\n</tbody></table>\n<p>因此，从一个较高的层面上来看，producer通过网络发送消息到Kafka集群，然后consumer<br>来进行消费，如下图：</p>\n<img src=\"/2022/07/10/Kafka/QQ%E6%88%AA%E5%9B%BE20220110112502.png\" class title=\"输入图片说明\">\n\n<p>服务端(brokers)和客户端(producer、consumer)之间通信通过 <strong>TCP协议</strong> 来完成。</p>\n<h1 id=\"二、kafka基本使用\"><a href=\"#二、kafka基本使用\" class=\"headerlink\" title=\"二、kafka基本使用\"></a>二、kafka基本使用</h1><h2 id=\"1-安装前的环境准备\"><a href=\"#1-安装前的环境准备\" class=\"headerlink\" title=\"1.安装前的环境准备\"></a>1.安装前的环境准备</h2><ul>\n<li><p>安装jdk</p>\n</li>\n<li><p>安装zk</p>\n</li>\n<li><p>官网下载kafka的压缩包:<a href=\"http://kafka.apache.org/downloads\">http://kafka.apache.org/downloads</a></p>\n</li>\n<li><p>解压缩至如下路径</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">/usr/local/kafka/</span><br></pre></td></tr></table></figure></li>\n<li><p>修改配置文件：/usr/local/kafka/kafka2.11-2.4/config/server.properties</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">broker.id属性在kafka集群中必须要是唯一</span></span><br><span class=\"line\">broker.id= 0</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">kafka部署的机器ip和提供服务的端口号</span></span><br><span class=\"line\">listeners=PLAINTEXT://192.168.65.60:9092</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">kafka的消息存储文件</span></span><br><span class=\"line\">log.dir=/usr/local/data/kafka-logs</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">kafka连接zookeeper的地址</span></span><br><span class=\"line\">zookeeper.connect= 192.168.65.60:2181</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-启动kafka服务器\"><a href=\"#2-启动kafka服务器\" class=\"headerlink\" title=\"2.启动kafka服务器\"></a>2.启动kafka服务器</h2></li>\n</ul>\n<p>进入到bin目录下。使用命令来启动</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">./kafka-server-start.sh -daemon../config/server.properties</span><br></pre></td></tr></table></figure>\n<p>验证是否启动成功：</p>\n<p>进入到zk中的节点看id是 0 的broker有没有存在（上线）</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">ls /brokers/ids/</span><br></pre></td></tr></table></figure>\n<p><strong>server.properties核心配置详解：</strong></p>\n<table>\n<thead>\n<tr>\n<th>Property</th>\n<th align=\"left\">Default</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>broker.id</td>\n<td align=\"left\">0</td>\n<td align=\"left\">每个broker都可以⽤⼀个唯⼀的⾮负整数id进⾏标识；这个id可以作为broker的“名字”，你可以选择任意你喜欢的数字作为id，只要id是唯⼀的即可。</td>\n</tr>\n<tr>\n<td>log.dirs</td>\n<td align=\"left\">/tmp/kafka-logs</td>\n<td align=\"left\">kafka存放数据的路径。这个路径并不是唯⼀的，可以是多个，路径之间只需要使⽤逗号分隔即可；每当创建新partition时，都会选择在包含最少partitions的路径下进⾏。</td>\n</tr>\n<tr>\n<td>listeners</td>\n<td align=\"left\">PLAINTEXT://192.168.65.60:9092</td>\n<td align=\"left\">server接受客户端连接的端⼝，ip配置kafka本机ip即可</td>\n</tr>\n<tr>\n<td>zookeeper.connect</td>\n<td align=\"left\">localhost:2181</td>\n<td align=\"left\">zooKeeper连接字符串的格式为：hostname:port，此处hostname和port分别是ZooKeeper集群中某个节点的host和port；zookeeper如果是集群，连接⽅式为hostname1:port1, hostname2:port2,hostname3:port3</td>\n</tr>\n<tr>\n<td>log.retention.hours</td>\n<td align=\"left\">168</td>\n<td align=\"left\">每个⽇志⽂件删除之前保存的时间。默认数据保存时间对所有topic都⼀样。</td>\n</tr>\n<tr>\n<td>num.partitions</td>\n<td align=\"left\">1</td>\n<td align=\"left\">创建topic的默认分区数</td>\n</tr>\n<tr>\n<td>default.replication.factor</td>\n<td align=\"left\">1</td>\n<td align=\"left\">⾃动创建topic的默认副本数量，建议设置为⼤于等于2</td>\n</tr>\n<tr>\n<td>min.insync.replicas</td>\n<td align=\"left\">1</td>\n<td align=\"left\">当producer设置acks为-1时，min.insync.replicas指定replicas的最⼩数⽬（必须确认每⼀个repica的写数据都是成功的），如果这个数⽬没有达到，producer发送消息会产⽣异常</td>\n</tr>\n<tr>\n<td>delete.topic.enable</td>\n<td align=\"left\">false</td>\n<td align=\"left\">是否允许删除主题</td>\n</tr>\n</tbody></table>\n<h2 id=\"3-创建主题topic\"><a href=\"#3-创建主题topic\" class=\"headerlink\" title=\"3.创建主题topic\"></a>3.创建主题topic</h2><blockquote>\n<p>topic是什么概念？topic可以实现消息的分类，不同消费者订阅不同的topic。</p>\n</blockquote>\n<img src=\"/2022/07/10/Kafka/QQ%E6%88%AA%E5%9B%BE20220110122844.png\" class title=\"输入图片说明\">\n\n<p>执行以下命令创建名为“test”的topic，这个topic只有一个partition，并且备份因子也设置为1</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">./kafka-topics.sh --create --zookeeper 172.16.253.35:2181 --replication-factor 1 --partitions 1 --topic test</span><br></pre></td></tr></table></figure>\n<p>查看当前kafka内有哪些topic</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">./kafka-topics.sh --list --zookeeper 172.16.253.35:2181</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-发送消息\"><a href=\"#4-发送消息\" class=\"headerlink\" title=\"4.发送消息\"></a>4.发送消息</h2><blockquote>\n<p>kafka自带了一个producer命令客户端，可以从本地文件中读取内容，或者我们也可以以命令行中直接输入内容，并将这些内容以消息的形式发送到kafka集群中。在默认情况下，每一个行会被当做成一个独立的消息。使用kafka的发送消息的客户端，指定发送到的kafka服务器地址和topic</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">./kafka-console-producer.sh --broker-list 172.16.253.38:9092 --topic test</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-消费消息\"><a href=\"#5-消费消息\" class=\"headerlink\" title=\"5.消费消息\"></a>5.消费消息</h2><p>对于consumer，kafka同样也携带了一个命令行客户端，会将获取到内容在命令中进行输<br>出， <strong>默认是消费最新的消息</strong> 。使用kafka的消费者消息的客户端，从指定kafka服务器的指定<br>topic中消费消息</p>\n<p>方式一：从最后一条消息的偏移量+1开始消费</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">./kafka-console-consumer.sh --bootstrap-server 172.16.253.38:9092 --topic test</span><br></pre></td></tr></table></figure>\n<p>方式二：从头开始消费</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">./kafka-console-consumer.sh --bootstrap-server 172.16.253.38:9092 --from-beginning --topic test</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"几个注意点：\"><a href=\"#几个注意点：\" class=\"headerlink\" title=\"几个注意点：\"></a>几个注意点：</h3><ul>\n<li>消息会被存储</li>\n<li>消息是顺序存储</li>\n<li>消息是有偏移量的</li>\n<li>消费时可以指明偏移量进行消费</li>\n</ul>\n<h1 id=\"三、Kafka中的关键细节\"><a href=\"#三、Kafka中的关键细节\" class=\"headerlink\" title=\"三、Kafka中的关键细节\"></a>三、Kafka中的关键细节</h1><h2 id=\"1-消息的顺序存储\"><a href=\"#1-消息的顺序存储\" class=\"headerlink\" title=\"1.消息的顺序存储\"></a>1.消息的顺序存储</h2><blockquote>\n<p>消息的发送方会把消息发送到broker中，broker会存储消息，消息是按照发送的顺序进行存储。因此消费者在消费消息时可以指明主题中消息的偏移量。默认情况下，是从最后一个消息的下一个偏移量开始消费。</p>\n</blockquote>\n<h2 id=\"2-单播消息的实现\"><a href=\"#2-单播消息的实现\" class=\"headerlink\" title=\"2. 单播消息的实现\"></a>2. 单播消息的实现</h2><blockquote>\n<p>单播消息：一个消费组里 只会有一个消费者能消费到某一个topic中的消息。于是可以创建多个消费者，这些消费者在同一个消费组中。</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">./kafka-console-consumer.sh --bootstrap-server 10.31.167.10:9092 --consumer-property group.id=testGroup --topic test</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-多播消息的实现\"><a href=\"#3-多播消息的实现\" class=\"headerlink\" title=\"3.多播消息的实现\"></a>3.多播消息的实现</h2><h3 id=\"在一些业务场景中需要让一条消息被多个消费者消费，那么就可以使用多播模式。\"><a href=\"#在一些业务场景中需要让一条消息被多个消费者消费，那么就可以使用多播模式。\" class=\"headerlink\" title=\"在一些业务场景中需要让一条消息被多个消费者消费，那么就可以使用多播模式。\"></a>在一些业务场景中需要让一条消息被多个消费者消费，那么就可以使用多播模式。</h3><p>kafka实现多播，只需要让不同的消费者处于不同的消费组即可。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">./kafka-console-consumer.sh --bootstrap-server 10.31.167.10:9092 --consumer-property group.id=testGroup1 --topic test</span><br><span class=\"line\"></span><br><span class=\"line\">./kafka-console-consumer.sh --bootstrap-server 10.31.167.10:9092 --consumer-property group.id=testGroup2 --topic test</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-查看消费组及信息\"><a href=\"#4-查看消费组及信息\" class=\"headerlink\" title=\"4.查看消费组及信息\"></a>4.查看消费组及信息</h2><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 查看当前主题下有哪些消费组</span></span><br><span class=\"line\">./kafka-consumer-groups.sh --bootstrap-server 10.31.167.10:9092 --list</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 查看消费组中的具体信息：比如当前偏移量、最后一条消息的偏移量、堆积的消息数量</span></span><br><span class=\"line\">./kafka-consumer-groups.sh --bootstrap-server 172.16.253.38:9092 --describe --group testGroup</span><br></pre></td></tr></table></figure>\n<img src=\"/2022/07/10/Kafka/QQ%E6%88%AA%E5%9B%BE20220110125233.png\" class title=\"输入图片说明\">\n<ul>\n<li>Currennt-offset: 当前消费组的已消费偏移量</li>\n<li>Log-end-offset: 主题对应分区消息的结束偏移量(HW)</li>\n<li>Lag: 当前消费组未消费的消息数</li>\n</ul>\n<h1 id=\"四、主题、分区的概念\"><a href=\"#四、主题、分区的概念\" class=\"headerlink\" title=\"四、主题、分区的概念\"></a>四、主题、分区的概念</h1><h2 id=\"1-主题Topic\"><a href=\"#1-主题Topic\" class=\"headerlink\" title=\"1.主题Topic\"></a>1.主题Topic</h2><p>?主题Topic可以理解成是一个类别的名称。</p>\n<h2 id=\"2-partition分区\"><a href=\"#2-partition分区\" class=\"headerlink\" title=\"2.partition分区\"></a>2.partition分区</h2><img src=\"/2022/07/10/Kafka/QQ%E6%88%AA%E5%9B%BE20220110125413.png\" class title=\"输入图片说明\">\n\n<blockquote>\n<p>一个主题中的消息量是非常大的，因此可以通过分区的设置，来分布式存储这些消息。比如一个topic创建了 3 个分区。那么topic中的消息就会分别存放在这三个分区中。</p>\n</blockquote>\n<h3 id=\"为一个主题创建多个分区\"><a href=\"#为一个主题创建多个分区\" class=\"headerlink\" title=\"为一个主题创建多个分区\"></a>为一个主题创建多个分区</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">./kafka-topics.sh --create --zookeeper localhost:2181 --partitions 2 --topic test1</span><br></pre></td></tr></table></figure>\n<p><strong>可以通过这样的命令查看topic的分区信息</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">./kafka-topics.sh --describe --zookeeper localhost:2181 --topic test1</span><br></pre></td></tr></table></figure>\n<h3 id=\"分区的作用：\"><a href=\"#分区的作用：\" class=\"headerlink\" title=\"分区的作用：\"></a>分区的作用：</h3><ul>\n<li>可以分布式存储</li>\n<li>可以并行写</li>\n</ul>\n<p>实际上是存在data/kafka-logs/test-0 和 test-1中的0000000.log文件中</p>\n<p>小细节：</p>\n<blockquote>\n<p>定期将自己消费分区的offset提交给kafka内部topic：__consumer_offsets，提交过去的<br>时候，key是consumerGroupId+topic+分区号，value就是当前offset的值，kafka会定<br>期清理topic里的消息，最后就保留最新的那条数据<br>因为__consumer_offsets可能会接收高并发的请求，kafka默认给其分配 50 个分区(可以<br>通过offsets.topic.num.partitions设置)，这样可以通过加机器的方式抗大并发。<br>通过如下公式可以选出consumer消费的offset要提交到__consumer_offsets的哪个分区<br>公式：hash(consumerGroupId) % __consumer_offsets主题的分区数</p>\n</blockquote>\n<h1 id=\"五、Kafka集群及副本的概念\"><a href=\"#五、Kafka集群及副本的概念\" class=\"headerlink\" title=\"五、Kafka集群及副本的概念\"></a>五、Kafka集群及副本的概念</h1><h2 id=\"1-搭建kafka集群，-3-个broker\"><a href=\"#1-搭建kafka集群，-3-个broker\" class=\"headerlink\" title=\"1.搭建kafka集群， 3 个broker\"></a>1.搭建kafka集群， 3 个broker</h2><p>准备 3 个server.properties文件</p>\n<p>每个文件中的这些内容要调整</p>\n<ul>\n<li>server.properties<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">broker.id= 0</span><br><span class=\"line\">listeners=PLAINTEXT://192.168.65.60:</span><br><span class=\"line\">log.dir=/usr/local/data/kafka-logs</span><br></pre></td></tr></table></figure></li>\n<li>server1.properties<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">broker.id= 1</span><br><span class=\"line\">listeners=PLAINTEXT://192.168.65.60:</span><br><span class=\"line\">log.dir=/usr/local/data/kafka-logs-</span><br></pre></td></tr></table></figure></li>\n<li>server2.properties<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">broker.id= 2</span><br><span class=\"line\">listeners=PLAINTEXT://192.168.65.60:</span><br><span class=\"line\">log.dir=/usr/local/data/kafka-logs-</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用如下命令来启动-3-台服务器\"><a href=\"#使用如下命令来启动-3-台服务器\" class=\"headerlink\" title=\"使用如下命令来启动 3 台服务器\"></a>使用如下命令来启动 3 台服务器</h3></li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">./kafka-server-start.sh -daemon../config/server0.properties</span><br><span class=\"line\">./kafka-server-start.sh -daemon../config/server1.properties</span><br><span class=\"line\">./kafka-server-start.sh -daemon../config/server2.properties</span><br></pre></td></tr></table></figure>\n\n<p>搭建完后通过查看zk中的/brokers/ids 看是否启动成功</p>\n<h2 id=\"2-副本的概念\"><a href=\"#2-副本的概念\" class=\"headerlink\" title=\"2.副本的概念\"></a>2.副本的概念</h2><blockquote>\n<p>副本是对分区的备份。在集群中，不同的副本会被部署在不同的broker上。下面例子：创建 1个主题， 2 个分区、 3 个副本。</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">./kafka-topics.sh --create --zookeeper 172.16.253.35:2181 --replication-factor 3 --partitions 2 --topic my-replicated-topic</span><br></pre></td></tr></table></figure>\n<img src=\"/2022/07/10/Kafka/QQ%E6%88%AA%E5%9B%BE20220110133849.png\" class title=\"输入图片说明\">\n\n<p>通过查看主题信息，其中的关键数据：</p>\n<ul>\n<li>replicas：当前副本存在的broker节点</li>\n<li>leader：副本里的概念<ul>\n<li>每个partition都有一个broker作为leader。</li>\n<li>消息发送方要把消息发给哪个broker？就看副本的leader是在哪个broker上面。副本里的leader专⻔用来接收消息。</li>\n<li>接收到消息，其他follower通过poll的方式来同步数据。</li>\n</ul>\n</li>\n<li>follower：leader处理所有针对这个partition的读写请求，而follower被动复制leader，不提供读写（主要是为了保证多副本数据与消费的一致性），如果leader所在的broker挂掉，那么就会进行新leader的选举，至于怎么选，在之后的controller的概念中介绍。</li>\n</ul>\n<p>通过kill掉leader后再查看主题情况</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"built_in\">kill</span>掉leader</span></span><br><span class=\"line\">ps -aux | grep server.properties</span><br><span class=\"line\">kill 17631</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 查看topic情况</span></span><br><span class=\"line\">./kafka-topics.sh --describe --zookeeper 172.16.253.35:2181 --topic my-replicated-topic</span><br></pre></td></tr></table></figure>\n\n<p>isr：<br>可以同步的broker节点和已同步的broker节点，存放在isr集合中。</p>\n<h2 id=\"3-broker、主题、分区、副本\"><a href=\"#3-broker、主题、分区、副本\" class=\"headerlink\" title=\"3.broker、主题、分区、副本\"></a>3.broker、主题、分区、副本</h2><ul>\n<li>kafka集群中由多个broker组成</li>\n<li>一个broker中存放一个topic的不同partition——副本</li>\n</ul>\n<img src=\"/2022/07/10/Kafka/QQ%E6%88%AA%E5%9B%BE20220110134554.png\" class title=\"输入图片说明\">\n\n<h2 id=\"4-kafka集群消息的发送\"><a href=\"#4-kafka集群消息的发送\" class=\"headerlink\" title=\"4.kafka集群消息的发送\"></a>4.kafka集群消息的发送</h2><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">./kafka-console-producer.sh --broker-list 172.16.253.38:9092,172.16.253.38:9093,172.16.253.38:9094 --topic my-replicated-topic</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-kafka集群消息的消费\"><a href=\"#5-kafka集群消息的消费\" class=\"headerlink\" title=\"5.kafka集群消息的消费\"></a>5.kafka集群消息的消费</h2><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">./kafka-console-consumer.sh --bootstrap-server 172.16.253.38:9092,172.16.253.38:9093,172.16.253.38:9094 --from-beginning --topic my-replicated-topic</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-关于分区消费组消费者的细节\"><a href=\"#6-关于分区消费组消费者的细节\" class=\"headerlink\" title=\"6.关于分区消费组消费者的细节\"></a>6.关于分区消费组消费者的细节</h2><img src=\"/2022/07/10/Kafka/QQ%E6%88%AA%E5%9B%BE20220110134734.png\" class title=\"输入图片说明\">\n\n<blockquote>\n<p>图中Kafka集群有两个broker，每个broker中有多个partition。一个partition只能被一个消费组里的某一个消费者消费，从而保证消费顺序。Kafka只在partition的范围内保证消息消费的局部顺序性，不能在同一个topic中的多个partition中保证总的消费顺序性。一个消费者可以消费多个partition。</p>\n</blockquote>\n<p><code>消费组中消费者的数量不能比一个topic中的partition数量多，否则多出来的消费者消费不到消息。</code></p>\n<h1 id=\"六、Kafka的Java客户端-生产者\"><a href=\"#六、Kafka的Java客户端-生产者\" class=\"headerlink\" title=\"六、Kafka的Java客户端-生产者\"></a>六、Kafka的Java客户端-生产者</h1><h2 id=\"1-引入依赖\"><a href=\"#1-引入依赖\" class=\"headerlink\" title=\"1.引入依赖\"></a>1.引入依赖</h2><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.kafka<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>kafka-clients<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.4.1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"2-生产者发送消息的基本实现\"><a href=\"#2-生产者发送消息的基本实现\" class=\"headerlink\" title=\"2.生产者发送消息的基本实现\"></a>2.生产者发送消息的基本实现</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">#### <span class=\"comment\">//消息的发送方</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyProducer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String TOPIC_NAME = <span class=\"string\">&quot;my-replicated-topic&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ExecutionException,InterruptedException </span>&#123;</span><br><span class=\"line\">Properties props = <span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\">props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG,<span class=\"string\">&quot;10.31.167.10:9092,10.31.167.10:9093,10.31.167.10:9094&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//把发送的key从字符串序列化为字节数组</span></span><br><span class=\"line\">props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG,StringSerializer.class.getName());</span><br><span class=\"line\"><span class=\"comment\">//把发送消息value从字符串序列化为字节数组</span></span><br><span class=\"line\">props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG,StringSerializer.class.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">Producer&lt;String, String&gt; producer = <span class=\"keyword\">new</span> KafkaProducer&lt;String,String&gt;(props);</span><br><span class=\"line\"></span><br><span class=\"line\">Order order = <span class=\"keyword\">new</span> Order((<span class=\"keyword\">long</span>) i, i);</span><br><span class=\"line\">ProducerRecord&lt;String, String&gt; producerRecord = <span class=\"keyword\">new</span> ProducerRecord&lt;String, String&gt;(TOPIC_NAME, order.getOrderId().toString(), JSON.toJSONString(order));</span><br><span class=\"line\">RecordMetadata metadata = producer.send(producerRecord).get();</span><br><span class=\"line\"><span class=\"comment\">//=====阻塞=======</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;同步方式发送消息结果：&quot;</span> + <span class=\"string\">&quot;topic-&quot;</span> +metadata.topic() + <span class=\"string\">&quot;|partition-&quot;</span>+ metadata.partition() + <span class=\"string\">&quot;|offset-&quot;</span> +metadata.offset());</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-发送消息到指定分区上\"><a href=\"#3-发送消息到指定分区上\" class=\"headerlink\" title=\"3.发送消息到指定分区上\"></a>3.发送消息到指定分区上</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ProducerRecord&lt;String, String&gt; producerRecord = <span class=\"keyword\">new</span> ProducerRecord&lt;String, String&gt;(TOPIC_NAME, <span class=\"number\">0</span> , order.getOrderId().toString(), JSON.toJSONString(order));</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-未指定分区，则会通过业务key的hash运算，算出消息往哪个分区上发\"><a href=\"#4-未指定分区，则会通过业务key的hash运算，算出消息往哪个分区上发\" class=\"headerlink\" title=\"4.未指定分区，则会通过业务key的hash运算，算出消息往哪个分区上发\"></a>4.未指定分区，则会通过业务key的hash运算，算出消息往哪个分区上发</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//未指定发送分区，具体发送的分区计算公式：hash(key)%partitionNum</span></span><br><span class=\"line\">ProducerRecord&lt;String, String&gt; producerRecord = <span class=\"keyword\">new</span> ProducerRecord&lt;String, String&gt;(TOPIC_NAME, order.getOrderId().toString(), JSON.toJSONString(order));</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-同步发送\"><a href=\"#5-同步发送\" class=\"headerlink\" title=\"5.同步发送\"></a>5.同步发送</h2><p>生产者同步发消息，在收到kafka的ack告知发送成功之前一直处于阻塞状态</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//等待消息发送成功的同步阻塞方法</span></span><br><span class=\"line\">RecordMetadata metadata = producer.send(producerRecord).get();</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;同步方式发送消息结果：&quot;</span> + <span class=\"string\">&quot;topic-&quot;</span> +metadata.topic() + <span class=\"string\">&quot;|partition-&quot;</span>+ metadata.partition() + <span class=\"string\">&quot;|offset-&quot;</span> +metadata.offset());</span><br></pre></td></tr></table></figure>\n<img src=\"/2022/07/10/Kafka/QQ%E6%88%AA%E5%9B%BE20220110142708.png\" class title=\"输入图片说明\">\n<h2 id=\"6-异步发消息\"><a href=\"#6-异步发消息\" class=\"headerlink\" title=\"6.异步发消息\"></a>6.异步发消息</h2><h3 id=\"生产者发消息，发送完后不用等待broker给回复，直接执行下面的业务逻辑。可以提供callback，让broker异步的调用callback，告知生产者，消息发送的结果\"><a href=\"#生产者发消息，发送完后不用等待broker给回复，直接执行下面的业务逻辑。可以提供callback，让broker异步的调用callback，告知生产者，消息发送的结果\" class=\"headerlink\" title=\"生产者发消息，发送完后不用等待broker给回复，直接执行下面的业务逻辑。可以提供callback，让broker异步的调用callback，告知生产者，消息发送的结果\"></a>生产者发消息，发送完后不用等待broker给回复，直接执行下面的业务逻辑。可以提供callback，让broker异步的调用callback，告知生产者，消息发送的结果</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//要发送 5 条消息</span></span><br><span class=\"line\">Order order = <span class=\"keyword\">new</span> Order((<span class=\"keyword\">long</span>) i, i);</span><br><span class=\"line\"><span class=\"comment\">//指定发送分区</span></span><br><span class=\"line\">ProducerRecord&lt;String, String&gt; producerRecord = <span class=\"keyword\">new</span> ProducerRecord&lt;String, String&gt;(TOPIC_NAME, <span class=\"number\">0</span> , order.getOrderId().toString(),JSON.toJSONString(order));</span><br><span class=\"line\"><span class=\"comment\">//异步回调方式发送消息</span></span><br><span class=\"line\">producer.send(producerRecord, <span class=\"keyword\">new</span> Callback() &#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompletion</span><span class=\"params\">(RecordMetadata metadata, Exception exception)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (exception != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    System.err.println(<span class=\"string\">&quot;发送消息失败：&quot;</span> +</span><br><span class=\"line\">    exception.getStackTrace());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (metadata != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;异步方式发送消息结果：&quot;</span> + <span class=\"string\">&quot;topic-&quot;</span> +metadata.topic() + <span class=\"string\">&quot;|partition-&quot;</span>+ metadata.partition() + <span class=\"string\">&quot;|offset-&quot;</span> + metadata.offset());</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-关于生产者的ack参数配置\"><a href=\"#7-关于生产者的ack参数配置\" class=\"headerlink\" title=\"7.关于生产者的ack参数配置\"></a>7.关于生产者的ack参数配置</h2><h3 id=\"在同步发消息的场景下：生产者发动broker上后，ack会有-3-种不同的选择：\"><a href=\"#在同步发消息的场景下：生产者发动broker上后，ack会有-3-种不同的选择：\" class=\"headerlink\" title=\"在同步发消息的场景下：生产者发动broker上后，ack会有 3 种不同的选择：\"></a>在同步发消息的场景下：生产者发动broker上后，ack会有 3 种不同的选择：</h3><ul>\n<li>（ 1 ）acks=0： 表示producer不需要等待任何broker确认收到消息的回复，就可以继续发送下一条消息。性能最高，但是最容易丢消息。</li>\n<li>（ 2 ）acks=1： 至少要等待leader已经成功将数据写入本地log，但是不需要等待所有follower是否成功写入。就可以继续发送下一条消息。这种情况下，如果follower没有成功备份数据，而此时leader又挂掉，则消息会丢失。</li>\n<li>（ 3 ）acks=-1或all： 需要等待 min.insync.replicas(默认为 1 ，推荐配置大于等于2) 这个参数配置的副本个数都成功写入日志，这种策略会保证只要有一个备份存活就不会丢失数据。这是最强的数据保证。一般除非是金融级别，或跟钱打交道的场景才会使用这种配置。</li>\n</ul>\n<h3 id=\"code\"><a href=\"#code\" class=\"headerlink\" title=\"code:\"></a>code:</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">props.put(ProducerConfig.ACKS_CONFIG, <span class=\"string\">&quot;1&quot;</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"8-其他一些细节\"><a href=\"#8-其他一些细节\" class=\"headerlink\" title=\"8.其他一些细节\"></a>8.其他一些细节</h2><ul>\n<li>发送会默认会重试 3 次，每次间隔100ms</li>\n<li>发送的消息会先进入到本地缓冲区（32mb），kakfa会跑一个线程，该线程去缓冲区中取16k的数据，发送到kafka，如果到 10 毫秒数据没取满16k，也会发送一次。</li>\n</ul>\n<h1 id=\"七、消费者\"><a href=\"#七、消费者\" class=\"headerlink\" title=\"七、消费者\"></a>七、消费者</h1><h2 id=\"1-消费者消费消息的基本实现\"><a href=\"#1-消费者消费消息的基本实现\" class=\"headerlink\" title=\"1.消费者消费消息的基本实现\"></a>1.消费者消费消息的基本实现</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyConsumer</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String TOPIC_NAME = <span class=\"string\">&quot;my-replicated-topic&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String CONSUMER_GROUP_NAME = <span class=\"string\">&quot;testGroup&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">Properties props = <span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\">props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG,<span class=\"string\">&quot;10.31.167.10:9092,10.31.167.10:9093,10.31.167.10:9094&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 消费分组名</span></span><br><span class=\"line\">props.put(ConsumerConfig.GROUP_ID_CONFIG, CONSUMER_GROUP_NAME);</span><br><span class=\"line\">props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG,StringDeserializer.class.getName());</span><br><span class=\"line\">props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,StringDeserializer.class.getName());</span><br><span class=\"line\"><span class=\"comment\">//创建一个消费者的客户端</span></span><br><span class=\"line\">KafkaConsumer&lt;String, String&gt; consumer = <span class=\"keyword\">new</span> KafkaConsumer&lt;String,String&gt;(props);</span><br><span class=\"line\"><span class=\"comment\">// 消费者订阅主题列表</span></span><br><span class=\"line\">consumer.subscribe(Arrays.asList(TOPIC_NAME));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* poll() API 是拉取消息的⻓轮询</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">ConsumerRecords&lt;String, String&gt; records =consumer.poll(Duration.ofMillis( <span class=\"number\">1000</span> ));</span><br><span class=\"line\"><span class=\"keyword\">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class=\"line\">System.out.printf(<span class=\"string\">&quot;收到消息：partition = %d,offset = %d, key =%s, value = %s%n&quot;</span>, record.partition(),record.offset(), record.key(), record.value());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-自动提交offset\"><a href=\"#2-自动提交offset\" class=\"headerlink\" title=\"2.自动提交offset\"></a>2.自动提交offset</h2><ul>\n<li>设置自动提交参数 - 默认</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 是否自动提交offset，默认就是true</span></span><br><span class=\"line\">props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, <span class=\"string\">&quot;true&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 自动提交offset的间隔时间</span></span><br><span class=\"line\">props.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG, <span class=\"string\">&quot;1000&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>消费者poll到消息后默认情况下，会自动向broker的_consumer_offsets主题提交当前主题-分区消费的偏移量。</p>\n<p>自动提交会丢消息： 因为如果消费者还没消费完poll下来的消息就自动提交了偏移量，那么此 时消费者挂了，于是下一个消费者会从已提交的offset的下一个位置开始消费消息。之前未被消费的消息就丢失掉了。</p>\n<h2 id=\"3-手动提交offset\"><a href=\"#3-手动提交offset\" class=\"headerlink\" title=\"3.手动提交offset\"></a>3.手动提交offset</h2><ul>\n<li>设置手动提交参数</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, <span class=\"string\">&quot;false&quot;</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"在消费完消息后进行手动提交\"><a href=\"#在消费完消息后进行手动提交\" class=\"headerlink\" title=\"在消费完消息后进行手动提交\"></a>在消费完消息后进行手动提交</h3><ul>\n<li>手动同步提交<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (records.count() &gt; <span class=\"number\">0</span> ) &#123;</span><br><span class=\"line\"><span class=\"comment\">// 手动同步提交offset，当前线程会阻塞直到offset提交成功</span></span><br><span class=\"line\"><span class=\"comment\">// 一般使用同步提交，因为提交之后一般也没有什么逻辑代码了</span></span><br><span class=\"line\">consumer.commitSync();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>手动异步提交<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (records.count() &gt; <span class=\"number\">0</span> ) &#123;</span><br><span class=\"line\"><span class=\"comment\">// 手动异步提交offset，当前线程提交offset不会阻塞，可以继续处理后面的程序逻辑</span></span><br><span class=\"line\">consumer.commitAsync(<span class=\"keyword\">new</span> OffsetCommitCallback() &#123;</span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">(Map&lt;TopicPartition, OffsetAndMetadata&gt;offsets, Exception exception)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (exception != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                System.err.println(<span class=\"string\">&quot;Commit failed for &quot;</span> + offsets);</span><br><span class=\"line\">                System.err.println(<span class=\"string\">&quot;Commit failed exception: &quot;</span> +exception.getStackTrace());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"4-消费者poll消息的过程\"><a href=\"#4-消费者poll消息的过程\" class=\"headerlink\" title=\"4.消费者poll消息的过程\"></a>4.消费者poll消息的过程</h2><ul>\n<li>消费者建立了与broker之间的⻓连接，开始poll消息。</li>\n<li>默认一次poll 500条消息</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">props.put(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, <span class=\"number\">500</span> );</span><br></pre></td></tr></table></figure>\n\n<p>可以根据消费速度的快慢来设置，因为如果两次poll的时间如果超出了30s的时间间隔，kafka会认为其消费能力过弱，将其踢出消费组。将分区分配给其他消费者。</p>\n<p>可以通过这个值进行设置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">props.put(ConsumerConfig.MAX_POLL_INTERVAL_MS_CONFIG, <span class=\"number\">30</span> * <span class=\"number\">1000</span> );</span><br></pre></td></tr></table></figure>\n\n<p>如果每隔1s内没有poll到任何消息，则继续去poll消息，循环往复，直到poll到消息。如果超出了1s，则此次⻓轮询结束。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ConsumerRecords&lt;String, String&gt; records =consumer.poll(Duration.ofMillis( <span class=\"number\">1000</span> ));</span><br></pre></td></tr></table></figure>\n<p>消费者发送心跳的时间间隔</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">props.put(ConsumerConfig.HEARTBEAT_INTERVAL_MS_CONFIG, <span class=\"number\">1000</span> );</span><br></pre></td></tr></table></figure>\n\n<p>kafka如果超过 10 秒没有收到消费者的心跳，则会把消费者踢出消费组，进行rebalance，把分区分配给其他消费者。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">props.put(ConsumerConfig.SESSION_TIMEOUT_MS_CONFIG, <span class=\"number\">10</span> * <span class=\"number\">1000</span> );</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-指定分区消费\"><a href=\"#5-指定分区消费\" class=\"headerlink\" title=\"5.指定分区消费\"></a>5.指定分区消费</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">consumer.assign(Arrays.asList(<span class=\"keyword\">new</span> TopicPartition(TOPIC_NAME, <span class=\"number\">0</span> )));</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-消息回溯消费\"><a href=\"#6-消息回溯消费\" class=\"headerlink\" title=\"6.消息回溯消费\"></a>6.消息回溯消费</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">consumer.assign(Arrays.asList(<span class=\"keyword\">new</span> TopicPartition(TOPIC_NAME, <span class=\"number\">0</span> )));</span><br><span class=\"line\">consumer.seekToBeginning(Arrays.asList(<span class=\"keyword\">new</span> TopicPartition(TOPIC_NAME,<span class=\"number\">0</span> )));</span><br></pre></td></tr></table></figure>\n<h2 id=\"7-指定offset消费\"><a href=\"#7-指定offset消费\" class=\"headerlink\" title=\"7.指定offset消费\"></a>7.指定offset消费</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">consumer.assign(Arrays.asList(<span class=\"keyword\">new</span> TopicPartition(TOPIC_NAME, <span class=\"number\">0</span> )));</span><br><span class=\"line\">consumer.seek(<span class=\"keyword\">new</span> TopicPartition(TOPIC_NAME, <span class=\"number\">0</span> ), <span class=\"number\">10</span> );</span><br></pre></td></tr></table></figure>\n<h2 id=\"8-从指定时间点消费\"><a href=\"#8-从指定时间点消费\" class=\"headerlink\" title=\"8.从指定时间点消费\"></a>8.从指定时间点消费</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;PartitionInfo&gt; topicPartitions =consumer.partitionsFor(TOPIC_NAME);</span><br><span class=\"line\"><span class=\"comment\">//从 1 小时前开始消费</span></span><br><span class=\"line\"><span class=\"keyword\">long</span> fetchDataTime = <span class=\"keyword\">new</span> Date().getTime() - <span class=\"number\">1000</span> * <span class=\"number\">60</span> * <span class=\"number\">60</span> ;</span><br><span class=\"line\">Map&lt;TopicPartition, Long&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (PartitionInfo par : topicPartitions) &#123;</span><br><span class=\"line\">    map.put(<span class=\"keyword\">new</span> TopicPartition(TOPIC_NAME, par.partition()),fetchDataTime);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Map&lt;TopicPartition, OffsetAndTimestamp&gt; parMap =consumer.offsetsForTimes(map);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (Map.Entry&lt;TopicPartition, OffsetAndTimestamp&gt; entry :parMap.entrySet()) &#123;</span><br><span class=\"line\">    TopicPartition key = entry.getKey();</span><br><span class=\"line\">    OffsetAndTimestamp value = entry.getValue();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span> || value == <span class=\"keyword\">null</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    Long offset = value.offset();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;partition-&quot;</span> + key.partition() +<span class=\"string\">&quot;|offset-&quot;</span> + offset);</span><br><span class=\"line\">    System.out.println();</span><br><span class=\"line\">    <span class=\"comment\">//根据消费里的timestamp确定offset</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        consumer.assign(Arrays.asList(key));</span><br><span class=\"line\">        consumer.seek(key, offset);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-新消费组的消费偏移量\"><a href=\"#9-新消费组的消费偏移量\" class=\"headerlink\" title=\"9.新消费组的消费偏移量\"></a>9.新消费组的消费偏移量</h2><blockquote>\n<p>当消费主题的是一个新的消费组，或者指定offset的消费方式，offset不存在，那么应该如何消费?</p>\n</blockquote>\n<ul>\n<li>latest(默认) ：只消费自己启动之后发送到主题的消息</li>\n<li>earliest：第一次从头开始消费，以后按照消费offset记录继续消费，这个需要区别于consumer.seekToBeginning(每次都从头开始消费)<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">props.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, &quot;earliest&quot;);</span><br></pre></td></tr></table></figure>\n<h1 id=\"八-、Springboot中使用Kafka\"><a href=\"#八-、Springboot中使用Kafka\" class=\"headerlink\" title=\"八 、Springboot中使用Kafka\"></a>八 、Springboot中使用Kafka</h1></li>\n</ul>\n<h2 id=\"1-引入依赖-1\"><a href=\"#1-引入依赖-1\" class=\"headerlink\" title=\"1.引入依赖\"></a>1.引入依赖</h2><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.kafka<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-kafka<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-配置文件\"><a href=\"#2-配置文件\" class=\"headerlink\" title=\"2.配置文件\"></a>2.配置文件</h2><figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">server:</span></span><br><span class=\"line\">    <span class=\"attr\">port:</span> <span class=\"number\">8080</span></span><br><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">    <span class=\"attr\">kafka:</span></span><br><span class=\"line\">        <span class=\"attr\">bootstrap-servers: 172.16.253.21:</span> <span class=\"number\">9093</span></span><br><span class=\"line\">        <span class=\"attr\">producer:</span> <span class=\"comment\"># 生产者</span></span><br><span class=\"line\">            <span class=\"attr\">retries:</span> <span class=\"number\">3</span> <span class=\"comment\"># 设置大于 0 的值，则客户端会将发送失败的记录重新发送</span></span><br><span class=\"line\">            <span class=\"attr\">batch-size:</span> <span class=\"number\">16384</span></span><br><span class=\"line\">            <span class=\"attr\">buffer-memory:</span> <span class=\"number\">33554432</span></span><br><span class=\"line\">            <span class=\"attr\">acks:</span> <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"comment\"># 指定消息key和消息体的编解码方式</span></span><br><span class=\"line\">            <span class=\"attr\">key-serializer:</span> <span class=\"string\">org.apache.kafka.common.serialization.StringSerializer</span></span><br><span class=\"line\">            <span class=\"attr\">value-serializer:</span> <span class=\"string\">org.apache.kafka.common.serialization.StringSerializer</span></span><br><span class=\"line\">        <span class=\"attr\">consumer:</span></span><br><span class=\"line\">            <span class=\"attr\">group-id:</span> <span class=\"string\">default-group</span></span><br><span class=\"line\">            <span class=\"attr\">enable-auto-commit:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">            <span class=\"attr\">auto-offset-reset:</span> <span class=\"string\">earliest</span></span><br><span class=\"line\">            <span class=\"attr\">key-deserializer:</span> <span class=\"string\">org.apache.kafka.common.serialization.StringDeserializer</span></span><br><span class=\"line\">            <span class=\"attr\">value-deserializer:</span> <span class=\"string\">org.apache.kafka.common.serialization.StringDeserializer</span></span><br><span class=\"line\">            <span class=\"attr\">max-poll-records:</span> <span class=\"number\">500</span></span><br><span class=\"line\">        <span class=\"attr\">listener:</span></span><br><span class=\"line\">        <span class=\"comment\"># 当每一条记录被消费者监听器（ListenerConsumer）处理之后提交</span></span><br><span class=\"line\">        <span class=\"comment\"># RECORD</span></span><br><span class=\"line\">        <span class=\"comment\"># 当每一批poll()的数据被消费者监听器（ListenerConsumer）处理之后提交</span></span><br><span class=\"line\">        <span class=\"comment\"># BATCH</span></span><br><span class=\"line\">        <span class=\"comment\"># 当每一批poll()的数据被消费者监听器（ListenerConsumer）处理之后，距离上次提交时间大于TIME时提交</span></span><br><span class=\"line\">        <span class=\"comment\"># TIME</span></span><br><span class=\"line\">        <span class=\"comment\"># 当每一批poll()的数据被消费者监听器（ListenerConsumer）处理之后，被处理record数量大于等于COUNT时提交</span></span><br><span class=\"line\">        <span class=\"comment\"># COUNT</span></span><br><span class=\"line\">        <span class=\"comment\"># TIME | COUNT　有一个条件满足时提交</span></span><br><span class=\"line\">        <span class=\"comment\"># COUNT_TIME</span></span><br><span class=\"line\">        <span class=\"comment\"># 当每一批poll()的数据被消费者监听器（ListenerConsumer）处理之后, 手动调用Acknowledgment.acknowledge()后提交</span></span><br><span class=\"line\">        <span class=\"comment\"># MANUAL</span></span><br><span class=\"line\">        <span class=\"comment\"># 手动调用Acknowledgment.acknowledge()后立即提交，一般使用这种</span></span><br><span class=\"line\">        <span class=\"comment\"># MANUAL_IMMEDIATE</span></span><br><span class=\"line\">            <span class=\"attr\">ack-mode:</span> <span class=\"string\">MANUAL_IMMEDIATE</span></span><br><span class=\"line\">    <span class=\"attr\">redis:</span></span><br><span class=\"line\">        <span class=\"attr\">host:</span> <span class=\"number\">172.16</span><span class=\"number\">.253</span><span class=\"number\">.21</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-消息生产者\"><a href=\"#3-消息生产者\" class=\"headerlink\" title=\"3.消息生产者\"></a>3.消息生产者</h2><ul>\n<li>发送消息到指定topic</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">KafkaController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String TOPIC_NAME = <span class=\"string\">&quot;my-replicated-topic&quot;</span>;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> KafkaTemplate&lt;String, String&gt; kafkaTemplate;</span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/send&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">send</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        kafkaTemplate.send(TOPIC_NAME, <span class=\"number\">0</span> , <span class=\"string\">&quot;key&quot;</span>, <span class=\"string\">&quot;this is a msg&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-消息消费者\"><a href=\"#4-消息消费者\" class=\"headerlink\" title=\"4.消息消费者\"></a>4.消息消费者</h2><ul>\n<li><p>设置消费组，消费指定topic</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@KafkaListener(topics = &quot;my-replicated-topic&quot;,groupId = &quot;MyGroup1&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">listenGroup</span><span class=\"params\">(ConsumerRecord&lt;String, String&gt; record,Acknowledgment ack)</span> </span>&#123;</span><br><span class=\"line\">    String value = record.value();</span><br><span class=\"line\">    System.out.println(value);</span><br><span class=\"line\">    System.out.println(record);</span><br><span class=\"line\">    <span class=\"comment\">//手动提交offset</span></span><br><span class=\"line\">    ack.acknowledge();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>设置消费组、多topic、指定分区、指定偏移量消费及设置消费者个数。</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@KafkaListener(groupId = &quot;testGroup&quot;, topicPartitions = &#123;</span></span><br><span class=\"line\"><span class=\"meta\">@TopicPartition(topic = &quot;topic1&quot;, partitions = &#123;&quot;0&quot;, &quot;1&quot;&#125;),</span></span><br><span class=\"line\"><span class=\"meta\">@TopicPartition(topic = &quot;topic2&quot;, partitions = &quot;0&quot;,partitionOffsets = @PartitionOffset(partition = &quot;1&quot;,initialOffset = &quot;100&quot;))&#125;</span></span><br><span class=\"line\"><span class=\"meta\">,concurrency = &quot;3&quot;)</span><span class=\"comment\">//concurrency就是同组下的消费者个数，就是并发消费数，建议小于等于分区总数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">listenGroup</span><span class=\"params\">(ConsumerRecord&lt;String, String&gt; record,Acknowledgment ack)</span> </span>&#123;</span><br><span class=\"line\">    String value = record.value();</span><br><span class=\"line\">    System.out.println(value);</span><br><span class=\"line\">    System.out.println(record);</span><br><span class=\"line\">    <span class=\"comment\">//手动提交offset</span></span><br><span class=\"line\">    ack.acknowledge();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"九、Kafka集群Controller、Rebalance和HW\"><a href=\"#九、Kafka集群Controller、Rebalance和HW\" class=\"headerlink\" title=\"九、Kafka集群Controller、Rebalance和HW\"></a>九、Kafka集群Controller、Rebalance和HW</h1><h2 id=\"1-Controller\"><a href=\"#1-Controller\" class=\"headerlink\" title=\"1.Controller\"></a>1.Controller</h2><ul>\n<li>Kafka集群中的broker在zk中创建临时序号节点，序号最小的节点（最先创建的节点）将作为集群的controller，负责管理整个集群中的所有分区和副本的状态：<ul>\n<li>当某个分区的leader副本出现故障时，由控制器负责为该分区选举新的leader副本。</li>\n<li>当检测到某个分区的ISR集合发生变化时，由控制器负责通知所有broker更新其元数据信息。</li>\n<li>当使用kafka-topics.sh脚本为某个topic增加分区数量时，同样还是由控制器负责让新分区被其他节点感知到。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-Rebalance机制\"><a href=\"#2-Rebalance机制\" class=\"headerlink\" title=\"2.Rebalance机制\"></a>2.Rebalance机制</h2><p>前提是：消费者没有指明分区消费。当消费组里消费者和分区的关系发生变化，那么就会触发rebalance机制。</p>\n<p>这个机制会重新调整消费者消费哪个分区。</p>\n<p>在触发rebalance机制之前，消费者消费哪个分区有三种策略：</p>\n<ul>\n<li>range：通过公示来计算某个消费者消费哪个分区</li>\n<li>轮询：大家轮着消费</li>\n<li>sticky：在触发了rebalance后，在消费者消费的原分区不变的基础上进行调整。</li>\n</ul>\n<h2 id=\"3-HW和LEO\"><a href=\"#3-HW和LEO\" class=\"headerlink\" title=\"3.HW和LEO\"></a>3.HW和LEO</h2><blockquote>\n<p>HW俗称高水位，HighWatermark的缩写，取一个partition对应的ISR中最小的LEO(log-end-offset)作为HW，consumer最多只能消费到HW所在的位置。另外每个replica都有HW,leader和follower各自负责更新自己的HW的状态。对于leader新写入的消息，consumer不能立刻消费，leader会等待该消息被所有ISR中的replicas同步后更新HW，此时消息才能被consumer消费。这样就保证了如果leader所在的broker失效，该消息仍然可以从新选举的leader中获取。</p>\n</blockquote>\n<h1 id=\"十、Kafka线上问题优化\"><a href=\"#十、Kafka线上问题优化\" class=\"headerlink\" title=\"十、Kafka线上问题优化\"></a>十、Kafka线上问题优化</h1><h2 id=\"1-如何防止消息丢失\"><a href=\"#1-如何防止消息丢失\" class=\"headerlink\" title=\"1.如何防止消息丢失\"></a>1.如何防止消息丢失</h2><ul>\n<li>发送方： ack是 1 或者-1/all 可以防止消息丢失，如果要做到99.9999%，ack设成all，把min.insync.replicas配置成分区备份数</li>\n<li>消费方：把自动提交改为手动提交。</li>\n</ul>\n<h2 id=\"2-如何防止消息的重复消费\"><a href=\"#2-如何防止消息的重复消费\" class=\"headerlink\" title=\"2.如何防止消息的重复消费\"></a>2.如何防止消息的重复消费</h2><blockquote>\n<p>一条消息被消费者消费多次。如果为了消息的不重复消费，而把生产端的重试机制关闭、消费端的手动提交改成自动提交，这样反而会出现消息丢失，那么可以直接在防治消息丢失的手段上再加上消费消息时的幂等性保证，就能解决消息的重复消费问题。</p>\n</blockquote>\n<h3 id=\"幂等性如何保证：\"><a href=\"#幂等性如何保证：\" class=\"headerlink\" title=\"幂等性如何保证：\"></a>幂等性如何保证：</h3><ul>\n<li>mysql 插入业务id作为主键，主键是唯一的，所以一次只能插入一条</li>\n<li>使用redis或zk的分布式锁（主流的方案）</li>\n</ul>\n<h2 id=\"3-如何做到顺序消费RocketMQ\"><a href=\"#3-如何做到顺序消费RocketMQ\" class=\"headerlink\" title=\"3.如何做到顺序消费RocketMQ\"></a>3.如何做到顺序消费RocketMQ</h2><ul>\n<li>发送方：在发送时将ack不能设置 0 ，关闭重试，使用同步发送，等到发送成功再发送下一条。确保消息是顺序发送的。</li>\n<li>接收方：消息是发送到一个分区中，只能有一个消费组的消费者来接收消息。因此，kafka的顺序消费会牺牲掉性能。</li>\n</ul>\n<h2 id=\"4-解决消息积压问题\"><a href=\"#4-解决消息积压问题\" class=\"headerlink\" title=\"4.解决消息积压问题\"></a>4.解决消息积压问题</h2><blockquote>\n<p>消息积压会导致很多问题，比如磁盘被打满、生产端发消息导致kafka性能过慢，就容易出现服务雪崩，就需要有相应的手段：</p>\n</blockquote>\n<ul>\n<li>方案一：在一个消费者中启动多个线程，让多个线程同时消费。——提升一个消费者的消费能力（增加分区增加消费者）。</li>\n<li>方案二：如果方案一还不够的话，这个时候可以启动多个消费者，多个消费者部署在不同的服务器上。其实多个消费者部署在同一服务器上也可以提高消费能力——充分利用服务器的cpu资源。</li>\n<li>方案三：让一个消费者去把收到的消息往另外一个topic上发，另一个topic设置多个分区和多个消费者 ，进行具体的业务消费。</li>\n</ul>\n<h2 id=\"5-延迟队列\"><a href=\"#5-延迟队列\" class=\"headerlink\" title=\"5.延迟队列\"></a>5.延迟队列</h2><p>延迟队列的应用场景：在订单创建成功后如果超过 30 分钟没有付款，则需要取消订单，此时可用延时队列来实现</p>\n<ul>\n<li><p>创建多个topic，每个topic表示延时的间隔</p>\n<ul>\n<li>topic_5s: 延时5s执行的队列</li>\n<li>topic_1m: 延时 1 分钟执行的队列</li>\n<li>topic_30m: 延时 30 分钟执行的队列</li>\n</ul>\n</li>\n<li><p>消息发送者发送消息到相应的topic，并带上消息的发送时间</p>\n</li>\n<li><p>消费者订阅相应的topic，消费时轮询消费整个topic中的消息</p>\n<ul>\n<li>如果消息的发送时间，和消费的当前时间超过预设的值，比如 30 分钟</li>\n<li>如果消息的发送时间，和消费的当前时间没有超过预设的值，则不消费当前的offset及之后的offset的所有消息都消费</li>\n<li>下次继续消费该offset处的消息，判断时间是否已满足预设值</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"十一、Kafka-eagle监控平台\"><a href=\"#十一、Kafka-eagle监控平台\" class=\"headerlink\" title=\"十一、Kafka-eagle监控平台\"></a>十一、Kafka-eagle监控平台</h1><h2 id=\"安装Kafka-eagle\"><a href=\"#安装Kafka-eagle\" class=\"headerlink\" title=\"安装Kafka-eagle\"></a>安装Kafka-eagle</h2><h3 id=\"官网下载压缩包\"><a href=\"#官网下载压缩包\" class=\"headerlink\" title=\"官网下载压缩包\"></a>官网下载压缩包</h3><p><a href=\"http://www.kafka-eagle.org/\">http://www.kafka-eagle.org/</a></p>\n<ul>\n<li>安装jdk</li>\n<li>解压缩后修改配置文件 system-config.properties</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 配置zk  去掉cluster2</span></span><br><span class=\"line\">efak.zk.cluster.alias=cluster1</span><br><span class=\"line\">cluster1.zk.list=172.16.253.35:2181</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> cluster2.zk.list=xdn10:2181,xdn11:2181,xdn12:2181</span></span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 配置mysql</span></span><br><span class=\"line\">kafka.eagle.driver=com.mysql.cj.jdbc.Driver</span><br><span class=\"line\">kafka.eagle.url=jdbc:mysql://172.16.253.22:3306/ke?useUnicode=true&amp;characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNull</span><br><span class=\"line\">kafka.eagle.username=root</span><br><span class=\"line\">kafka.eagle.password= 123456</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>修改/etc/profile</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">export  JAVA_HOME=/usr/local/jdk/jdk1.8.0_191</span><br><span class=\"line\">CLASSPATH=.:$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar</span><br><span class=\"line\">export KE_HOME=/home/aisys/efak-web-2.0.9</span><br><span class=\"line\">export PATH=$PATH:$KE_HOME/bin:$JAVA_HOME/bin</span><br></pre></td></tr></table></figure></li>\n<li><p>刷新配置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">source /etc/profile</span><br></pre></td></tr></table></figure></li>\n<li><p>进入到bin目录，为ke.sh增加可执行的权限</p>\n</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">chmod +x ke.sh</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>启动kafka-eagle<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">./ke.sh start</span><br></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{"bangumis":{"wantWatch":[],"watching":[{"title":"凡人修仙传","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/70d11dfab23a3ee81ccf64f18efa139416a633ff.jpg@220w_280h.webp","totalCount":"未完结","id":28223043,"follow":"615.7 万","view":"8.9 亿","danmaku":"490.9 万","coin":"1186.9 万","score":9.7,"des":"看机智的凡人小子韩立如何稳健发展、步步为营，战魔道、夺至宝、驰骋星海、快意恩仇，成为纵横三界的强者。他日仙界重相逢，一声道友尽沧桑。..."},{"title":"恋爱游戏世界对路人角色很不友好","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/c9723d8c77d881a8debba2852d580e97826b43d0.png@220w_280h.webp","totalCount":"全12话","id":28237300,"follow":"151.2 万","view":"5120.4 万","danmaku":"40.6 万","coin":"24.5 万","score":9.1,"des":"从现代日本转生到“恋爱游戏”世界的里昂，发现这里女尊男卑，对男性很不友好。身为路人角色的他，为了摆脱自己因地位低下而被肆意决定的人生，决定活用从游戏中得到的知识，保持路人角色的身份，取得“失落物品”来..."},{"title":"魔法纪录 魔法少女小圆外传 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/9eef1df9ab157be52d2c4d70d3500442f00cafc3.png@220w_280h.webp","totalCount":"全12话","id":28234642,"follow":"237.1 万","view":"907.6 万","danmaku":"5.0 万","coin":"4.9 万","score":7.7,"des":"愿望的代价，究竟是希望还是绝望——。"},{"title":"小林家的龙女仆 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/847e9dbb6876fb37a30199a5c88910704976d45b.png@220w_280h.webp","totalCount":"全13话","id":28234613,"follow":"855.7 万","view":"1.1 亿","danmaku":"49.0 万","coin":"69.0 万","score":9.6,"des":"那位不可思议的龙女仆再度登场！\n因为各种奇妙的原因而作为小林家的女仆而工作中的龙·托尔。\n偶尔（胡说，是经常）给亲爱的小林添麻烦，总算是融入了人类社会，成为了一个完美的（骗人，也就还行）女仆。\n同样是..."},{"title":"国王排名","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/376d7e69a667bcb1c0b934a4e35e07e7fa23110b.png@220w_280h.webp","totalCount":"全23话","id":28235154,"follow":"927.7 万","view":"4.8 亿","danmaku":"250.1 万","coin":"260.9 万","score":7,"des":"国家的丰饶、麾下勇者的数量、\n以及国王本人如何像勇者一般强大，\n这些要素的综合排名，便是所谓的“国王排名”。\n主人公波吉是国王排名第七名的伯斯王治下王国的第一王子。\n但是波吉却生来又聋又哑，贫弱到挥不..."},{"title":"阿松 第三季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0212baa8898d0c819c7fb84015e95b8fca621435.png@220w_280h.webp","totalCount":"全25话","id":28229892,"follow":"67.6 万","view":"938.0 万","danmaku":"13.0 万","coin":"5.4 万","score":9.6,"des":"日本最有名的六胞胎的传说，第三次开幕！！这次会有怎样意想不到的新展开！？..."},{"title":"命运-冠位指定 冠位时间神殿所罗门","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0e094b798388da19a4feffa6a6dabc1dc1dc90cd.jpg@220w_280h.webp","totalCount":"全1话","id":28236225,"follow":"525.5 万","view":"1220.0 万","danmaku":"8.9 万","coin":"15.1 万","score":8.5,"des":"在经过七个特异点的大战后，\n人理存续保障机关迦勒底，终于到达了圣杯探索的最终地点——终局特异点 冠位时间神殿所罗门。\n他们要击败身为罪魁祸首的魔术王所罗门，夺回未来。\n在开战的前一刻，一行人各自度过了..."},{"title":"JOJO的奇妙冒险 星尘远征军","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/47c0108259355d6d2c517ed97f6b90fb777f844f.png@220w_280h.webp","totalCount":"全24话","id":28223481,"follow":"444.2 万","view":"1.5 亿","danmaku":"463.4 万","coin":"45.7 万","score":9.8,"des":"时为1987年，乔瑟夫·乔斯达与“柱之男”们之间的死战后过了50年……乔瑟夫为了为了帮助“被恶灵附身了”的外孙子·空条承太郎而来到了日本。原来那并不是恶灵而是幽波纹（替身）。替身突然出现的原因在于，从..."},{"title":"JOJO的奇妙冒险 星尘远征军 埃及篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f6709b76e88f50aa132d1e09e2d8de9663a09b3e.png@220w_280h.webp","totalCount":"全24话","id":28223483,"follow":"421.9 万","view":"1.3 亿","danmaku":"468.7 万","coin":"44.3 万","score":9.9,"des":"在乔斯达家的宿敌·迪奥（DIO）复活的影响下，一位年轻人——空条承太郎，得到了名为“幽波纹（替身）”的能力。为了拯救因迪奥的诅咒而倒下的母亲荷莉，空条承太郎与外祖父·乔瑟夫以及伙伴们，一起为了打倒迪奥..."},{"title":"JOJO的奇妙冒险 不灭钻石","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/6a04c87e990ab74cd8d555ef45a863de0993b161.png@220w_280h.webp","totalCount":"全39话","id":140552,"follow":"302.3 万","view":"2.1 亿","danmaku":"813.8 万","coin":"55.9 万","score":9.8,"des":"在埃及与宿敌DIO的死斗之后过了11年。1999年，空条承太郎为了与祖父乔瑟夫·乔斯达的私生子东方仗助见面，而来到了日本M县S市杜王町。但，仗助却持有与承太郎相同的特殊能力“替身”。之后，以承太郎的来..."},{"title":"命运-冠位嘉年华","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/c660976f4502a544d990a882ae62194b57753a71.png@220w_280h.webp","totalCount":"全2话","id":28234639,"follow":"479.8 万","view":"862.4 万","danmaku":"4.1 万","coin":"9.1 万","score":9.8,"des":"一起庆祝吧！为了这奇迹般的嘉年华！"},{"title":"伍六七","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/b69e26d9e50514f3fa99eac9ab5aabf2a6e28c88.jpg@220w_280h.webp","totalCount":"全13话","id":6360,"follow":"585.8 万","view":"3.3 亿","danmaku":"227.1 万","coin":"191.8 万","score":9.8,"des":"在某个小岛上，有一个可以伪装成任何东西的廉价刺客，名叫伍六七。平时看上去是个理发师，其实背地里却做着刺客生意。热爱理发事业，喜欢给人剪头发，善用剪刀——剪刀也是他的刺杀武器。由于初入刺客行当，行情十分..."},{"title":"命运-冠位指定 -月光／失落之室-","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3fa5fd2b7afae827b0bf150d7f0cbfc54eda1ff2.png@220w_280h.webp","totalCount":"全1话","id":28234950,"follow":"483.3 万","view":"551.2 万","danmaku":9696,"coin":"2.9 万","score":9.5,"des":"失落之室——。\n这是一个可以看到被夺去亦或是遗失之物的地方。\n这是位于迦勒底被遗忘的角落，不属于任何人的地方。..."},{"title":"致不灭的你","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/1ae94fbb35d8e23bb84926b694509f8b057f96e6.png@220w_280h.webp","totalCount":"全20话","id":28233896,"follow":"476.3 万","view":"1.3 亿","danmaku":"140.1 万","coin":"95.0 万","score":9.6,"des":"本剧讲述了一个情节跌宕、场面宏大的奇幻故事，通过拥有不灭之身的主人公“不死”来探索人生哲理。\n不死起初是一个被投放到人世间的“球”。\n\n它具有“幻化为刺激源形态的能力”和“死后重生的能力”。\n\n先后从..."},{"title":"来自新世界","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/aaa60f9cb17fb4a38df464f1064ca9623e0769cc.jpg@220w_280h.webp","totalCount":"全25话","id":1598,"follow":"115.9 万","view":"1540.9 万","danmaku":"76.3 万","coin":"5.7 万","score":9.5,"des":"1000年后的日本，孩子们不断地消失，只存在想象中的恐怖动物与人类展开殊死战争。反乌托邦式的未来超级社会“新世界”，是口吐真言凭藉“咒力”就能移动物体的人类，与有着等同于普通人智力的生物“妖鼠”共存的..."},{"title":"转生成蜘蛛又怎样！","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f0796e37abac25ba2aa9f23120646aaa9a3d5ea7.png@220w_280h.webp","totalCount":"全24话","id":28231809,"follow":"600.0 万","view":"3.7 亿","danmaku":"190.3 万","coin":"164.6 万","score":7.8,"des":"曾经是一名女高中生的“我”，突然转生变成了幻想世界中的蜘蛛魔物。\n而且，出生地点还是各种凶恶魔物所盘踞的大迷宫。\n“我”以人类的智慧和非同寻常的积极心态为武器，使用蜘蛛的丝网以及陷阱打倒比自己等级高得..."},{"title":"装甲重拳/MEGALOBOX 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/e14dc4a935397fc074c7a12d9520225615209025.png@220w_280h.webp","totalCount":"全13话","id":28233916,"follow":"244.9 万","view":"3435.4 万","danmaku":"19.7 万","coin":"53.1 万","score":9.9,"des":"再一次，为梦想而活——\n\n将肉体与“装甲技术”融合的究极格斗技“装甲拳击”。\n在决出其顶点之人的大会“重拳之巅”上，身穿装甲用自己肉身挑战一切的拳击手“JOE”。\n\n从最下层的比赛开始仅仅花了三个月就..."},{"title":"机动战士高达SEED HD","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/855c88677267d707ebfe4040403692ff2c0938f0.png@220w_280h.webp","totalCount":"全48话","id":497,"follow":"54.8 万","view":"4044.4 万","danmaku":"114.4 万","coin":"6.0 万","score":9.6,"des":"《机动战士高达SEED》是高达系列在2002年至2003年度放映的动画。续作为《机动战士高达SEED Destiny》在2004年播放。因各具魅力的角色，明星云集的声优阵容和高度商业化的宣传而受到较低..."},{"title":"夏目友人帐 唤石者与怪异的访客","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6cf43708b779cde84ad285ff4e3a080de98df0af.png@220w_280h.webp","totalCount":"全1话","id":28234316,"follow":"567.1 万","view":"1374.8 万","danmaku":"18.1 万","coin":"17.9 万","score":9.9,"des":"本作由【唤石者】与【怪异的访客】两个人气短篇集锦而成。讲述生来便能看见各种妖怪的夏目，与自称保镖的猫咪老师一同邂逅的一系列温暖故事。\n【唤石者】一天夏目在森林中遇到一只小妖怪——密实。密实称自己肩负「..."},{"title":"Fate/Grand Order ‐First Order‐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/b75c55d209d156c8631f5ceb21e5c52c834dbb60.jpg@220w_280h.webp","totalCount":"全1话","id":5747,"follow":"250.9 万","view":"3329.7 万","danmaku":"76.7 万","coin":"10.7 万","score":8.3,"des":"【2016年12月31日bilibili独播】2015年。示巴所观测到的未来领域毫无前兆地消失。根据计算，发现——不，是证明了人类将于2017年灭绝。人理延续保障机构·迦勒底将“无法观测的领域”假定为..."},{"title":"伍六七之玄武国篇","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/00843865ea13702eccc4efd64c313fd4c8029c6b.jpg@220w_280h.webp","totalCount":"全10话","id":28232253,"follow":"999.4 万","view":"4.0 亿","danmaku":"177.7 万","coin":"385.3 万","score":9.8,"des":"为了保护小鸡岛居民和这里平静的生活，伍六七和他的伙伴大保和小飞开启了去往玄武国的冒险旅程，去寻找身世的真相和解救小岛的办法，等待他们的又将是更多的未知与奇遇。..."},{"title":"堀与宫村","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/039c4e0b14e27c7a9e5cce2f20a6efd3c8909401.png@220w_280h.webp","totalCount":"全13话","id":28231840,"follow":"695.2 万","view":"2.2 亿","danmaku":"242.1 万","coin":"361.4 万","score":9.8,"des":"不论是谁，都会有不想被人知道的一面。\n\n在学校中漂亮大方、成绩优秀的人气女生堀，私下却打扮土气、忙于家务和照顾弟弟。\n在学校中是阴暗宅男形象的宫村，生活中却是打扮时尚、带耳钉的帅气男生。\n因为一次特别..."},{"title":"奇蛋物语 / WONDER EGG PRIORITY","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/10e0bbc1047b2c45f0f881de334a6f3bfb42a3b6.png@220w_280h.webp","totalCount":"全12话","id":28231851,"follow":"254.9 万","view":"4686.8 万","danmaku":"47.6 万","coin":"65.5 万","score":9.7,"des":"14岁少女·大户爱在深夜散步的途中，\n随着神秘声音的指引，获得了一枚「蛋」。\n\n「如果想要改变世界的话」\n「那么就在现在做出选择」\n「请相信自己——」\n「打破这枚蛋——」\n\n而在打破「蛋」之后，等待着..."},{"title":"Re：从零开始的异世界生活 第二季 后半","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/4f3edbede7fc0bdb52842075cf8faaa1c5953eaa.png@220w_280h.webp","totalCount":"全12话","id":28232073,"follow":"849.9 万","view":"9308.1 万","danmaku":"108.1 万","coin":"230.1 万","score":9.9,"des":"我一定会拯救你。\n在打倒了魔女教大罪司教「怠惰」担当——培提其乌斯·罗曼尼康帝之后，菜月昴和爱蜜莉雅又得以重新开始。\n克服了艰难的诀别，两人终于和解，然而这只是新一轮风波的序幕。\n超乎想象的绝境危机，..."},{"title":"灰与幻想的格林姆迦尔","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/7fb4945f864e9e988212b7d20f206df2677053f8.jpg@220w_280h.webp","totalCount":"全12话","id":106512,"follow":"172.0 万","view":"2343.4 万","danmaku":"63.8 万","coin":"18.3 万","score":9.8,"des":"电视动画《灰与幻想的格林姆迦尔》改编自日本轻小说家十文字青原作白井锐利插画的同名轻小说。\n我们为什么要这么做…？\n哈尔希洛回过神来，才发现自己身处在黑暗当中，他完全不知道自己人在何处，也不明白这个地方..."},{"title":"龙与虎","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/144910805f172d16c5f544f43939a05d8ca20576.jpg@220w_280h.webp","totalCount":"全26话","id":1672,"follow":"336.9 万","view":"6671.9 万","danmaku":"511.9 万","coin":"61.5 万","score":9.7,"des":"樱花飞舞的四月，全新的高中二年级，新的班级……\n眼神凶恶的普通男孩——高须龙儿，遇上了众人害怕、凶暴残忍的“掌中老虎”逢坂大河，还知道了她不欲为人知的秘密。这就是龙虎相争爱与战斗的序幕。\n再加上总是笑..."},{"title":"机动战士高达 铁血的奥尔芬斯 第一季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/f84a80d731d0431c00903d8951fd66623d8237f7.png@220w_280h.webp","totalCount":"全25话","id":4310042,"follow":"62.4 万","view":"2318.6 万","danmaku":"52.2 万","coin":"5.4 万","score":9.5,"des":"主人公三日月·奥古斯，从所属的民间警备公司克律塞安保公司（下称CGS）那里，接受了对少女库德莉亚·蓝那·伯恩斯坦的护卫任务。但CGS受到了摘取反叛之芽的武力组织加拉尔霍恩的袭击，于是在把三日月当做诱饵..."},{"title":"机动战士高达00 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1d7a969e8f1045739c596de89a963e30475aff0e.jpg@220w_280h.webp","totalCount":"全25话","id":1193,"follow":"37.2 万","view":"2458.1 万","danmaku":"61.4 万","coin":"4.1 万","score":9.8,"des":"天人与联合国军的最终决战后过了四年。建立地球联邦政府的人类，为了追求更进一步的国家间之统合，以及人类意识的统一，在联合正规军之外，设立了独立治安维持部队“A-Laws”，目的为对所有危害联合的势力与主..."},{"title":"机动战士高达00","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/35b11bf59eb3fd12f0387951510a5d722d7435e5.jpg@220w_280h.webp","totalCount":"全25话","id":1192,"follow":"62.1 万","view":"2465.5 万","danmaku":"53.6 万","coin":"4.6 万","score":9.7,"des":"在西历2307年，虽然化石燃料枯竭了，但是人类得到了截然不同的新型能源。三台巨大的轨道升降机以及伴随它们的大规模的太阳光发电系统。但是能得到这个系统恩惠的，只有一部分大国和其同盟国而已。\n拥有三台轨道..."},{"title":"Re：从零开始的异世界生活 第二季 前半","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f2425cbdb07cc93bd0d3ba1c0099bfe78f5dc58a.png@220w_280h.webp","totalCount":"全13话","id":28229233,"follow":"774.2 万","view":"1.3 亿","danmaku":"201.4 万","coin":"126.7 万","score":9.7,"des":"我一定会拯救你。\n在打倒了魔女教大罪司教「怠惰」担当——培提其乌斯·罗曼尼康帝之后，菜月昴和爱蜜莉雅又得以重新开始。\n克服了艰难的诀别，两人终于和解，然而这只是新一轮风波的序幕。\n超乎想象的绝境危机，..."},{"title":"超级小白","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3d3e8257d22596f5d3e4395ca759bd1e0fe9b873.jpg@220w_280h.webp","totalCount":"全48话","id":28222671,"follow":"27.4 万","view":"978.0 万","danmaku":"3.6 万","coin":"3.6 万","score":9.6,"des":"为了阻止企图霸占世界的黑暗势力，野原家的普通小狗——小白接肩负重大使命，变身成为了守护世界的“超级小白”。小白将要面对的不仅是发明狗，还有其他意想不到的对手。当然，面对邪恶势力，小白也有着令人惊讶的超..."},{"title":"Re：从零开始的异世界生活 新编集版","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3c125e1aad08643e3eff2fb7d45e740c1a052725.png@220w_280h.webp","totalCount":"全13话","id":28224394,"follow":"631.1 万","view":"7674.2 万","danmaku":"166.2 万","coin":"51.1 万","score":9.6,"des":"在从便利商店回家的路上，突然被异世界召唤的少年菜月昴。在无法依靠任何东西的异世界，无力的少年手唯一的力量……那是“死去然后重新开始”的力量。为了守护最重要的人们，为了取回确实存在着又无可替代的时间，少..."},{"title":"因为太怕痛就全点防御力了","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/8021d3f6b0df6dbba6d32f76eb9cfe2531e166c4.png@220w_280h.webp","totalCount":"全12话","id":28224137,"follow":"620.6 万","view":"2.3 亿","danmaku":"326.8 万","coin":"103.8 万","score":9,"des":"主角本条枫在好友白峰理沙推荐下开始游玩游戏“NewWorld Online”，创建了名为“梅普露”的角色。然而作为游戏初学者，梅普露选择了不受欢迎的大盾当武器，同时因为怕痛而把所有状态点加到防御力的极..."},{"title":"冰海战记","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/c30401817895e67399094b4e669785a104270cdf.jpg@220w_280h.webp","totalCount":"全24话","id":28220475,"follow":"174.4 万","view":"4893.8 万","danmaku":"48.7 万","coin":"36.7 万","score":9.8,"des":"公元10世纪末期，出现了在世界各地出没的最强民族。被讴歌为最强战士的托尔兹，其子托尔芬幼时便生活在战场上，并向往着梦幻大陆“文兰”。这是一个发生在激荡时代的，真正的英雄物语。..."},{"title":"齐木楠雄的灾难 始动篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ba59822eded39b5254fb01448a7f1502101d5624.png@220w_280h.webp","totalCount":"全6话","id":28223748,"follow":"372.4 万","view":"3054.5 万","danmaku":"20.0 万","coin":"17.8 万","score":9.8,"des":"在电视剧中堪称帅气的超能力，对于高中生齐木楠雄来说只是招致灾难的元凶。作为新动画系列展开的楠雄的日常又会如何！？..."},{"title":"OVERLORD Ⅱ","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/851f979c8ebcc7583a43abd4b786c4e2e66b746b.jpg@220w_280h.webp","totalCount":"全13话","id":8792,"follow":"539.3 万","view":"3.8 亿","danmaku":"413.9 万","coin":"114.1 万","score":9.6,"des":"时为2138年。曾卷起一大风潮的虚拟现实体感型网络游戏《YGGDRASIL》即将迎来停服。玩家飞鼠在曾经以同伴和荣华自傲的根据地纳萨力克地下大坟墓，独自一人安静等待着那一刻。但是，不料发生了结束时间已..."},{"title":"夏目友人帐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/99c549494d9425f6455bd45a151f4d26397d6151.png@220w_280h.webp","totalCount":"全13话","id":1660,"follow":"324.0 万","view":"4975.2 万","danmaku":"278.7 万","coin":"15.5 万","score":9.8,"des":"夏目贵志生来拥有强大的灵力，能感知平常人所无法接触的妖怪神明的存在。因父母双亡，他多年间辗转于互相推卸责任的亲戚之间，又受到同龄人的欺负，未曾与任何人深交，造成性格一定程度上的孤僻。夏目本性和善，对于..."}],"watched":[{"title":"装甲重拳/MEGALOBOX","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0c44785cb5d25cc9f648800d251f21a2e236bb8a.png@220w_280h.webp","totalCount":"全13话","id":79472,"follow":"221.9 万","view":"6162.0 万","danmaku":"48.6 万","coin":"32.9 万","score":9.8,"des":"将肉体与“装甲技术”融合的究极格斗技——“MEGALOBOX”，将自己的全部赌在上面的男人们的热血战斗开始！\n今天也立于未认可地区的赌博比赛赛场上的MEGALO拳击手“JNK DOG”。虽然具备实力，..."},{"title":"超能力女儿","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/152c536f8ecaad8f3d7d568d33da81c963a4a722.png@220w_280h.webp","totalCount":"全12话","id":78352,"follow":"293.8 万","view":"9252.2 万","danmaku":"98.5 万","coin":"35.4 万","score":9.6,"des":"支持着芦川组的年轻智力型黑道新田义史，过着被喜欢的壶所包围的悠然自得单身生活。但某一天，随着装在神秘物体里的少女雏来到他家，他的生活为之一变。他被能使用念动力的雏所胁迫，迫不得已开始和她同居！\n容易暴..."},{"title":"OVERLORD Ⅲ","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/dd7a9d0a0bee32b1f43c2656398d8463d12b3069.jpg@220w_280h.webp","totalCount":"全13话","id":102252,"follow":"551.6 万","view":"4.0 亿","danmaku":"399.7 万","coin":"129.2 万","score":9.4,"des":"时间为2138年。曾卷起一大风潮的虚拟现实体感型网络游戏《YGGDRASIL》即将迎来停服。玩家飞鼠在曾经以同伴和荣华自傲的根据地纳萨力克地下大坟墓，独自一人安静等待着那一刻。\n但是，不料发生了“过了..."},{"title":"路人超能100 第一次灵能咨询所员工旅游～舒缓心灵的疗愈之旅~（OVA2）","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/1271324d51634b68980704731987724a1afc60aa.jpg@220w_280h.webp","totalCount":"全1话","id":28222715,"follow":"318.8 万","view":"520.7 万","danmaku":"3.6 万","coin":"4.6 万","score":9.8,"des":"由原作ONE老师担任原案的完全新作OVA！「灵能咨询所」一行人，龙套与灵幻、小酒窝以及新同伴芹泽的目的地，正是缟马县深山中鲜为人知的温泉·疣神温泉。因为灵幻接受了旅馆老板娘的委托，「弄清温泉的恐怖传闻..."},{"title":"少女终末旅行","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1431ca5bb2f7143062e3df8f21b8448cf8cccc13.jpg@220w_280h.webp","totalCount":"全12话","id":6463,"follow":"239.8 万","view":"3714.7 万","danmaku":"100.7 万","coin":"37.2 万","score":9.8,"des":"本作舞台在人类繁华的文明迎来终结的很久以后，人类基本灭绝，甚至生物都不再存在的末日世界。复杂够高的都市成为迷宫般的废墟，得不到维护的机械渐渐停止运转。连何时终结了，何时开始终结的思考都不复存在的这个世..."},{"title":"齐木楠雄的灾难（日播&精选版）","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/eb4f17335f48951945fb9da47e6ee0bc65fa2fbb.jpg@220w_280h.webp","totalCount":"全120话","id":5070,"follow":"187.0 万","view":"2.3 亿","danmaku":"130.7 万","coin":"32.7 万","score":9.6,"des":"高中生·齐木楠雄是超能力者。心灵感应、念动力、透视、预知、瞬间移动、千里眼等，不论任何事情都自由自在。但这任谁都羡慕不已的最强能力，实际上对于本人而言是引来灾难的不幸元凶。因此，他在别人面前封印了超能..."},{"title":"比宇宙更远的地方","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/c9eca3cbc386c63b27461074b8b218898cb7440e.jpg@220w_280h.webp","totalCount":"全13话","id":13032,"follow":"156.0 万","view":"2298.0 万","danmaku":"45.9 万","coin":"23.9 万","score":9.8,"des":"无论何时，我们的第一步总是从好奇心开始。\n不曾看过的风景，不曾听过的声音，不曾闻过的味道，不曾摸过的质感，不曾尝过的食物，以及不曾感受过的澎湃。\n为了重拾不知何时忘却的记忆碎片和不知何时舍弃的感动的旅..."},{"title":"OVERLORD","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/b8e72ea69e57e0b7ac85d8b4d366554fd866df1a.jpg@220w_280h.webp","totalCount":"全13话","id":2576,"follow":"626.2 万","view":"4.1 亿","danmaku":"385.2 万","coin":"84.4 万","score":9.6,"des":"作品主要讲述了某天，一款曾经掀起过大热潮的VRMMORPG「YGGDRASIL」停止了运营。游戏原本会停止一切服务，但过了结束时间后，玩家们却发现不能退出，NPC也产生了各自的思想。现实世界中喜爱电玩..."},{"title":"路人超能100 II(灵能百分百 第二季)","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/216e1bdaf88244215a13b1154116805ee9adbe07.png@220w_280h.webp","totalCount":"全13话","id":4762734,"follow":"284.9 万","view":"1.0 亿","danmaku":"97.8 万","coin":"56.1 万","score":9.9,"des":"当有什么东西达到“100”的时候，就会爆发的少年·路人（龙套）。外表极其普通——不如说是不起眼。不擅长迎合气氛的他，实际上拥有着强力的超能力。盯上了这样的他的能力，而接连现身的伪灵能力者以及宗教团体、..."},{"title":"多罗罗","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3fc16a667502cbff226e585eb660a96a20c7458c.png@220w_280h.webp","totalCount":"全24话","id":4312482,"follow":"452.1 万","view":"1.8 亿","danmaku":"143.9 万","coin":"73.9 万","score":9.4,"des":"他们向着命运抗争，在那尽头等待他们的是人心，还是业障。\n时值乱世。\n名为景光的醍醐将军，向某个寺庙殿堂中的12尊魔神像祈求早日结束战乱。\n作为代价，他的嫡子在出生时就失去了身体的某些部位，被丢弃在河流..."},{"title":"魔法少女小圆","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/7fcaa0e98b561611538ae4deba7949cec4ca39a8.png@220w_280h.webp","totalCount":"全12话","id":2539,"follow":"218.7 万","view":"4199.0 万","danmaku":"201.5 万","coin":"20.0 万","score":9.8,"des":"就读初中二年级的鹿目圆，过着平凡幸福的生活。神秘转学生晓美焰的出现，开始让小圆的命运有了巨大转变。某日一只名为丘比的神秘生物，希望小圆能够与它签订魔法契约，成为“魔法少女”以对抗邪恶的魔女保护世界。正..."}]},"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h1 id=\"消息队列的流派\"><a href=\"#消息队列的流派\" class=\"headerlink\" title=\"消息队列的流派\"></a>消息队列的流派</h1><h3 id=\"什么是-MQ\"><a href=\"#什么是-MQ\" class=\"headerlink\" title=\"什么是 MQ\"></a>什么是 MQ</h3><blockquote>\n<p>Message Queue（MQ），消息队列中间件。很多人都说：MQ 通过将消息的发送和接收分离来实现应用程序的异步和解偶，这个给人的直觉是——MQ 是异步的，用来解耦的，但是这个只是 MQ 的效果而不是目的。MQ 真正的目的是为了通讯，屏蔽底层复杂的通讯协议，定义了一套应用层的、更加简单的通讯协议。一个分布式系统中两个模块之间通讯要么是HTTP，要么是自己开发的（rpc） TCP，但是这两种协议其实都是原始的协议。HTTP 协议很难实现两端通讯——模块 A 可以调用 B，B 也可以主动调用 A，如果要做到这个两端都要背上WebServer，而且还不支持⻓连接（HTTP 2.0 的库根本找不到）。TCP 就更加原始了，粘包、心跳、私有的协议，想一想头皮就发麻。MQ 所要做的就是在这些协议之上构建一个简单的“协议”——生产者/消费者模型。MQ 带给我的“协议”不是具体的通讯协议，而是更高层次通讯模型。它定义了两个对象——发送数据的叫生产者；接收数据的叫消费者， 提供一个SDK 让我们可以定义自己的生产者和消费者实现消息通讯而无视底层通讯协议</p>\n</blockquote>\n<h3 id=\"有-Broker-的-MQ\"><a href=\"#有-Broker-的-MQ\" class=\"headerlink\" title=\"有 Broker 的 MQ\"></a>有 Broker 的 MQ</h3><blockquote>\n<p>这个流派通常有一台服务器作为 Broker，所有的消息都通过它中转。生产者把消息发送给它就结束自己的任务了，Broker 则把消息主动推送给消费者（或者消费者主动轮询）</p>\n</blockquote>\n<h3 id=\"重-Topic\"><a href=\"#重-Topic\" class=\"headerlink\" title=\"重 Topic\"></a>重 Topic</h3><blockquote>\n<p>kafka、JMS（ActiveMQ）就属于这个流派，生产者会发送 key 和数据到 Broker，由 Broker比较 key 之后决定给哪个消费者。这种模式是我们最常⻅的模式，是我们对 MQ 最多的印象。在这种模式下一个 topic 往往是一个比较大的概念，甚至一个系统中就可能只有一个topic，topic 某种意义上就是 queue，生产者发送 key 相当于说：“hi，把数据放到 key 的队列中”</p>\n</blockquote>\n<blockquote>\n<p>如上图所示，Broker 定义了三个队列，key1，key2，key3，生产者发送数据的时候会发送key1 和 data，Broker 在推送数据的时候则推送 data（也可能把 key 带上）。</p>\n</blockquote>\n<blockquote>\n<p>虽然架构一样但是 kafka 的性能要比 jms 的性能不知道高到多少倍，所以基本这种类型的MQ 只有 kafka 一种备选方案。如果你需要一条暴力的数据流（在乎性能而非灵活性）那么kafka 是最好的选择</p>\n</blockquote>\n<h3 id=\"轻-Topic\"><a href=\"#轻-Topic\" class=\"headerlink\" title=\"轻 Topic\"></a>轻 Topic</h3><blockquote>\n<p>这种的代表是 RabbitMQ（或者说是 AMQP）。生产者发送 key 和数据，消费者定义订阅的队列，Broker 收到数据之后会通过一定的逻辑计算出 key 对应的队列，然后把数据交给队列</p>\n</blockquote>\n<blockquote>\n<p>这种模式下解耦了 key 和 queue，在这种架构中 queue 是非常轻量级的（在 RabbitMQ 中它的上限取决于你的内存），消费者关心的只是自己的 queue；生产者不必关心数据最终给谁只要指定 key 就行了，中间的那层映射在 AMQP 中叫 exchange（交换机）。</p>\n</blockquote>\n<p>AMQP 中有四种 exchange</p>\n<ul>\n<li>Direct exchange：key 就等于 queue</li>\n<li>Fanout exchange：无视 key，给所有的 queue 都来一份</li>\n<li>Topic exchange：key 可以用“宽字符”模糊匹配 queue</li>\n<li>Headers exchange：无视 key，通过查看消息的头部元数据来决定发给那个</li>\n<li>queue（AMQP 头部元数据非常丰富而且可以自定义）</li>\n</ul>\n<p>这种结构的架构给通讯带来了很大的灵活性，我们能想到的通讯方式都可以用这四种exchange 表达出来。如果你需要一个企业数据总线（在乎灵活性）那么 RabbitMQ 绝对的值得一用</p>\n<h3 id=\"无-Broker-的-MQ\"><a href=\"#无-Broker-的-MQ\" class=\"headerlink\" title=\"无 Broker 的 MQ\"></a>无 Broker 的 MQ</h3><blockquote>\n<p>无 Broker 的 MQ 的代表是 ZeroMQ。该作者非常睿智，他非常敏锐的意识到——MQ 是更高级的 Socket，它是解决通讯问题的。所以 ZeroMQ 被设计成了一个“库”而不是一个中间件，这种实现也可以达到——没有 Broker 的目的</p>\n</blockquote>\n<blockquote>\n<p>节点之间通讯的消息都是发送到彼此的队列中，每个节点都既是生产者又是消费者。ZeroMQ做的事情就是封装出一套类似于 Socket 的 API 可以完成发送数据，读取数据</p>\n</blockquote>\n<blockquote>\n<p>ZeroMQ 其实就是一个跨语言的、重量级的 Actor 模型邮箱库。你可以把自己的程序想象成一个 Actor，ZeroMQ 就是提供邮箱功能的库；ZeroMQ 可以实现同一台机器的 RPC 通讯也可以实现不同机器的 TCP、UDP 通讯，如果你需要一个强大的、灵活、野蛮的通讯能力，别犹豫 ZeroMQ</p>\n</blockquote>\n<h1 id=\"一、Kafka介绍\"><a href=\"#一、Kafka介绍\" class=\"headerlink\" title=\"一、Kafka介绍\"></a>一、Kafka介绍</h1><blockquote>\n<p>Kafka是最初由Linkedin公司开发，是一个分布式、支持分区的（partition）、多副本的<br>（replica），基于zookeeper协调的分布式消息系统，它的最大的特性就是可以实时的处理<br>大量数据以满足各种需求场景：比如基于hadoop的批处理系统、低延迟的实时系统、<br>Storm/Spark流式处理引擎，web/nginx日志、访问日志，消息服务等等，用scala语言编<br>写，Linkedin于 2010 年贡献给了Apache基金会并成为顶级开源 项目。</p>\n</blockquote>\n<h2 id=\"1-Kafka的使用场景\"><a href=\"#1-Kafka的使用场景\" class=\"headerlink\" title=\"1.Kafka的使用场景\"></a>1.Kafka的使用场景</h2><blockquote>\n<p>日志收集：一个公司可以用Kafka收集各种服务的log，通过kafka以统一接口服务的方式<br>开放给各种consumer，例如hadoop、Hbase、Solr等。<br>消息系统：解耦和生产者和消费者、缓存消息等。<br>用户活动跟踪：Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网⻚、<br>搜索、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过<br>订阅这些topic来做实时的监控分析，或者装载到hadoop、数据仓库中做离线分析和挖<br>掘。<br>运营指标：Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产<br>各种操作的集中反馈，比如报警和报告。</p>\n</blockquote>\n<h2 id=\"2-Kafka基本概念\"><a href=\"#2-Kafka基本概念\" class=\"headerlink\" title=\"2.Kafka基本概念\"></a>2.Kafka基本概念</h2><blockquote>\n<p>kafka是一个分布式的，分区的消息(官方称之为commit log)服务。它提供一个消息系统应该<br>具备的功能，但是确有着独特的设计。可以这样来说，Kafka借鉴了JMS规范的思想，但是确<br>并 <code>没有完全遵循JMS规范。</code></p>\n</blockquote>\n<p>首先，让我们来看一下基础的消息(Message)相关术语：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th align=\"center\">解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Broker</td>\n<td align=\"center\">消息中间件处理节点，⼀个Kafka节点就是⼀个broker，⼀个或者多个Broker可以组成⼀个Kafka集群</td>\n</tr>\n<tr>\n<td>Topic</td>\n<td align=\"center\">Kafka根据topic对消息进⾏归类，发布到Kafka集群的每条消息都需要指定⼀个topic</td>\n</tr>\n<tr>\n<td>Producer</td>\n<td align=\"center\">消息⽣产者，向Broker发送消息的客户端</td>\n</tr>\n<tr>\n<td>Consumer</td>\n<td align=\"center\">消息消费者，从Broker读取消息的客户端</td>\n</tr>\n<tr>\n<td>ConsumerGroup</td>\n<td align=\"center\">每个Consumer属于⼀个特定的Consumer Group，⼀条消息可以被多个不同的Consumer Group消费，但是⼀个Consumer Group中只能有⼀个Consumer能够消费该消息</td>\n</tr>\n<tr>\n<td>Partition</td>\n<td align=\"center\">物理上的概念，⼀个topic可以分为多个partition，每个partition内部消息是有序的</td>\n</tr>\n</tbody></table>\n<p>因此，从一个较高的层面上来看，producer通过网络发送消息到Kafka集群，然后consumer<br>来进行消费，如下图：</p>\n<img src=\"/2022/07/10/Kafka/QQ%E6%88%AA%E5%9B%BE20220110112502.png\" class title=\"输入图片说明\">\n\n<p>服务端(brokers)和客户端(producer、consumer)之间通信通过 <strong>TCP协议</strong> 来完成。</p>\n<h1 id=\"二、kafka基本使用\"><a href=\"#二、kafka基本使用\" class=\"headerlink\" title=\"二、kafka基本使用\"></a>二、kafka基本使用</h1><h2 id=\"1-安装前的环境准备\"><a href=\"#1-安装前的环境准备\" class=\"headerlink\" title=\"1.安装前的环境准备\"></a>1.安装前的环境准备</h2><ul>\n<li><p>安装jdk</p>\n</li>\n<li><p>安装zk</p>\n</li>\n<li><p>官网下载kafka的压缩包:<a href=\"http://kafka.apache.org/downloads\">http://kafka.apache.org/downloads</a></p>\n</li>\n<li><p>解压缩至如下路径</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">/usr/local/kafka/</span><br></pre></td></tr></table></figure></li>\n<li><p>修改配置文件：/usr/local/kafka/kafka2.11-2.4/config/server.properties</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">broker.id属性在kafka集群中必须要是唯一</span></span><br><span class=\"line\">broker.id= 0</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">kafka部署的机器ip和提供服务的端口号</span></span><br><span class=\"line\">listeners=PLAINTEXT://192.168.65.60:9092</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">kafka的消息存储文件</span></span><br><span class=\"line\">log.dir=/usr/local/data/kafka-logs</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">kafka连接zookeeper的地址</span></span><br><span class=\"line\">zookeeper.connect= 192.168.65.60:2181</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-启动kafka服务器\"><a href=\"#2-启动kafka服务器\" class=\"headerlink\" title=\"2.启动kafka服务器\"></a>2.启动kafka服务器</h2></li>\n</ul>\n<p>进入到bin目录下。使用命令来启动</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">./kafka-server-start.sh -daemon../config/server.properties</span><br></pre></td></tr></table></figure>\n<p>验证是否启动成功：</p>\n<p>进入到zk中的节点看id是 0 的broker有没有存在（上线）</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">ls /brokers/ids/</span><br></pre></td></tr></table></figure>\n<p><strong>server.properties核心配置详解：</strong></p>\n<table>\n<thead>\n<tr>\n<th>Property</th>\n<th align=\"left\">Default</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>broker.id</td>\n<td align=\"left\">0</td>\n<td align=\"left\">每个broker都可以⽤⼀个唯⼀的⾮负整数id进⾏标识；这个id可以作为broker的“名字”，你可以选择任意你喜欢的数字作为id，只要id是唯⼀的即可。</td>\n</tr>\n<tr>\n<td>log.dirs</td>\n<td align=\"left\">/tmp/kafka-logs</td>\n<td align=\"left\">kafka存放数据的路径。这个路径并不是唯⼀的，可以是多个，路径之间只需要使⽤逗号分隔即可；每当创建新partition时，都会选择在包含最少partitions的路径下进⾏。</td>\n</tr>\n<tr>\n<td>listeners</td>\n<td align=\"left\">PLAINTEXT://192.168.65.60:9092</td>\n<td align=\"left\">server接受客户端连接的端⼝，ip配置kafka本机ip即可</td>\n</tr>\n<tr>\n<td>zookeeper.connect</td>\n<td align=\"left\">localhost:2181</td>\n<td align=\"left\">zooKeeper连接字符串的格式为：hostname:port，此处hostname和port分别是ZooKeeper集群中某个节点的host和port；zookeeper如果是集群，连接⽅式为hostname1:port1, hostname2:port2,hostname3:port3</td>\n</tr>\n<tr>\n<td>log.retention.hours</td>\n<td align=\"left\">168</td>\n<td align=\"left\">每个⽇志⽂件删除之前保存的时间。默认数据保存时间对所有topic都⼀样。</td>\n</tr>\n<tr>\n<td>num.partitions</td>\n<td align=\"left\">1</td>\n<td align=\"left\">创建topic的默认分区数</td>\n</tr>\n<tr>\n<td>default.replication.factor</td>\n<td align=\"left\">1</td>\n<td align=\"left\">⾃动创建topic的默认副本数量，建议设置为⼤于等于2</td>\n</tr>\n<tr>\n<td>min.insync.replicas</td>\n<td align=\"left\">1</td>\n<td align=\"left\">当producer设置acks为-1时，min.insync.replicas指定replicas的最⼩数⽬（必须确认每⼀个repica的写数据都是成功的），如果这个数⽬没有达到，producer发送消息会产⽣异常</td>\n</tr>\n<tr>\n<td>delete.topic.enable</td>\n<td align=\"left\">false</td>\n<td align=\"left\">是否允许删除主题</td>\n</tr>\n</tbody></table>\n<h2 id=\"3-创建主题topic\"><a href=\"#3-创建主题topic\" class=\"headerlink\" title=\"3.创建主题topic\"></a>3.创建主题topic</h2><blockquote>\n<p>topic是什么概念？topic可以实现消息的分类，不同消费者订阅不同的topic。</p>\n</blockquote>\n<img src=\"/2022/07/10/Kafka/QQ%E6%88%AA%E5%9B%BE20220110122844.png\" class title=\"输入图片说明\">\n\n<p>执行以下命令创建名为“test”的topic，这个topic只有一个partition，并且备份因子也设置为1</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">./kafka-topics.sh --create --zookeeper 172.16.253.35:2181 --replication-factor 1 --partitions 1 --topic test</span><br></pre></td></tr></table></figure>\n<p>查看当前kafka内有哪些topic</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">./kafka-topics.sh --list --zookeeper 172.16.253.35:2181</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-发送消息\"><a href=\"#4-发送消息\" class=\"headerlink\" title=\"4.发送消息\"></a>4.发送消息</h2><blockquote>\n<p>kafka自带了一个producer命令客户端，可以从本地文件中读取内容，或者我们也可以以命令行中直接输入内容，并将这些内容以消息的形式发送到kafka集群中。在默认情况下，每一个行会被当做成一个独立的消息。使用kafka的发送消息的客户端，指定发送到的kafka服务器地址和topic</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">./kafka-console-producer.sh --broker-list 172.16.253.38:9092 --topic test</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-消费消息\"><a href=\"#5-消费消息\" class=\"headerlink\" title=\"5.消费消息\"></a>5.消费消息</h2><p>对于consumer，kafka同样也携带了一个命令行客户端，会将获取到内容在命令中进行输<br>出， <strong>默认是消费最新的消息</strong> 。使用kafka的消费者消息的客户端，从指定kafka服务器的指定<br>topic中消费消息</p>\n<p>方式一：从最后一条消息的偏移量+1开始消费</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">./kafka-console-consumer.sh --bootstrap-server 172.16.253.38:9092 --topic test</span><br></pre></td></tr></table></figure>\n<p>方式二：从头开始消费</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">./kafka-console-consumer.sh --bootstrap-server 172.16.253.38:9092 --from-beginning --topic test</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"几个注意点：\"><a href=\"#几个注意点：\" class=\"headerlink\" title=\"几个注意点：\"></a>几个注意点：</h3><ul>\n<li>消息会被存储</li>\n<li>消息是顺序存储</li>\n<li>消息是有偏移量的</li>\n<li>消费时可以指明偏移量进行消费</li>\n</ul>\n<h1 id=\"三、Kafka中的关键细节\"><a href=\"#三、Kafka中的关键细节\" class=\"headerlink\" title=\"三、Kafka中的关键细节\"></a>三、Kafka中的关键细节</h1><h2 id=\"1-消息的顺序存储\"><a href=\"#1-消息的顺序存储\" class=\"headerlink\" title=\"1.消息的顺序存储\"></a>1.消息的顺序存储</h2><blockquote>\n<p>消息的发送方会把消息发送到broker中，broker会存储消息，消息是按照发送的顺序进行存储。因此消费者在消费消息时可以指明主题中消息的偏移量。默认情况下，是从最后一个消息的下一个偏移量开始消费。</p>\n</blockquote>\n<h2 id=\"2-单播消息的实现\"><a href=\"#2-单播消息的实现\" class=\"headerlink\" title=\"2. 单播消息的实现\"></a>2. 单播消息的实现</h2><blockquote>\n<p>单播消息：一个消费组里 只会有一个消费者能消费到某一个topic中的消息。于是可以创建多个消费者，这些消费者在同一个消费组中。</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">./kafka-console-consumer.sh --bootstrap-server 10.31.167.10:9092 --consumer-property group.id=testGroup --topic test</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-多播消息的实现\"><a href=\"#3-多播消息的实现\" class=\"headerlink\" title=\"3.多播消息的实现\"></a>3.多播消息的实现</h2><h3 id=\"在一些业务场景中需要让一条消息被多个消费者消费，那么就可以使用多播模式。\"><a href=\"#在一些业务场景中需要让一条消息被多个消费者消费，那么就可以使用多播模式。\" class=\"headerlink\" title=\"在一些业务场景中需要让一条消息被多个消费者消费，那么就可以使用多播模式。\"></a>在一些业务场景中需要让一条消息被多个消费者消费，那么就可以使用多播模式。</h3><p>kafka实现多播，只需要让不同的消费者处于不同的消费组即可。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">./kafka-console-consumer.sh --bootstrap-server 10.31.167.10:9092 --consumer-property group.id=testGroup1 --topic test</span><br><span class=\"line\"></span><br><span class=\"line\">./kafka-console-consumer.sh --bootstrap-server 10.31.167.10:9092 --consumer-property group.id=testGroup2 --topic test</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-查看消费组及信息\"><a href=\"#4-查看消费组及信息\" class=\"headerlink\" title=\"4.查看消费组及信息\"></a>4.查看消费组及信息</h2><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 查看当前主题下有哪些消费组</span></span><br><span class=\"line\">./kafka-consumer-groups.sh --bootstrap-server 10.31.167.10:9092 --list</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 查看消费组中的具体信息：比如当前偏移量、最后一条消息的偏移量、堆积的消息数量</span></span><br><span class=\"line\">./kafka-consumer-groups.sh --bootstrap-server 172.16.253.38:9092 --describe --group testGroup</span><br></pre></td></tr></table></figure>\n<img src=\"/2022/07/10/Kafka/QQ%E6%88%AA%E5%9B%BE20220110125233.png\" class title=\"输入图片说明\">\n<ul>\n<li>Currennt-offset: 当前消费组的已消费偏移量</li>\n<li>Log-end-offset: 主题对应分区消息的结束偏移量(HW)</li>\n<li>Lag: 当前消费组未消费的消息数</li>\n</ul>\n<h1 id=\"四、主题、分区的概念\"><a href=\"#四、主题、分区的概念\" class=\"headerlink\" title=\"四、主题、分区的概念\"></a>四、主题、分区的概念</h1><h2 id=\"1-主题Topic\"><a href=\"#1-主题Topic\" class=\"headerlink\" title=\"1.主题Topic\"></a>1.主题Topic</h2><p>?主题Topic可以理解成是一个类别的名称。</p>\n<h2 id=\"2-partition分区\"><a href=\"#2-partition分区\" class=\"headerlink\" title=\"2.partition分区\"></a>2.partition分区</h2><img src=\"/2022/07/10/Kafka/QQ%E6%88%AA%E5%9B%BE20220110125413.png\" class title=\"输入图片说明\">\n\n<blockquote>\n<p>一个主题中的消息量是非常大的，因此可以通过分区的设置，来分布式存储这些消息。比如一个topic创建了 3 个分区。那么topic中的消息就会分别存放在这三个分区中。</p>\n</blockquote>\n<h3 id=\"为一个主题创建多个分区\"><a href=\"#为一个主题创建多个分区\" class=\"headerlink\" title=\"为一个主题创建多个分区\"></a>为一个主题创建多个分区</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">./kafka-topics.sh --create --zookeeper localhost:2181 --partitions 2 --topic test1</span><br></pre></td></tr></table></figure>\n<p><strong>可以通过这样的命令查看topic的分区信息</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">./kafka-topics.sh --describe --zookeeper localhost:2181 --topic test1</span><br></pre></td></tr></table></figure>\n<h3 id=\"分区的作用：\"><a href=\"#分区的作用：\" class=\"headerlink\" title=\"分区的作用：\"></a>分区的作用：</h3><ul>\n<li>可以分布式存储</li>\n<li>可以并行写</li>\n</ul>\n<p>实际上是存在data/kafka-logs/test-0 和 test-1中的0000000.log文件中</p>\n<p>小细节：</p>\n<blockquote>\n<p>定期将自己消费分区的offset提交给kafka内部topic：__consumer_offsets，提交过去的<br>时候，key是consumerGroupId+topic+分区号，value就是当前offset的值，kafka会定<br>期清理topic里的消息，最后就保留最新的那条数据<br>因为__consumer_offsets可能会接收高并发的请求，kafka默认给其分配 50 个分区(可以<br>通过offsets.topic.num.partitions设置)，这样可以通过加机器的方式抗大并发。<br>通过如下公式可以选出consumer消费的offset要提交到__consumer_offsets的哪个分区<br>公式：hash(consumerGroupId) % __consumer_offsets主题的分区数</p>\n</blockquote>\n<h1 id=\"五、Kafka集群及副本的概念\"><a href=\"#五、Kafka集群及副本的概念\" class=\"headerlink\" title=\"五、Kafka集群及副本的概念\"></a>五、Kafka集群及副本的概念</h1><h2 id=\"1-搭建kafka集群，-3-个broker\"><a href=\"#1-搭建kafka集群，-3-个broker\" class=\"headerlink\" title=\"1.搭建kafka集群， 3 个broker\"></a>1.搭建kafka集群， 3 个broker</h2><p>准备 3 个server.properties文件</p>\n<p>每个文件中的这些内容要调整</p>\n<ul>\n<li>server.properties<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">broker.id= 0</span><br><span class=\"line\">listeners=PLAINTEXT://192.168.65.60:</span><br><span class=\"line\">log.dir=/usr/local/data/kafka-logs</span><br></pre></td></tr></table></figure></li>\n<li>server1.properties<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">broker.id= 1</span><br><span class=\"line\">listeners=PLAINTEXT://192.168.65.60:</span><br><span class=\"line\">log.dir=/usr/local/data/kafka-logs-</span><br></pre></td></tr></table></figure></li>\n<li>server2.properties<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">broker.id= 2</span><br><span class=\"line\">listeners=PLAINTEXT://192.168.65.60:</span><br><span class=\"line\">log.dir=/usr/local/data/kafka-logs-</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用如下命令来启动-3-台服务器\"><a href=\"#使用如下命令来启动-3-台服务器\" class=\"headerlink\" title=\"使用如下命令来启动 3 台服务器\"></a>使用如下命令来启动 3 台服务器</h3></li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">./kafka-server-start.sh -daemon../config/server0.properties</span><br><span class=\"line\">./kafka-server-start.sh -daemon../config/server1.properties</span><br><span class=\"line\">./kafka-server-start.sh -daemon../config/server2.properties</span><br></pre></td></tr></table></figure>\n\n<p>搭建完后通过查看zk中的/brokers/ids 看是否启动成功</p>\n<h2 id=\"2-副本的概念\"><a href=\"#2-副本的概念\" class=\"headerlink\" title=\"2.副本的概念\"></a>2.副本的概念</h2><blockquote>\n<p>副本是对分区的备份。在集群中，不同的副本会被部署在不同的broker上。下面例子：创建 1个主题， 2 个分区、 3 个副本。</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">./kafka-topics.sh --create --zookeeper 172.16.253.35:2181 --replication-factor 3 --partitions 2 --topic my-replicated-topic</span><br></pre></td></tr></table></figure>\n<img src=\"/2022/07/10/Kafka/QQ%E6%88%AA%E5%9B%BE20220110133849.png\" class title=\"输入图片说明\">\n\n<p>通过查看主题信息，其中的关键数据：</p>\n<ul>\n<li>replicas：当前副本存在的broker节点</li>\n<li>leader：副本里的概念<ul>\n<li>每个partition都有一个broker作为leader。</li>\n<li>消息发送方要把消息发给哪个broker？就看副本的leader是在哪个broker上面。副本里的leader专⻔用来接收消息。</li>\n<li>接收到消息，其他follower通过poll的方式来同步数据。</li>\n</ul>\n</li>\n<li>follower：leader处理所有针对这个partition的读写请求，而follower被动复制leader，不提供读写（主要是为了保证多副本数据与消费的一致性），如果leader所在的broker挂掉，那么就会进行新leader的选举，至于怎么选，在之后的controller的概念中介绍。</li>\n</ul>\n<p>通过kill掉leader后再查看主题情况</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"built_in\">kill</span>掉leader</span></span><br><span class=\"line\">ps -aux | grep server.properties</span><br><span class=\"line\">kill 17631</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 查看topic情况</span></span><br><span class=\"line\">./kafka-topics.sh --describe --zookeeper 172.16.253.35:2181 --topic my-replicated-topic</span><br></pre></td></tr></table></figure>\n\n<p>isr：<br>可以同步的broker节点和已同步的broker节点，存放在isr集合中。</p>\n<h2 id=\"3-broker、主题、分区、副本\"><a href=\"#3-broker、主题、分区、副本\" class=\"headerlink\" title=\"3.broker、主题、分区、副本\"></a>3.broker、主题、分区、副本</h2><ul>\n<li>kafka集群中由多个broker组成</li>\n<li>一个broker中存放一个topic的不同partition——副本</li>\n</ul>\n<img src=\"/2022/07/10/Kafka/QQ%E6%88%AA%E5%9B%BE20220110134554.png\" class title=\"输入图片说明\">\n\n<h2 id=\"4-kafka集群消息的发送\"><a href=\"#4-kafka集群消息的发送\" class=\"headerlink\" title=\"4.kafka集群消息的发送\"></a>4.kafka集群消息的发送</h2><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">./kafka-console-producer.sh --broker-list 172.16.253.38:9092,172.16.253.38:9093,172.16.253.38:9094 --topic my-replicated-topic</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-kafka集群消息的消费\"><a href=\"#5-kafka集群消息的消费\" class=\"headerlink\" title=\"5.kafka集群消息的消费\"></a>5.kafka集群消息的消费</h2><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">./kafka-console-consumer.sh --bootstrap-server 172.16.253.38:9092,172.16.253.38:9093,172.16.253.38:9094 --from-beginning --topic my-replicated-topic</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-关于分区消费组消费者的细节\"><a href=\"#6-关于分区消费组消费者的细节\" class=\"headerlink\" title=\"6.关于分区消费组消费者的细节\"></a>6.关于分区消费组消费者的细节</h2><img src=\"/2022/07/10/Kafka/QQ%E6%88%AA%E5%9B%BE20220110134734.png\" class title=\"输入图片说明\">\n\n<blockquote>\n<p>图中Kafka集群有两个broker，每个broker中有多个partition。一个partition只能被一个消费组里的某一个消费者消费，从而保证消费顺序。Kafka只在partition的范围内保证消息消费的局部顺序性，不能在同一个topic中的多个partition中保证总的消费顺序性。一个消费者可以消费多个partition。</p>\n</blockquote>\n<p><code>消费组中消费者的数量不能比一个topic中的partition数量多，否则多出来的消费者消费不到消息。</code></p>\n<h1 id=\"六、Kafka的Java客户端-生产者\"><a href=\"#六、Kafka的Java客户端-生产者\" class=\"headerlink\" title=\"六、Kafka的Java客户端-生产者\"></a>六、Kafka的Java客户端-生产者</h1><h2 id=\"1-引入依赖\"><a href=\"#1-引入依赖\" class=\"headerlink\" title=\"1.引入依赖\"></a>1.引入依赖</h2><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.kafka<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>kafka-clients<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.4.1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"2-生产者发送消息的基本实现\"><a href=\"#2-生产者发送消息的基本实现\" class=\"headerlink\" title=\"2.生产者发送消息的基本实现\"></a>2.生产者发送消息的基本实现</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">#### <span class=\"comment\">//消息的发送方</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyProducer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String TOPIC_NAME = <span class=\"string\">&quot;my-replicated-topic&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ExecutionException,InterruptedException </span>&#123;</span><br><span class=\"line\">Properties props = <span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\">props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG,<span class=\"string\">&quot;10.31.167.10:9092,10.31.167.10:9093,10.31.167.10:9094&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//把发送的key从字符串序列化为字节数组</span></span><br><span class=\"line\">props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG,StringSerializer.class.getName());</span><br><span class=\"line\"><span class=\"comment\">//把发送消息value从字符串序列化为字节数组</span></span><br><span class=\"line\">props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG,StringSerializer.class.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">Producer&lt;String, String&gt; producer = <span class=\"keyword\">new</span> KafkaProducer&lt;String,String&gt;(props);</span><br><span class=\"line\"></span><br><span class=\"line\">Order order = <span class=\"keyword\">new</span> Order((<span class=\"keyword\">long</span>) i, i);</span><br><span class=\"line\">ProducerRecord&lt;String, String&gt; producerRecord = <span class=\"keyword\">new</span> ProducerRecord&lt;String, String&gt;(TOPIC_NAME, order.getOrderId().toString(), JSON.toJSONString(order));</span><br><span class=\"line\">RecordMetadata metadata = producer.send(producerRecord).get();</span><br><span class=\"line\"><span class=\"comment\">//=====阻塞=======</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;同步方式发送消息结果：&quot;</span> + <span class=\"string\">&quot;topic-&quot;</span> +metadata.topic() + <span class=\"string\">&quot;|partition-&quot;</span>+ metadata.partition() + <span class=\"string\">&quot;|offset-&quot;</span> +metadata.offset());</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-发送消息到指定分区上\"><a href=\"#3-发送消息到指定分区上\" class=\"headerlink\" title=\"3.发送消息到指定分区上\"></a>3.发送消息到指定分区上</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ProducerRecord&lt;String, String&gt; producerRecord = <span class=\"keyword\">new</span> ProducerRecord&lt;String, String&gt;(TOPIC_NAME, <span class=\"number\">0</span> , order.getOrderId().toString(), JSON.toJSONString(order));</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-未指定分区，则会通过业务key的hash运算，算出消息往哪个分区上发\"><a href=\"#4-未指定分区，则会通过业务key的hash运算，算出消息往哪个分区上发\" class=\"headerlink\" title=\"4.未指定分区，则会通过业务key的hash运算，算出消息往哪个分区上发\"></a>4.未指定分区，则会通过业务key的hash运算，算出消息往哪个分区上发</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//未指定发送分区，具体发送的分区计算公式：hash(key)%partitionNum</span></span><br><span class=\"line\">ProducerRecord&lt;String, String&gt; producerRecord = <span class=\"keyword\">new</span> ProducerRecord&lt;String, String&gt;(TOPIC_NAME, order.getOrderId().toString(), JSON.toJSONString(order));</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-同步发送\"><a href=\"#5-同步发送\" class=\"headerlink\" title=\"5.同步发送\"></a>5.同步发送</h2><p>生产者同步发消息，在收到kafka的ack告知发送成功之前一直处于阻塞状态</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//等待消息发送成功的同步阻塞方法</span></span><br><span class=\"line\">RecordMetadata metadata = producer.send(producerRecord).get();</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;同步方式发送消息结果：&quot;</span> + <span class=\"string\">&quot;topic-&quot;</span> +metadata.topic() + <span class=\"string\">&quot;|partition-&quot;</span>+ metadata.partition() + <span class=\"string\">&quot;|offset-&quot;</span> +metadata.offset());</span><br></pre></td></tr></table></figure>\n<img src=\"/2022/07/10/Kafka/QQ%E6%88%AA%E5%9B%BE20220110142708.png\" class title=\"输入图片说明\">\n<h2 id=\"6-异步发消息\"><a href=\"#6-异步发消息\" class=\"headerlink\" title=\"6.异步发消息\"></a>6.异步发消息</h2><h3 id=\"生产者发消息，发送完后不用等待broker给回复，直接执行下面的业务逻辑。可以提供callback，让broker异步的调用callback，告知生产者，消息发送的结果\"><a href=\"#生产者发消息，发送完后不用等待broker给回复，直接执行下面的业务逻辑。可以提供callback，让broker异步的调用callback，告知生产者，消息发送的结果\" class=\"headerlink\" title=\"生产者发消息，发送完后不用等待broker给回复，直接执行下面的业务逻辑。可以提供callback，让broker异步的调用callback，告知生产者，消息发送的结果\"></a>生产者发消息，发送完后不用等待broker给回复，直接执行下面的业务逻辑。可以提供callback，让broker异步的调用callback，告知生产者，消息发送的结果</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//要发送 5 条消息</span></span><br><span class=\"line\">Order order = <span class=\"keyword\">new</span> Order((<span class=\"keyword\">long</span>) i, i);</span><br><span class=\"line\"><span class=\"comment\">//指定发送分区</span></span><br><span class=\"line\">ProducerRecord&lt;String, String&gt; producerRecord = <span class=\"keyword\">new</span> ProducerRecord&lt;String, String&gt;(TOPIC_NAME, <span class=\"number\">0</span> , order.getOrderId().toString(),JSON.toJSONString(order));</span><br><span class=\"line\"><span class=\"comment\">//异步回调方式发送消息</span></span><br><span class=\"line\">producer.send(producerRecord, <span class=\"keyword\">new</span> Callback() &#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompletion</span><span class=\"params\">(RecordMetadata metadata, Exception exception)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (exception != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    System.err.println(<span class=\"string\">&quot;发送消息失败：&quot;</span> +</span><br><span class=\"line\">    exception.getStackTrace());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (metadata != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;异步方式发送消息结果：&quot;</span> + <span class=\"string\">&quot;topic-&quot;</span> +metadata.topic() + <span class=\"string\">&quot;|partition-&quot;</span>+ metadata.partition() + <span class=\"string\">&quot;|offset-&quot;</span> + metadata.offset());</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-关于生产者的ack参数配置\"><a href=\"#7-关于生产者的ack参数配置\" class=\"headerlink\" title=\"7.关于生产者的ack参数配置\"></a>7.关于生产者的ack参数配置</h2><h3 id=\"在同步发消息的场景下：生产者发动broker上后，ack会有-3-种不同的选择：\"><a href=\"#在同步发消息的场景下：生产者发动broker上后，ack会有-3-种不同的选择：\" class=\"headerlink\" title=\"在同步发消息的场景下：生产者发动broker上后，ack会有 3 种不同的选择：\"></a>在同步发消息的场景下：生产者发动broker上后，ack会有 3 种不同的选择：</h3><ul>\n<li>（ 1 ）acks=0： 表示producer不需要等待任何broker确认收到消息的回复，就可以继续发送下一条消息。性能最高，但是最容易丢消息。</li>\n<li>（ 2 ）acks=1： 至少要等待leader已经成功将数据写入本地log，但是不需要等待所有follower是否成功写入。就可以继续发送下一条消息。这种情况下，如果follower没有成功备份数据，而此时leader又挂掉，则消息会丢失。</li>\n<li>（ 3 ）acks=-1或all： 需要等待 min.insync.replicas(默认为 1 ，推荐配置大于等于2) 这个参数配置的副本个数都成功写入日志，这种策略会保证只要有一个备份存活就不会丢失数据。这是最强的数据保证。一般除非是金融级别，或跟钱打交道的场景才会使用这种配置。</li>\n</ul>\n<h3 id=\"code\"><a href=\"#code\" class=\"headerlink\" title=\"code:\"></a>code:</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">props.put(ProducerConfig.ACKS_CONFIG, <span class=\"string\">&quot;1&quot;</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"8-其他一些细节\"><a href=\"#8-其他一些细节\" class=\"headerlink\" title=\"8.其他一些细节\"></a>8.其他一些细节</h2><ul>\n<li>发送会默认会重试 3 次，每次间隔100ms</li>\n<li>发送的消息会先进入到本地缓冲区（32mb），kakfa会跑一个线程，该线程去缓冲区中取16k的数据，发送到kafka，如果到 10 毫秒数据没取满16k，也会发送一次。</li>\n</ul>\n<h1 id=\"七、消费者\"><a href=\"#七、消费者\" class=\"headerlink\" title=\"七、消费者\"></a>七、消费者</h1><h2 id=\"1-消费者消费消息的基本实现\"><a href=\"#1-消费者消费消息的基本实现\" class=\"headerlink\" title=\"1.消费者消费消息的基本实现\"></a>1.消费者消费消息的基本实现</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyConsumer</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String TOPIC_NAME = <span class=\"string\">&quot;my-replicated-topic&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String CONSUMER_GROUP_NAME = <span class=\"string\">&quot;testGroup&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">Properties props = <span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\">props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG,<span class=\"string\">&quot;10.31.167.10:9092,10.31.167.10:9093,10.31.167.10:9094&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 消费分组名</span></span><br><span class=\"line\">props.put(ConsumerConfig.GROUP_ID_CONFIG, CONSUMER_GROUP_NAME);</span><br><span class=\"line\">props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG,StringDeserializer.class.getName());</span><br><span class=\"line\">props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,StringDeserializer.class.getName());</span><br><span class=\"line\"><span class=\"comment\">//创建一个消费者的客户端</span></span><br><span class=\"line\">KafkaConsumer&lt;String, String&gt; consumer = <span class=\"keyword\">new</span> KafkaConsumer&lt;String,String&gt;(props);</span><br><span class=\"line\"><span class=\"comment\">// 消费者订阅主题列表</span></span><br><span class=\"line\">consumer.subscribe(Arrays.asList(TOPIC_NAME));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* poll() API 是拉取消息的⻓轮询</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">ConsumerRecords&lt;String, String&gt; records =consumer.poll(Duration.ofMillis( <span class=\"number\">1000</span> ));</span><br><span class=\"line\"><span class=\"keyword\">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class=\"line\">System.out.printf(<span class=\"string\">&quot;收到消息：partition = %d,offset = %d, key =%s, value = %s%n&quot;</span>, record.partition(),record.offset(), record.key(), record.value());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-自动提交offset\"><a href=\"#2-自动提交offset\" class=\"headerlink\" title=\"2.自动提交offset\"></a>2.自动提交offset</h2><ul>\n<li>设置自动提交参数 - 默认</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 是否自动提交offset，默认就是true</span></span><br><span class=\"line\">props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, <span class=\"string\">&quot;true&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 自动提交offset的间隔时间</span></span><br><span class=\"line\">props.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG, <span class=\"string\">&quot;1000&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>消费者poll到消息后默认情况下，会自动向broker的_consumer_offsets主题提交当前主题-分区消费的偏移量。</p>\n<p>自动提交会丢消息： 因为如果消费者还没消费完poll下来的消息就自动提交了偏移量，那么此 时消费者挂了，于是下一个消费者会从已提交的offset的下一个位置开始消费消息。之前未被消费的消息就丢失掉了。</p>\n<h2 id=\"3-手动提交offset\"><a href=\"#3-手动提交offset\" class=\"headerlink\" title=\"3.手动提交offset\"></a>3.手动提交offset</h2><ul>\n<li>设置手动提交参数</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, <span class=\"string\">&quot;false&quot;</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"在消费完消息后进行手动提交\"><a href=\"#在消费完消息后进行手动提交\" class=\"headerlink\" title=\"在消费完消息后进行手动提交\"></a>在消费完消息后进行手动提交</h3><ul>\n<li>手动同步提交<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (records.count() &gt; <span class=\"number\">0</span> ) &#123;</span><br><span class=\"line\"><span class=\"comment\">// 手动同步提交offset，当前线程会阻塞直到offset提交成功</span></span><br><span class=\"line\"><span class=\"comment\">// 一般使用同步提交，因为提交之后一般也没有什么逻辑代码了</span></span><br><span class=\"line\">consumer.commitSync();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>手动异步提交<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (records.count() &gt; <span class=\"number\">0</span> ) &#123;</span><br><span class=\"line\"><span class=\"comment\">// 手动异步提交offset，当前线程提交offset不会阻塞，可以继续处理后面的程序逻辑</span></span><br><span class=\"line\">consumer.commitAsync(<span class=\"keyword\">new</span> OffsetCommitCallback() &#123;</span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">(Map&lt;TopicPartition, OffsetAndMetadata&gt;offsets, Exception exception)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (exception != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                System.err.println(<span class=\"string\">&quot;Commit failed for &quot;</span> + offsets);</span><br><span class=\"line\">                System.err.println(<span class=\"string\">&quot;Commit failed exception: &quot;</span> +exception.getStackTrace());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"4-消费者poll消息的过程\"><a href=\"#4-消费者poll消息的过程\" class=\"headerlink\" title=\"4.消费者poll消息的过程\"></a>4.消费者poll消息的过程</h2><ul>\n<li>消费者建立了与broker之间的⻓连接，开始poll消息。</li>\n<li>默认一次poll 500条消息</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">props.put(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, <span class=\"number\">500</span> );</span><br></pre></td></tr></table></figure>\n\n<p>可以根据消费速度的快慢来设置，因为如果两次poll的时间如果超出了30s的时间间隔，kafka会认为其消费能力过弱，将其踢出消费组。将分区分配给其他消费者。</p>\n<p>可以通过这个值进行设置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">props.put(ConsumerConfig.MAX_POLL_INTERVAL_MS_CONFIG, <span class=\"number\">30</span> * <span class=\"number\">1000</span> );</span><br></pre></td></tr></table></figure>\n\n<p>如果每隔1s内没有poll到任何消息，则继续去poll消息，循环往复，直到poll到消息。如果超出了1s，则此次⻓轮询结束。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ConsumerRecords&lt;String, String&gt; records =consumer.poll(Duration.ofMillis( <span class=\"number\">1000</span> ));</span><br></pre></td></tr></table></figure>\n<p>消费者发送心跳的时间间隔</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">props.put(ConsumerConfig.HEARTBEAT_INTERVAL_MS_CONFIG, <span class=\"number\">1000</span> );</span><br></pre></td></tr></table></figure>\n\n<p>kafka如果超过 10 秒没有收到消费者的心跳，则会把消费者踢出消费组，进行rebalance，把分区分配给其他消费者。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">props.put(ConsumerConfig.SESSION_TIMEOUT_MS_CONFIG, <span class=\"number\">10</span> * <span class=\"number\">1000</span> );</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-指定分区消费\"><a href=\"#5-指定分区消费\" class=\"headerlink\" title=\"5.指定分区消费\"></a>5.指定分区消费</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">consumer.assign(Arrays.asList(<span class=\"keyword\">new</span> TopicPartition(TOPIC_NAME, <span class=\"number\">0</span> )));</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-消息回溯消费\"><a href=\"#6-消息回溯消费\" class=\"headerlink\" title=\"6.消息回溯消费\"></a>6.消息回溯消费</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">consumer.assign(Arrays.asList(<span class=\"keyword\">new</span> TopicPartition(TOPIC_NAME, <span class=\"number\">0</span> )));</span><br><span class=\"line\">consumer.seekToBeginning(Arrays.asList(<span class=\"keyword\">new</span> TopicPartition(TOPIC_NAME,<span class=\"number\">0</span> )));</span><br></pre></td></tr></table></figure>\n<h2 id=\"7-指定offset消费\"><a href=\"#7-指定offset消费\" class=\"headerlink\" title=\"7.指定offset消费\"></a>7.指定offset消费</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">consumer.assign(Arrays.asList(<span class=\"keyword\">new</span> TopicPartition(TOPIC_NAME, <span class=\"number\">0</span> )));</span><br><span class=\"line\">consumer.seek(<span class=\"keyword\">new</span> TopicPartition(TOPIC_NAME, <span class=\"number\">0</span> ), <span class=\"number\">10</span> );</span><br></pre></td></tr></table></figure>\n<h2 id=\"8-从指定时间点消费\"><a href=\"#8-从指定时间点消费\" class=\"headerlink\" title=\"8.从指定时间点消费\"></a>8.从指定时间点消费</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;PartitionInfo&gt; topicPartitions =consumer.partitionsFor(TOPIC_NAME);</span><br><span class=\"line\"><span class=\"comment\">//从 1 小时前开始消费</span></span><br><span class=\"line\"><span class=\"keyword\">long</span> fetchDataTime = <span class=\"keyword\">new</span> Date().getTime() - <span class=\"number\">1000</span> * <span class=\"number\">60</span> * <span class=\"number\">60</span> ;</span><br><span class=\"line\">Map&lt;TopicPartition, Long&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (PartitionInfo par : topicPartitions) &#123;</span><br><span class=\"line\">    map.put(<span class=\"keyword\">new</span> TopicPartition(TOPIC_NAME, par.partition()),fetchDataTime);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Map&lt;TopicPartition, OffsetAndTimestamp&gt; parMap =consumer.offsetsForTimes(map);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (Map.Entry&lt;TopicPartition, OffsetAndTimestamp&gt; entry :parMap.entrySet()) &#123;</span><br><span class=\"line\">    TopicPartition key = entry.getKey();</span><br><span class=\"line\">    OffsetAndTimestamp value = entry.getValue();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span> || value == <span class=\"keyword\">null</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    Long offset = value.offset();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;partition-&quot;</span> + key.partition() +<span class=\"string\">&quot;|offset-&quot;</span> + offset);</span><br><span class=\"line\">    System.out.println();</span><br><span class=\"line\">    <span class=\"comment\">//根据消费里的timestamp确定offset</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        consumer.assign(Arrays.asList(key));</span><br><span class=\"line\">        consumer.seek(key, offset);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-新消费组的消费偏移量\"><a href=\"#9-新消费组的消费偏移量\" class=\"headerlink\" title=\"9.新消费组的消费偏移量\"></a>9.新消费组的消费偏移量</h2><blockquote>\n<p>当消费主题的是一个新的消费组，或者指定offset的消费方式，offset不存在，那么应该如何消费?</p>\n</blockquote>\n<ul>\n<li>latest(默认) ：只消费自己启动之后发送到主题的消息</li>\n<li>earliest：第一次从头开始消费，以后按照消费offset记录继续消费，这个需要区别于consumer.seekToBeginning(每次都从头开始消费)<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">props.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, &quot;earliest&quot;);</span><br></pre></td></tr></table></figure>\n<h1 id=\"八-、Springboot中使用Kafka\"><a href=\"#八-、Springboot中使用Kafka\" class=\"headerlink\" title=\"八 、Springboot中使用Kafka\"></a>八 、Springboot中使用Kafka</h1></li>\n</ul>\n<h2 id=\"1-引入依赖-1\"><a href=\"#1-引入依赖-1\" class=\"headerlink\" title=\"1.引入依赖\"></a>1.引入依赖</h2><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.kafka<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-kafka<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-配置文件\"><a href=\"#2-配置文件\" class=\"headerlink\" title=\"2.配置文件\"></a>2.配置文件</h2><figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">server:</span></span><br><span class=\"line\">    <span class=\"attr\">port:</span> <span class=\"number\">8080</span></span><br><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">    <span class=\"attr\">kafka:</span></span><br><span class=\"line\">        <span class=\"attr\">bootstrap-servers: 172.16.253.21:</span> <span class=\"number\">9093</span></span><br><span class=\"line\">        <span class=\"attr\">producer:</span> <span class=\"comment\"># 生产者</span></span><br><span class=\"line\">            <span class=\"attr\">retries:</span> <span class=\"number\">3</span> <span class=\"comment\"># 设置大于 0 的值，则客户端会将发送失败的记录重新发送</span></span><br><span class=\"line\">            <span class=\"attr\">batch-size:</span> <span class=\"number\">16384</span></span><br><span class=\"line\">            <span class=\"attr\">buffer-memory:</span> <span class=\"number\">33554432</span></span><br><span class=\"line\">            <span class=\"attr\">acks:</span> <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"comment\"># 指定消息key和消息体的编解码方式</span></span><br><span class=\"line\">            <span class=\"attr\">key-serializer:</span> <span class=\"string\">org.apache.kafka.common.serialization.StringSerializer</span></span><br><span class=\"line\">            <span class=\"attr\">value-serializer:</span> <span class=\"string\">org.apache.kafka.common.serialization.StringSerializer</span></span><br><span class=\"line\">        <span class=\"attr\">consumer:</span></span><br><span class=\"line\">            <span class=\"attr\">group-id:</span> <span class=\"string\">default-group</span></span><br><span class=\"line\">            <span class=\"attr\">enable-auto-commit:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">            <span class=\"attr\">auto-offset-reset:</span> <span class=\"string\">earliest</span></span><br><span class=\"line\">            <span class=\"attr\">key-deserializer:</span> <span class=\"string\">org.apache.kafka.common.serialization.StringDeserializer</span></span><br><span class=\"line\">            <span class=\"attr\">value-deserializer:</span> <span class=\"string\">org.apache.kafka.common.serialization.StringDeserializer</span></span><br><span class=\"line\">            <span class=\"attr\">max-poll-records:</span> <span class=\"number\">500</span></span><br><span class=\"line\">        <span class=\"attr\">listener:</span></span><br><span class=\"line\">        <span class=\"comment\"># 当每一条记录被消费者监听器（ListenerConsumer）处理之后提交</span></span><br><span class=\"line\">        <span class=\"comment\"># RECORD</span></span><br><span class=\"line\">        <span class=\"comment\"># 当每一批poll()的数据被消费者监听器（ListenerConsumer）处理之后提交</span></span><br><span class=\"line\">        <span class=\"comment\"># BATCH</span></span><br><span class=\"line\">        <span class=\"comment\"># 当每一批poll()的数据被消费者监听器（ListenerConsumer）处理之后，距离上次提交时间大于TIME时提交</span></span><br><span class=\"line\">        <span class=\"comment\"># TIME</span></span><br><span class=\"line\">        <span class=\"comment\"># 当每一批poll()的数据被消费者监听器（ListenerConsumer）处理之后，被处理record数量大于等于COUNT时提交</span></span><br><span class=\"line\">        <span class=\"comment\"># COUNT</span></span><br><span class=\"line\">        <span class=\"comment\"># TIME | COUNT　有一个条件满足时提交</span></span><br><span class=\"line\">        <span class=\"comment\"># COUNT_TIME</span></span><br><span class=\"line\">        <span class=\"comment\"># 当每一批poll()的数据被消费者监听器（ListenerConsumer）处理之后, 手动调用Acknowledgment.acknowledge()后提交</span></span><br><span class=\"line\">        <span class=\"comment\"># MANUAL</span></span><br><span class=\"line\">        <span class=\"comment\"># 手动调用Acknowledgment.acknowledge()后立即提交，一般使用这种</span></span><br><span class=\"line\">        <span class=\"comment\"># MANUAL_IMMEDIATE</span></span><br><span class=\"line\">            <span class=\"attr\">ack-mode:</span> <span class=\"string\">MANUAL_IMMEDIATE</span></span><br><span class=\"line\">    <span class=\"attr\">redis:</span></span><br><span class=\"line\">        <span class=\"attr\">host:</span> <span class=\"number\">172.16</span><span class=\"number\">.253</span><span class=\"number\">.21</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-消息生产者\"><a href=\"#3-消息生产者\" class=\"headerlink\" title=\"3.消息生产者\"></a>3.消息生产者</h2><ul>\n<li>发送消息到指定topic</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">KafkaController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String TOPIC_NAME = <span class=\"string\">&quot;my-replicated-topic&quot;</span>;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> KafkaTemplate&lt;String, String&gt; kafkaTemplate;</span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/send&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">send</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        kafkaTemplate.send(TOPIC_NAME, <span class=\"number\">0</span> , <span class=\"string\">&quot;key&quot;</span>, <span class=\"string\">&quot;this is a msg&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-消息消费者\"><a href=\"#4-消息消费者\" class=\"headerlink\" title=\"4.消息消费者\"></a>4.消息消费者</h2><ul>\n<li><p>设置消费组，消费指定topic</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@KafkaListener(topics = &quot;my-replicated-topic&quot;,groupId = &quot;MyGroup1&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">listenGroup</span><span class=\"params\">(ConsumerRecord&lt;String, String&gt; record,Acknowledgment ack)</span> </span>&#123;</span><br><span class=\"line\">    String value = record.value();</span><br><span class=\"line\">    System.out.println(value);</span><br><span class=\"line\">    System.out.println(record);</span><br><span class=\"line\">    <span class=\"comment\">//手动提交offset</span></span><br><span class=\"line\">    ack.acknowledge();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>设置消费组、多topic、指定分区、指定偏移量消费及设置消费者个数。</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@KafkaListener(groupId = &quot;testGroup&quot;, topicPartitions = &#123;</span></span><br><span class=\"line\"><span class=\"meta\">@TopicPartition(topic = &quot;topic1&quot;, partitions = &#123;&quot;0&quot;, &quot;1&quot;&#125;),</span></span><br><span class=\"line\"><span class=\"meta\">@TopicPartition(topic = &quot;topic2&quot;, partitions = &quot;0&quot;,partitionOffsets = @PartitionOffset(partition = &quot;1&quot;,initialOffset = &quot;100&quot;))&#125;</span></span><br><span class=\"line\"><span class=\"meta\">,concurrency = &quot;3&quot;)</span><span class=\"comment\">//concurrency就是同组下的消费者个数，就是并发消费数，建议小于等于分区总数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">listenGroup</span><span class=\"params\">(ConsumerRecord&lt;String, String&gt; record,Acknowledgment ack)</span> </span>&#123;</span><br><span class=\"line\">    String value = record.value();</span><br><span class=\"line\">    System.out.println(value);</span><br><span class=\"line\">    System.out.println(record);</span><br><span class=\"line\">    <span class=\"comment\">//手动提交offset</span></span><br><span class=\"line\">    ack.acknowledge();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"九、Kafka集群Controller、Rebalance和HW\"><a href=\"#九、Kafka集群Controller、Rebalance和HW\" class=\"headerlink\" title=\"九、Kafka集群Controller、Rebalance和HW\"></a>九、Kafka集群Controller、Rebalance和HW</h1><h2 id=\"1-Controller\"><a href=\"#1-Controller\" class=\"headerlink\" title=\"1.Controller\"></a>1.Controller</h2><ul>\n<li>Kafka集群中的broker在zk中创建临时序号节点，序号最小的节点（最先创建的节点）将作为集群的controller，负责管理整个集群中的所有分区和副本的状态：<ul>\n<li>当某个分区的leader副本出现故障时，由控制器负责为该分区选举新的leader副本。</li>\n<li>当检测到某个分区的ISR集合发生变化时，由控制器负责通知所有broker更新其元数据信息。</li>\n<li>当使用kafka-topics.sh脚本为某个topic增加分区数量时，同样还是由控制器负责让新分区被其他节点感知到。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-Rebalance机制\"><a href=\"#2-Rebalance机制\" class=\"headerlink\" title=\"2.Rebalance机制\"></a>2.Rebalance机制</h2><p>前提是：消费者没有指明分区消费。当消费组里消费者和分区的关系发生变化，那么就会触发rebalance机制。</p>\n<p>这个机制会重新调整消费者消费哪个分区。</p>\n<p>在触发rebalance机制之前，消费者消费哪个分区有三种策略：</p>\n<ul>\n<li>range：通过公示来计算某个消费者消费哪个分区</li>\n<li>轮询：大家轮着消费</li>\n<li>sticky：在触发了rebalance后，在消费者消费的原分区不变的基础上进行调整。</li>\n</ul>\n<h2 id=\"3-HW和LEO\"><a href=\"#3-HW和LEO\" class=\"headerlink\" title=\"3.HW和LEO\"></a>3.HW和LEO</h2><blockquote>\n<p>HW俗称高水位，HighWatermark的缩写，取一个partition对应的ISR中最小的LEO(log-end-offset)作为HW，consumer最多只能消费到HW所在的位置。另外每个replica都有HW,leader和follower各自负责更新自己的HW的状态。对于leader新写入的消息，consumer不能立刻消费，leader会等待该消息被所有ISR中的replicas同步后更新HW，此时消息才能被consumer消费。这样就保证了如果leader所在的broker失效，该消息仍然可以从新选举的leader中获取。</p>\n</blockquote>\n<h1 id=\"十、Kafka线上问题优化\"><a href=\"#十、Kafka线上问题优化\" class=\"headerlink\" title=\"十、Kafka线上问题优化\"></a>十、Kafka线上问题优化</h1><h2 id=\"1-如何防止消息丢失\"><a href=\"#1-如何防止消息丢失\" class=\"headerlink\" title=\"1.如何防止消息丢失\"></a>1.如何防止消息丢失</h2><ul>\n<li>发送方： ack是 1 或者-1/all 可以防止消息丢失，如果要做到99.9999%，ack设成all，把min.insync.replicas配置成分区备份数</li>\n<li>消费方：把自动提交改为手动提交。</li>\n</ul>\n<h2 id=\"2-如何防止消息的重复消费\"><a href=\"#2-如何防止消息的重复消费\" class=\"headerlink\" title=\"2.如何防止消息的重复消费\"></a>2.如何防止消息的重复消费</h2><blockquote>\n<p>一条消息被消费者消费多次。如果为了消息的不重复消费，而把生产端的重试机制关闭、消费端的手动提交改成自动提交，这样反而会出现消息丢失，那么可以直接在防治消息丢失的手段上再加上消费消息时的幂等性保证，就能解决消息的重复消费问题。</p>\n</blockquote>\n<h3 id=\"幂等性如何保证：\"><a href=\"#幂等性如何保证：\" class=\"headerlink\" title=\"幂等性如何保证：\"></a>幂等性如何保证：</h3><ul>\n<li>mysql 插入业务id作为主键，主键是唯一的，所以一次只能插入一条</li>\n<li>使用redis或zk的分布式锁（主流的方案）</li>\n</ul>\n<h2 id=\"3-如何做到顺序消费RocketMQ\"><a href=\"#3-如何做到顺序消费RocketMQ\" class=\"headerlink\" title=\"3.如何做到顺序消费RocketMQ\"></a>3.如何做到顺序消费RocketMQ</h2><ul>\n<li>发送方：在发送时将ack不能设置 0 ，关闭重试，使用同步发送，等到发送成功再发送下一条。确保消息是顺序发送的。</li>\n<li>接收方：消息是发送到一个分区中，只能有一个消费组的消费者来接收消息。因此，kafka的顺序消费会牺牲掉性能。</li>\n</ul>\n<h2 id=\"4-解决消息积压问题\"><a href=\"#4-解决消息积压问题\" class=\"headerlink\" title=\"4.解决消息积压问题\"></a>4.解决消息积压问题</h2><blockquote>\n<p>消息积压会导致很多问题，比如磁盘被打满、生产端发消息导致kafka性能过慢，就容易出现服务雪崩，就需要有相应的手段：</p>\n</blockquote>\n<ul>\n<li>方案一：在一个消费者中启动多个线程，让多个线程同时消费。——提升一个消费者的消费能力（增加分区增加消费者）。</li>\n<li>方案二：如果方案一还不够的话，这个时候可以启动多个消费者，多个消费者部署在不同的服务器上。其实多个消费者部署在同一服务器上也可以提高消费能力——充分利用服务器的cpu资源。</li>\n<li>方案三：让一个消费者去把收到的消息往另外一个topic上发，另一个topic设置多个分区和多个消费者 ，进行具体的业务消费。</li>\n</ul>\n<h2 id=\"5-延迟队列\"><a href=\"#5-延迟队列\" class=\"headerlink\" title=\"5.延迟队列\"></a>5.延迟队列</h2><p>延迟队列的应用场景：在订单创建成功后如果超过 30 分钟没有付款，则需要取消订单，此时可用延时队列来实现</p>\n<ul>\n<li><p>创建多个topic，每个topic表示延时的间隔</p>\n<ul>\n<li>topic_5s: 延时5s执行的队列</li>\n<li>topic_1m: 延时 1 分钟执行的队列</li>\n<li>topic_30m: 延时 30 分钟执行的队列</li>\n</ul>\n</li>\n<li><p>消息发送者发送消息到相应的topic，并带上消息的发送时间</p>\n</li>\n<li><p>消费者订阅相应的topic，消费时轮询消费整个topic中的消息</p>\n<ul>\n<li>如果消息的发送时间，和消费的当前时间超过预设的值，比如 30 分钟</li>\n<li>如果消息的发送时间，和消费的当前时间没有超过预设的值，则不消费当前的offset及之后的offset的所有消息都消费</li>\n<li>下次继续消费该offset处的消息，判断时间是否已满足预设值</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"十一、Kafka-eagle监控平台\"><a href=\"#十一、Kafka-eagle监控平台\" class=\"headerlink\" title=\"十一、Kafka-eagle监控平台\"></a>十一、Kafka-eagle监控平台</h1><h2 id=\"安装Kafka-eagle\"><a href=\"#安装Kafka-eagle\" class=\"headerlink\" title=\"安装Kafka-eagle\"></a>安装Kafka-eagle</h2><h3 id=\"官网下载压缩包\"><a href=\"#官网下载压缩包\" class=\"headerlink\" title=\"官网下载压缩包\"></a>官网下载压缩包</h3><p><a href=\"http://www.kafka-eagle.org/\">http://www.kafka-eagle.org/</a></p>\n<ul>\n<li>安装jdk</li>\n<li>解压缩后修改配置文件 system-config.properties</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 配置zk  去掉cluster2</span></span><br><span class=\"line\">efak.zk.cluster.alias=cluster1</span><br><span class=\"line\">cluster1.zk.list=172.16.253.35:2181</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> cluster2.zk.list=xdn10:2181,xdn11:2181,xdn12:2181</span></span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 配置mysql</span></span><br><span class=\"line\">kafka.eagle.driver=com.mysql.cj.jdbc.Driver</span><br><span class=\"line\">kafka.eagle.url=jdbc:mysql://172.16.253.22:3306/ke?useUnicode=true&amp;characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNull</span><br><span class=\"line\">kafka.eagle.username=root</span><br><span class=\"line\">kafka.eagle.password= 123456</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>修改/etc/profile</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">export  JAVA_HOME=/usr/local/jdk/jdk1.8.0_191</span><br><span class=\"line\">CLASSPATH=.:$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar</span><br><span class=\"line\">export KE_HOME=/home/aisys/efak-web-2.0.9</span><br><span class=\"line\">export PATH=$PATH:$KE_HOME/bin:$JAVA_HOME/bin</span><br></pre></td></tr></table></figure></li>\n<li><p>刷新配置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">source /etc/profile</span><br></pre></td></tr></table></figure></li>\n<li><p>进入到bin目录，为ke.sh增加可执行的权限</p>\n</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">chmod +x ke.sh</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>启动kafka-eagle<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">./ke.sh start</span><br></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"MarkdownPad 2  操作指南","comments":1,"top_img":false,"cover":"http://rebp38war.bkt.clouddn.com/img/markdownpad2-weblogo.png","_content":"![](http://rebp38war.bkt.clouddn.com/img/markdownpad2-weblogo.png)<br>\n> &emsp;&emsp;使用 [Hexo](https://hexo.io/)来写博客 ， 需要使用Markdown工具来快速编写.md文件，我使用的是MarkdownPad 2。<br>MarkdownPad 2是一款较不错的Markdown编辑器，可快速将文本转换为美观的HTML/XHTML的网页格式代码，且操作方便，用户可以通过键盘快捷键和工具栏按钮来使用或者移除Markdown格式，左右栏的分割方式令用户可以实时看到 HTML 格式的 Markdown 文档。\n\n## Quick Start\n> 简单三步，快速使用\n\n\n### 第一步（下载） ###\n\n[点击下载程序](https://pan.baidu.com/s/1ffdu3der4hE8DNFE_9cuwQ)\n`提取码：zm8e`，下载解压到指定目录<br>\n\n\n\n> 注意：如果是<font color=#A52A2A size=4 >win10</font>还需要安装一个组件 <font color=#A52A2A size=4 >awesomium_v1.6.6_sdk_win</font>，否则会出现错误<br>\n[点击下载组件](https://pan.baidu.com/s/1Skj-ZgxL_nbBgujlBlemZg)\n`提取码：e7jn`\n\n### 第二步（撬锁） ###\n找到根目录下MarkdownPad 2应用程序，运行并输入以下邮箱秘钥破解\n\n邮箱：<br>`Soar360@live.com`<br>\n授权秘钥：<br>        \n              \n    GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ==\n\n \n![](http://rebp38war.bkt.clouddn.com/img/1.png)\n### 第三步(重启) ###\n重启MarkdownPad 2就可以用了!\n\n![](http://rebp38war.bkt.clouddn.com/img/4.png)\n## 使用\n常用MarkdownPad2快捷键：<br>\n\n|  快捷键   | 说明  |\n|  :------:  | :------:  |\n| Ctrl + B  | 粗体 |\n| Ctrl + I  | 斜体 |\n| Ctrl + Q  | 引用 |\n| Ctrl + K  | 代码块 |\n| Ctrl + 1  | 标题1 |\n| Ctrl + 2  | 标题2 |\n| Ctrl + 3  | 标题3 |\n| Ctrl + U  | 无序列表 |\n| Ctrl + Shift + O  | 有序列表 |\n| Ctrl + G  | 图片 |\n| Ctrl + L  | 超链接 |\n| Ctrl + T  | 时间戳 |\n| Ctrl + R  | 水平标尺 |\n\nMD基本语法 ：\n![](http://rebp38war.bkt.clouddn.com/img/2.png)\n![](http://rebp38war.bkt.clouddn.com/img/3.png)","source":"_posts/MarkdownPad 2  操作指南.md","raw":"---\ntitle: MarkdownPad 2  操作指南\ncomments: true\ncategories:\n - 工具\ntags:\n - markdown\n - blog\ntop_img: false\ncover: http://rebp38war.bkt.clouddn.com/img/markdownpad2-weblogo.png\n---\n![](http://rebp38war.bkt.clouddn.com/img/markdownpad2-weblogo.png)<br>\n> &emsp;&emsp;使用 [Hexo](https://hexo.io/)来写博客 ， 需要使用Markdown工具来快速编写.md文件，我使用的是MarkdownPad 2。<br>MarkdownPad 2是一款较不错的Markdown编辑器，可快速将文本转换为美观的HTML/XHTML的网页格式代码，且操作方便，用户可以通过键盘快捷键和工具栏按钮来使用或者移除Markdown格式，左右栏的分割方式令用户可以实时看到 HTML 格式的 Markdown 文档。\n\n## Quick Start\n> 简单三步，快速使用\n\n\n### 第一步（下载） ###\n\n[点击下载程序](https://pan.baidu.com/s/1ffdu3der4hE8DNFE_9cuwQ)\n`提取码：zm8e`，下载解压到指定目录<br>\n\n\n\n> 注意：如果是<font color=#A52A2A size=4 >win10</font>还需要安装一个组件 <font color=#A52A2A size=4 >awesomium_v1.6.6_sdk_win</font>，否则会出现错误<br>\n[点击下载组件](https://pan.baidu.com/s/1Skj-ZgxL_nbBgujlBlemZg)\n`提取码：e7jn`\n\n### 第二步（撬锁） ###\n找到根目录下MarkdownPad 2应用程序，运行并输入以下邮箱秘钥破解\n\n邮箱：<br>`Soar360@live.com`<br>\n授权秘钥：<br>        \n              \n    GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ==\n\n \n![](http://rebp38war.bkt.clouddn.com/img/1.png)\n### 第三步(重启) ###\n重启MarkdownPad 2就可以用了!\n\n![](http://rebp38war.bkt.clouddn.com/img/4.png)\n## 使用\n常用MarkdownPad2快捷键：<br>\n\n|  快捷键   | 说明  |\n|  :------:  | :------:  |\n| Ctrl + B  | 粗体 |\n| Ctrl + I  | 斜体 |\n| Ctrl + Q  | 引用 |\n| Ctrl + K  | 代码块 |\n| Ctrl + 1  | 标题1 |\n| Ctrl + 2  | 标题2 |\n| Ctrl + 3  | 标题3 |\n| Ctrl + U  | 无序列表 |\n| Ctrl + Shift + O  | 有序列表 |\n| Ctrl + G  | 图片 |\n| Ctrl + L  | 超链接 |\n| Ctrl + T  | 时间戳 |\n| Ctrl + R  | 水平标尺 |\n\nMD基本语法 ：\n![](http://rebp38war.bkt.clouddn.com/img/2.png)\n![](http://rebp38war.bkt.clouddn.com/img/3.png)","slug":"MarkdownPad 2  操作指南","published":1,"date":"2021-12-22T07:16:45.212Z","updated":"2022-07-01T04:38:38.436Z","layout":"post","photos":[],"link":"","_id":"cl5w7e73p0003igvufypo916b","content":"<p><img src=\"http://rebp38war.bkt.clouddn.com/img/markdownpad2-weblogo.png\"><br></p>\n<blockquote>\n<p>&emsp;&emsp;使用 <a href=\"https://hexo.io/\">Hexo</a>来写博客 ， 需要使用Markdown工具来快速编写.md文件，我使用的是MarkdownPad 2。<br>MarkdownPad 2是一款较不错的Markdown编辑器，可快速将文本转换为美观的HTML/XHTML的网页格式代码，且操作方便，用户可以通过键盘快捷键和工具栏按钮来使用或者移除Markdown格式，左右栏的分割方式令用户可以实时看到 HTML 格式的 Markdown 文档。</p>\n</blockquote>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><blockquote>\n<p>简单三步，快速使用</p>\n</blockquote>\n<h3 id=\"第一步（下载）\"><a href=\"#第一步（下载）\" class=\"headerlink\" title=\"第一步（下载）\"></a>第一步（下载）</h3><p><a href=\"https://pan.baidu.com/s/1ffdu3der4hE8DNFE_9cuwQ\">点击下载程序</a><br><code>提取码：zm8e</code>，下载解压到指定目录<br></p>\n<blockquote>\n<p>注意：如果是<font color=\"#A52A2A\" size=\"4\">win10</font>还需要安装一个组件 <font color=\"#A52A2A\" size=\"4\">awesomium_v1.6.6_sdk_win</font>，否则会出现错误<br><br><a href=\"https://pan.baidu.com/s/1Skj-ZgxL_nbBgujlBlemZg\">点击下载组件</a><br><code>提取码：e7jn</code></p>\n</blockquote>\n<h3 id=\"第二步（撬锁）\"><a href=\"#第二步（撬锁）\" class=\"headerlink\" title=\"第二步（撬锁）\"></a>第二步（撬锁）</h3><p>找到根目录下MarkdownPad 2应用程序，运行并输入以下邮箱秘钥破解</p>\n<p>邮箱：<br><code>Soar360@live.com</code><br><br>授权秘钥：<br>        </p>\n<pre><code>GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ==\n</code></pre>\n<p><img src=\"http://rebp38war.bkt.clouddn.com/img/1.png\"></p>\n<h3 id=\"第三步-重启\"><a href=\"#第三步-重启\" class=\"headerlink\" title=\"第三步(重启)\"></a>第三步(重启)</h3><p>重启MarkdownPad 2就可以用了!</p>\n<p><img src=\"http://rebp38war.bkt.clouddn.com/img/4.png\"></p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>常用MarkdownPad2快捷键：<br></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">快捷键</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Ctrl + B</td>\n<td align=\"center\">粗体</td>\n</tr>\n<tr>\n<td align=\"center\">Ctrl + I</td>\n<td align=\"center\">斜体</td>\n</tr>\n<tr>\n<td align=\"center\">Ctrl + Q</td>\n<td align=\"center\">引用</td>\n</tr>\n<tr>\n<td align=\"center\">Ctrl + K</td>\n<td align=\"center\">代码块</td>\n</tr>\n<tr>\n<td align=\"center\">Ctrl + 1</td>\n<td align=\"center\">标题1</td>\n</tr>\n<tr>\n<td align=\"center\">Ctrl + 2</td>\n<td align=\"center\">标题2</td>\n</tr>\n<tr>\n<td align=\"center\">Ctrl + 3</td>\n<td align=\"center\">标题3</td>\n</tr>\n<tr>\n<td align=\"center\">Ctrl + U</td>\n<td align=\"center\">无序列表</td>\n</tr>\n<tr>\n<td align=\"center\">Ctrl + Shift + O</td>\n<td align=\"center\">有序列表</td>\n</tr>\n<tr>\n<td align=\"center\">Ctrl + G</td>\n<td align=\"center\">图片</td>\n</tr>\n<tr>\n<td align=\"center\">Ctrl + L</td>\n<td align=\"center\">超链接</td>\n</tr>\n<tr>\n<td align=\"center\">Ctrl + T</td>\n<td align=\"center\">时间戳</td>\n</tr>\n<tr>\n<td align=\"center\">Ctrl + R</td>\n<td align=\"center\">水平标尺</td>\n</tr>\n</tbody></table>\n<p>MD基本语法 ：<br><img src=\"http://rebp38war.bkt.clouddn.com/img/2.png\"><br><img src=\"http://rebp38war.bkt.clouddn.com/img/3.png\"></p>\n","site":{"data":{"bangumis":{"wantWatch":[],"watching":[{"title":"凡人修仙传","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/70d11dfab23a3ee81ccf64f18efa139416a633ff.jpg@220w_280h.webp","totalCount":"未完结","id":28223043,"follow":"615.7 万","view":"8.9 亿","danmaku":"490.9 万","coin":"1186.9 万","score":9.7,"des":"看机智的凡人小子韩立如何稳健发展、步步为营，战魔道、夺至宝、驰骋星海、快意恩仇，成为纵横三界的强者。他日仙界重相逢，一声道友尽沧桑。..."},{"title":"恋爱游戏世界对路人角色很不友好","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/c9723d8c77d881a8debba2852d580e97826b43d0.png@220w_280h.webp","totalCount":"全12话","id":28237300,"follow":"151.2 万","view":"5120.4 万","danmaku":"40.6 万","coin":"24.5 万","score":9.1,"des":"从现代日本转生到“恋爱游戏”世界的里昂，发现这里女尊男卑，对男性很不友好。身为路人角色的他，为了摆脱自己因地位低下而被肆意决定的人生，决定活用从游戏中得到的知识，保持路人角色的身份，取得“失落物品”来..."},{"title":"魔法纪录 魔法少女小圆外传 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/9eef1df9ab157be52d2c4d70d3500442f00cafc3.png@220w_280h.webp","totalCount":"全12话","id":28234642,"follow":"237.1 万","view":"907.6 万","danmaku":"5.0 万","coin":"4.9 万","score":7.7,"des":"愿望的代价，究竟是希望还是绝望——。"},{"title":"小林家的龙女仆 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/847e9dbb6876fb37a30199a5c88910704976d45b.png@220w_280h.webp","totalCount":"全13话","id":28234613,"follow":"855.7 万","view":"1.1 亿","danmaku":"49.0 万","coin":"69.0 万","score":9.6,"des":"那位不可思议的龙女仆再度登场！\n因为各种奇妙的原因而作为小林家的女仆而工作中的龙·托尔。\n偶尔（胡说，是经常）给亲爱的小林添麻烦，总算是融入了人类社会，成为了一个完美的（骗人，也就还行）女仆。\n同样是..."},{"title":"国王排名","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/376d7e69a667bcb1c0b934a4e35e07e7fa23110b.png@220w_280h.webp","totalCount":"全23话","id":28235154,"follow":"927.7 万","view":"4.8 亿","danmaku":"250.1 万","coin":"260.9 万","score":7,"des":"国家的丰饶、麾下勇者的数量、\n以及国王本人如何像勇者一般强大，\n这些要素的综合排名，便是所谓的“国王排名”。\n主人公波吉是国王排名第七名的伯斯王治下王国的第一王子。\n但是波吉却生来又聋又哑，贫弱到挥不..."},{"title":"阿松 第三季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0212baa8898d0c819c7fb84015e95b8fca621435.png@220w_280h.webp","totalCount":"全25话","id":28229892,"follow":"67.6 万","view":"938.0 万","danmaku":"13.0 万","coin":"5.4 万","score":9.6,"des":"日本最有名的六胞胎的传说，第三次开幕！！这次会有怎样意想不到的新展开！？..."},{"title":"命运-冠位指定 冠位时间神殿所罗门","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0e094b798388da19a4feffa6a6dabc1dc1dc90cd.jpg@220w_280h.webp","totalCount":"全1话","id":28236225,"follow":"525.5 万","view":"1220.0 万","danmaku":"8.9 万","coin":"15.1 万","score":8.5,"des":"在经过七个特异点的大战后，\n人理存续保障机关迦勒底，终于到达了圣杯探索的最终地点——终局特异点 冠位时间神殿所罗门。\n他们要击败身为罪魁祸首的魔术王所罗门，夺回未来。\n在开战的前一刻，一行人各自度过了..."},{"title":"JOJO的奇妙冒险 星尘远征军","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/47c0108259355d6d2c517ed97f6b90fb777f844f.png@220w_280h.webp","totalCount":"全24话","id":28223481,"follow":"444.2 万","view":"1.5 亿","danmaku":"463.4 万","coin":"45.7 万","score":9.8,"des":"时为1987年，乔瑟夫·乔斯达与“柱之男”们之间的死战后过了50年……乔瑟夫为了为了帮助“被恶灵附身了”的外孙子·空条承太郎而来到了日本。原来那并不是恶灵而是幽波纹（替身）。替身突然出现的原因在于，从..."},{"title":"JOJO的奇妙冒险 星尘远征军 埃及篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f6709b76e88f50aa132d1e09e2d8de9663a09b3e.png@220w_280h.webp","totalCount":"全24话","id":28223483,"follow":"421.9 万","view":"1.3 亿","danmaku":"468.7 万","coin":"44.3 万","score":9.9,"des":"在乔斯达家的宿敌·迪奥（DIO）复活的影响下，一位年轻人——空条承太郎，得到了名为“幽波纹（替身）”的能力。为了拯救因迪奥的诅咒而倒下的母亲荷莉，空条承太郎与外祖父·乔瑟夫以及伙伴们，一起为了打倒迪奥..."},{"title":"JOJO的奇妙冒险 不灭钻石","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/6a04c87e990ab74cd8d555ef45a863de0993b161.png@220w_280h.webp","totalCount":"全39话","id":140552,"follow":"302.3 万","view":"2.1 亿","danmaku":"813.8 万","coin":"55.9 万","score":9.8,"des":"在埃及与宿敌DIO的死斗之后过了11年。1999年，空条承太郎为了与祖父乔瑟夫·乔斯达的私生子东方仗助见面，而来到了日本M县S市杜王町。但，仗助却持有与承太郎相同的特殊能力“替身”。之后，以承太郎的来..."},{"title":"命运-冠位嘉年华","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/c660976f4502a544d990a882ae62194b57753a71.png@220w_280h.webp","totalCount":"全2话","id":28234639,"follow":"479.8 万","view":"862.4 万","danmaku":"4.1 万","coin":"9.1 万","score":9.8,"des":"一起庆祝吧！为了这奇迹般的嘉年华！"},{"title":"伍六七","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/b69e26d9e50514f3fa99eac9ab5aabf2a6e28c88.jpg@220w_280h.webp","totalCount":"全13话","id":6360,"follow":"585.8 万","view":"3.3 亿","danmaku":"227.1 万","coin":"191.8 万","score":9.8,"des":"在某个小岛上，有一个可以伪装成任何东西的廉价刺客，名叫伍六七。平时看上去是个理发师，其实背地里却做着刺客生意。热爱理发事业，喜欢给人剪头发，善用剪刀——剪刀也是他的刺杀武器。由于初入刺客行当，行情十分..."},{"title":"命运-冠位指定 -月光／失落之室-","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3fa5fd2b7afae827b0bf150d7f0cbfc54eda1ff2.png@220w_280h.webp","totalCount":"全1话","id":28234950,"follow":"483.3 万","view":"551.2 万","danmaku":9696,"coin":"2.9 万","score":9.5,"des":"失落之室——。\n这是一个可以看到被夺去亦或是遗失之物的地方。\n这是位于迦勒底被遗忘的角落，不属于任何人的地方。..."},{"title":"致不灭的你","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/1ae94fbb35d8e23bb84926b694509f8b057f96e6.png@220w_280h.webp","totalCount":"全20话","id":28233896,"follow":"476.3 万","view":"1.3 亿","danmaku":"140.1 万","coin":"95.0 万","score":9.6,"des":"本剧讲述了一个情节跌宕、场面宏大的奇幻故事，通过拥有不灭之身的主人公“不死”来探索人生哲理。\n不死起初是一个被投放到人世间的“球”。\n\n它具有“幻化为刺激源形态的能力”和“死后重生的能力”。\n\n先后从..."},{"title":"来自新世界","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/aaa60f9cb17fb4a38df464f1064ca9623e0769cc.jpg@220w_280h.webp","totalCount":"全25话","id":1598,"follow":"115.9 万","view":"1540.9 万","danmaku":"76.3 万","coin":"5.7 万","score":9.5,"des":"1000年后的日本，孩子们不断地消失，只存在想象中的恐怖动物与人类展开殊死战争。反乌托邦式的未来超级社会“新世界”，是口吐真言凭藉“咒力”就能移动物体的人类，与有着等同于普通人智力的生物“妖鼠”共存的..."},{"title":"转生成蜘蛛又怎样！","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f0796e37abac25ba2aa9f23120646aaa9a3d5ea7.png@220w_280h.webp","totalCount":"全24话","id":28231809,"follow":"600.0 万","view":"3.7 亿","danmaku":"190.3 万","coin":"164.6 万","score":7.8,"des":"曾经是一名女高中生的“我”，突然转生变成了幻想世界中的蜘蛛魔物。\n而且，出生地点还是各种凶恶魔物所盘踞的大迷宫。\n“我”以人类的智慧和非同寻常的积极心态为武器，使用蜘蛛的丝网以及陷阱打倒比自己等级高得..."},{"title":"装甲重拳/MEGALOBOX 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/e14dc4a935397fc074c7a12d9520225615209025.png@220w_280h.webp","totalCount":"全13话","id":28233916,"follow":"244.9 万","view":"3435.4 万","danmaku":"19.7 万","coin":"53.1 万","score":9.9,"des":"再一次，为梦想而活——\n\n将肉体与“装甲技术”融合的究极格斗技“装甲拳击”。\n在决出其顶点之人的大会“重拳之巅”上，身穿装甲用自己肉身挑战一切的拳击手“JOE”。\n\n从最下层的比赛开始仅仅花了三个月就..."},{"title":"机动战士高达SEED HD","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/855c88677267d707ebfe4040403692ff2c0938f0.png@220w_280h.webp","totalCount":"全48话","id":497,"follow":"54.8 万","view":"4044.4 万","danmaku":"114.4 万","coin":"6.0 万","score":9.6,"des":"《机动战士高达SEED》是高达系列在2002年至2003年度放映的动画。续作为《机动战士高达SEED Destiny》在2004年播放。因各具魅力的角色，明星云集的声优阵容和高度商业化的宣传而受到较低..."},{"title":"夏目友人帐 唤石者与怪异的访客","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6cf43708b779cde84ad285ff4e3a080de98df0af.png@220w_280h.webp","totalCount":"全1话","id":28234316,"follow":"567.1 万","view":"1374.8 万","danmaku":"18.1 万","coin":"17.9 万","score":9.9,"des":"本作由【唤石者】与【怪异的访客】两个人气短篇集锦而成。讲述生来便能看见各种妖怪的夏目，与自称保镖的猫咪老师一同邂逅的一系列温暖故事。\n【唤石者】一天夏目在森林中遇到一只小妖怪——密实。密实称自己肩负「..."},{"title":"Fate/Grand Order ‐First Order‐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/b75c55d209d156c8631f5ceb21e5c52c834dbb60.jpg@220w_280h.webp","totalCount":"全1话","id":5747,"follow":"250.9 万","view":"3329.7 万","danmaku":"76.7 万","coin":"10.7 万","score":8.3,"des":"【2016年12月31日bilibili独播】2015年。示巴所观测到的未来领域毫无前兆地消失。根据计算，发现——不，是证明了人类将于2017年灭绝。人理延续保障机构·迦勒底将“无法观测的领域”假定为..."},{"title":"伍六七之玄武国篇","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/00843865ea13702eccc4efd64c313fd4c8029c6b.jpg@220w_280h.webp","totalCount":"全10话","id":28232253,"follow":"999.4 万","view":"4.0 亿","danmaku":"177.7 万","coin":"385.3 万","score":9.8,"des":"为了保护小鸡岛居民和这里平静的生活，伍六七和他的伙伴大保和小飞开启了去往玄武国的冒险旅程，去寻找身世的真相和解救小岛的办法，等待他们的又将是更多的未知与奇遇。..."},{"title":"堀与宫村","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/039c4e0b14e27c7a9e5cce2f20a6efd3c8909401.png@220w_280h.webp","totalCount":"全13话","id":28231840,"follow":"695.2 万","view":"2.2 亿","danmaku":"242.1 万","coin":"361.4 万","score":9.8,"des":"不论是谁，都会有不想被人知道的一面。\n\n在学校中漂亮大方、成绩优秀的人气女生堀，私下却打扮土气、忙于家务和照顾弟弟。\n在学校中是阴暗宅男形象的宫村，生活中却是打扮时尚、带耳钉的帅气男生。\n因为一次特别..."},{"title":"奇蛋物语 / WONDER EGG PRIORITY","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/10e0bbc1047b2c45f0f881de334a6f3bfb42a3b6.png@220w_280h.webp","totalCount":"全12话","id":28231851,"follow":"254.9 万","view":"4686.8 万","danmaku":"47.6 万","coin":"65.5 万","score":9.7,"des":"14岁少女·大户爱在深夜散步的途中，\n随着神秘声音的指引，获得了一枚「蛋」。\n\n「如果想要改变世界的话」\n「那么就在现在做出选择」\n「请相信自己——」\n「打破这枚蛋——」\n\n而在打破「蛋」之后，等待着..."},{"title":"Re：从零开始的异世界生活 第二季 后半","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/4f3edbede7fc0bdb52842075cf8faaa1c5953eaa.png@220w_280h.webp","totalCount":"全12话","id":28232073,"follow":"849.9 万","view":"9308.1 万","danmaku":"108.1 万","coin":"230.1 万","score":9.9,"des":"我一定会拯救你。\n在打倒了魔女教大罪司教「怠惰」担当——培提其乌斯·罗曼尼康帝之后，菜月昴和爱蜜莉雅又得以重新开始。\n克服了艰难的诀别，两人终于和解，然而这只是新一轮风波的序幕。\n超乎想象的绝境危机，..."},{"title":"灰与幻想的格林姆迦尔","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/7fb4945f864e9e988212b7d20f206df2677053f8.jpg@220w_280h.webp","totalCount":"全12话","id":106512,"follow":"172.0 万","view":"2343.4 万","danmaku":"63.8 万","coin":"18.3 万","score":9.8,"des":"电视动画《灰与幻想的格林姆迦尔》改编自日本轻小说家十文字青原作白井锐利插画的同名轻小说。\n我们为什么要这么做…？\n哈尔希洛回过神来，才发现自己身处在黑暗当中，他完全不知道自己人在何处，也不明白这个地方..."},{"title":"龙与虎","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/144910805f172d16c5f544f43939a05d8ca20576.jpg@220w_280h.webp","totalCount":"全26话","id":1672,"follow":"336.9 万","view":"6671.9 万","danmaku":"511.9 万","coin":"61.5 万","score":9.7,"des":"樱花飞舞的四月，全新的高中二年级，新的班级……\n眼神凶恶的普通男孩——高须龙儿，遇上了众人害怕、凶暴残忍的“掌中老虎”逢坂大河，还知道了她不欲为人知的秘密。这就是龙虎相争爱与战斗的序幕。\n再加上总是笑..."},{"title":"机动战士高达 铁血的奥尔芬斯 第一季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/f84a80d731d0431c00903d8951fd66623d8237f7.png@220w_280h.webp","totalCount":"全25话","id":4310042,"follow":"62.4 万","view":"2318.6 万","danmaku":"52.2 万","coin":"5.4 万","score":9.5,"des":"主人公三日月·奥古斯，从所属的民间警备公司克律塞安保公司（下称CGS）那里，接受了对少女库德莉亚·蓝那·伯恩斯坦的护卫任务。但CGS受到了摘取反叛之芽的武力组织加拉尔霍恩的袭击，于是在把三日月当做诱饵..."},{"title":"机动战士高达00 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1d7a969e8f1045739c596de89a963e30475aff0e.jpg@220w_280h.webp","totalCount":"全25话","id":1193,"follow":"37.2 万","view":"2458.1 万","danmaku":"61.4 万","coin":"4.1 万","score":9.8,"des":"天人与联合国军的最终决战后过了四年。建立地球联邦政府的人类，为了追求更进一步的国家间之统合，以及人类意识的统一，在联合正规军之外，设立了独立治安维持部队“A-Laws”，目的为对所有危害联合的势力与主..."},{"title":"机动战士高达00","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/35b11bf59eb3fd12f0387951510a5d722d7435e5.jpg@220w_280h.webp","totalCount":"全25话","id":1192,"follow":"62.1 万","view":"2465.5 万","danmaku":"53.6 万","coin":"4.6 万","score":9.7,"des":"在西历2307年，虽然化石燃料枯竭了，但是人类得到了截然不同的新型能源。三台巨大的轨道升降机以及伴随它们的大规模的太阳光发电系统。但是能得到这个系统恩惠的，只有一部分大国和其同盟国而已。\n拥有三台轨道..."},{"title":"Re：从零开始的异世界生活 第二季 前半","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f2425cbdb07cc93bd0d3ba1c0099bfe78f5dc58a.png@220w_280h.webp","totalCount":"全13话","id":28229233,"follow":"774.2 万","view":"1.3 亿","danmaku":"201.4 万","coin":"126.7 万","score":9.7,"des":"我一定会拯救你。\n在打倒了魔女教大罪司教「怠惰」担当——培提其乌斯·罗曼尼康帝之后，菜月昴和爱蜜莉雅又得以重新开始。\n克服了艰难的诀别，两人终于和解，然而这只是新一轮风波的序幕。\n超乎想象的绝境危机，..."},{"title":"超级小白","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3d3e8257d22596f5d3e4395ca759bd1e0fe9b873.jpg@220w_280h.webp","totalCount":"全48话","id":28222671,"follow":"27.4 万","view":"978.0 万","danmaku":"3.6 万","coin":"3.6 万","score":9.6,"des":"为了阻止企图霸占世界的黑暗势力，野原家的普通小狗——小白接肩负重大使命，变身成为了守护世界的“超级小白”。小白将要面对的不仅是发明狗，还有其他意想不到的对手。当然，面对邪恶势力，小白也有着令人惊讶的超..."},{"title":"Re：从零开始的异世界生活 新编集版","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3c125e1aad08643e3eff2fb7d45e740c1a052725.png@220w_280h.webp","totalCount":"全13话","id":28224394,"follow":"631.1 万","view":"7674.2 万","danmaku":"166.2 万","coin":"51.1 万","score":9.6,"des":"在从便利商店回家的路上，突然被异世界召唤的少年菜月昴。在无法依靠任何东西的异世界，无力的少年手唯一的力量……那是“死去然后重新开始”的力量。为了守护最重要的人们，为了取回确实存在着又无可替代的时间，少..."},{"title":"因为太怕痛就全点防御力了","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/8021d3f6b0df6dbba6d32f76eb9cfe2531e166c4.png@220w_280h.webp","totalCount":"全12话","id":28224137,"follow":"620.6 万","view":"2.3 亿","danmaku":"326.8 万","coin":"103.8 万","score":9,"des":"主角本条枫在好友白峰理沙推荐下开始游玩游戏“NewWorld Online”，创建了名为“梅普露”的角色。然而作为游戏初学者，梅普露选择了不受欢迎的大盾当武器，同时因为怕痛而把所有状态点加到防御力的极..."},{"title":"冰海战记","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/c30401817895e67399094b4e669785a104270cdf.jpg@220w_280h.webp","totalCount":"全24话","id":28220475,"follow":"174.4 万","view":"4893.8 万","danmaku":"48.7 万","coin":"36.7 万","score":9.8,"des":"公元10世纪末期，出现了在世界各地出没的最强民族。被讴歌为最强战士的托尔兹，其子托尔芬幼时便生活在战场上，并向往着梦幻大陆“文兰”。这是一个发生在激荡时代的，真正的英雄物语。..."},{"title":"齐木楠雄的灾难 始动篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ba59822eded39b5254fb01448a7f1502101d5624.png@220w_280h.webp","totalCount":"全6话","id":28223748,"follow":"372.4 万","view":"3054.5 万","danmaku":"20.0 万","coin":"17.8 万","score":9.8,"des":"在电视剧中堪称帅气的超能力，对于高中生齐木楠雄来说只是招致灾难的元凶。作为新动画系列展开的楠雄的日常又会如何！？..."},{"title":"OVERLORD Ⅱ","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/851f979c8ebcc7583a43abd4b786c4e2e66b746b.jpg@220w_280h.webp","totalCount":"全13话","id":8792,"follow":"539.3 万","view":"3.8 亿","danmaku":"413.9 万","coin":"114.1 万","score":9.6,"des":"时为2138年。曾卷起一大风潮的虚拟现实体感型网络游戏《YGGDRASIL》即将迎来停服。玩家飞鼠在曾经以同伴和荣华自傲的根据地纳萨力克地下大坟墓，独自一人安静等待着那一刻。但是，不料发生了结束时间已..."},{"title":"夏目友人帐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/99c549494d9425f6455bd45a151f4d26397d6151.png@220w_280h.webp","totalCount":"全13话","id":1660,"follow":"324.0 万","view":"4975.2 万","danmaku":"278.7 万","coin":"15.5 万","score":9.8,"des":"夏目贵志生来拥有强大的灵力，能感知平常人所无法接触的妖怪神明的存在。因父母双亡，他多年间辗转于互相推卸责任的亲戚之间，又受到同龄人的欺负，未曾与任何人深交，造成性格一定程度上的孤僻。夏目本性和善，对于..."}],"watched":[{"title":"装甲重拳/MEGALOBOX","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0c44785cb5d25cc9f648800d251f21a2e236bb8a.png@220w_280h.webp","totalCount":"全13话","id":79472,"follow":"221.9 万","view":"6162.0 万","danmaku":"48.6 万","coin":"32.9 万","score":9.8,"des":"将肉体与“装甲技术”融合的究极格斗技——“MEGALOBOX”，将自己的全部赌在上面的男人们的热血战斗开始！\n今天也立于未认可地区的赌博比赛赛场上的MEGALO拳击手“JNK DOG”。虽然具备实力，..."},{"title":"超能力女儿","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/152c536f8ecaad8f3d7d568d33da81c963a4a722.png@220w_280h.webp","totalCount":"全12话","id":78352,"follow":"293.8 万","view":"9252.2 万","danmaku":"98.5 万","coin":"35.4 万","score":9.6,"des":"支持着芦川组的年轻智力型黑道新田义史，过着被喜欢的壶所包围的悠然自得单身生活。但某一天，随着装在神秘物体里的少女雏来到他家，他的生活为之一变。他被能使用念动力的雏所胁迫，迫不得已开始和她同居！\n容易暴..."},{"title":"OVERLORD Ⅲ","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/dd7a9d0a0bee32b1f43c2656398d8463d12b3069.jpg@220w_280h.webp","totalCount":"全13话","id":102252,"follow":"551.6 万","view":"4.0 亿","danmaku":"399.7 万","coin":"129.2 万","score":9.4,"des":"时间为2138年。曾卷起一大风潮的虚拟现实体感型网络游戏《YGGDRASIL》即将迎来停服。玩家飞鼠在曾经以同伴和荣华自傲的根据地纳萨力克地下大坟墓，独自一人安静等待着那一刻。\n但是，不料发生了“过了..."},{"title":"路人超能100 第一次灵能咨询所员工旅游～舒缓心灵的疗愈之旅~（OVA2）","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/1271324d51634b68980704731987724a1afc60aa.jpg@220w_280h.webp","totalCount":"全1话","id":28222715,"follow":"318.8 万","view":"520.7 万","danmaku":"3.6 万","coin":"4.6 万","score":9.8,"des":"由原作ONE老师担任原案的完全新作OVA！「灵能咨询所」一行人，龙套与灵幻、小酒窝以及新同伴芹泽的目的地，正是缟马县深山中鲜为人知的温泉·疣神温泉。因为灵幻接受了旅馆老板娘的委托，「弄清温泉的恐怖传闻..."},{"title":"少女终末旅行","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1431ca5bb2f7143062e3df8f21b8448cf8cccc13.jpg@220w_280h.webp","totalCount":"全12话","id":6463,"follow":"239.8 万","view":"3714.7 万","danmaku":"100.7 万","coin":"37.2 万","score":9.8,"des":"本作舞台在人类繁华的文明迎来终结的很久以后，人类基本灭绝，甚至生物都不再存在的末日世界。复杂够高的都市成为迷宫般的废墟，得不到维护的机械渐渐停止运转。连何时终结了，何时开始终结的思考都不复存在的这个世..."},{"title":"齐木楠雄的灾难（日播&精选版）","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/eb4f17335f48951945fb9da47e6ee0bc65fa2fbb.jpg@220w_280h.webp","totalCount":"全120话","id":5070,"follow":"187.0 万","view":"2.3 亿","danmaku":"130.7 万","coin":"32.7 万","score":9.6,"des":"高中生·齐木楠雄是超能力者。心灵感应、念动力、透视、预知、瞬间移动、千里眼等，不论任何事情都自由自在。但这任谁都羡慕不已的最强能力，实际上对于本人而言是引来灾难的不幸元凶。因此，他在别人面前封印了超能..."},{"title":"比宇宙更远的地方","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/c9eca3cbc386c63b27461074b8b218898cb7440e.jpg@220w_280h.webp","totalCount":"全13话","id":13032,"follow":"156.0 万","view":"2298.0 万","danmaku":"45.9 万","coin":"23.9 万","score":9.8,"des":"无论何时，我们的第一步总是从好奇心开始。\n不曾看过的风景，不曾听过的声音，不曾闻过的味道，不曾摸过的质感，不曾尝过的食物，以及不曾感受过的澎湃。\n为了重拾不知何时忘却的记忆碎片和不知何时舍弃的感动的旅..."},{"title":"OVERLORD","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/b8e72ea69e57e0b7ac85d8b4d366554fd866df1a.jpg@220w_280h.webp","totalCount":"全13话","id":2576,"follow":"626.2 万","view":"4.1 亿","danmaku":"385.2 万","coin":"84.4 万","score":9.6,"des":"作品主要讲述了某天，一款曾经掀起过大热潮的VRMMORPG「YGGDRASIL」停止了运营。游戏原本会停止一切服务，但过了结束时间后，玩家们却发现不能退出，NPC也产生了各自的思想。现实世界中喜爱电玩..."},{"title":"路人超能100 II(灵能百分百 第二季)","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/216e1bdaf88244215a13b1154116805ee9adbe07.png@220w_280h.webp","totalCount":"全13话","id":4762734,"follow":"284.9 万","view":"1.0 亿","danmaku":"97.8 万","coin":"56.1 万","score":9.9,"des":"当有什么东西达到“100”的时候，就会爆发的少年·路人（龙套）。外表极其普通——不如说是不起眼。不擅长迎合气氛的他，实际上拥有着强力的超能力。盯上了这样的他的能力，而接连现身的伪灵能力者以及宗教团体、..."},{"title":"多罗罗","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3fc16a667502cbff226e585eb660a96a20c7458c.png@220w_280h.webp","totalCount":"全24话","id":4312482,"follow":"452.1 万","view":"1.8 亿","danmaku":"143.9 万","coin":"73.9 万","score":9.4,"des":"他们向着命运抗争，在那尽头等待他们的是人心，还是业障。\n时值乱世。\n名为景光的醍醐将军，向某个寺庙殿堂中的12尊魔神像祈求早日结束战乱。\n作为代价，他的嫡子在出生时就失去了身体的某些部位，被丢弃在河流..."},{"title":"魔法少女小圆","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/7fcaa0e98b561611538ae4deba7949cec4ca39a8.png@220w_280h.webp","totalCount":"全12话","id":2539,"follow":"218.7 万","view":"4199.0 万","danmaku":"201.5 万","coin":"20.0 万","score":9.8,"des":"就读初中二年级的鹿目圆，过着平凡幸福的生活。神秘转学生晓美焰的出现，开始让小圆的命运有了巨大转变。某日一只名为丘比的神秘生物，希望小圆能够与它签订魔法契约，成为“魔法少女”以对抗邪恶的魔女保护世界。正..."}]},"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<p><img src=\"http://rebp38war.bkt.clouddn.com/img/markdownpad2-weblogo.png\"><br></p>\n<blockquote>\n<p>&emsp;&emsp;使用 <a href=\"https://hexo.io/\">Hexo</a>来写博客 ， 需要使用Markdown工具来快速编写.md文件，我使用的是MarkdownPad 2。<br>MarkdownPad 2是一款较不错的Markdown编辑器，可快速将文本转换为美观的HTML/XHTML的网页格式代码，且操作方便，用户可以通过键盘快捷键和工具栏按钮来使用或者移除Markdown格式，左右栏的分割方式令用户可以实时看到 HTML 格式的 Markdown 文档。</p>\n</blockquote>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><blockquote>\n<p>简单三步，快速使用</p>\n</blockquote>\n<h3 id=\"第一步（下载）\"><a href=\"#第一步（下载）\" class=\"headerlink\" title=\"第一步（下载）\"></a>第一步（下载）</h3><p><a href=\"https://pan.baidu.com/s/1ffdu3der4hE8DNFE_9cuwQ\">点击下载程序</a><br><code>提取码：zm8e</code>，下载解压到指定目录<br></p>\n<blockquote>\n<p>注意：如果是<font color=\"#A52A2A\" size=\"4\">win10</font>还需要安装一个组件 <font color=\"#A52A2A\" size=\"4\">awesomium_v1.6.6_sdk_win</font>，否则会出现错误<br><br><a href=\"https://pan.baidu.com/s/1Skj-ZgxL_nbBgujlBlemZg\">点击下载组件</a><br><code>提取码：e7jn</code></p>\n</blockquote>\n<h3 id=\"第二步（撬锁）\"><a href=\"#第二步（撬锁）\" class=\"headerlink\" title=\"第二步（撬锁）\"></a>第二步（撬锁）</h3><p>找到根目录下MarkdownPad 2应用程序，运行并输入以下邮箱秘钥破解</p>\n<p>邮箱：<br><code>Soar360@live.com</code><br><br>授权秘钥：<br>        </p>\n<pre><code>GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ==\n</code></pre>\n<p><img src=\"http://rebp38war.bkt.clouddn.com/img/1.png\"></p>\n<h3 id=\"第三步-重启\"><a href=\"#第三步-重启\" class=\"headerlink\" title=\"第三步(重启)\"></a>第三步(重启)</h3><p>重启MarkdownPad 2就可以用了!</p>\n<p><img src=\"http://rebp38war.bkt.clouddn.com/img/4.png\"></p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>常用MarkdownPad2快捷键：<br></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">快捷键</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Ctrl + B</td>\n<td align=\"center\">粗体</td>\n</tr>\n<tr>\n<td align=\"center\">Ctrl + I</td>\n<td align=\"center\">斜体</td>\n</tr>\n<tr>\n<td align=\"center\">Ctrl + Q</td>\n<td align=\"center\">引用</td>\n</tr>\n<tr>\n<td align=\"center\">Ctrl + K</td>\n<td align=\"center\">代码块</td>\n</tr>\n<tr>\n<td align=\"center\">Ctrl + 1</td>\n<td align=\"center\">标题1</td>\n</tr>\n<tr>\n<td align=\"center\">Ctrl + 2</td>\n<td align=\"center\">标题2</td>\n</tr>\n<tr>\n<td align=\"center\">Ctrl + 3</td>\n<td align=\"center\">标题3</td>\n</tr>\n<tr>\n<td align=\"center\">Ctrl + U</td>\n<td align=\"center\">无序列表</td>\n</tr>\n<tr>\n<td align=\"center\">Ctrl + Shift + O</td>\n<td align=\"center\">有序列表</td>\n</tr>\n<tr>\n<td align=\"center\">Ctrl + G</td>\n<td align=\"center\">图片</td>\n</tr>\n<tr>\n<td align=\"center\">Ctrl + L</td>\n<td align=\"center\">超链接</td>\n</tr>\n<tr>\n<td align=\"center\">Ctrl + T</td>\n<td align=\"center\">时间戳</td>\n</tr>\n<tr>\n<td align=\"center\">Ctrl + R</td>\n<td align=\"center\">水平标尺</td>\n</tr>\n</tbody></table>\n<p>MD基本语法 ：<br><img src=\"http://rebp38war.bkt.clouddn.com/img/2.png\"><br><img src=\"http://rebp38war.bkt.clouddn.com/img/3.png\"></p>\n"},{"title":"RabbitMQ","date":"2022-07-09T09:16:37.000Z","cover":"http://rebp38war.bkt.clouddn.com/img/0c6040bca724a889d51ddc29ca994f31.jpeg","_content":"\n# 消息队列\n## MQ 的相关概念 \n\n### 什么是MQ\n\nMQ(message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是 message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常 见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不 用依赖其他服务。\n\n### 为什么要用MQ\n\n- **流量消峰**\n\n举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体验要好。\n\n- **应用解耦**\n\n以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合 调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于 消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在 这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流 系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。\n\n![RabbitMQ-00000004](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000004.png)\n\n- **异步处理**\n\n有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可以执行完。\n\n以前一般有两种方式，A 过一段时间去调用 B 的查询 api 查询。或者 A 提供一个 callback api， B 执行完之后调用 api 通知 A 服务。这两种方式都不是很优雅。\n\n使用消息总线，可以很方便解决这个问题， A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此消息转发给 A 服务。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样B 服务也不用 做这些操作。A 服务还能及时的得到异步处理成功的消息。\n\n![RabbitMQ-00000005](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000005.png)\n\n### MQ 的分类\n\n\n\n::: tip ActiveMQ\n\n:::\n\n优点：单机吞吐量万级，时效性 ms 级，可用性高，基于主从架构实现高可用性，消息可靠性较 低的概率丢失数据\n\n缺点：官方社区现在对 ActiveMQ 5.x 维护越来越少，高吞吐量场景较少使用。\n\n::: tip Kafka\n\n:::\n\n大数据的杀手锏，谈到大数据领域内的消息传输，则绕不开 Kafka，这款为**大数据而生**的消息中间件， 以其百万级 TPS 的吞吐量名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥 着举足轻重的作用。目前已经被 LinkedIn，Uber, Twitter, Netflix 等大公司所采纳。\n\n**优点**：性能卓越，单机写入 TPS 约在百万条/秒，最大的优点，就是**吞吐量高**。时效性 ms 级可用性非 常高，kafka 是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用,消费者采 用 Pull 方式获取消息, 消息有序, 通过控制能够保证所有消息被消费且仅被消费一次;有优秀的第三方Kafka Web 管理界面 Kafka-Manager；在日志领域比较成熟，被多家公司和多个开源项目使用；功能支持： 功能 较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用\n\n**缺点**：Kafka 单机超过 64 个队列/分区，Load 会发生明显的飙高现象，队列越多，load 越高，发送消 息响应时间变长，使用短轮询方式，实时性取决于轮询间隔时间，消费失败不支持重试；支持消息顺序， 但是一台代理宕机后，就会产生消息乱序，**社区更新较慢**；\n\n::: tip RocketMQ\n\n:::\n\nRocketMQ 出自阿里巴巴的开源产品，用 Java 语言实现，在设计时参考了 Kafka，并做出了自己的一 些改进。被阿里巴巴广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog 分发等场 景。\n\n优点：**单机吞吐量十万级**,可用性非常高，分布式架构，**消息可以做到 0 丢失**,MQ 功能较为完善，还是分 布式的，扩展性好,支**持 10 亿级别的消息堆积**，不会因为堆积导致性能下降,源码是 java 我们可以自己阅 读源码，定制自己公司的 MQ\n\n缺点：**支持的客户端语言不多**，目前是 java 及 c++，其中 c++不成熟；社区活跃度一般,没有在MQ 核心中去实现 JMS 等接口,有些系统要迁移需要修改大量代码\n\n::: note RabbitMQ\n\n:::\n\n2007 年发布，是一个在AMQP(高级消息队列协议)基础上完成的，可复用的企业消息系统，**是当前最主流的消息中间件之一。**\n\n优点：由于 erlang 语言的高并发特性，性能较好；吞吐量到万级，MQ 功能比较完备,健壮、稳定、易 用、跨平台、支持多种语言 如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，支持 AJAX 文档齐全；开源提供的管理界面非常棒，用起来很好用,社区活跃度高；更新频率相当高 \n\n官网更新：<https://www.rabbitmq.com/news.html>\n\n缺点：商业版需要收费,学习成本较高\n\n\n\n### MQ 的选择\n\n- **Kafka**\n\nKafka 主要特点是基于Pull 的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集 和传输，适合产生大量数据的互联网服务的数据收集业务。大型公司建议可以选用，如果有日志采集功能， 肯定是首选 kafka 了。\n\n尚硅谷官网 kafka 视频教程：http://www.gulixueyuan.com/course/330/tasks\n\n- **RocketMQ**\n\n天生为**金融互联网**领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削 峰，在大量交易涌入时，后端可能无法及时处理的情况。RoketMQ 在稳定性上可能更值得信赖，这些业务 场景在阿里双 11 已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择 RocketMQ。\n\n- RabbitMQ\n\n结合 erlang 语言本身的并发优势，性能好时效性微秒级，社区活跃度也比较高，管理界面用起来十分 方便，如果你的**数据量没有那么大**，中小型公司优先选择功能比较完备的 RabbitMQ。\n\n\n\n## RabbitMQ\n\n### RabbitMQ 的概念 \n\nRabbitMQ 是一个消息中间件：它接受并转发消息。\n\n你可以把它当做一个快递站点，当你要发送一个包裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑 RabbitMQ 是 一个快递站，一个快递员帮你传递快件。\n\nRabbitMQ 与快递站的主要区别在于，它不处理快件而是接收， 存储和转发消息数据。\n\n![image-20210625230930992](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210625230930992.png)\n\n官网：<https://www.rabbitmq.com/#features>\n\n### 四大核心概念\n\n- 生产者\n\n  产生数据发送消息的程序是生产者\n\n- 交换机\n\n  交换机是 RabbitMQ 非常重要的一个部件，一方面它接收来自生产者的消息，另一方面它将消息 推送到队列中。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推 送到多个队列，亦或者是把消息丢弃，这个得有交换机类型决定\n\n- 队列\n\n  队列是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ 和应用程序，但它们只能存 储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可 以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。这就是我们使用队列的方式\n\n- 消费者\n\n  消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者，消费 者和消息中间件很多时候并不在同一机器上。同一个应用程序既可以是生产者又是可以是消费者。\n\n\n\n### 各个名词介绍 \n\n\n\n![RabbitMQ-00000007](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000007.png)\n\n- Broker\n\n  接收和分发消息的应用，RabbitMQ Server 就是 Message Broker\n\n- Virtual host\n\n  出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似 于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出 多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等\n\n- Connection\n\n  publisher／consumer 和 broker 之间的 TCP 连接\n\n- Channel\n\n  如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程 序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客 户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的 Connection 极大减少了操作系统建立 TCP connection 的开销 \n\n- Exchange\n\n  message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发 消息到 queue 中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)\n\n- Queue\n\n  消息最终被送到这里等待 consumer 取走\n\n- Binding\n\n  exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key，Binding 信息被保 存到 exchange 中的查询表中，用于 message 的分发依据\n\n\n### 安装RabbitMQ\n\n**1、下载**\n\n官网下载地址：<https://www.rabbitmq.com/download.html>\n\n这里我们选择的版本号（注意这两版本要求）\n\n- rabbitmq-server-3.8.8-1.el7.noarch.rpm\n\n  GitHub：<https://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.8.8>\n\n  加载下载：<https://packagecloud.io/rabbitmq/rabbitmq-server/packages/el/7/rabbitmq-server-3.8.8-1.el7.noarch.rpm>\n\n- erlang-21.3.8.21-1.el7.x86_64.rpm\n\n  官网：https://www.erlang-solutions.com/downloads/\n\n  加速：<https://packagecloud.io/rabbitmq/erlang/packages/el/7/erlang-21.3.8.21-1.el7.x86_64.rpm>\n\n\n\nRed Hat 8, CentOS 8 和 modern Fedora 版本，把 “el7” 替换成 “el8”\n\n**2、安装**\n\n上传到 `/usr/local/software` 目录下(如果没有 software 需要自己创建)\n\n```shell\nrpm -ivh erlang-21.3.8.21-1.el7.x86_64.rpm\nyum install socat -y\nrpm -ivh rabbitmq-server-3.8.8-1.el7.noarch.rpm\n```\n\n**3、启动**\n\n\n\n```shell\n# 启动服务\nsystemctl start rabbitmq-server\n# 查看服务状态\nsystemctl status rabbitmq-server\n# 开机自启动\nsystemctl enable rabbitmq-server\n# 停止服务\nsystemctl stop rabbitmq-server\n# 重启服务\nsystemctl restart rabbitmq-server\n```\n\n### Web管理界面及授权操作\n\n**1、安装**\n\n默认情况下，是没有安装web端的客户端插件，需要安装才可以生效\n\n```shell\nrabbitmq-plugins enable rabbitmq_management\n```\n\n安装完毕以后，重启服务即可\n\n```shell\nsystemctl restart rabbitmq-server\n```\n\n访问 http://42.192.149.71:15672 ，用默认账号密码(guest)登录，出现权限问题\n\n默认情况只能在 localhost 本机下访问，所以需要添加一个远程登录的用户\n\n**2、添加用户**\n\n\n\n```shell\n# 创建账号和密码\nrabbitmqctl add_user admin 123456\n\n# 设置用户角色\nrabbitmqctl set_user_tags admin administrator\n\n# 为用户添加资源权限\n# set_permissions [-p <vhostpath>] <user> <conf> <write> <read>\nrabbitmqctl set_permissions -p \"/\" admin \".*\" \".*\" \".*\"\n# 添加配置、写、读权限\n```\n\n\n\n用户级别：\n\n1. **administrator**：可以登录控制台、查看所有信息、可以对 rabbitmq 进行管理\n2. **monitoring**：监控者 登录控制台，查看所有信息\n3. **policymaker**：策略制定者 登录控制台，指定策略\n4. **managment**：普通管理员 登录控制台\n\n\n\n再次登录，用 admin 用户\n\n\n\n::: tip 重置命令\n\n:::\n\n关闭应用的命令为：rabbitmqctl stop_app\n\n清除的命令为：rabbitmqctl reset\n\n重新启动命令为：rabbitmqctl start_app\n\n\n\n### Docker 安装\n\n官网：<https://registry.hub.docker.com/_/rabbitmq/>\n\n\n\n```shell\ndocker run -id --name myrabbit -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=123456 -p 15672:15672 rabbitmq:3-management\n```\n\n\n# Hello world\n\n\n\n我们将用 Java 编写两个程序。发送单个消息的生产者和接收消息并打印出来的消费者\n\n在下图中，“ P” 是我们的生产者，“ C” 是我们的消费者。中间的框是一个队列 RabbitMQ 代表使用者保留的消息缓冲区\n\n![RabbitMQ-00000012](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000012.png)\n\n连接的时候，需要开启 5672 端口\n\n![image-20210626162052259](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210626162052259.png)\n\n- **依赖**\n\npom.xml\n\n```xml\n<!--指定 jdk 编译版本-->\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.apache.maven.plugins</groupId>\n            <artifactId>maven-compiler-plugin</artifactId>\n            <configuration>\n                <source>8</source>\n                <target>8</target>\n            </configuration>\n        </plugin>\n    </plugins>\n</build>\n<dependencies>\n    <!--rabbitmq 依赖客户端-->\n    <dependency>\n        <groupId>com.rabbitmq</groupId>\n        <artifactId>amqp-client</artifactId>\n        <version>5.8.0</version>\n    </dependency>\n    <!--操作文件流的一个依赖-->\n    <dependency>\n        <groupId>commons-io</groupId>\n        <artifactId>commons-io</artifactId>\n        <version>2.6</version>\n    </dependency>\n</dependencies>\n```\n\n- **消息生产者**\n\n\n\n发送消息\n\n```java\npackage com.oddfar.one;\n\nimport com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.Connection;\nimport com.rabbitmq.client.ConnectionFactory;\n\n/**\n * @author zhiyuan\n */\npublic class Producer {\n    private final static String QUEUE_NAME = \"hello\";\n\n    public static void main(String[] args) throws Exception {\n        //创建一个连接工厂\n        ConnectionFactory factory = new ConnectionFactory();\n        factory.setHost(\"42.192.149.71\");\n        factory.setUsername(\"admin\");\n        factory.setPassword(\"123456\");\n        //channel 实现了自动 close 接口 自动关闭 不需要显示关闭\n        //创建连接\n        Connection connection = factory.newConnection();\n        //获取信道\n        Channel channel = connection.createChannel();\n        /**\n         * 生成一个队列\n         * 1.队列名称\n         * 2.队列里面的消息是否持久化 也就是是否用完就删除\n         * 3.该队列是否只供一个消费者进行消费 是否进行共享 true 可以多个消费者消费\n         * 4.是否自动删除 最后一个消费者端开连接以后 该队列是否自动删除 true 自动删除\n         * 5.其他参数\n         */\n        channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n        String message = \"hello world\";\n        /**\n         * 发送一个消息\n         * 1.发送到那个交换机\n         * 2.路由的 key 是哪个\n         * 3.其他的参数信息\n         * 4.发送消息的消息体\n         */\n        channel.basicPublish(\"\", QUEUE_NAME, null, message.getBytes());\n        System.out.println(\"消息发送完毕\");\n\n    }\n    \n}\n```\n\n\n\n- **消息消费者**\n\n获取“生产者”发出的消息\n\n```java\npackage com.oddfar.one;\n\nimport com.rabbitmq.client.*;\n\n/**\n * @author zhiyuan\n */\npublic class Consumer {\n    private final static String QUEUE_NAME = \"hello\";\n\n    public static void main(String[] args) throws Exception {\n        ConnectionFactory factory = new ConnectionFactory();\n        factory.setHost(\"42.192.149.71\");\n        factory.setUsername(\"admin\");\n        factory.setPassword(\"123456\");\n        Connection connection = factory.newConnection();\n        Channel channel = connection.createChannel();\n\n        System.out.println(\"等待接收消息.........\");\n\n        //推送的消息如何进行消费的接口回调\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody());\n            System.out.println(message);\n        };\n        //取消消费的一个回调接口 如在消费的时候队列被删除掉了\n        CancelCallback cancelCallback = (consumerTag) -> {\n            System.out.println(\"消息消费被中断\");\n        };\n        /**\n         * 消费者消费消息 - 接受消息\n         * 1.消费哪个队列\n         * 2.消费成功之后是否要自动应答 true 代表自动应答 false 手动应答\n         * 3.消费者未成功消费的回调\n         * 4.消息被取消时的回调\n         */\n        channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);\n    }\n\n}\n```\n\n# Work Queues\n\nWork Queues——工作队列(又称任务队列)的主要思想是避免立即执行资源密集型任务，而不得不等待它完成。 相反我们安排任务在之后执行。我们把任务封装为消息并将其发送到队列。在后台运行的工作进 程将弹出任务并最终执行作业。当有多个工作线程时，这些工作线程将一起处理这些任务。\n\n## 轮训分发消息\n\n在这个案例中我们会启动两个工作线程，一个消息发送线程，我们来看看他们两个工作线程是如何工作的。\n\n**1、抽取工具类**\n\n```java\npackage com.oddfar.utils;\n\nimport com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.Connection;\nimport com.rabbitmq.client.ConnectionFactory;\n\npublic class RabbitMqUtils {\n    //得到一个连接的 channel\n    public static Channel getChannel() throws Exception {\n        //创建一个连接工厂\n        ConnectionFactory factory = new ConnectionFactory();\n        factory.setHost(\"42.192.149.71\");\n        factory.setUsername(\"admin\");\n        factory.setPassword(\"123456\");\n        Connection connection = factory.newConnection();\n        Channel channel = connection.createChannel();\n        return channel;\n    }\n}\n```\n\n**2、启动两个工作线程来接受消息**\n\n```java\npackage com.oddfar.two;\n\nimport com.oddfar.utils.RabbitMqUtils;\nimport com.rabbitmq.client.CancelCallback;\nimport com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.DeliverCallback;\n\n/**\n * 这是一个工作线程，相当于之前的消费者\n *\n * @author zhiyuan\n */\npublic class Worker01 {\n\n    private static final String QUEUE_NAME = \"hello\";\n\n    public static void main(String[] args) throws Exception {\n\n        Channel channel = RabbitMqUtils.getChannel();\n\n        //消息接受\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String receivedMessage = new String(delivery.getBody());\n            System.out.println(\"接收到消息:\" + receivedMessage);\n        };\n        //消息被取消\n        CancelCallback cancelCallback = (consumerTag) -> {\n            System.out.println(consumerTag + \"消费者取消消费接口回调逻辑\");\n\n        };\n\n        System.out.println(\"C1 消费者启动等待消费.................. \");\n        channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);\n\n    }\n}\n```\n\n\n\n选中 `Allow multiple instances`\n![image-20210627125840217](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210627125840217.png)\n\n启动后\n\n![image-20210627130146584](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210627130146584.png)\n\n\n\n\n\n**3、启动一个发送消息线程**\n\n```java\npublic class Task01 {\n    public static final String QUEUE_NAME = \"hello\";\n\n    public static void main(String[] args) throws Exception {\n\n        Channel channel = RabbitMqUtils.getChannel();\n\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNext()) {\n            String message = scanner.next();\n            channel.basicPublish(\"\", QUEUE_NAME, null, message.getBytes());\n            System.out.println(\"消息发送完成：\" + message);\n        }\n\n    }\n}\n```\n\n\n\n- **结果展示**\n\n通过程序执行发现生产者总共发送 4 个消息，消费者 1 和消费者 2 分别分得两个消息，并且是按照有序的一个接收一次消息\n\n![RabbitMQ-00000016](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000016.png)\n\n## 消息应答\n\n\n\n消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成了部分突然它挂掉了，会发生什么情况。RabbitMQ 一旦向消费者传递了一条消息，便立即将该消息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息。以及后续发送给该消费这的消息，因为它无法接收到。\n\n为了保证消息在发送过程中不丢失，引入消息应答机制，消息应答就是：**消费者在接收到消息并且处理该消息之后，告诉 rabbitmq 它已经处理了，rabbitmq 可以把该消息删除了。** \n\n\n\n### 自动应答\n\n消息发送后立即被认为已经传送成功，这种模式需要在**高吞吐量和数据传输安全性方面做权衡**,因为这种模式如果消息在接收到之前，消费者那边出现连接或者 channel 关闭，那么消息就丢失 了,当然另一方面这种模式消费者那边可以传递过载的消息，**没有对传递的消息数量进行限制**，当然这样有可能使得消费者这边由于接收太多还来不及处理的消息，导致这些消息的积压，最终使 得内存耗尽，最终这些消费者线程被操作系统杀死，**所以这种模式仅适用在消费者可以高效并以 某种速率能够处理这些消息的情况下使用。**\n\n\n\n### 手动消息应答的方法 \n\n- Channel.basicAck(用于肯定确认)\n\n  RabbitMQ 已知道该消息并且成功的处理消息，可以将其丢弃了 \n\n- Channel.basicNack(用于否定确认) \n\n- Channel.basicReject(用于否定确认)\n\n  与 Channel.basicNack 相比少一个参数，不处理该消息了直接拒绝，可以将其丢弃了\n\n\n\n**Multiple 的解释：**\n\n手动应答的好处是可以批量应答并且减少网络拥堵 \n\n![RabbitMQ-00000017](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000017.png)\n\n- true 代表批量应答 channel 上未应答的消息\n\n  比如说 channel 上有传送 tag 的消息 5,6,7,8 当前 tag 是8 那么此时5-8 的这些还未应答的消息都会被确认收到消息应答\n\n- false 同上面相比只会应答 tag=8 的消息 5,6,7 这三个消息依然不会被确认收到消息应答\n\n\n\n![RabbitMQ-00000018](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000018.png)\n\n\n\n### 消息自动重新入队\n\n\n\n如果消费者由于某些原因失去连接(其通道已关闭，连接已关闭或 TCP 连接丢失)，导致消息未发送 ACK 确认，RabbitMQ 将了解到消息未完全处理，并将对其重新排队。如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确保不会丢失任何消息。\n\n\n\n![RabbitMQ-00000019](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000019.png)\n\n\n\n### 消息手动应答代码\n\n\n\n默认消息采用的是自动应答，所以我们要想实现消息消费过程中不丢失，需要把自动应答改为手动应答\n\n消费者在上面代码的基础上增加了以下内容\n\n```java\nchannel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);\n```\n\n\n\n**消息生产者：**\n\n```java\npackage com.oddfar.three;\n\nimport com.oddfar.utils.RabbitMqUtils;\nimport com.rabbitmq.client.Channel;\n\nimport java.util.Scanner;\n\n/**\n * 消息生产者,消息在手动应答时是不丢失的，放回队列重新消费\n *\n * @author zhiyuan\n */\npublic class Task02 {\n    private static final String TASK_QUEUE_NAME = \"ack_queue\";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtils.getChannel();\n        //声明队列\n        channel.queueDeclare(TASK_QUEUE_NAME, false, false, false, null);\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"请输入信息\");\n        while (sc.hasNext()) {\n            String message = sc.nextLine();\n            //发布消息\n            channel.basicPublish(\"\", TASK_QUEUE_NAME, null, message.getBytes(\"UTF-8\"));\n            System.out.println(\"生产者发出消息\" + message);\n        }\n    }\n\n}\n```\n\n**消费者 01：**\n\n```java\npackage com.oddfar.three;\n\nimport com.oddfar.utils.RabbitMqUtils;\nimport com.rabbitmq.client.CancelCallback;\nimport com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.DeliverCallback;\n\n/**\n * 消费者01\n *\n * @author zhiyuan\n */\npublic class Work03 {\n    private static final String TASK_QUEUE_NAME = \"ack_queue\";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtils.getChannel();\n        System.out.println(\"C1 等待接收消息处理时间较 短\");\n\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody());\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(\"接收到消息:\" + message);\n            /**\n             * 1.消息标记 tag\n             * 2.是否批量应答未应答消息\n             */\n            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);\n        };\n\n        CancelCallback cancelCallback = (s) -> {\n            System.out.println(s + \"消费者取消消费接口回调逻辑\");\n        };\n\n        //采用手动应答\n        boolean autoAck = false;\n        channel.basicConsume(TASK_QUEUE_NAME, autoAck, deliverCallback, cancelCallback);\n\n\n    }\n}\n```\n\n\n\n**消费者 02：**\n\n​\t把时间改成30秒\n\n\n\n::: tip 手动应答效果演示\n\n:::\n\n正常情况下消息发送方发送两个消息 C1 和 C2 分别接收到消息并进行处理\n\n![RabbitMQ-00000021](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000021.png)\n\n在发送者发送消息 dd，发出消息之后的把 C2 消费者停掉，按理说该 C2 来处理该消息，但是由于它处理时间较长，在还未处理完，也就是说 C2 还没有执行 ack 代码的时候，C2 被停掉了， 此时会看到消息被 C1 接收到了，说明消息 dd 被重新入队，然后分配给能处理消息的 C1 处理了\n\n\n\n![RabbitMQ-00000022](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000022.png)\n\n![RabbitMQ-00000023](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000023.png)\n\n\n\n![RabbitMQ-00000024](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000024.png)\n\n\n\n## RabbitMQ 持久化 \n\n当 RabbitMQ 服务停掉以后，消息生产者发送过来的消息不丢失要如何保障？默认情况下 RabbitMQ 退出或由于某种原因崩溃时，它忽视队列和消息，除非告知它不要这样做。确保消息不会丢失需要做两件事：**我们需要将队列和消息都标记为持久化。**\n\n\n\n::: tip 队列如何实现持久化\n\n:::\n\n之前我们创建的队列都是非持久化的，rabbitmq 如果重启的化，该队列就会被删除掉，如果要队列实现持久化需要在声明队列的时候把 durable 参数设置为持久化\n\n```java\n//让队列持久化\nboolean durable = true;\n//声明队列\nchannel.queueDeclare(TASK_QUEUE_NAME, durable, false, false, null);\n```\n\n\n\n注意：如果之前声明的队列不是持久化的，需要把原先队列先删除，或者重新创建一个持久化的队列，不然就会出现错误\n\n![RabbitMQ-00000026](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000026.png)\n\n以下为控制台中持久化与非持久化队列的 UI 显示区、\n\n![RabbitMQ-00000027](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000027.png)\n\n\n\n::: tip 消息实现持久化\n\n:::\n\n需要在消息**生产者**修改代码，`MessageProperties.PERSISTENT_TEXT_PLAIN` 添加这个属性。\n\n![RabbitMQ-00000028](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000028.png)\n\n将消息标记为持久化并不能完全保证不会丢失消息。尽管它告诉 RabbitMQ 将消息保存到磁盘，但是这里依然存在当消息刚准备存储在磁盘的时候 但是还没有存储完，消息还在缓存的一个间隔点。此时并没 有真正写入磁盘。持久性保证并不强，但是对于我们的简单任务队列而言，这已经绰绰有余了。\n\n如果需要更强有力的持久化策略，参考后边课件发布确认章节。\n\n## 不公平分发\n\n在最开始的时候我们学习到 RabbitMQ 分发消息采用的轮训分发，但是在某种场景下这种策略并不是很好，比方说有两个消费者在处理任务，其中有个**消费者 1** 处理任务的速度非常快，而另外一个**消费者 2** 处理速度却很慢，这个时候我们还是采用轮训分发的化就会到这处理速度快的这个消费者很大一部分时间处于空闲状态，而处理慢的那个消费者一直在干活，这种分配方式在这种情况下其实就不太好，但是 RabbitMQ 并不知道这种情况它依然很公平的进行分发。\n\n为了避免这种情况，**在消费者中消费之前**，我们可以设置参数 `channel.basicQos(1);`\n\n```java\n//不公平分发\nint prefetchCount = 1;\nchannel.basicQos(prefetchCount);\n//采用手动应答\nboolean autoAck = false;\nchannel.basicConsume(TASK_QUEUE_NAME, autoAck, deliverCallback, cancelCallback);\n```\n\n\n\n![RabbitMQ-00000030](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000030.png)\n\n![RabbitMQ-00000031](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000031.png)\n\n意思就是如果这个任务我还没有处理完或者我还没有应答你，你先别分配给我，我目前只能处理一个 任务，然后 rabbitmq 就会把该任务分配给没有那么忙的那个空闲消费者，当然如果所有的消费者都没有完 成手上任务，队列还在不停的添加新任务，队列有可能就会遇到队列被撑满的情况，这个时候就只能添加 新的 worker 或者改变其他存储任务的策略。\n\n## 预取值分发\n\n带权的消息分发\n\n本身消息的发送就是异步发送的，所以在任何时候，channel 上肯定不止只有一个消息另外来自消费 者的手动确认本质上也是异步的。因此这里就存在一个未确认的消息缓冲区，因此希望开发人员能**限制此缓冲区的大小**，**以避免缓冲区里面无限制的未确认消息问题**。这个时候就可以通过使用 basic.qos 方法设 置“预取计数”值来完成的。\n\n该值定义通道上允许的未确认消息的最大数量。一旦数量达到配置的数量， RabbitMQ 将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认，例如，假设在通道上有未确认的消息 5、6、7，8，并且通道的预取计数设置为 4，此时RabbitMQ 将不会在该通道上再传递任何消息，除非至少有一个未应答的消息被 ack。比方说 tag=6 这个消息刚刚被确认 ACK，RabbitMQ 将会感知 这个情况到并再发送一条消息。消息应答和 QoS 预取值对用户吞吐量有重大影响。\n\n通常，增加预取将提高 向消费者传递消息的速度。**虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理的消息的数量也会增加，从而增加了消费者的 RAM 消耗**(随机存取存储器)应该小心使用具有无限预处理的自动确认模式或手动确认模式，消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的 内存消耗变大，所以找到合适的预取值是一个反复试验的过程，不同的负载该值取值也不同 100 到 300 范 围内的值通常可提供最佳的吞吐量，并且不会给消费者带来太大的风险。\n\n预取值为 1 是最保守的。当然这将使吞吐量变得很低，特别是消费者连接延迟很严重的情况下，特别是在消费者连接等待时间较长的环境 中。对于大多数应用来说，稍微高一点的值将是最佳的。\n\n![RabbitMQ-00000032](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000032.png)\n\n\n# 发布确认\n\n## 发布确认原理\n\n生产者将信道设置成 confirm 模式，一旦信道进入 confirm 模式，所有在该信道上面发布的消息都将会被指派一个唯一的 ID(从 1 开始)，一旦消息被投递到所有匹配的队列之后，broker 就会发送一个确认给生产者(包含消息的唯一 ID)，这就使得生产者知道消息已经正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker 回传给生产者的确认消息中 delivery-tag 域包含了确认消息的序列号，此外 broker 也可以设置basic.ack 的 multiple 域，表示到这个序列号之前的所有消息都已经得到了处理。\n\nconfirm 模式最大的好处在于他是异步的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消息， 生产者应用程序同样可以在回调方法中处理该 nack 消息。\n\n\n\n## 发布确认的策略\n\n开启发布确认的方法:\n\n发布确认默认是没有开启的，如果要开启需要调用方法 confirmSelect，每当你要想使用发布确认，都需要在 channel 上调用该方法\n\n```java\n//开启发布确认\nchannel.confirmSelect();\n```\n\n### 单个确认发布\n\n这是一种简单的确认方式，它是一种**同步确认发布**的方式，也就是发布一个消息之后只有它被确认发布，后续的消息才能继续发布，`waitForConfirmsOrDie(long)` 这个方法只有在消息被确认的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。\n\n这种确认方式有一个最大的缺点就是：**发布速度特别的慢**，因为如果没有确认发布的消息就会阻塞所有后续消息的发布，这种方式最多提供每秒不超过数百条发布消息的吞吐量。当然对于某些应用程序来说这可能已经足够了。\n\n```java\n/**\n * 单个发送\n */\npublic static void publishMessageIndividually() throws Exception {\n    Channel channel = RabbitMqUtils.getChannel();\n    //队列声明\n    String queueName = UUID.randomUUID().toString();\n    channel.queueDeclare(queueName, true, false, false, null);\n    //开启发布确认\n    channel.confirmSelect();\n\n    long begin = System.currentTimeMillis();\n\n    for (int i = 0; i < MESSAGE_COUNT; i++) {\n        String message = i + \"\";\n        channel.basicPublish(\"\", queueName, null, message.getBytes());\n        //服务端返回 false 或超时时间内未返回，生产者可以消息重发\n        boolean flag = channel.waitForConfirms();\n        if (flag) {\n            System.out.println(\"消息发送成功\");\n        }\n    }\n\n    long end = System.currentTimeMillis();\n    System.out.println(\"发布\" + MESSAGE_COUNT + \"个单独确认消息,耗时\" + (end - begin) + \"ms\");\n\n}\n```\n\n### 批量确认发布\n\n上面那种方式非常慢，与单个等待确认消息相比，先发布一批消息然后一起确认可以极大地提高吞吐量，当然这种方式的缺点就是：当发生故障导致发布出现问题时，不知道是哪个消息出 问题了，我们必须将整个批处理保存在内存中，以记录重要的信息而后重新发布消息。当然这种方案仍然是同步的，也一样阻塞消息的发布。\n\n```java\n/**\n * 批量\n */\npublic static void publishMessageBatch() throws Exception {\n    Channel channel = RabbitMqUtils.getChannel();\n    //队列声明\n    String queueName = UUID.randomUUID().toString();\n    channel.queueDeclare(queueName, true, false, false, null);\n    //开启发布确认\n    channel.confirmSelect();\n    //批量确认消息大小\n    int batchSize = 100;\n    //未确认消息个数\n    int outstandingMessageCount = 0;\n    long begin = System.currentTimeMillis();\n\n    for (int i = 0; i < MESSAGE_COUNT; i++) {\n        String message = i + \"\";\n        channel.basicPublish(\"\", queueName, null, message.getBytes());\n        outstandingMessageCount++;\n        if (outstandingMessageCount == batchSize) {\n            channel.waitForConfirms();\n            outstandingMessageCount = 0;\n        }\n    }\n    //为了确保还有剩余没有确认消息 再次确认\n    if (outstandingMessageCount > 0) {\n        channel.waitForConfirms();\n    }\n    long end = System.currentTimeMillis();\n    System.out.println(\"发布\" + MESSAGE_COUNT + \"个批量确认消息,耗时\" + (end - begin) + \"ms\");\n}\n```\n\n### 异步确认发布 \n\n异步确认虽然编程逻辑比上两个要复杂，但是性价比最高，无论是可靠性还是效率都没得说， 他是利用回调函数来达到消息可靠性传递的，这个中间件也是通过函数回调来保证是否投递成功， 下面就让我们来详细讲解异步确认是怎么实现的。\n\n![RabbitMQ-00000034](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000034.png)\n\n\n\n\n\n\n\n如何处理异步未确认消息?\n\n最好的解决的解决方案就是把未确认的消息放到一个基于内存的能被发布线程访问的队列， 比如说用 ConcurrentLinkedQueue 这个队列在 confirm callbacks 与发布线程之间进行消息的传递。\n\n**以上 3 种发布确认速度对比 :**\n\n- 单独发布消息\n\n  同步等待确认，简单，但吞吐量非常有限。\n\n- 批量发布消息\n\n  批量同步等待确认，简单，合理的吞吐量，一旦出现问题但很难推断出是那条消息出现了问题。\n\n- 异步处理\n\n  最佳性能和资源使用，在出现错误的情况下可以很好地控制，但是实现起来稍微难些\n\n\n\n\n# 交换机\n\n\n## Exchanges\n\nRabbitMQ 消息传递模型的核心思想是: **生产者生产的消息从不会直接发送到队列**。实际上，通常生产者甚至都不知道这些消息传递传递到了哪些队列中。\n\n相反，**生产者只能将消息发送到交换机(exchange)**，交换机工作的内容非常简单，一方面它接收来自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息。是应该把这些消息放到特定队列还是说把他们到许多队列中还是说应该丢弃它们。这就的由交换机的类型来决定。\n\n![RabbitMQ-00000035](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000035.png)\n\n**Exchanges 的类型：**\n\n​\t直接(direct), 主题(topic) ,标题(headers) , 扇出(fanout)\n\n**无名exchange：**\n\n​\t在前面部分我们对 exchange 一无所知，但仍然能够将消息发送到队列。之前能实现的 原因是因为我们使用的是默认交换，我们通过空字符串(“”)进行标识。\n\n![RabbitMQ-00000036](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000036.png)\n\n第一个参数是交换机的名称。空字符串表示默认或无名称交换机：消息能路由发送到队列中其实是由 routingKey(bindingkey)绑定 key 指定的，如果它存在的话\n\n\n\n## 临时队列\n\n之前的章节我们使用的是具有特定名称的队列(还记得 hello 和 ack_queue 吗？)。队列的名称我们来说至关重要，我们需要指定我们的消费者去消费哪个队列的消息。\n\n每当我们连接到 Rabbit 时，我们都需要一个全新的空队列，为此我们可以创建一个具有**随机名称的队列**，或者能让服务器为我们选择一个随机队列名称那就更好了。其次一旦我们断开了消费者的连接，队列将被自动删除。\n\n创建临时队列的方式如下: \n\n```java\nString queueName = channel.queueDeclare().getQueue();\n```\n\n![RabbitMQ-00000037](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000037.png)\n\n## 绑定 bindings\n\n什么是 bingding 呢，binding 其实是 exchange 和 queue 之间的桥梁，它告诉我们 exchange 和那个队列进行了绑定关系。比如说下面这张图告诉我们的就是 X 与 Q1 和 Q2 进行了绑定\n\n![RabbitMQ-00000038](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000038.png)\n\n\n\n![image-20210627203918539](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210627203918539.png)\n\n## Fanout exchange\n\n### Fanout 介绍\n\nFanout 这种类型非常简单。正如从名称中猜到的那样，它是将接收到的所有消息广播到它知道的 所有队列中。系统中默认有些 exchange 类型\n\n![RabbitMQ-00000039](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000039.png)\n\n### Fanout 实战 \n\n\n\n![RabbitMQ-00000040](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000040.png)\n\nLogs 和临时队列的绑定关系如下图\n\n![RabbitMQ-00000041](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000041.png)\n\n\n\n为了说明这种模式，我们将构建一个简单的日志系统。它将由两个程序组成:第一个程序将发出日志消 息，第二个程序是消费者。其中我们会启动两个消费者，其中一个消费者接收到消息后把日志存储在磁盘，\n\n\n\nReceiveLogs01 将接收到的消息打印在控制台\n\n```java\npackage com.oddfar.five;\n\nimport com.oddfar.utils.RabbitMqUtils;\nimport com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.DeliverCallback;\n\n/**\n * @author zhiyuan\n */\npublic class ReceiveLogs01 {\n    private static final String EXCHANGE_NAME = \"logs\";\n\n    public static void main(String[] args) throws Exception {\n\n        Channel channel = RabbitMqUtils.getChannel();\n        channel.exchangeDeclare(EXCHANGE_NAME, \"fanout\");\n        /**\n         * 生成一个临时的队列 队列的名称是随机的\n         * 当消费者断开和该队列的连接时 队列自动删除\n         */\n        String queueName = channel.queueDeclare().getQueue();\n        //把该临时队列绑定我们的 exchange 其中 routingkey(也称之为 binding key)为空字符串\n        channel.queueBind(queueName, EXCHANGE_NAME, \"\");\n        System.out.println(\"等待接收消息,把接收到的消息打印在屏幕........... \");\n\n        //发送回调\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody(), \"UTF-8\");\n            System.out.println(\"控制台打印接收到的消息\" + message);\n        };\n        channel.basicConsume(queueName, true, deliverCallback, consumerTag -> {});\n\n    }\n}\n```\n\nReceiveLogs02 把消息写出到文件\n\n```java\npublic class ReceiveLogs02 {\n    private static final String EXCHANGE_NAME = \"logs\";\n\n    public static void main(String[] args) throws Exception {\n\n        Channel channel = RabbitMqUtils.getChannel();\n        channel.exchangeDeclare(EXCHANGE_NAME, \"fanout\");\n        /**\n         * 生成一个临时的队列 队列的名称是随机的\n         * 当消费者断开和该队列的连接时 队列自动删除\n         */\n        String queueName = channel.queueDeclare().getQueue();\n        //把该临时队列绑定我们的 exchange 其中 routingkey(也称之为 binding key)为空字符串\n        channel.queueBind(queueName, EXCHANGE_NAME, \"\");\n        System.out.println(\"等待接收消息,把接收到的消息写到文件........... \");\n\n        //发送回调\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody(), \"UTF-8\");\n            File file = new File(\"D:\\\\test\\\\rabbitmq_info.txt\");\n            FileUtils.writeStringToFile(file,message,\"UTF-8\");\n            System.out.println(\"数据写入文件成功\");\n        };\n        channel.basicConsume(queueName, true, deliverCallback, consumerTag -> {});\n\n    }\n}\n```\n\n\n\n\n\nEmitLog 发送消息给两个消费者接收：\n\n```java\npublic class EmitLog {\n    private static final String EXCHANGE_NAME = \"logs\";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtils.getChannel();\n\n        /**\n         * 声明一个 exchange\n         * 1.exchange 的名称\n         * 2.exchange 的类型\n         */\n        channel.exchangeDeclare(EXCHANGE_NAME, \"fanout\");\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"请输入信息\");\n        while (sc.hasNext()) {\n            String message = sc.nextLine();\n            channel.basicPublish(EXCHANGE_NAME, \"\", null, message.getBytes(\"UTF-8\"));\n            System.out.println(\"生产者发出消息\" + message);\n        }\n    }\n    \n}\n```\n\n## Direct exchange\n\n在上一节中，我们构建了一个简单的日志记录系统。我们能够向许多接收者广播日志消息。在本节我们将向其中添加一些特别的功能——让某个消费者订阅发布的部分消息。例如我们只把严重错误消息定向存储到日志文件(以节省磁盘空间)，同时仍然能够在控制台上打印所有日志消息。\n\n我们再次来回顾一下什么是 bindings，绑定是交换机和队列之间的桥梁关系。也可以这么理解： **队列只对它绑定的交换机的消息感兴趣**。绑定用参数：routingKey 来表示也可称该参数为 binding key， 创建绑定我们用代码:channel.queueBind(queueName, EXCHANGE_NAME, \"routingKey\");\n\n绑定之后的意义由其交换类型决定。\n\n### Direct 介绍\n\n\n\n上一节中的我们的日志系统将所有消息广播给所有消费者，对此我们想做一些改变，例如我们希 望将日志消息写入磁盘的程序仅接收严重错误(errros)，而不存储哪些警告(warning)或信息(info)日志 消息避免浪费磁盘空间。Fanout 这种交换类型并不能给我们带来很大的灵活性-它只能进行无意识的 广播，在这里我们将使用 direct 这种类型来进行替换，这种类型的工作方式是，消息只去到它绑定的 routingKey 队列中去。\n\n![RabbitMQ-00000042](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000042.png)\n\n在上面这张图中，我们可以看到 X 绑定了两个队列，绑定类型是 direct。队列Q1 绑定键为 orange， 队列 Q2 绑定键有两个:一个绑定键为 black，另一个绑定键为 green.\n\n在这种绑定情况下，生产者发布消息到 exchange 上，绑定键为 orange 的消息会被发布到队列 Q1。绑定键为 blackgreen 和的消息会被发布到队列 Q2，其他消息类型的消息将被丢弃。\n\n### 多重绑定 \n\n\n\n![RabbitMQ-00000043](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000043.png)\n\n当然如果 exchange 的绑定类型是direct，**但是它绑定的多个队列的 key 如果都相同**，在这种情况下虽然绑定类型是 direct **但是它表现的就和 fanout 有点类似了**，就跟广播差不多，如上图所示。\n\n### Direct 实战\n\n关系：\n\n![RabbitMQ-00000044](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000044.png)\n\n交换机：\n\n![RabbitMQ-00000045](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000045.png)\n\nc2：绑定disk，routingKey为error\n\nc1：绑定console，routingKey为info、warning\n\n1、\n\n```java\npackage com.oddfar.six;\n\nimport com.oddfar.utils.RabbitMqUtils;\nimport com.rabbitmq.client.BuiltinExchangeType;\nimport com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.DeliverCallback;\n\n/**\n * @author zhiyuan\n */\npublic class ReceiveLogsDirect01 {\n    private static final String EXCHANGE_NAME = \"direct_logs\";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtils.getChannel();\n        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);\n\n        String queueName = \"disk\";\n        //队列声明\n        channel.queueDeclare(queueName, false, false, false, null);\n        //队列绑定\n        channel.queueBind(queueName, EXCHANGE_NAME, \"error\");\n        System.out.println(\"等待接收消息...\");\n\n        //发送回调\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody(), \"UTF-8\");\n            message = \"接收绑定键:\" + delivery.getEnvelope().getRoutingKey() + \",消息:\" + message;\n            System.out.println(\"error 消息已经接收：\\n\" + message);\n        };\n        channel.basicConsume(queueName, true, deliverCallback, consumerTag -> {\n        });\n    }\n}\n```\n\n2、\n\n```java\npublic class ReceiveLogsDirect02 {\n    private static final String EXCHANGE_NAME = \"direct_logs\";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtils.getChannel();\n        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);\n\n        String queueName = \"console\";\n        //队列声明\n        channel.queueDeclare(queueName, false, false, false, null);\n        //队列绑定\n        channel.queueBind(queueName, EXCHANGE_NAME, \"info\");\n        channel.queueBind(queueName, EXCHANGE_NAME, \"warning\");\n\n        System.out.println(\"等待接收消息...\");\n\n        //发送回调\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody(), \"UTF-8\");\n            message = \"接收绑定键:\" + delivery.getEnvelope().getRoutingKey() + \",消息:\" + message;\n            System.out.println(\"info和warning 消息已经接收：\\n\" + message);\n        };\n        channel.basicConsume(queueName, true, deliverCallback, consumerTag -> {\n        });\n    }\n}\n```\n\n3、\n\n```java\npublic class EmitLogDirect {\n    private static final String EXCHANGE_NAME = \"direct_logs\";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtils.getChannel();\n        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);\n\n        //创建多个 bindingKey\n        Map<String, String> bindingKeyMap = new HashMap<>();\n        bindingKeyMap.put(\"info\", \"普通 info 信息\");\n        bindingKeyMap.put(\"warning\", \"警告 warning 信息\");\n        bindingKeyMap.put(\"error\", \"错误 error 信息\");\n        //debug 没有消费这接收这个消息 所有就丢失了\n        bindingKeyMap.put(\"debug\", \"调试 debug 信息\");\n\n        for (Map.Entry<String, String> bindingKeyEntry : bindingKeyMap.entrySet()) {\n            //获取 key value\n            String bindingKey = bindingKeyEntry.getKey();\n            String message = bindingKeyEntry.getValue();\n\n            channel.basicPublish(EXCHANGE_NAME, bindingKey, null, message.getBytes(\"UTF-8\"));\n            System.out.println(\"生产者发出消息:\" + message);\n        }\n    }\n}\n```\n\n## Topics exchange\n\n### Topic 的介绍\n\n在上一个小节中，我们改进了日志记录系统。我们没有使用只能进行随意广播的 fanout 交换机，而是使用了 direct 交换机，从而有能实现有选择性地接收日志。\n\n尽管使用 direct 交换机改进了我们的系统，但是它仍然存在局限性——比方说我们想接收的日志类型有 info.base 和 info.advantage，某个队列只想 info.base 的消息，那这个时候direct 就办不到了。这个时候就只能使用 **topic** 类型\n\n::: tip Topic的要求\n\n:::\n\n发送到类型是 topic 交换机的消息的 routing_key 不能随意写，必须满足一定的要求，它必须是**一个单词列表**，**以点号分隔开**。这些单词可以是任意单词\n\n比如说：\"stock.usd.nyse\", \"nyse.vmw\", \"quick.orange.rabbit\".这种类型的。\n\n当然这个单词列表最多不能超过 255 个字节。\n\n在这个规则列表中，其中有两个替换符是大家需要注意的：\n\n- ***(星号)可以代替一个单词**\n- **\\#(井号)可以替代零个或多个单词**\n\n\n\n### Topic 匹配案例\n\n下图绑定关系如下\n\n![RabbitMQ-00000046](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000046.png)\n\n- Q1-->绑定的是\n  - 中间带 orange 带 3 个单词的字符串 `(*.orange.*)`\n\n- Q2-->绑定的是\n  - 最后一个单词是 rabbit 的 3 个单词 `(*.*.rabbit)`\n  - 第一个单词是 lazy 的多个单词 `(lazy.#)`\n\n上图是一个队列绑定关系图，我们来看看他们之间数据接收情况是怎么样的\n\n| 例子                     | 说明                                       |\n| ------------------------ | ------------------------------------------ |\n| quick.orange.rabbit      | 被队列 Q1Q2 接收到                         |\n| azy.orange.elephant      | 被队列 Q1Q2 接收到                         |\n| quick.orange.fox         | 被队列 Q1 接收到                           |\n| lazy.brown.fox           | 被队列 Q2 接收到                           |\n| lazy.pink.rabbit         | 虽然满足两个绑定但只被队列 Q2 接收一次     |\n| quick.brown.fox          | 不匹配任何绑定不会被任何队列接收到会被丢弃 |\n| quick.orange.male.rabbit | 是四个单词不匹配任何绑定会被丢弃           |\n| lazy.orange.male.rabbit  | 是四个单词但匹配 Q2                        |\n\n注意：\n\n- 当一个队列绑定键是#，那么这个队列将接收所有数据，就有点像 fanout 了\n- 如果队列绑定键当中没有#和*出现，那么该队列绑定类型就是 direct 了\n\n### Topic 实战 \n\n![RabbitMQ-00000047](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000047.png)\n\n代码如下：\n\n```java\npackage com.oddfar.seven;\n\nimport com.oddfar.utils.RabbitMqUtils;\nimport com.rabbitmq.client.BuiltinExchangeType;\nimport com.rabbitmq.client.Channel;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * 发送端\n *\n * @author zhiyuan\n */\npublic class EmitLogTopic {\n    private static final String EXCHANGE_NAME = \"topic_logs\";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtils.getChannel();\n        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);\n\n        /**\n         * Q1-->绑定的是\n         *      中间带 orange 带 3 个单词的字符串(*.orange.*)\n         * Q2-->绑定的是\n         *      最后一个单词是 rabbit 的 3 个单词(*.*.rabbit)\n         *      第一个单词是 lazy 的多个单词(lazy.#)\n         *\n         */\n        Map<String, String> bindingKeyMap = new HashMap<>();\n        bindingKeyMap.put(\"quick.orange.rabbit\", \"被队列 Q1Q2 接收到\");\n        bindingKeyMap.put(\"lazy.orange.elephant\", \"被队列 Q1Q2 接收到\");\n        bindingKeyMap.put(\"quick.orange.fox\", \"被队列 Q1 接收到\");\n        bindingKeyMap.put(\"lazy.brown.fox\", \"被队列 Q2 接收到\");\n        bindingKeyMap.put(\"lazy.pink.rabbit\", \"虽然满足两个绑定但只被队列 Q2 接收一次\");\n        bindingKeyMap.put(\"quick.brown.fox\", \"不匹配任何绑定不会被任何队列接收到会被丢弃\");\n        bindingKeyMap.put(\"quick.orange.male.rabbit\", \"是四个单词不匹配任何绑定会被丢弃\");\n        bindingKeyMap.put(\"lazy.orange.male.rabbit\", \"是四个单词但匹配 Q2\");\n        for (Map.Entry<String, String> bindingKeyEntry : bindingKeyMap.entrySet()) {\n            String bindingKey = bindingKeyEntry.getKey();\n            String message = bindingKeyEntry.getValue();\n\n            channel.basicPublish(EXCHANGE_NAME, bindingKey, null, message.getBytes(\"UTF-8\"));\n            System.out.println(\"生产者发出消息：\" + message);\n        }\n    }\n}\n```\n\n\n\n```java\npublic class ReceiveLogsTopic01 {\n    private static final String EXCHANGE_NAME = \"topic_logs\";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtils.getChannel();\n        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);\n        //声明 Q1 队列与绑定关系\n        String queueName = \"Q1\";\n        //声明\n        channel.queueDeclare(queueName, false, false, false, null);\n        //绑定\n        channel.queueBind(queueName, EXCHANGE_NAME, \"*.orange.*\");\n        System.out.println(\"等待接收消息........... \");\n\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody(), \"UTF-8\");\n            System.out.println(\" 接收队列:\" + queueName + \" 绑定键:\" + delivery.getEnvelope().getRoutingKey() + \",消息:\" + message);\n        };\n        channel.basicConsume(queueName, true, deliverCallback, consumerTag -> {\n        });\n    }\n}\n```\n\n\n\n```java\npublic class ReceiveLogsTopic02 {\n    private static final String EXCHANGE_NAME = \"topic_logs\";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtils.getChannel();\n        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);\n        //声明 Q2 队列与绑定关系\n        String queueName = \"Q2\";\n        //声明\n        channel.queueDeclare(queueName, false, false, false, null);\n        //绑定\n        channel.queueBind(queueName, EXCHANGE_NAME, \"*.*.rabbit\");\n        channel.queueBind(queueName, EXCHANGE_NAME, \"lazy.#\");\n\n        System.out.println(\"等待接收消息........... \");\n\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody(), \"UTF-8\");\n            System.out.println(\" 接收队列:\" + queueName + \" 绑定键:\" + delivery.getEnvelope().getRoutingKey() + \",消息:\" + message);\n        };\n        channel.basicConsume(queueName, true, deliverCallback, consumerTag -> {\n        });\n    }\n}\n```\n# 死信队列\n\n## 死信的概念\n\n先从概念解释上搞清楚这个定义，死信，顾名思义就是无法被消费的消息，字面意思可以这样理 解，一般来说，producer 将消息投递到 broker 或者直接到queue 里了，consumer 从 queue 取出消息 进行消费，但某些时候由于特定的原因**导致 queue 中的某些消息无法被消费**，这样的消息如果没有后续的处理，就变成了死信，有死信自然就有了死信队列。\n\n应用场景：为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息消费发生异常时，将消息投入死信队列中。还有比如说：用户在商城下单成功并点击去支付后在指定时间未支付时自动失效\n\n\n\n## 死信的来源 \n\n- 消息 TTL 过期\n\n  TTL是Time To Live的缩写, 也就是生存时间\n\n- 队列达到最大长度\n\n  队列满了，无法再添加数据到 mq 中\n\n- 消息被拒绝\n\n  (basic.reject 或 basic.nack) 并且 requeue=false.\n\n## 死信实战 \n\n\n\n\n\n![RabbitMQ-00000048](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000048.png)\n\n### 死信之TTl\n\n消费者 C1 代码：\n\n```java\n/**\n * 死信队列 - 消费者01\n *\n * @author zhiyuan\n */\npublic class Consumer01 {\n\n    //普通交换机名称\n    private static final String NORMAL_EXCHANGE = \"normal_exchange\";\n    //死信交换机名称\n    private static final String DEAD_EXCHANGE = \"dead_exchange\";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtils.getChannel();\n\n        //声明死信和普通交换机 类型为 direct\n        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);\n        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);\n\n        //声明死信队列\n        String deadQueue = \"dead-queue\";\n        channel.queueDeclare(deadQueue, false, false, false, null);\n        //死信队列绑定：队列、交换机、路由键（routingKey）\n        channel.queueBind(deadQueue, DEAD_EXCHANGE, \"lisi\");\n\n        //正常队列绑定死信队列信息\n        Map<String, Object> params = new HashMap<>();\n        //正常队列设置死信交换机 参数 key 是固定值\n        params.put(\"x-dead-letter-exchange\", DEAD_EXCHANGE);\n        //正常队列设置死信 routing-key 参数 key 是固定值\n        params.put(\"x-dead-letter-routing-key\", \"lisi\");\n\n        //正常队列\n        String normalQueue = \"normal-queue\";\n        channel.queueDeclare(normalQueue, false, false, false, params);\n        channel.queueBind(normalQueue, NORMAL_EXCHANGE, \"zhangsan\");\n\n        System.out.println(\"等待接收消息........... \");\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody(), \"UTF-8\");\n            System.out.println(\"Consumer01 接收到消息\" + message);\n        };\n        channel.basicConsume(normalQueue, true, deliverCallback, consumerTag -> {\n        });\n    }\n\n}\n```\n\n生产者代码\n\n```java\npublic class Producer {\n    private static final String NORMAL_EXCHANGE = \"normal_exchange\";\n\n    public static void main(String[] argv) throws Exception {\n        Channel channel = RabbitMqUtils.getChannel();\n\n        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);\n        //设置消息的 TTL 时间 10s\n        AMQP.BasicProperties properties = new AMQP.BasicProperties().builder().expiration(\"10000\").build();\n        //该信息是用作演示队列个数限制\n        for (int i = 1; i < 11; i++) {\n            String message = \"info\" + i;\n            channel.basicPublish(NORMAL_EXCHANGE, \"zhangsan\", properties, message.getBytes());\n            System.out.println(\"生产者发送消息:\" + message);\n        }\n\n    }\n}\n```\n\n启动 C1 ，之后关闭消费者，模拟其接收不到消息。再启动 Producer\n\n![RabbitMQ-00000049](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000049.png)\n\n消费者 C2 代码：\n\n以上步骤完成后，启动 C2 消费者，它消费死信队列里面的消息\n\n```java\npublic class Consumer02 {\n    //死信交换机名称\n    private static final String DEAD_EXCHANGE = \"dead_exchange\";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtils.getChannel();\n\n        //声明交换机\n        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);\n        //声明队列\n        String deadQueue = \"dead-queue\";\n        channel.queueDeclare(deadQueue, false, false, false, null);\n        channel.queueBind(deadQueue, DEAD_EXCHANGE, \"lisi\");\n\n        System.out.println(\"等待接收死信消息........... \");\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody(), \"UTF-8\");\n            System.out.println(\"Consumer02 接收到消息\" + message);\n        };\n        channel.basicConsume(deadQueue, true, deliverCallback, consumerTag -> {\n        });\n    }\n}\n```\n\n![RabbitMQ-00000050](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000050.png)\n\n### 死信之最大长度\n\n1、消息生产者代码去掉 TTL 属性\n\n![image-20210628101337825](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210628101337825.png)\n\n2、C1 消费者修改以下代码**(启动之后关闭该消费者 模拟其接收不到消息)**\n\n![RabbitMQ-00000051](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000051.png)\n\n```java\n//设置正常队列的长度限制，例如发10个，4个则为死信\nparams.put(\"x-max-length\",6);\n```\n\n<mark>注意此时需要把原先队列删除 因为参数改变了</mark>\n\n3、C2 消费者代码不变(启动 C2 消费者) \n\n![RabbitMQ-00000052](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000052.png)\n\n### 死信之消息被拒\n\n1、消息生产者代码同上生产者一致\n\n2、C1 消费者代码(启动之后关闭该消费者 模拟其接收不到消息)\n\n拒收消息 \"info5\" \n\n```java\npublic class Consumer01 {\n\n    //普通交换机名称\n    private static final String NORMAL_EXCHANGE = \"normal_exchange\";\n    //死信交换机名称\n    private static final String DEAD_EXCHANGE = \"dead_exchange\";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtils.getChannel();\n\n        //声明死信和普通交换机 类型为 direct\n        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);\n        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);\n\n        //声明死信队列\n        String deadQueue = \"dead-queue\";\n        channel.queueDeclare(deadQueue, false, false, false, null);\n        //死信队列绑定：队列、交换机、路由键（routingKey）\n        channel.queueBind(deadQueue, DEAD_EXCHANGE, \"lisi\");\n        \n        //正常队列绑定死信队列信息\n        Map<String, Object> params = new HashMap<>();\n        //正常队列设置死信交换机 参数 key 是固定值\n        params.put(\"x-dead-letter-exchange\", DEAD_EXCHANGE);\n        //正常队列设置死信 routing-key 参数 key 是固定值\n        params.put(\"x-dead-letter-routing-key\", \"lisi\");\n//        //设置正常队列的长度限制，例如发10个，4个则为死信\n//        params.put(\"x-max-length\",6);\n        \n        //正常队列\n        String normalQueue = \"normal-queue\";\n        channel.queueDeclare(normalQueue, false, false, false, params);\n        channel.queueBind(normalQueue, NORMAL_EXCHANGE, \"zhangsan\");\n\n        System.out.println(\"等待接收消息........... \");\n        \n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody(), \"UTF-8\");\n            if (message.equals(\"info5\")) {\n                System.out.println(\"Consumer01 接收到消息\" + message + \"并拒绝签收该消息\");\n                //requeue 设置为 false 代表拒绝重新入队 该队列如果配置了死信交换机将发送到死信队列中\n                channel.basicReject(delivery.getEnvelope().getDeliveryTag(), false);\n            } else {\n                System.out.println(\"Consumer01 接收到消息\" + message);\n                channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);\n            }\n\n        };\n        //开启手动应答\n        channel.basicConsume(normalQueue, false, deliverCallback, consumerTag -> {\n        });\n    }\n\n}\n```\n\n![RabbitMQ-00000053](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000053.png)\n\n3、C2 消费者代码不变\n\n启动消费者 1 然后再启动消费者 2 \n\n![RabbitMQ-00000054](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000054.png)\n\n\n# 延迟队列\n\n## 延迟队列介绍\n\n- **延迟队列概念：**\n\n延时队列,队列内部是有序的，最重要的特性就体现在它的延时属性上，延时队列中的元素是希望 在指定时间到了以后或之前取出和处理，简单来说，延时队列就是用来存放需要在指定时间被处理的 元素的队列。\n\n- **延迟队列使用场景：**\n\n1.订单在十分钟之内未支付则自动取消\n2.新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒。\n3.用户注册成功后，如果三天内没有登陆则进行短信提醒。\n4.用户发起退款，如果三天内没有得到处理则通知相关运营人员。\n5.预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议\n\n这些场景都有一个特点，需要在某个事件发生之后或者之前的指定时间点完成某一项任务，如： 发生订单生成事件，在十分钟之后检查该订单支付状态，然后将未支付的订单进行关闭；那我们一直轮询数据，每秒查一次，取出需要被处理的数据，然后处理不就完事了吗？\n\n如果数据量比较少，确实可以这样做，比如：对于“如果账单一周内未支付则进行自动结算”这样的需求， 如果对于时间不是严格限制，而是宽松意义上的一周，那么每天晚上跑个定时任务检查一下所有未支付的账单，确实也是一个可行的方案。但对于数据量比较大，并且时效性较强的场景，如：“订单十分钟内未支付则关闭“，短期内未支付的订单数据可能会有很多，活动期间甚至会达到百万甚至千万级别，对这么庞大的数据量仍旧使用轮询的方式显然是不可取的，很可能在一秒内无法完成所有订单的检查，同时会给数据库带来很大压力，无法满足业务要求而且性能低下。\n\n![RabbitMQ-00000055](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000055.png)\n\n## RabbitMQ 中的 TTL\n\nTTL 是什么呢？TTL 是 RabbitMQ 中一个消息或者队列的属性，表明一条消息或者该队列中的所有消息的最大存活时间，单位是毫秒。\n\n换句话说，如果一条消息设置了 TTL 属性或者进入了设置TTL 属性的队列，那么这条消息如果在 TTL 设置的时间内没有被消费，则会成为\"死信\"。如果同时配置了队列的TTL 和消息的 TTL，那么较小的那个值将会被使用，有两种方式设置 TTL。\n\n\n\n- **队列设置TTL**\n\n在创建队列的时候设置队列的“x-message-ttl”属性\n\n![RabbitMQ-00000057](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000057.png)\n\n- **消息设置TTL**\n\n是针对每条消息设置TTL\n\n![RabbitMQ-00000056](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000056.png)\n\n\n\n::: tip 两者的区别 \n\n:::\n\n如果设置了队列的 TTL 属性，那么一旦消息过期，就会被队列丢弃(如果配置了死信队列被丢到死信队列中)，而第二种方式，消息即使过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者之前判定的，如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间；\n\n另外，还需要注意的一点是，如果不设置 TTL，表示消息永远不会过期，如果将 TTL 设置为 0，则表示除非此时可以直接投递该消息到消费者，否则该消息将会被丢弃。\n\n\n\n## 整合 springboot\n\n\n\n前一小节我们介绍了死信队列，刚刚又介绍了 TTL，至此利用 RabbitMQ 实现延时队列的两大要素已经集齐，接下来只需要将它们进行融合，再加入一点点调味料，延时队列就可以新鲜出炉了。想想看，延时队列，不就是想要消息延迟多久被处理吗，TTL 则刚好能让消息在延迟多久之后成为死信，另一方面， 成为死信的消息都会被投递到死信队列里，这样只需要消费者一直消费死信队列里的消息就完事了，因为里面的消息都是希望被立即处理的消息。\n\n\n\n1、创建一个空项目：\n\n![RabbitMQ-00000058](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000058.png)\n\n2、添加依赖：\n\n```xml\n<dependencies>\n   <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter</artifactId>\n    </dependency>\n    <!--RabbitMQ 依赖-->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-amqp</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-test</artifactId>\n        <scope>test</scope>\n    </dependency>\n    <dependency>\n        <groupId>com.alibaba</groupId>\n        <artifactId>fastjson</artifactId>\n        <version>1.2.47</version>\n    </dependency>\n    <dependency>\n        <groupId>org.projectlombok</groupId>\n        <artifactId>lombok</artifactId>\n    </dependency>\n    <!--swagger-->\n    <dependency>\n        <groupId>io.springfox</groupId>\n        <artifactId>springfox-swagger2</artifactId>\n        <version>3.0.0</version>\n    </dependency>\n    <dependency>\n        <groupId>io.springfox</groupId>\n        <artifactId>springfox-swagger-ui</artifactId>\n        <version>3.0.0</version>\n    </dependency>\n    <!--RabbitMQ 测试依赖-->\n    <dependency>\n        <groupId>org.springframework.amqp</groupId>\n        <artifactId>spring-rabbit-test</artifactId>\n        <scope>test</scope>\n    </dependency>\n</dependencies>\n```\n\n3、修改配置文件\n\n```properties\nspring.rabbitmq.host=42.192.149.71\nspring.rabbitmq.port=5672\nspring.rabbitmq.username=admin\nspring.rabbitmq.password=123456\n```\n\n4、添加Swagger 配置类 \n\n```java\npackage com.oddfar.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport springfox.documentation.builders.ApiInfoBuilder;\nimport springfox.documentation.service.ApiInfo;\nimport springfox.documentation.service.Contact;\nimport springfox.documentation.spi.DocumentationType;\nimport springfox.documentation.spring.web.plugins.Docket;\nimport springfox.documentation.swagger2.annotations.EnableSwagger2;\n\n\n@Configuration\n@EnableSwagger2\npublic class SwaggerConfig {\n\n    @Bean\n    public Docket webApiConfig() {\n        return new Docket(DocumentationType.SWAGGER_2)\n                .groupName(\"webApi\")\n                .apiInfo(webApiInfo())\n                .select()\n                .build();\n    }\n\n    private ApiInfo webApiInfo() {\n        return new ApiInfoBuilder()\n                .title(\"rabbitmq 接口文档\")\n                .description(\"本文档描述了 rabbitmq 微服务接口定义\")\n                .version(\"1.0\")\n                .contact(new Contact(\"zhiyuan\", \"http://oddfar.com\", \"test@qq.com\"))\n                .build();\n    }\n\n}\n```\n\n## 队列 TTL\n\n- **代码架构图** \n\n创建两个队列 QA 和 QB，两者队列 TTL 分别设置为 10S 和 40S，然后在创建一个交换机 X 和死信交 换机 Y，它们的类型都是direct，创建一个死信队列 QD，它们的绑定关系如下：\n\n![RabbitMQ-00000060](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000060.png)\n\n原先配置队列信息，写在了生产者和消费者代码中，现在可写咋配置类中，生产者只发消息，消费者只接受消息\n\n**1、配置文件类代码 ：**\n\n```java\npackage com.oddfar.config;\n\nimport org.springframework.amqp.core.*;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * @author zhiyuan\n */\n@Configuration\npublic class TtlQueueConfig {\n    public static final String X_EXCHANGE = \"X\";\n    public static final String QUEUE_A = \"QA\";\n    public static final String QUEUE_B = \"QB\";\n    //死信交换机\n    public static final String Y_DEAD_LETTER_EXCHANGE = \"Y\";\n    //死信队列\n    public static final String DEAD_LETTER_QUEUE = \"QD\";\n\n    // 声明 xExchange\n    @Bean(\"xExchange\")\n    public DirectExchange xExchange() {\n        return new DirectExchange(X_EXCHANGE);\n    }\n\n    // 声明 死信队列交换机\n    @Bean(\"yExchange\")\n    public DirectExchange yExchange() {\n        return new DirectExchange(Y_DEAD_LETTER_EXCHANGE);\n    }\n\n    //声明队列 A ttl 为 10s 并绑定到对应的死信交换机\n    @Bean(\"queueA\")\n    public Queue queueA() {\n        Map<String, Object> args = new HashMap<>(3);\n        //声明当前队列绑定的死信交换机\n        args.put(\"x-dead-letter-exchange\", Y_DEAD_LETTER_EXCHANGE);\n        //声明当前队列的死信路由 key\n        args.put(\"x-dead-letter-routing-key\", \"YD\");\n        //声明队列的 TTL\n        args.put(\"x-message-ttl\", 10000);\n        return QueueBuilder.durable(QUEUE_A).withArguments(args).build();\n    }\n\n    // 声明队列 A 绑定 X 交换机\n    @Bean\n    public Binding queueaBindingX(@Qualifier(\"queueA\") Queue queueA,\n                                  @Qualifier(\"xExchange\") DirectExchange xExchange) {\n        return BindingBuilder.bind(queueA).to(xExchange).with(\"XA\");\n    }\n\n    //声明队列 B ttl 为 40s 并绑定到对应的死信交换机\n    @Bean(\"queueB\")\n    public Queue queueB() {\n        Map<String, Object> args = new HashMap<>(3);\n        //声明当前队列绑定的死信交换机\n        args.put(\"x-dead-letter-exchange\", Y_DEAD_LETTER_EXCHANGE);\n        //声明当前队列的死信路由 key\n        args.put(\"x-dead-letter-routing-key\", \"YD\");\n        //声明队列的 TTL\n        args.put(\"x-message-ttl\", 40000);\n        return QueueBuilder.durable(QUEUE_B).withArguments(args).build();\n    }\n\n    //声明队列 B 绑定 X 交换机\n    @Bean\n    public Binding queuebBindingX(@Qualifier(\"queueB\") Queue queue1B,\n                                  @Qualifier(\"xExchange\") DirectExchange xExchange) {\n        return BindingBuilder.bind(queue1B).to(xExchange).with(\"XB\");\n    }\n\n    //声明死信队列 QD\n    @Bean(\"queueD\")\n    public Queue queueD() {\n        return new Queue(DEAD_LETTER_QUEUE);\n    }\n\n    //声明死信队列 QD 绑定关系\n    @Bean\n    public Binding deadLetterBindingQAD(@Qualifier(\"queueD\") Queue queueD,\n                                        @Qualifier(\"yExchange\") DirectExchange yExchange) {\n        return BindingBuilder.bind(queueD).to(yExchange).with(\"YD\");\n    }\n\n}\n```\n\n**2、消息生产者代码**\n\n```java\npackage com.oddfar.contorller;\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.amqp.rabbit.core.RabbitTemplate;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport java.util.Date;\n\n/**\n * @author zhiyuan\n */\n@Slf4j\n@RequestMapping(\"ttl\")\n@RestController\npublic class SendMsgController {\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n\n    @GetMapping(\"sendMsg/{message}\")\n    public void sendMsg(@PathVariable String message) {\n        log.info(\"当前时间：{},发送一条信息给两个 TTL 队列:{}\", new Date(), message);\n        rabbitTemplate.convertAndSend(\"X\", \"XA\", \"消息来自 ttl 为 10S 的队列: \" + message);\n        rabbitTemplate.convertAndSend(\"X\", \"XB\", \"消息来自 ttl 为 40S 的队列: \" + message);\n    }\n    \n}\n```\n\n**3、消息消费者代码** \n\n```java\npackage com.oddfar.consumer;\n\nimport com.rabbitmq.client.Channel;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.amqp.core.Message;\nimport org.springframework.amqp.rabbit.annotation.RabbitListener;\nimport org.springframework.stereotype.Component;\n\nimport java.io.IOException;\nimport java.util.Date;\n\n/**\n * 消费者 - 死信队列\n * @author zhiyuan\n */\n@Slf4j\n@Component\npublic class DeadLetterQueueConsumer {\n\n    @RabbitListener(queues = \"QD\")\n    public void receiveD(Message message, Channel channel) throws IOException {\n        String msg = new String(message.getBody());\n        log.info(\"当前时间：{},收到死信队列信息{}\", new Date().toString(), msg);\n    }\n\n}\n```\n\n发起一个请求 <http://localhost:8080/ttl/sendMsg/嘻嘻嘻>\n\n\n\n![image-20210628162017168](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210628162017168.png)\n\n第一条消息在 10S 后变成了死信消息，然后被消费者消费掉，第二条消息在 40S 之后变成了死信消息， 然后被消费掉，这样一个延时队列就打造完成了。\n\n\n\n不过，如果这样使用的话，岂不是每增加一个新的时间需求，就要新增一个队列，这里只有 10S 和 40S 两个时间选项，如果需要一个小时后处理，那么就需要增加TTL 为一个小时的队列，如果是预定会议室然后提前通知这样的场景，岂不是要增加无数个队列才能满足需求？\n\n## 延时队列TTL优化\n\n在这里新增了一个队列 QC,绑定关系如下,该队列不设置TTL 时间\n\n![RabbitMQ-00000062](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000062.png)\n\n配置文件类代码：\n\n```java\n@Configuration\npublic class MsgTtlQueueConfig {\n    public static final String Y_DEAD_LETTER_EXCHANGE = \"Y\";\n    public static final String QUEUE_C = \"QC\";\n\n    //声明队列 C 死信交换机\n    @Bean(\"queueC\")\n    public Queue queueB() {\n        Map<String, Object> args = new HashMap<>(3);\n        //声明当前队列绑定的死信交换机\n        args.put(\"x-dead-letter-exchange\", Y_DEAD_LETTER_EXCHANGE);\n        //声明当前队列的死信路由 key\n        args.put(\"x-dead-letter-routing-key\", \"YD\");\n        //没有声明 TTL 属性\n        return QueueBuilder.durable(QUEUE_C).withArguments(args).build();\n    }\n\n    //声明队列 B 绑定 X 交换机\n    @Bean\n    public Binding queuecBindingX(@Qualifier(\"queueC\") Queue queueC,\n                                  @Qualifier(\"xExchange\") DirectExchange xExchange) {\n        return BindingBuilder.bind(queueC).to(xExchange).with(\"XC\");\n    }\n}\n```\n\n生产者代码：\n\n```java\n/**\n * 延时队列优化\n * @param message 消息\n * @param ttlTime 延时的毫秒\n */\n@GetMapping(\"sendExpirationMsg/{message}/{ttlTime}\")\npublic void sendMsg(@PathVariable String message, @PathVariable String ttlTime) {\n    rabbitTemplate.convertAndSend(\"X\", \"XC\", message, correlationData -> {\n        correlationData.getMessageProperties().setExpiration(ttlTime);\n        return correlationData;\n    });\n    log.info(\"当前时间：{},发送一条时长{}毫秒 TTL 信息给队列 C:{}\", new Date(), ttlTime, message);\n}\n```\n\n发起请求\n\n<http://localhost:8080/ttl/sendExpirationMsg/你好1/20000>\n\n<http://localhost:8080/ttl/sendExpirationMsg/你好2/2000>\n\n![RabbitMQ-00000063](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000063.png)\n\n看起来似乎没什么问题，但是在最开始的时候，就介绍过如果使用在消息属性上设置 TTL 的方式，消息可能并不会按时“死亡“\n\n因为 RabbitMQ 只会检查第一个消息是否过期，如果过期则丢到死信队列， 如果第一个消息的延时时长很长，而第二个消息的延时时长很短，第二个消息并不会优先得到执行。\n\n这也就是为什么第二个延时2秒，却后执行。\n\n## Rabbitmq 插件实现延迟队列\n\n上文中提到的问题，确实是一个问题，如果不能实现在消息粒度上的 TTL，并使其在设置的TTL 时间及时死亡，就无法设计成一个通用的延时队列。那如何解决呢，接下来我们就去解决该问题。\n\n::: tip 安装延时队列插件\n\n:::\n\n可去[官网下载](https://www.rabbitmq.com/community-plugins.html) **rabbitmq_delayed_message_exchange** 插件，放置到 RabbitMQ 的插件目录。\n\n进入 RabbitMQ 的安装目录下的 plgins 目录，执行下面命令让该插件生效，然后重启 RabbitMQ\n\n```sh\n[root@VM-0-6-centos software]# ls\nerlang-21.3.8.21-1.el7.x86_64.rpm  rabbitmq_delayed_message_exchange-3.8.0.ez  rabbitmq-server-3.8.8-1.el7.noarch.rpm\n#移动\ncp rabbitmq_delayed_message_exchange-3.8.0.ez /usr/lib/rabbitmq/lib/rabbitmq_server-3.8.8/plugins\n#安装\nrabbitmq-plugins enable rabbitmq_delayed_message_exchange\n#重启服务\nsystemctl restart rabbitmq-server\n```\n\n![RabbitMQ-00000065](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000065.png)\n\n::: tip 代码\n\n:::\n\n在这里新增了一个队列delayed.queue,一个自定义交换机 delayed.exchange，绑定关系如下:\n\n![RabbitMQ-00000066](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000066.png)\n\n\n\n**1、配置文件类代码：**\n\n\n\n在我们自定义的交换机中，这是一种新的交换类型，该类型消息支持延迟投递机制消息传递后并不会立即投递到目标队列中，而是存储在 mnesia(一个分布式数据系统)表中，当达到投递时间时，才投递到目标队列中。\n\n```java\n@Configuration\npublic class DelayedQueueConfig {\n    public static final String DELAYED_QUEUE_NAME = \"delayed.queue\";\n    public static final String DELAYED_EXCHANGE_NAME = \"delayed.exchange\";\n    public static final String DELAYED_ROUTING_KEY = \"delayed.routingkey\";\n\n    @Bean\n    public Queue delayedQueue() {\n        return new Queue(DELAYED_QUEUE_NAME);\n    }\n\n    //自定义交换机 我们在这里定义的是一个延迟交换机\n    @Bean\n    public CustomExchange delayedExchange() {\n        Map<String, Object> args = new HashMap<>();\n        //自定义交换机的类型\n        args.put(\"x-delayed-type\", \"direct\");\n        return new CustomExchange(DELAYED_EXCHANGE_NAME, \"x-delayed-message\", true, false, args);\n    }\n\n    @Bean\n    public Binding bindingDelayedQueue(@Qualifier(\"delayedQueue\") Queue queue,\n                                       @Qualifier(\"delayedExchange\") CustomExchange delayedExchange) {\n        return BindingBuilder.bind(queue).to(delayedExchange).with(DELAYED_ROUTING_KEY).noargs();\n    }\n\n}\n```\n\n\n\n\n\n**2、生产者代码**\n\n```java\n@GetMapping(\"sendDelayMsg/{message}/{delayTime}\")\npublic void sendMsg(@PathVariable String message, @PathVariable Integer delayTime) {\n    rabbitTemplate.convertAndSend(DELAYED_EXCHANGE_NAME, DELAYED_ROUTING_KEY, message,\n            correlationData -> {\n                correlationData.getMessageProperties().setDelay(delayTime);\n                return correlationData;\n            });\n    log.info(\" 当 前 时 间 ： {}, 发 送 一 条 延 迟 {} 毫秒的信息给队列 delayed.queue:{}\", new Date(), delayTime, message);\n}\n```\n\n\n\n**3、消费者代码** \n\n```java\n/**\n * 消费者 - 基于插件的延时队列\n *\n * @author zhiyuan\n */\n@Slf4j\n@Component\npublic class DelayQueueConsumer {\n\n    public static final String DELAYED_QUEUE_NAME = \"delayed.queue\";\n\n    @RabbitListener(queues = DELAYED_QUEUE_NAME)\n    public void receiveDelayedQueue(Message message) {\n        String msg = new String(message.getBody());\n        log.info(\"当前时间：{},收到延时队列的消息：{}\", new Date().toString(), msg);\n    }\n}\n```\n\n发送请求：\n\n- <http://localhost:8080/ttl/sendDelayMsg/hello1/20000>\n- <http://localhost:8080/ttl/sendDelayMsg/hello2/2000>\n\n![image-20210628214856678](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210628214856678.png)\n\n第二个消息被先消费掉了，符合预期\n\n## 总结\n\n延时队列在需要延时处理的场景下非常有用，使用 RabbitMQ 来实现延时队列可以很好的利用 RabbitMQ 的特性，如：消息可靠发送、消息可靠投递、死信队列来保障消息至少被消费一次以及未被正确处理的消息不会被丢弃。另外，通过 RabbitMQ 集群的特性，可以很好的解决单点故障问题，不会因为 单个节点挂掉导致延时队列不可用或者消息丢失。\n\n当然，延时队列还有很多其它选择，比如利用 Java 的 DelayQueue，利用 Redis 的 zset，利用 Quartz 或者利用 kafka 的时间轮，这些方式各有特点,看需要适用的场景\n\n\n# 发布确认高级\n\n在生产环境中由于一些不明原因，导致 RabbitMQ  重启，在 RabbitMQ 重启期间生产者消息投递失败， 导致消息丢失，需要手动处理和恢复。于是，我们开始思考，如何才能进行 RabbitMQ 的消息可靠投递呢？ \n\n## 发布确认 springboot 版本\n\n确认机制方案：\n\n![RabbitMQ-00000068](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000068.png)\n\n代码架构图：\n\n\n\n![RabbitMQ-00000069](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000069.png)\n\n在配置文件当中需要添加\n\n```properties\nspring.rabbitmq.publisher-confirm-type=correlated\n```\n\n- `NONE` 值是禁用发布确认模式，是默认值\n\n- `CORRELATED` 值是发布消息成功到交换器后会触发回调方法\n\n- `SIMPLE` 值经测试有两种效果，其一效果和 CORRELATED 值一样会触发回调方法，其二在发布消息成功后使用 rabbitTemplate 调用 waitForConfirms 或 waitForConfirmsOrDie 方法等待 broker 节点返回发送结果，根据返回结果来判定下一步的逻辑，要注意的点是 waitForConfirmsOrDie 方法如果返回 false 则会关闭 channel，则接下来无法发送消息到 broker;\n\n::: tip 代码\n\n:::\n\n**1、添加配置类：**\n\n```java\n@Configuration\npublic class ConfirmConfig {\n    public static final String CONFIRM_EXCHANGE_NAME = \"confirm.exchange\";\n    public static final String CONFIRM_QUEUE_NAME = \"confirm.queue\";\n\n    //声明业务 Exchange\n    @Bean(\"confirmExchange\")\n    public DirectExchange confirmExchange() {\n        return new DirectExchange(CONFIRM_EXCHANGE_NAME);\n    }\n\n    // 声明确认队列\n    @Bean(\"confirmQueue\")\n    public Queue confirmQueue() {\n        return QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();\n    }\n\n    // 声明确认队列绑定关系\n    @Bean\n    public Binding queueBinding(@Qualifier(\"confirmQueue\") Queue queue,\n                                @Qualifier(\"confirmExchange\") DirectExchange exchange) {\n        return BindingBuilder.bind(queue).to(exchange).with(\"key1\");\n    }\n}\n```\n\n**2、消息生产者的回调接口**\n\n```java\n@Component\n@Slf4j\npublic class MyCallBack implements RabbitTemplate.ConfirmCallback {\n    /**\n     * 交换机不管是否收到消息的一个回调方法\n     *\n     * @param correlationData 消息相关数据\n     * @param ack             交换机是否收到消息\n     * @param cause           为收到消息的原因\n     */\n    @Override\n    public void confirm(CorrelationData correlationData, boolean ack, String cause) {\n        String id = correlationData != null ? correlationData.getId() : \"\";\n        if (ack) {\n            log.info(\"交换机已经收到 id 为:{}的消息\", id);\n        } else {\n            log.info(\"交换机还未收到 id 为:{}消息，原因:{}\", id, cause);\n        }\n    }\n\n}\n```\n\n**3、消息生产者** \n\n```java\n@RestController\n@RequestMapping(\"/confirm\")\n@Slf4j\npublic class ProducerController {\n    public static final String CONFIRM_EXCHANGE_NAME = \"confirm.exchange\";\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n    @Autowired\n    private MyCallBack myCallBack;\n\n    //依赖注入 rabbitTemplate 之后再设置它的回调对象\n    @PostConstruct\n    public void init() {\n        rabbitTemplate.setConfirmCallback(myCallBack);\n    }\n    \n    /**\n     * 消息回调和退回\n     *\n     * @param message\n     */\n    @GetMapping(\"sendMessage/{message}\")\n    public void sendMessage(@PathVariable String message) {\n\n        //指定消息 id 为 1\n        CorrelationData correlationData1 = new CorrelationData(\"1\");\n        String routingKey = \"key1\";\n        rabbitTemplate.convertAndSend(CONFIRM_EXCHANGE_NAME, routingKey, message + routingKey, correlationData1);\n        log.info(routingKey + \"发送消息内容:{}\", message + routingKey);\n\n        CorrelationData correlationData2 = new CorrelationData(\"2\");\n        routingKey = \"key2\";\n        rabbitTemplate.convertAndSend(CONFIRM_EXCHANGE_NAME, routingKey, message + routingKey, correlationData2);\n        log.info(routingKey + \"发送消息内容:{}\", message + routingKey);\n\n    }\n\n}\n```\n\n**4、消息消费者** \n\n```java\n@Component\n@Slf4j\npublic class ConfirmConsumer {\n    public static final String CONFIRM_QUEUE_NAME = \"confirm.queue\";\n\n    @RabbitListener(queues = CONFIRM_QUEUE_NAME)\n    public void receiveMsg(Message message) {\n        String msg = new String(message.getBody());\n        log.info(\"接受到队列 confirm.queue 消息:{}\", msg);\n    }\n\n}\n```\n\n访问： <http://localhost:8080/confirm/sendMessage/%E4%BD%A0%E5%A5%BD>\n\n结果分析：\n\n![image-20210629135636990](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210629135636990.png)\n\n可以看到，发送了两条消息，第一条消息的 RoutingKey 为 \"key1\"，第二条消息的 RoutingKey 为 \"key2\"，两条消息都成功被交换机接收，也收到了交换机的确认回调，但消费者只收到了一条消息，因为第二条消息的 RoutingKey 与队列的 BindingKey 不一致，也没有其它队列能接收这个消息，所有第二条消息被直接丢弃了。\n\n丢弃的消息交换机是不知道的，需要解决告诉生产者消息传送失败\n\n## 回退消息\n\nMandatory 参数 \n\n```java\nrabbitTemplate.setReturnsCallback(myCallBack);\n```\n\n在仅开启了生产者确认机制的情况下，交换机接收到消息后，会直接给消息生产者发送确认消息，如果发现该消息不可路由，那么消息会被直接丢弃，此时生产者是不知道消息被丢弃这个事件的。\n\n那么如何让无法被路由的消息帮我想办法处理一下？最起码通知我一声，我好自己处理啊。通过设置 mandatory 参数可以在当消息传递过程中不可达目的地时将消息返回给生产者。\n\n**1、修改配置**\n\n```properties\n#消息退回\nspring.rabbitmq.publisher-returns=true\n```\n\n**2、修改回调接口**\n\n```java\n@Component\n@Slf4j\npublic class MyCallBack implements RabbitTemplate.ConfirmCallback, RabbitTemplate.ReturnsCallback {\n\n    /**\n     * 交换机不管是否收到消息的一个回调方法\n     *\n     * @param correlationData 消息相关数据\n     * @param ack             交换机是否收到消息\n     * @param cause           为收到消息的原因\n     */\n    @Override\n    public void confirm(CorrelationData correlationData, boolean ack, String cause) {\n        String id = correlationData != null ? correlationData.getId() : \"\";\n        if (ack) {\n            log.info(\"交换机已经收到 id 为:{}的消息\", id);\n        } else {\n            log.info(\"交换机还未收到 id 为:{}消息，原因:{}\", id, cause);\n        }\n    }\n\n    //当消息无法路由的时候的回调方法\n    @Override\n    public void returnedMessage(ReturnedMessage returned) {\n\n        log.error(\"消息：{}，被交换机 {} 退回，原因：{}，路由key：{},code:{}\",\n                new String(returned.getMessage().getBody()), returned.getExchange(),\n                returned.getReplyText(), returned.getRoutingKey(),\n                returned.getReplyCode());\n\n    }\n}\n```\n\n低版本可能没有 `RabbitTemplate.ReturnsCallback` 请用 `RabbitTemplate.ReturnCallback`\n\n```java\n@Override\npublic void returnedMessage(Message message, int replyCode, String replyText, String\nexchange, String routingKey) {\n\tlog.info(\"消息:{}被服务器退回，退回原因:{}, 交换机是:{}, 路由 key:{}\",new String(message.getBody()),replyText, exchange, routingKey);\n}\n```\n\n\n\n**3、修改发送者 ProducerController**\n\n```java\n//依赖注入 rabbitTemplate 之后再设置它的回调对象\n@PostConstruct\npublic void init() {\n    //消息回调\n    rabbitTemplate.setConfirmCallback(myCallBack);\n    /**\n     * true：交换机无法将消息进行路由时，会将该消息返回给生产者\n     * false：如果发现消息无法进行路由，则直接丢弃\n     */\n    rabbitTemplate.setMandatory(true);\n    //设置回退消息交给谁处理\n    rabbitTemplate.setReturnsCallback(myCallBack);\n\n}\n```\n\n\n\n访问： <http://localhost:8080/confirm/sendMessage/%E4%BD%A0%E5%A5%BD>\n\n结果分析：\n\n![image-20210629143756078](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210629143756078.png)\n\n\n\n\n\n## 备份交换机\n\n有了 mandatory 参数和回退消息，我们获得了对无法投递消息的感知能力，在生产者的消息无法被投递时发现并处理。但有时候，我们并不知道该如何处理这些无法路由的消息，最多打个日志，然后触发报警，再来手动处理。而通过日志来处理这些无法路由的消息是很不优雅的做法，特别是当生产者所在的服务有多台机器的时候，手动复制日志会更加麻烦而且容易出错。而且设置 mandatory 参数会增加生产者的复杂性，需要添加处理这些被退回的消息的逻辑。如果既不想丢失消息，又不想增加生产者的复杂性，该怎么做呢？\n\n前面在设置死信队列的文章中，我们提到，可以为队列设置死信交换机来存储那些处理失败的消息，可是这些不可路由消息根本没有机会进入到队列，因此无法使用死信队列来保存消息。 在 RabbitMQ 中，有一种备份交换机的机制存在，可以很好的应对这个问题。\n\n什么是备份交换机呢？备份交换机可以理解为 RabbitMQ 中交换机的“备胎”，当我们为某一个交换机声明一个对应的备份交换机时，就是为它创建一个备胎，当交换机接收到一条不可路由消息时，将会把这条消息转发到备份交换机中，由备份交换机来进行转发和处理，通常备份交换机的类型为 Fanout ，这样就能把所有消息都投递到与其绑定的队列中，然后我们在备份交换机下绑定一个队列，这样所有那些原交换机无法被路由的消息，就会都进 入这个队列了。当然，我们还可以建立一个报警队列，用独立的消费者来进行监测和报警。\n\n- 代码架构图 \n\n![RabbitMQ-00000072](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000072.png)\n\n1、修改配置类\n\n```java\n@Configuration\npublic class ConfirmConfig {\n    public static final String CONFIRM_EXCHANGE_NAME = \"confirm.exchange\";\n    public static final String CONFIRM_QUEUE_NAME = \"confirm.queue\";\n    //关于备份的\n    public static final String BACKUP_EXCHANGE_NAME = \"backup.exchange\";\n    public static final String BACKUP_QUEUE_NAME = \"backup.queue\";\n    public static final String WARNING_QUEUE_NAME = \"warning.queue\";\n\n\n    /*\n    //声明业务 Exchange\n    @Bean(\"confirmExchange\")\n    public DirectExchange confirmExchange() {\n        return new DirectExchange(CONFIRM_EXCHANGE_NAME);\n    }\n    */\n\n    // 声明确认队列\n    @Bean(\"confirmQueue\")\n    public Queue confirmQueue() {\n        return QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();\n    }\n\n    // 声明确认队列绑定关系\n    @Bean\n    public Binding queueBinding(@Qualifier(\"confirmQueue\") Queue queue,\n                                @Qualifier(\"confirmExchange\") DirectExchange exchange) {\n        return BindingBuilder.bind(queue).to(exchange).with(\"key1\");\n    }\n\n    //************************以下是关于备份的******************************\n\n    //声明备份 Exchange\n    @Bean(\"backupExchange\")\n    public FanoutExchange backupExchange() {\n        return new FanoutExchange(BACKUP_EXCHANGE_NAME);\n    }\n\n    //声明确认 Exchange 交换机的备份交换机\n    @Bean(\"confirmExchange\")\n    public DirectExchange confirmExchange() {\n        ExchangeBuilder exchangeBuilder = ExchangeBuilder.directExchange(CONFIRM_EXCHANGE_NAME)\n                .durable(true)\n                //设置该交换机的备份交换机\n                .withArgument(\"alternate-exchange\", BACKUP_EXCHANGE_NAME);\n        return exchangeBuilder.build();\n    }\n\n\n    // 声明警告队列\n    @Bean(\"warningQueue\")\n    public Queue warningQueue() {\n        return QueueBuilder.durable(WARNING_QUEUE_NAME).build();\n    }\n\n    // 声明报警队列绑定关系\n    @Bean\n    public Binding warningBinding(@Qualifier(\"warningQueue\") Queue queue,\n                                  @Qualifier(\"backupExchange\") FanoutExchange backupExchange) {\n        return BindingBuilder.bind(queue).to(backupExchange);\n    }\n\n    // 声明备份队列\n    @Bean(\"backQueue\")\n    public Queue backQueue() {\n        return QueueBuilder.durable(BACKUP_QUEUE_NAME).build();\n    }\n\n    // 声明备份队列绑定关系\n    @Bean\n    public Binding backupBinding(@Qualifier(\"backQueue\") Queue queue,\n                                 @Qualifier(\"backupExchange\") FanoutExchange backupExchange) {\n        return BindingBuilder.bind(queue).to(backupExchange);\n    }\n}\n```\n\n2、报警消费者\n\n```java\n@Component\n@Slf4j\npublic class WarningConsumer {\n    public static final String WARNING_QUEUE_NAME = \"warning.queue\";\n\n    @RabbitListener(queues = WARNING_QUEUE_NAME)\n    public void receiveWarningMsg(Message message) {\n        String msg = new String(message.getBody());\n        log.error(\"报警发现不可路由消息：{}\", msg);\n    }\n}\n```\n\n之前已写过 `confirm.exchange` 交换机，由于更改配置，需要删掉，不然会报错\n\n![RabbitMQ-00000073](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000073.png)\n\n\n\n- 访问： <http://localhost:8080/confirm/sendMessage/%E4%BD%A0%E5%A5%BD>\n\n![image-20210629152752935](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210629152752935.png)\n\nmandatory 参数与备份交换机可以一起使用的时候，如果两者同时开启，消息究竟何去何从？谁优先级高，经过上面结果显示答案是**备份交换机优先级高**。\n\n\n\n# 幂等性\n\n::: tip 概念\n\n:::\n\n用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。 举个最简单的例子，那就是支付，用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常， 此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额发现多扣钱 了，流水记录也变成了两条。在以前的单应用系统中，我们只需要把数据操作放入事务中即可，发生错误立即回滚，但是再响应客户端的时候也有可能出现网络中断或者异常等等\n\n\n\n::: tip 消息重复消费\n\n:::\n\n消费者在消费 MQ 中的消息时，MQ 已把消息发送给消费者，消费者在给 MQ 返回 ack 时网络中断， 故 MQ 未收到确认信息，该条消息会重新发给其他的消费者，或者在网络重连后再次发送给该消费者，但实际上该消费者已成功消费了该条消息，造成消费者消费了重复的消息。\n\n\n\n::: tip 解决思路\n\n:::\n\nMQ 消费者的幂等性的解决一般使用全局 ID 或者写个唯一标识比如时间戳 或者 UUID 或者订单消费者消费 MQ 中的消息也可利用 MQ 的该 id 来判断，或者可按自己的规则生成一个全局唯一 id，每次消费消息时用该 id 先判断该消息是否已消费过。\n\n\n\n::: tip 消费端的幂等性保障\n\n:::\n\n在海量订单生成的业务高峰期，生产端有可能就会重复发生了消息，这时候消费端就要实现幂等性， 这就意味着我们的消息永远不会被消费多次，即使我们收到了一样的消息。\n\n业界主流的幂等性有两种操作:a. 唯一 ID+指纹码机制,利用数据库主键去重, b.利用 redis 的原子性去实现\n\n- 唯一ID+指纹码机制 \n\n\n\n指纹码：我们的一些规则或者时间戳加别的服务给到的唯一信息码,它并不一定是我们系统生成的，基本都是由我们的业务规则拼接而来，但是一定要保证唯一性，然后就利用查询语句进行判断这个 id 是否存在数据库中，优势就是实现简单就一个拼接，然后查询判断是否重复；劣势就是在高并发时，如果是单个数据库就会有写入性能瓶颈当然也可以采用分库分表提升性能，但也不是我们最推荐的方式。\n\n-  note Redis 原子性\n\n利用 redis 执行 setnx 命令，天然具有幂等性。从而实现不重复消费\n\n\n\n## 优先级队列\n\n- **使用场景**\n\n在我们系统中有一个订单催付的场景，我们的客户在天猫下的订单，淘宝会及时将订单推送给我们，如果在用户设定的时间内未付款那么就会给用户推送一条短信提醒，很简单的一个功能对吧。\n\n但是，tmall 商家对我们来说，肯定是要分大客户和小客户的对吧，比如像苹果，小米这样大商家一年起码能给我们创造很大的利润，所以理应当然，他们的订单必须得到优先处理，而曾经我们的后端系统是使用 redis 来存放的定时轮询，大家都知道 redis 只能用 List 做一个简简单单的消息队列，并不能实现一个优先级的场景，所以订单量大了后采用 RabbitMQ 进行改造和优化，如果发现是大客户的订单给一个相对比较高的优先级， 否则就是默认优先级。\n\n- **如何添加？**\n\na.控制台页面添加\n\n![RabbitMQ-00000076](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000076.png)\n\nb.队列中代码添加优先级\n\n```java\nMap<String, Object> params = new HashMap();\nparams.put(\"x-max-priority\", 10);\nchannel.queueDeclare(\"hello\", true, false, false, params);\n```\n\nc.消息中代码添加优先级\n\n```java\nAMQP.BasicProperties properties = new AMQP.BasicProperties().builder().priority(10).build();\n```\n\n**注意事项：**\n\n要让队列实现优先级需要做的事情有如下事情：队列需要设置为优先级队列，消息需要设置消息的优先级，消费者需要等待消息已经发送到队列中才去消费因为，这样才有机会对消息进行排序\n\n\n\n::: tip 实战 \n\n:::\n\n生产者：\n\n```java\npublic class PriorityProducer {\n    private static final String QUEUE_NAME = \"hello\";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtils.getChannel();\n\n        //给消息赋予一个 priority 属性\n        AMQP.BasicProperties properties = new AMQP.BasicProperties().builder().priority(10).build();\n\n        for (int i = 1; i < 11; i++) {\n            String message = \"info\" + i;\n            if (i == 5) {\n                channel.basicPublish(\"\", QUEUE_NAME, properties, message.getBytes());\n            } else {\n                channel.basicPublish(\"\", QUEUE_NAME, null, message.getBytes());\n            }\n            System.out.println(\"发送消息完成:\" + message);\n        }\n    }\n\n}\n```\n\n\n\n消费者：\n\n```java\npublic class PriorityConsumer {\n    private final static String QUEUE_NAME = \"hello\";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtils.getChannel();\n\n        //设置队列的最大优先级 最大可以设置到 255 官网推荐 1-10 如果设置太高比较吃内存和 CPU\n        Map<String, Object> params = new HashMap();\n        params.put(\"x-max-priority\", 10);\n        channel.queueDeclare(QUEUE_NAME, true, false, false, params);\n\n        //推送的消息如何进行消费的接口回调\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody());\n            System.out.println(message);\n        };\n        //取消消费的一个回调接口 如在消费的时候队列被删除掉了\n        CancelCallback cancelCallback = (consumerTag) -> {\n            System.out.println(\"消息消费被中断\");\n        };\n\n        channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);\n    }\n\n}\n```\n\n![image-20210629163922085](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210629163922085.png)\n\n\n\n## 惰性队列\n\n- **使用场景**\n\nRabbitMQ 从 3.6.0 版本开始引入了惰性队列的概念。惰性队列会尽可能的将消息存入磁盘中，而在消费者消费到相应的消息时才会被加载到内存中，它的一个重要的设计目标是能够支持更长的队列，即支持更多的消息存储。当消费者由于各种各样的原因(比如消费者下线、宕机亦或者是由于维护而关闭等)而致使长时间内不能消费消息造成堆积时，惰性队列就很有必要了。\n\n默认情况下，当生产者将消息发送到 RabbitMQ 的时候，队列中的消息会尽可能的存储在内存之中， 这样可以更加快速的将消息发送给消费者。即使是持久化的消息，在被写入磁盘的同时也会在内存中驻留一份备份。当RabbitMQ 需要释放内存的时候，会将内存中的消息换页至磁盘中，这个操作会耗费较长的时间，也会阻塞队列的操作，进而无法接收新的消息。虽然 RabbitMQ 的开发者们一直在升级相关的算法， 但是效果始终不太理想，尤其是在消息量特别大的时候。\n\n- **两种模式** \n\n队列具备两种模式：default 和 lazy。默认的为default 模式，在3.6.0 之前的版本无需做任何变更。lazy 模式即为惰性队列的模式，可以通过调用 channel.queueDeclare 方法的时候在参数中设置，也可以通过 Policy 的方式设置，如果一个队列同时使用这两种方式设置的话，那么 Policy 的方式具备更高的优先级。 如果要通过声明的方式改变已有队列的模式的话，那么只能先删除队列，然后再重新声明一个新的。\n\n在队列声明的时候可以通过“x-queue-mode”参数来设置队列的模式，取值为“default”和“lazy”。下面示例中演示了一个惰性队列的声明细节：\n\n```java\nMap<String, Object> args = new HashMap<String, Object>();\nargs.put(\"x-queue-mode\", \"lazy\");\nchannel.queueDeclare(\"myqueue\", false, false, false, args);\n```\n\n- 内存开销对比 \n\n![RabbitMQ-00000077](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000077.png)\n\n在发送 1 百万条消息，每条消息大概占 1KB 的情况下，普通队列占用内存是 1.2GB，而惰性队列仅仅 占用 1.5MB","source":"_posts/rabbitmq.md","raw":"---\ntitle: RabbitMQ\ndate: 2022-07-09 17:16:37\ntags: \n - mq\n - 消息中间件\ncategories: 消息中间件\ncover: http://rebp38war.bkt.clouddn.com/img/0c6040bca724a889d51ddc29ca994f31.jpeg\n---\n\n# 消息队列\n## MQ 的相关概念 \n\n### 什么是MQ\n\nMQ(message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是 message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常 见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不 用依赖其他服务。\n\n### 为什么要用MQ\n\n- **流量消峰**\n\n举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体验要好。\n\n- **应用解耦**\n\n以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合 调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于 消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在 这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流 系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。\n\n![RabbitMQ-00000004](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000004.png)\n\n- **异步处理**\n\n有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可以执行完。\n\n以前一般有两种方式，A 过一段时间去调用 B 的查询 api 查询。或者 A 提供一个 callback api， B 执行完之后调用 api 通知 A 服务。这两种方式都不是很优雅。\n\n使用消息总线，可以很方便解决这个问题， A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此消息转发给 A 服务。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样B 服务也不用 做这些操作。A 服务还能及时的得到异步处理成功的消息。\n\n![RabbitMQ-00000005](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000005.png)\n\n### MQ 的分类\n\n\n\n::: tip ActiveMQ\n\n:::\n\n优点：单机吞吐量万级，时效性 ms 级，可用性高，基于主从架构实现高可用性，消息可靠性较 低的概率丢失数据\n\n缺点：官方社区现在对 ActiveMQ 5.x 维护越来越少，高吞吐量场景较少使用。\n\n::: tip Kafka\n\n:::\n\n大数据的杀手锏，谈到大数据领域内的消息传输，则绕不开 Kafka，这款为**大数据而生**的消息中间件， 以其百万级 TPS 的吞吐量名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥 着举足轻重的作用。目前已经被 LinkedIn，Uber, Twitter, Netflix 等大公司所采纳。\n\n**优点**：性能卓越，单机写入 TPS 约在百万条/秒，最大的优点，就是**吞吐量高**。时效性 ms 级可用性非 常高，kafka 是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用,消费者采 用 Pull 方式获取消息, 消息有序, 通过控制能够保证所有消息被消费且仅被消费一次;有优秀的第三方Kafka Web 管理界面 Kafka-Manager；在日志领域比较成熟，被多家公司和多个开源项目使用；功能支持： 功能 较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用\n\n**缺点**：Kafka 单机超过 64 个队列/分区，Load 会发生明显的飙高现象，队列越多，load 越高，发送消 息响应时间变长，使用短轮询方式，实时性取决于轮询间隔时间，消费失败不支持重试；支持消息顺序， 但是一台代理宕机后，就会产生消息乱序，**社区更新较慢**；\n\n::: tip RocketMQ\n\n:::\n\nRocketMQ 出自阿里巴巴的开源产品，用 Java 语言实现，在设计时参考了 Kafka，并做出了自己的一 些改进。被阿里巴巴广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog 分发等场 景。\n\n优点：**单机吞吐量十万级**,可用性非常高，分布式架构，**消息可以做到 0 丢失**,MQ 功能较为完善，还是分 布式的，扩展性好,支**持 10 亿级别的消息堆积**，不会因为堆积导致性能下降,源码是 java 我们可以自己阅 读源码，定制自己公司的 MQ\n\n缺点：**支持的客户端语言不多**，目前是 java 及 c++，其中 c++不成熟；社区活跃度一般,没有在MQ 核心中去实现 JMS 等接口,有些系统要迁移需要修改大量代码\n\n::: note RabbitMQ\n\n:::\n\n2007 年发布，是一个在AMQP(高级消息队列协议)基础上完成的，可复用的企业消息系统，**是当前最主流的消息中间件之一。**\n\n优点：由于 erlang 语言的高并发特性，性能较好；吞吐量到万级，MQ 功能比较完备,健壮、稳定、易 用、跨平台、支持多种语言 如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，支持 AJAX 文档齐全；开源提供的管理界面非常棒，用起来很好用,社区活跃度高；更新频率相当高 \n\n官网更新：<https://www.rabbitmq.com/news.html>\n\n缺点：商业版需要收费,学习成本较高\n\n\n\n### MQ 的选择\n\n- **Kafka**\n\nKafka 主要特点是基于Pull 的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集 和传输，适合产生大量数据的互联网服务的数据收集业务。大型公司建议可以选用，如果有日志采集功能， 肯定是首选 kafka 了。\n\n尚硅谷官网 kafka 视频教程：http://www.gulixueyuan.com/course/330/tasks\n\n- **RocketMQ**\n\n天生为**金融互联网**领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削 峰，在大量交易涌入时，后端可能无法及时处理的情况。RoketMQ 在稳定性上可能更值得信赖，这些业务 场景在阿里双 11 已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择 RocketMQ。\n\n- RabbitMQ\n\n结合 erlang 语言本身的并发优势，性能好时效性微秒级，社区活跃度也比较高，管理界面用起来十分 方便，如果你的**数据量没有那么大**，中小型公司优先选择功能比较完备的 RabbitMQ。\n\n\n\n## RabbitMQ\n\n### RabbitMQ 的概念 \n\nRabbitMQ 是一个消息中间件：它接受并转发消息。\n\n你可以把它当做一个快递站点，当你要发送一个包裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑 RabbitMQ 是 一个快递站，一个快递员帮你传递快件。\n\nRabbitMQ 与快递站的主要区别在于，它不处理快件而是接收， 存储和转发消息数据。\n\n![image-20210625230930992](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210625230930992.png)\n\n官网：<https://www.rabbitmq.com/#features>\n\n### 四大核心概念\n\n- 生产者\n\n  产生数据发送消息的程序是生产者\n\n- 交换机\n\n  交换机是 RabbitMQ 非常重要的一个部件，一方面它接收来自生产者的消息，另一方面它将消息 推送到队列中。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推 送到多个队列，亦或者是把消息丢弃，这个得有交换机类型决定\n\n- 队列\n\n  队列是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ 和应用程序，但它们只能存 储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可 以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。这就是我们使用队列的方式\n\n- 消费者\n\n  消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者，消费 者和消息中间件很多时候并不在同一机器上。同一个应用程序既可以是生产者又是可以是消费者。\n\n\n\n### 各个名词介绍 \n\n\n\n![RabbitMQ-00000007](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000007.png)\n\n- Broker\n\n  接收和分发消息的应用，RabbitMQ Server 就是 Message Broker\n\n- Virtual host\n\n  出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似 于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出 多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等\n\n- Connection\n\n  publisher／consumer 和 broker 之间的 TCP 连接\n\n- Channel\n\n  如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程 序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客 户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的 Connection 极大减少了操作系统建立 TCP connection 的开销 \n\n- Exchange\n\n  message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发 消息到 queue 中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)\n\n- Queue\n\n  消息最终被送到这里等待 consumer 取走\n\n- Binding\n\n  exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key，Binding 信息被保 存到 exchange 中的查询表中，用于 message 的分发依据\n\n\n### 安装RabbitMQ\n\n**1、下载**\n\n官网下载地址：<https://www.rabbitmq.com/download.html>\n\n这里我们选择的版本号（注意这两版本要求）\n\n- rabbitmq-server-3.8.8-1.el7.noarch.rpm\n\n  GitHub：<https://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.8.8>\n\n  加载下载：<https://packagecloud.io/rabbitmq/rabbitmq-server/packages/el/7/rabbitmq-server-3.8.8-1.el7.noarch.rpm>\n\n- erlang-21.3.8.21-1.el7.x86_64.rpm\n\n  官网：https://www.erlang-solutions.com/downloads/\n\n  加速：<https://packagecloud.io/rabbitmq/erlang/packages/el/7/erlang-21.3.8.21-1.el7.x86_64.rpm>\n\n\n\nRed Hat 8, CentOS 8 和 modern Fedora 版本，把 “el7” 替换成 “el8”\n\n**2、安装**\n\n上传到 `/usr/local/software` 目录下(如果没有 software 需要自己创建)\n\n```shell\nrpm -ivh erlang-21.3.8.21-1.el7.x86_64.rpm\nyum install socat -y\nrpm -ivh rabbitmq-server-3.8.8-1.el7.noarch.rpm\n```\n\n**3、启动**\n\n\n\n```shell\n# 启动服务\nsystemctl start rabbitmq-server\n# 查看服务状态\nsystemctl status rabbitmq-server\n# 开机自启动\nsystemctl enable rabbitmq-server\n# 停止服务\nsystemctl stop rabbitmq-server\n# 重启服务\nsystemctl restart rabbitmq-server\n```\n\n### Web管理界面及授权操作\n\n**1、安装**\n\n默认情况下，是没有安装web端的客户端插件，需要安装才可以生效\n\n```shell\nrabbitmq-plugins enable rabbitmq_management\n```\n\n安装完毕以后，重启服务即可\n\n```shell\nsystemctl restart rabbitmq-server\n```\n\n访问 http://42.192.149.71:15672 ，用默认账号密码(guest)登录，出现权限问题\n\n默认情况只能在 localhost 本机下访问，所以需要添加一个远程登录的用户\n\n**2、添加用户**\n\n\n\n```shell\n# 创建账号和密码\nrabbitmqctl add_user admin 123456\n\n# 设置用户角色\nrabbitmqctl set_user_tags admin administrator\n\n# 为用户添加资源权限\n# set_permissions [-p <vhostpath>] <user> <conf> <write> <read>\nrabbitmqctl set_permissions -p \"/\" admin \".*\" \".*\" \".*\"\n# 添加配置、写、读权限\n```\n\n\n\n用户级别：\n\n1. **administrator**：可以登录控制台、查看所有信息、可以对 rabbitmq 进行管理\n2. **monitoring**：监控者 登录控制台，查看所有信息\n3. **policymaker**：策略制定者 登录控制台，指定策略\n4. **managment**：普通管理员 登录控制台\n\n\n\n再次登录，用 admin 用户\n\n\n\n::: tip 重置命令\n\n:::\n\n关闭应用的命令为：rabbitmqctl stop_app\n\n清除的命令为：rabbitmqctl reset\n\n重新启动命令为：rabbitmqctl start_app\n\n\n\n### Docker 安装\n\n官网：<https://registry.hub.docker.com/_/rabbitmq/>\n\n\n\n```shell\ndocker run -id --name myrabbit -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=123456 -p 15672:15672 rabbitmq:3-management\n```\n\n\n# Hello world\n\n\n\n我们将用 Java 编写两个程序。发送单个消息的生产者和接收消息并打印出来的消费者\n\n在下图中，“ P” 是我们的生产者，“ C” 是我们的消费者。中间的框是一个队列 RabbitMQ 代表使用者保留的消息缓冲区\n\n![RabbitMQ-00000012](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000012.png)\n\n连接的时候，需要开启 5672 端口\n\n![image-20210626162052259](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210626162052259.png)\n\n- **依赖**\n\npom.xml\n\n```xml\n<!--指定 jdk 编译版本-->\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.apache.maven.plugins</groupId>\n            <artifactId>maven-compiler-plugin</artifactId>\n            <configuration>\n                <source>8</source>\n                <target>8</target>\n            </configuration>\n        </plugin>\n    </plugins>\n</build>\n<dependencies>\n    <!--rabbitmq 依赖客户端-->\n    <dependency>\n        <groupId>com.rabbitmq</groupId>\n        <artifactId>amqp-client</artifactId>\n        <version>5.8.0</version>\n    </dependency>\n    <!--操作文件流的一个依赖-->\n    <dependency>\n        <groupId>commons-io</groupId>\n        <artifactId>commons-io</artifactId>\n        <version>2.6</version>\n    </dependency>\n</dependencies>\n```\n\n- **消息生产者**\n\n\n\n发送消息\n\n```java\npackage com.oddfar.one;\n\nimport com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.Connection;\nimport com.rabbitmq.client.ConnectionFactory;\n\n/**\n * @author zhiyuan\n */\npublic class Producer {\n    private final static String QUEUE_NAME = \"hello\";\n\n    public static void main(String[] args) throws Exception {\n        //创建一个连接工厂\n        ConnectionFactory factory = new ConnectionFactory();\n        factory.setHost(\"42.192.149.71\");\n        factory.setUsername(\"admin\");\n        factory.setPassword(\"123456\");\n        //channel 实现了自动 close 接口 自动关闭 不需要显示关闭\n        //创建连接\n        Connection connection = factory.newConnection();\n        //获取信道\n        Channel channel = connection.createChannel();\n        /**\n         * 生成一个队列\n         * 1.队列名称\n         * 2.队列里面的消息是否持久化 也就是是否用完就删除\n         * 3.该队列是否只供一个消费者进行消费 是否进行共享 true 可以多个消费者消费\n         * 4.是否自动删除 最后一个消费者端开连接以后 该队列是否自动删除 true 自动删除\n         * 5.其他参数\n         */\n        channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n        String message = \"hello world\";\n        /**\n         * 发送一个消息\n         * 1.发送到那个交换机\n         * 2.路由的 key 是哪个\n         * 3.其他的参数信息\n         * 4.发送消息的消息体\n         */\n        channel.basicPublish(\"\", QUEUE_NAME, null, message.getBytes());\n        System.out.println(\"消息发送完毕\");\n\n    }\n    \n}\n```\n\n\n\n- **消息消费者**\n\n获取“生产者”发出的消息\n\n```java\npackage com.oddfar.one;\n\nimport com.rabbitmq.client.*;\n\n/**\n * @author zhiyuan\n */\npublic class Consumer {\n    private final static String QUEUE_NAME = \"hello\";\n\n    public static void main(String[] args) throws Exception {\n        ConnectionFactory factory = new ConnectionFactory();\n        factory.setHost(\"42.192.149.71\");\n        factory.setUsername(\"admin\");\n        factory.setPassword(\"123456\");\n        Connection connection = factory.newConnection();\n        Channel channel = connection.createChannel();\n\n        System.out.println(\"等待接收消息.........\");\n\n        //推送的消息如何进行消费的接口回调\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody());\n            System.out.println(message);\n        };\n        //取消消费的一个回调接口 如在消费的时候队列被删除掉了\n        CancelCallback cancelCallback = (consumerTag) -> {\n            System.out.println(\"消息消费被中断\");\n        };\n        /**\n         * 消费者消费消息 - 接受消息\n         * 1.消费哪个队列\n         * 2.消费成功之后是否要自动应答 true 代表自动应答 false 手动应答\n         * 3.消费者未成功消费的回调\n         * 4.消息被取消时的回调\n         */\n        channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);\n    }\n\n}\n```\n\n# Work Queues\n\nWork Queues——工作队列(又称任务队列)的主要思想是避免立即执行资源密集型任务，而不得不等待它完成。 相反我们安排任务在之后执行。我们把任务封装为消息并将其发送到队列。在后台运行的工作进 程将弹出任务并最终执行作业。当有多个工作线程时，这些工作线程将一起处理这些任务。\n\n## 轮训分发消息\n\n在这个案例中我们会启动两个工作线程，一个消息发送线程，我们来看看他们两个工作线程是如何工作的。\n\n**1、抽取工具类**\n\n```java\npackage com.oddfar.utils;\n\nimport com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.Connection;\nimport com.rabbitmq.client.ConnectionFactory;\n\npublic class RabbitMqUtils {\n    //得到一个连接的 channel\n    public static Channel getChannel() throws Exception {\n        //创建一个连接工厂\n        ConnectionFactory factory = new ConnectionFactory();\n        factory.setHost(\"42.192.149.71\");\n        factory.setUsername(\"admin\");\n        factory.setPassword(\"123456\");\n        Connection connection = factory.newConnection();\n        Channel channel = connection.createChannel();\n        return channel;\n    }\n}\n```\n\n**2、启动两个工作线程来接受消息**\n\n```java\npackage com.oddfar.two;\n\nimport com.oddfar.utils.RabbitMqUtils;\nimport com.rabbitmq.client.CancelCallback;\nimport com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.DeliverCallback;\n\n/**\n * 这是一个工作线程，相当于之前的消费者\n *\n * @author zhiyuan\n */\npublic class Worker01 {\n\n    private static final String QUEUE_NAME = \"hello\";\n\n    public static void main(String[] args) throws Exception {\n\n        Channel channel = RabbitMqUtils.getChannel();\n\n        //消息接受\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String receivedMessage = new String(delivery.getBody());\n            System.out.println(\"接收到消息:\" + receivedMessage);\n        };\n        //消息被取消\n        CancelCallback cancelCallback = (consumerTag) -> {\n            System.out.println(consumerTag + \"消费者取消消费接口回调逻辑\");\n\n        };\n\n        System.out.println(\"C1 消费者启动等待消费.................. \");\n        channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);\n\n    }\n}\n```\n\n\n\n选中 `Allow multiple instances`\n![image-20210627125840217](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210627125840217.png)\n\n启动后\n\n![image-20210627130146584](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210627130146584.png)\n\n\n\n\n\n**3、启动一个发送消息线程**\n\n```java\npublic class Task01 {\n    public static final String QUEUE_NAME = \"hello\";\n\n    public static void main(String[] args) throws Exception {\n\n        Channel channel = RabbitMqUtils.getChannel();\n\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNext()) {\n            String message = scanner.next();\n            channel.basicPublish(\"\", QUEUE_NAME, null, message.getBytes());\n            System.out.println(\"消息发送完成：\" + message);\n        }\n\n    }\n}\n```\n\n\n\n- **结果展示**\n\n通过程序执行发现生产者总共发送 4 个消息，消费者 1 和消费者 2 分别分得两个消息，并且是按照有序的一个接收一次消息\n\n![RabbitMQ-00000016](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000016.png)\n\n## 消息应答\n\n\n\n消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成了部分突然它挂掉了，会发生什么情况。RabbitMQ 一旦向消费者传递了一条消息，便立即将该消息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息。以及后续发送给该消费这的消息，因为它无法接收到。\n\n为了保证消息在发送过程中不丢失，引入消息应答机制，消息应答就是：**消费者在接收到消息并且处理该消息之后，告诉 rabbitmq 它已经处理了，rabbitmq 可以把该消息删除了。** \n\n\n\n### 自动应答\n\n消息发送后立即被认为已经传送成功，这种模式需要在**高吞吐量和数据传输安全性方面做权衡**,因为这种模式如果消息在接收到之前，消费者那边出现连接或者 channel 关闭，那么消息就丢失 了,当然另一方面这种模式消费者那边可以传递过载的消息，**没有对传递的消息数量进行限制**，当然这样有可能使得消费者这边由于接收太多还来不及处理的消息，导致这些消息的积压，最终使 得内存耗尽，最终这些消费者线程被操作系统杀死，**所以这种模式仅适用在消费者可以高效并以 某种速率能够处理这些消息的情况下使用。**\n\n\n\n### 手动消息应答的方法 \n\n- Channel.basicAck(用于肯定确认)\n\n  RabbitMQ 已知道该消息并且成功的处理消息，可以将其丢弃了 \n\n- Channel.basicNack(用于否定确认) \n\n- Channel.basicReject(用于否定确认)\n\n  与 Channel.basicNack 相比少一个参数，不处理该消息了直接拒绝，可以将其丢弃了\n\n\n\n**Multiple 的解释：**\n\n手动应答的好处是可以批量应答并且减少网络拥堵 \n\n![RabbitMQ-00000017](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000017.png)\n\n- true 代表批量应答 channel 上未应答的消息\n\n  比如说 channel 上有传送 tag 的消息 5,6,7,8 当前 tag 是8 那么此时5-8 的这些还未应答的消息都会被确认收到消息应答\n\n- false 同上面相比只会应答 tag=8 的消息 5,6,7 这三个消息依然不会被确认收到消息应答\n\n\n\n![RabbitMQ-00000018](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000018.png)\n\n\n\n### 消息自动重新入队\n\n\n\n如果消费者由于某些原因失去连接(其通道已关闭，连接已关闭或 TCP 连接丢失)，导致消息未发送 ACK 确认，RabbitMQ 将了解到消息未完全处理，并将对其重新排队。如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确保不会丢失任何消息。\n\n\n\n![RabbitMQ-00000019](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000019.png)\n\n\n\n### 消息手动应答代码\n\n\n\n默认消息采用的是自动应答，所以我们要想实现消息消费过程中不丢失，需要把自动应答改为手动应答\n\n消费者在上面代码的基础上增加了以下内容\n\n```java\nchannel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);\n```\n\n\n\n**消息生产者：**\n\n```java\npackage com.oddfar.three;\n\nimport com.oddfar.utils.RabbitMqUtils;\nimport com.rabbitmq.client.Channel;\n\nimport java.util.Scanner;\n\n/**\n * 消息生产者,消息在手动应答时是不丢失的，放回队列重新消费\n *\n * @author zhiyuan\n */\npublic class Task02 {\n    private static final String TASK_QUEUE_NAME = \"ack_queue\";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtils.getChannel();\n        //声明队列\n        channel.queueDeclare(TASK_QUEUE_NAME, false, false, false, null);\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"请输入信息\");\n        while (sc.hasNext()) {\n            String message = sc.nextLine();\n            //发布消息\n            channel.basicPublish(\"\", TASK_QUEUE_NAME, null, message.getBytes(\"UTF-8\"));\n            System.out.println(\"生产者发出消息\" + message);\n        }\n    }\n\n}\n```\n\n**消费者 01：**\n\n```java\npackage com.oddfar.three;\n\nimport com.oddfar.utils.RabbitMqUtils;\nimport com.rabbitmq.client.CancelCallback;\nimport com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.DeliverCallback;\n\n/**\n * 消费者01\n *\n * @author zhiyuan\n */\npublic class Work03 {\n    private static final String TASK_QUEUE_NAME = \"ack_queue\";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtils.getChannel();\n        System.out.println(\"C1 等待接收消息处理时间较 短\");\n\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody());\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(\"接收到消息:\" + message);\n            /**\n             * 1.消息标记 tag\n             * 2.是否批量应答未应答消息\n             */\n            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);\n        };\n\n        CancelCallback cancelCallback = (s) -> {\n            System.out.println(s + \"消费者取消消费接口回调逻辑\");\n        };\n\n        //采用手动应答\n        boolean autoAck = false;\n        channel.basicConsume(TASK_QUEUE_NAME, autoAck, deliverCallback, cancelCallback);\n\n\n    }\n}\n```\n\n\n\n**消费者 02：**\n\n​\t把时间改成30秒\n\n\n\n::: tip 手动应答效果演示\n\n:::\n\n正常情况下消息发送方发送两个消息 C1 和 C2 分别接收到消息并进行处理\n\n![RabbitMQ-00000021](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000021.png)\n\n在发送者发送消息 dd，发出消息之后的把 C2 消费者停掉，按理说该 C2 来处理该消息，但是由于它处理时间较长，在还未处理完，也就是说 C2 还没有执行 ack 代码的时候，C2 被停掉了， 此时会看到消息被 C1 接收到了，说明消息 dd 被重新入队，然后分配给能处理消息的 C1 处理了\n\n\n\n![RabbitMQ-00000022](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000022.png)\n\n![RabbitMQ-00000023](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000023.png)\n\n\n\n![RabbitMQ-00000024](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000024.png)\n\n\n\n## RabbitMQ 持久化 \n\n当 RabbitMQ 服务停掉以后，消息生产者发送过来的消息不丢失要如何保障？默认情况下 RabbitMQ 退出或由于某种原因崩溃时，它忽视队列和消息，除非告知它不要这样做。确保消息不会丢失需要做两件事：**我们需要将队列和消息都标记为持久化。**\n\n\n\n::: tip 队列如何实现持久化\n\n:::\n\n之前我们创建的队列都是非持久化的，rabbitmq 如果重启的化，该队列就会被删除掉，如果要队列实现持久化需要在声明队列的时候把 durable 参数设置为持久化\n\n```java\n//让队列持久化\nboolean durable = true;\n//声明队列\nchannel.queueDeclare(TASK_QUEUE_NAME, durable, false, false, null);\n```\n\n\n\n注意：如果之前声明的队列不是持久化的，需要把原先队列先删除，或者重新创建一个持久化的队列，不然就会出现错误\n\n![RabbitMQ-00000026](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000026.png)\n\n以下为控制台中持久化与非持久化队列的 UI 显示区、\n\n![RabbitMQ-00000027](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000027.png)\n\n\n\n::: tip 消息实现持久化\n\n:::\n\n需要在消息**生产者**修改代码，`MessageProperties.PERSISTENT_TEXT_PLAIN` 添加这个属性。\n\n![RabbitMQ-00000028](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000028.png)\n\n将消息标记为持久化并不能完全保证不会丢失消息。尽管它告诉 RabbitMQ 将消息保存到磁盘，但是这里依然存在当消息刚准备存储在磁盘的时候 但是还没有存储完，消息还在缓存的一个间隔点。此时并没 有真正写入磁盘。持久性保证并不强，但是对于我们的简单任务队列而言，这已经绰绰有余了。\n\n如果需要更强有力的持久化策略，参考后边课件发布确认章节。\n\n## 不公平分发\n\n在最开始的时候我们学习到 RabbitMQ 分发消息采用的轮训分发，但是在某种场景下这种策略并不是很好，比方说有两个消费者在处理任务，其中有个**消费者 1** 处理任务的速度非常快，而另外一个**消费者 2** 处理速度却很慢，这个时候我们还是采用轮训分发的化就会到这处理速度快的这个消费者很大一部分时间处于空闲状态，而处理慢的那个消费者一直在干活，这种分配方式在这种情况下其实就不太好，但是 RabbitMQ 并不知道这种情况它依然很公平的进行分发。\n\n为了避免这种情况，**在消费者中消费之前**，我们可以设置参数 `channel.basicQos(1);`\n\n```java\n//不公平分发\nint prefetchCount = 1;\nchannel.basicQos(prefetchCount);\n//采用手动应答\nboolean autoAck = false;\nchannel.basicConsume(TASK_QUEUE_NAME, autoAck, deliverCallback, cancelCallback);\n```\n\n\n\n![RabbitMQ-00000030](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000030.png)\n\n![RabbitMQ-00000031](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000031.png)\n\n意思就是如果这个任务我还没有处理完或者我还没有应答你，你先别分配给我，我目前只能处理一个 任务，然后 rabbitmq 就会把该任务分配给没有那么忙的那个空闲消费者，当然如果所有的消费者都没有完 成手上任务，队列还在不停的添加新任务，队列有可能就会遇到队列被撑满的情况，这个时候就只能添加 新的 worker 或者改变其他存储任务的策略。\n\n## 预取值分发\n\n带权的消息分发\n\n本身消息的发送就是异步发送的，所以在任何时候，channel 上肯定不止只有一个消息另外来自消费 者的手动确认本质上也是异步的。因此这里就存在一个未确认的消息缓冲区，因此希望开发人员能**限制此缓冲区的大小**，**以避免缓冲区里面无限制的未确认消息问题**。这个时候就可以通过使用 basic.qos 方法设 置“预取计数”值来完成的。\n\n该值定义通道上允许的未确认消息的最大数量。一旦数量达到配置的数量， RabbitMQ 将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认，例如，假设在通道上有未确认的消息 5、6、7，8，并且通道的预取计数设置为 4，此时RabbitMQ 将不会在该通道上再传递任何消息，除非至少有一个未应答的消息被 ack。比方说 tag=6 这个消息刚刚被确认 ACK，RabbitMQ 将会感知 这个情况到并再发送一条消息。消息应答和 QoS 预取值对用户吞吐量有重大影响。\n\n通常，增加预取将提高 向消费者传递消息的速度。**虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理的消息的数量也会增加，从而增加了消费者的 RAM 消耗**(随机存取存储器)应该小心使用具有无限预处理的自动确认模式或手动确认模式，消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的 内存消耗变大，所以找到合适的预取值是一个反复试验的过程，不同的负载该值取值也不同 100 到 300 范 围内的值通常可提供最佳的吞吐量，并且不会给消费者带来太大的风险。\n\n预取值为 1 是最保守的。当然这将使吞吐量变得很低，特别是消费者连接延迟很严重的情况下，特别是在消费者连接等待时间较长的环境 中。对于大多数应用来说，稍微高一点的值将是最佳的。\n\n![RabbitMQ-00000032](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000032.png)\n\n\n# 发布确认\n\n## 发布确认原理\n\n生产者将信道设置成 confirm 模式，一旦信道进入 confirm 模式，所有在该信道上面发布的消息都将会被指派一个唯一的 ID(从 1 开始)，一旦消息被投递到所有匹配的队列之后，broker 就会发送一个确认给生产者(包含消息的唯一 ID)，这就使得生产者知道消息已经正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker 回传给生产者的确认消息中 delivery-tag 域包含了确认消息的序列号，此外 broker 也可以设置basic.ack 的 multiple 域，表示到这个序列号之前的所有消息都已经得到了处理。\n\nconfirm 模式最大的好处在于他是异步的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消息， 生产者应用程序同样可以在回调方法中处理该 nack 消息。\n\n\n\n## 发布确认的策略\n\n开启发布确认的方法:\n\n发布确认默认是没有开启的，如果要开启需要调用方法 confirmSelect，每当你要想使用发布确认，都需要在 channel 上调用该方法\n\n```java\n//开启发布确认\nchannel.confirmSelect();\n```\n\n### 单个确认发布\n\n这是一种简单的确认方式，它是一种**同步确认发布**的方式，也就是发布一个消息之后只有它被确认发布，后续的消息才能继续发布，`waitForConfirmsOrDie(long)` 这个方法只有在消息被确认的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。\n\n这种确认方式有一个最大的缺点就是：**发布速度特别的慢**，因为如果没有确认发布的消息就会阻塞所有后续消息的发布，这种方式最多提供每秒不超过数百条发布消息的吞吐量。当然对于某些应用程序来说这可能已经足够了。\n\n```java\n/**\n * 单个发送\n */\npublic static void publishMessageIndividually() throws Exception {\n    Channel channel = RabbitMqUtils.getChannel();\n    //队列声明\n    String queueName = UUID.randomUUID().toString();\n    channel.queueDeclare(queueName, true, false, false, null);\n    //开启发布确认\n    channel.confirmSelect();\n\n    long begin = System.currentTimeMillis();\n\n    for (int i = 0; i < MESSAGE_COUNT; i++) {\n        String message = i + \"\";\n        channel.basicPublish(\"\", queueName, null, message.getBytes());\n        //服务端返回 false 或超时时间内未返回，生产者可以消息重发\n        boolean flag = channel.waitForConfirms();\n        if (flag) {\n            System.out.println(\"消息发送成功\");\n        }\n    }\n\n    long end = System.currentTimeMillis();\n    System.out.println(\"发布\" + MESSAGE_COUNT + \"个单独确认消息,耗时\" + (end - begin) + \"ms\");\n\n}\n```\n\n### 批量确认发布\n\n上面那种方式非常慢，与单个等待确认消息相比，先发布一批消息然后一起确认可以极大地提高吞吐量，当然这种方式的缺点就是：当发生故障导致发布出现问题时，不知道是哪个消息出 问题了，我们必须将整个批处理保存在内存中，以记录重要的信息而后重新发布消息。当然这种方案仍然是同步的，也一样阻塞消息的发布。\n\n```java\n/**\n * 批量\n */\npublic static void publishMessageBatch() throws Exception {\n    Channel channel = RabbitMqUtils.getChannel();\n    //队列声明\n    String queueName = UUID.randomUUID().toString();\n    channel.queueDeclare(queueName, true, false, false, null);\n    //开启发布确认\n    channel.confirmSelect();\n    //批量确认消息大小\n    int batchSize = 100;\n    //未确认消息个数\n    int outstandingMessageCount = 0;\n    long begin = System.currentTimeMillis();\n\n    for (int i = 0; i < MESSAGE_COUNT; i++) {\n        String message = i + \"\";\n        channel.basicPublish(\"\", queueName, null, message.getBytes());\n        outstandingMessageCount++;\n        if (outstandingMessageCount == batchSize) {\n            channel.waitForConfirms();\n            outstandingMessageCount = 0;\n        }\n    }\n    //为了确保还有剩余没有确认消息 再次确认\n    if (outstandingMessageCount > 0) {\n        channel.waitForConfirms();\n    }\n    long end = System.currentTimeMillis();\n    System.out.println(\"发布\" + MESSAGE_COUNT + \"个批量确认消息,耗时\" + (end - begin) + \"ms\");\n}\n```\n\n### 异步确认发布 \n\n异步确认虽然编程逻辑比上两个要复杂，但是性价比最高，无论是可靠性还是效率都没得说， 他是利用回调函数来达到消息可靠性传递的，这个中间件也是通过函数回调来保证是否投递成功， 下面就让我们来详细讲解异步确认是怎么实现的。\n\n![RabbitMQ-00000034](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000034.png)\n\n\n\n\n\n\n\n如何处理异步未确认消息?\n\n最好的解决的解决方案就是把未确认的消息放到一个基于内存的能被发布线程访问的队列， 比如说用 ConcurrentLinkedQueue 这个队列在 confirm callbacks 与发布线程之间进行消息的传递。\n\n**以上 3 种发布确认速度对比 :**\n\n- 单独发布消息\n\n  同步等待确认，简单，但吞吐量非常有限。\n\n- 批量发布消息\n\n  批量同步等待确认，简单，合理的吞吐量，一旦出现问题但很难推断出是那条消息出现了问题。\n\n- 异步处理\n\n  最佳性能和资源使用，在出现错误的情况下可以很好地控制，但是实现起来稍微难些\n\n\n\n\n# 交换机\n\n\n## Exchanges\n\nRabbitMQ 消息传递模型的核心思想是: **生产者生产的消息从不会直接发送到队列**。实际上，通常生产者甚至都不知道这些消息传递传递到了哪些队列中。\n\n相反，**生产者只能将消息发送到交换机(exchange)**，交换机工作的内容非常简单，一方面它接收来自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息。是应该把这些消息放到特定队列还是说把他们到许多队列中还是说应该丢弃它们。这就的由交换机的类型来决定。\n\n![RabbitMQ-00000035](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000035.png)\n\n**Exchanges 的类型：**\n\n​\t直接(direct), 主题(topic) ,标题(headers) , 扇出(fanout)\n\n**无名exchange：**\n\n​\t在前面部分我们对 exchange 一无所知，但仍然能够将消息发送到队列。之前能实现的 原因是因为我们使用的是默认交换，我们通过空字符串(“”)进行标识。\n\n![RabbitMQ-00000036](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000036.png)\n\n第一个参数是交换机的名称。空字符串表示默认或无名称交换机：消息能路由发送到队列中其实是由 routingKey(bindingkey)绑定 key 指定的，如果它存在的话\n\n\n\n## 临时队列\n\n之前的章节我们使用的是具有特定名称的队列(还记得 hello 和 ack_queue 吗？)。队列的名称我们来说至关重要，我们需要指定我们的消费者去消费哪个队列的消息。\n\n每当我们连接到 Rabbit 时，我们都需要一个全新的空队列，为此我们可以创建一个具有**随机名称的队列**，或者能让服务器为我们选择一个随机队列名称那就更好了。其次一旦我们断开了消费者的连接，队列将被自动删除。\n\n创建临时队列的方式如下: \n\n```java\nString queueName = channel.queueDeclare().getQueue();\n```\n\n![RabbitMQ-00000037](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000037.png)\n\n## 绑定 bindings\n\n什么是 bingding 呢，binding 其实是 exchange 和 queue 之间的桥梁，它告诉我们 exchange 和那个队列进行了绑定关系。比如说下面这张图告诉我们的就是 X 与 Q1 和 Q2 进行了绑定\n\n![RabbitMQ-00000038](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000038.png)\n\n\n\n![image-20210627203918539](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210627203918539.png)\n\n## Fanout exchange\n\n### Fanout 介绍\n\nFanout 这种类型非常简单。正如从名称中猜到的那样，它是将接收到的所有消息广播到它知道的 所有队列中。系统中默认有些 exchange 类型\n\n![RabbitMQ-00000039](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000039.png)\n\n### Fanout 实战 \n\n\n\n![RabbitMQ-00000040](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000040.png)\n\nLogs 和临时队列的绑定关系如下图\n\n![RabbitMQ-00000041](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000041.png)\n\n\n\n为了说明这种模式，我们将构建一个简单的日志系统。它将由两个程序组成:第一个程序将发出日志消 息，第二个程序是消费者。其中我们会启动两个消费者，其中一个消费者接收到消息后把日志存储在磁盘，\n\n\n\nReceiveLogs01 将接收到的消息打印在控制台\n\n```java\npackage com.oddfar.five;\n\nimport com.oddfar.utils.RabbitMqUtils;\nimport com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.DeliverCallback;\n\n/**\n * @author zhiyuan\n */\npublic class ReceiveLogs01 {\n    private static final String EXCHANGE_NAME = \"logs\";\n\n    public static void main(String[] args) throws Exception {\n\n        Channel channel = RabbitMqUtils.getChannel();\n        channel.exchangeDeclare(EXCHANGE_NAME, \"fanout\");\n        /**\n         * 生成一个临时的队列 队列的名称是随机的\n         * 当消费者断开和该队列的连接时 队列自动删除\n         */\n        String queueName = channel.queueDeclare().getQueue();\n        //把该临时队列绑定我们的 exchange 其中 routingkey(也称之为 binding key)为空字符串\n        channel.queueBind(queueName, EXCHANGE_NAME, \"\");\n        System.out.println(\"等待接收消息,把接收到的消息打印在屏幕........... \");\n\n        //发送回调\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody(), \"UTF-8\");\n            System.out.println(\"控制台打印接收到的消息\" + message);\n        };\n        channel.basicConsume(queueName, true, deliverCallback, consumerTag -> {});\n\n    }\n}\n```\n\nReceiveLogs02 把消息写出到文件\n\n```java\npublic class ReceiveLogs02 {\n    private static final String EXCHANGE_NAME = \"logs\";\n\n    public static void main(String[] args) throws Exception {\n\n        Channel channel = RabbitMqUtils.getChannel();\n        channel.exchangeDeclare(EXCHANGE_NAME, \"fanout\");\n        /**\n         * 生成一个临时的队列 队列的名称是随机的\n         * 当消费者断开和该队列的连接时 队列自动删除\n         */\n        String queueName = channel.queueDeclare().getQueue();\n        //把该临时队列绑定我们的 exchange 其中 routingkey(也称之为 binding key)为空字符串\n        channel.queueBind(queueName, EXCHANGE_NAME, \"\");\n        System.out.println(\"等待接收消息,把接收到的消息写到文件........... \");\n\n        //发送回调\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody(), \"UTF-8\");\n            File file = new File(\"D:\\\\test\\\\rabbitmq_info.txt\");\n            FileUtils.writeStringToFile(file,message,\"UTF-8\");\n            System.out.println(\"数据写入文件成功\");\n        };\n        channel.basicConsume(queueName, true, deliverCallback, consumerTag -> {});\n\n    }\n}\n```\n\n\n\n\n\nEmitLog 发送消息给两个消费者接收：\n\n```java\npublic class EmitLog {\n    private static final String EXCHANGE_NAME = \"logs\";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtils.getChannel();\n\n        /**\n         * 声明一个 exchange\n         * 1.exchange 的名称\n         * 2.exchange 的类型\n         */\n        channel.exchangeDeclare(EXCHANGE_NAME, \"fanout\");\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"请输入信息\");\n        while (sc.hasNext()) {\n            String message = sc.nextLine();\n            channel.basicPublish(EXCHANGE_NAME, \"\", null, message.getBytes(\"UTF-8\"));\n            System.out.println(\"生产者发出消息\" + message);\n        }\n    }\n    \n}\n```\n\n## Direct exchange\n\n在上一节中，我们构建了一个简单的日志记录系统。我们能够向许多接收者广播日志消息。在本节我们将向其中添加一些特别的功能——让某个消费者订阅发布的部分消息。例如我们只把严重错误消息定向存储到日志文件(以节省磁盘空间)，同时仍然能够在控制台上打印所有日志消息。\n\n我们再次来回顾一下什么是 bindings，绑定是交换机和队列之间的桥梁关系。也可以这么理解： **队列只对它绑定的交换机的消息感兴趣**。绑定用参数：routingKey 来表示也可称该参数为 binding key， 创建绑定我们用代码:channel.queueBind(queueName, EXCHANGE_NAME, \"routingKey\");\n\n绑定之后的意义由其交换类型决定。\n\n### Direct 介绍\n\n\n\n上一节中的我们的日志系统将所有消息广播给所有消费者，对此我们想做一些改变，例如我们希 望将日志消息写入磁盘的程序仅接收严重错误(errros)，而不存储哪些警告(warning)或信息(info)日志 消息避免浪费磁盘空间。Fanout 这种交换类型并不能给我们带来很大的灵活性-它只能进行无意识的 广播，在这里我们将使用 direct 这种类型来进行替换，这种类型的工作方式是，消息只去到它绑定的 routingKey 队列中去。\n\n![RabbitMQ-00000042](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000042.png)\n\n在上面这张图中，我们可以看到 X 绑定了两个队列，绑定类型是 direct。队列Q1 绑定键为 orange， 队列 Q2 绑定键有两个:一个绑定键为 black，另一个绑定键为 green.\n\n在这种绑定情况下，生产者发布消息到 exchange 上，绑定键为 orange 的消息会被发布到队列 Q1。绑定键为 blackgreen 和的消息会被发布到队列 Q2，其他消息类型的消息将被丢弃。\n\n### 多重绑定 \n\n\n\n![RabbitMQ-00000043](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000043.png)\n\n当然如果 exchange 的绑定类型是direct，**但是它绑定的多个队列的 key 如果都相同**，在这种情况下虽然绑定类型是 direct **但是它表现的就和 fanout 有点类似了**，就跟广播差不多，如上图所示。\n\n### Direct 实战\n\n关系：\n\n![RabbitMQ-00000044](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000044.png)\n\n交换机：\n\n![RabbitMQ-00000045](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000045.png)\n\nc2：绑定disk，routingKey为error\n\nc1：绑定console，routingKey为info、warning\n\n1、\n\n```java\npackage com.oddfar.six;\n\nimport com.oddfar.utils.RabbitMqUtils;\nimport com.rabbitmq.client.BuiltinExchangeType;\nimport com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.DeliverCallback;\n\n/**\n * @author zhiyuan\n */\npublic class ReceiveLogsDirect01 {\n    private static final String EXCHANGE_NAME = \"direct_logs\";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtils.getChannel();\n        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);\n\n        String queueName = \"disk\";\n        //队列声明\n        channel.queueDeclare(queueName, false, false, false, null);\n        //队列绑定\n        channel.queueBind(queueName, EXCHANGE_NAME, \"error\");\n        System.out.println(\"等待接收消息...\");\n\n        //发送回调\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody(), \"UTF-8\");\n            message = \"接收绑定键:\" + delivery.getEnvelope().getRoutingKey() + \",消息:\" + message;\n            System.out.println(\"error 消息已经接收：\\n\" + message);\n        };\n        channel.basicConsume(queueName, true, deliverCallback, consumerTag -> {\n        });\n    }\n}\n```\n\n2、\n\n```java\npublic class ReceiveLogsDirect02 {\n    private static final String EXCHANGE_NAME = \"direct_logs\";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtils.getChannel();\n        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);\n\n        String queueName = \"console\";\n        //队列声明\n        channel.queueDeclare(queueName, false, false, false, null);\n        //队列绑定\n        channel.queueBind(queueName, EXCHANGE_NAME, \"info\");\n        channel.queueBind(queueName, EXCHANGE_NAME, \"warning\");\n\n        System.out.println(\"等待接收消息...\");\n\n        //发送回调\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody(), \"UTF-8\");\n            message = \"接收绑定键:\" + delivery.getEnvelope().getRoutingKey() + \",消息:\" + message;\n            System.out.println(\"info和warning 消息已经接收：\\n\" + message);\n        };\n        channel.basicConsume(queueName, true, deliverCallback, consumerTag -> {\n        });\n    }\n}\n```\n\n3、\n\n```java\npublic class EmitLogDirect {\n    private static final String EXCHANGE_NAME = \"direct_logs\";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtils.getChannel();\n        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);\n\n        //创建多个 bindingKey\n        Map<String, String> bindingKeyMap = new HashMap<>();\n        bindingKeyMap.put(\"info\", \"普通 info 信息\");\n        bindingKeyMap.put(\"warning\", \"警告 warning 信息\");\n        bindingKeyMap.put(\"error\", \"错误 error 信息\");\n        //debug 没有消费这接收这个消息 所有就丢失了\n        bindingKeyMap.put(\"debug\", \"调试 debug 信息\");\n\n        for (Map.Entry<String, String> bindingKeyEntry : bindingKeyMap.entrySet()) {\n            //获取 key value\n            String bindingKey = bindingKeyEntry.getKey();\n            String message = bindingKeyEntry.getValue();\n\n            channel.basicPublish(EXCHANGE_NAME, bindingKey, null, message.getBytes(\"UTF-8\"));\n            System.out.println(\"生产者发出消息:\" + message);\n        }\n    }\n}\n```\n\n## Topics exchange\n\n### Topic 的介绍\n\n在上一个小节中，我们改进了日志记录系统。我们没有使用只能进行随意广播的 fanout 交换机，而是使用了 direct 交换机，从而有能实现有选择性地接收日志。\n\n尽管使用 direct 交换机改进了我们的系统，但是它仍然存在局限性——比方说我们想接收的日志类型有 info.base 和 info.advantage，某个队列只想 info.base 的消息，那这个时候direct 就办不到了。这个时候就只能使用 **topic** 类型\n\n::: tip Topic的要求\n\n:::\n\n发送到类型是 topic 交换机的消息的 routing_key 不能随意写，必须满足一定的要求，它必须是**一个单词列表**，**以点号分隔开**。这些单词可以是任意单词\n\n比如说：\"stock.usd.nyse\", \"nyse.vmw\", \"quick.orange.rabbit\".这种类型的。\n\n当然这个单词列表最多不能超过 255 个字节。\n\n在这个规则列表中，其中有两个替换符是大家需要注意的：\n\n- ***(星号)可以代替一个单词**\n- **\\#(井号)可以替代零个或多个单词**\n\n\n\n### Topic 匹配案例\n\n下图绑定关系如下\n\n![RabbitMQ-00000046](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000046.png)\n\n- Q1-->绑定的是\n  - 中间带 orange 带 3 个单词的字符串 `(*.orange.*)`\n\n- Q2-->绑定的是\n  - 最后一个单词是 rabbit 的 3 个单词 `(*.*.rabbit)`\n  - 第一个单词是 lazy 的多个单词 `(lazy.#)`\n\n上图是一个队列绑定关系图，我们来看看他们之间数据接收情况是怎么样的\n\n| 例子                     | 说明                                       |\n| ------------------------ | ------------------------------------------ |\n| quick.orange.rabbit      | 被队列 Q1Q2 接收到                         |\n| azy.orange.elephant      | 被队列 Q1Q2 接收到                         |\n| quick.orange.fox         | 被队列 Q1 接收到                           |\n| lazy.brown.fox           | 被队列 Q2 接收到                           |\n| lazy.pink.rabbit         | 虽然满足两个绑定但只被队列 Q2 接收一次     |\n| quick.brown.fox          | 不匹配任何绑定不会被任何队列接收到会被丢弃 |\n| quick.orange.male.rabbit | 是四个单词不匹配任何绑定会被丢弃           |\n| lazy.orange.male.rabbit  | 是四个单词但匹配 Q2                        |\n\n注意：\n\n- 当一个队列绑定键是#，那么这个队列将接收所有数据，就有点像 fanout 了\n- 如果队列绑定键当中没有#和*出现，那么该队列绑定类型就是 direct 了\n\n### Topic 实战 \n\n![RabbitMQ-00000047](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000047.png)\n\n代码如下：\n\n```java\npackage com.oddfar.seven;\n\nimport com.oddfar.utils.RabbitMqUtils;\nimport com.rabbitmq.client.BuiltinExchangeType;\nimport com.rabbitmq.client.Channel;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * 发送端\n *\n * @author zhiyuan\n */\npublic class EmitLogTopic {\n    private static final String EXCHANGE_NAME = \"topic_logs\";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtils.getChannel();\n        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);\n\n        /**\n         * Q1-->绑定的是\n         *      中间带 orange 带 3 个单词的字符串(*.orange.*)\n         * Q2-->绑定的是\n         *      最后一个单词是 rabbit 的 3 个单词(*.*.rabbit)\n         *      第一个单词是 lazy 的多个单词(lazy.#)\n         *\n         */\n        Map<String, String> bindingKeyMap = new HashMap<>();\n        bindingKeyMap.put(\"quick.orange.rabbit\", \"被队列 Q1Q2 接收到\");\n        bindingKeyMap.put(\"lazy.orange.elephant\", \"被队列 Q1Q2 接收到\");\n        bindingKeyMap.put(\"quick.orange.fox\", \"被队列 Q1 接收到\");\n        bindingKeyMap.put(\"lazy.brown.fox\", \"被队列 Q2 接收到\");\n        bindingKeyMap.put(\"lazy.pink.rabbit\", \"虽然满足两个绑定但只被队列 Q2 接收一次\");\n        bindingKeyMap.put(\"quick.brown.fox\", \"不匹配任何绑定不会被任何队列接收到会被丢弃\");\n        bindingKeyMap.put(\"quick.orange.male.rabbit\", \"是四个单词不匹配任何绑定会被丢弃\");\n        bindingKeyMap.put(\"lazy.orange.male.rabbit\", \"是四个单词但匹配 Q2\");\n        for (Map.Entry<String, String> bindingKeyEntry : bindingKeyMap.entrySet()) {\n            String bindingKey = bindingKeyEntry.getKey();\n            String message = bindingKeyEntry.getValue();\n\n            channel.basicPublish(EXCHANGE_NAME, bindingKey, null, message.getBytes(\"UTF-8\"));\n            System.out.println(\"生产者发出消息：\" + message);\n        }\n    }\n}\n```\n\n\n\n```java\npublic class ReceiveLogsTopic01 {\n    private static final String EXCHANGE_NAME = \"topic_logs\";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtils.getChannel();\n        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);\n        //声明 Q1 队列与绑定关系\n        String queueName = \"Q1\";\n        //声明\n        channel.queueDeclare(queueName, false, false, false, null);\n        //绑定\n        channel.queueBind(queueName, EXCHANGE_NAME, \"*.orange.*\");\n        System.out.println(\"等待接收消息........... \");\n\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody(), \"UTF-8\");\n            System.out.println(\" 接收队列:\" + queueName + \" 绑定键:\" + delivery.getEnvelope().getRoutingKey() + \",消息:\" + message);\n        };\n        channel.basicConsume(queueName, true, deliverCallback, consumerTag -> {\n        });\n    }\n}\n```\n\n\n\n```java\npublic class ReceiveLogsTopic02 {\n    private static final String EXCHANGE_NAME = \"topic_logs\";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtils.getChannel();\n        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);\n        //声明 Q2 队列与绑定关系\n        String queueName = \"Q2\";\n        //声明\n        channel.queueDeclare(queueName, false, false, false, null);\n        //绑定\n        channel.queueBind(queueName, EXCHANGE_NAME, \"*.*.rabbit\");\n        channel.queueBind(queueName, EXCHANGE_NAME, \"lazy.#\");\n\n        System.out.println(\"等待接收消息........... \");\n\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody(), \"UTF-8\");\n            System.out.println(\" 接收队列:\" + queueName + \" 绑定键:\" + delivery.getEnvelope().getRoutingKey() + \",消息:\" + message);\n        };\n        channel.basicConsume(queueName, true, deliverCallback, consumerTag -> {\n        });\n    }\n}\n```\n# 死信队列\n\n## 死信的概念\n\n先从概念解释上搞清楚这个定义，死信，顾名思义就是无法被消费的消息，字面意思可以这样理 解，一般来说，producer 将消息投递到 broker 或者直接到queue 里了，consumer 从 queue 取出消息 进行消费，但某些时候由于特定的原因**导致 queue 中的某些消息无法被消费**，这样的消息如果没有后续的处理，就变成了死信，有死信自然就有了死信队列。\n\n应用场景：为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息消费发生异常时，将消息投入死信队列中。还有比如说：用户在商城下单成功并点击去支付后在指定时间未支付时自动失效\n\n\n\n## 死信的来源 \n\n- 消息 TTL 过期\n\n  TTL是Time To Live的缩写, 也就是生存时间\n\n- 队列达到最大长度\n\n  队列满了，无法再添加数据到 mq 中\n\n- 消息被拒绝\n\n  (basic.reject 或 basic.nack) 并且 requeue=false.\n\n## 死信实战 \n\n\n\n\n\n![RabbitMQ-00000048](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000048.png)\n\n### 死信之TTl\n\n消费者 C1 代码：\n\n```java\n/**\n * 死信队列 - 消费者01\n *\n * @author zhiyuan\n */\npublic class Consumer01 {\n\n    //普通交换机名称\n    private static final String NORMAL_EXCHANGE = \"normal_exchange\";\n    //死信交换机名称\n    private static final String DEAD_EXCHANGE = \"dead_exchange\";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtils.getChannel();\n\n        //声明死信和普通交换机 类型为 direct\n        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);\n        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);\n\n        //声明死信队列\n        String deadQueue = \"dead-queue\";\n        channel.queueDeclare(deadQueue, false, false, false, null);\n        //死信队列绑定：队列、交换机、路由键（routingKey）\n        channel.queueBind(deadQueue, DEAD_EXCHANGE, \"lisi\");\n\n        //正常队列绑定死信队列信息\n        Map<String, Object> params = new HashMap<>();\n        //正常队列设置死信交换机 参数 key 是固定值\n        params.put(\"x-dead-letter-exchange\", DEAD_EXCHANGE);\n        //正常队列设置死信 routing-key 参数 key 是固定值\n        params.put(\"x-dead-letter-routing-key\", \"lisi\");\n\n        //正常队列\n        String normalQueue = \"normal-queue\";\n        channel.queueDeclare(normalQueue, false, false, false, params);\n        channel.queueBind(normalQueue, NORMAL_EXCHANGE, \"zhangsan\");\n\n        System.out.println(\"等待接收消息........... \");\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody(), \"UTF-8\");\n            System.out.println(\"Consumer01 接收到消息\" + message);\n        };\n        channel.basicConsume(normalQueue, true, deliverCallback, consumerTag -> {\n        });\n    }\n\n}\n```\n\n生产者代码\n\n```java\npublic class Producer {\n    private static final String NORMAL_EXCHANGE = \"normal_exchange\";\n\n    public static void main(String[] argv) throws Exception {\n        Channel channel = RabbitMqUtils.getChannel();\n\n        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);\n        //设置消息的 TTL 时间 10s\n        AMQP.BasicProperties properties = new AMQP.BasicProperties().builder().expiration(\"10000\").build();\n        //该信息是用作演示队列个数限制\n        for (int i = 1; i < 11; i++) {\n            String message = \"info\" + i;\n            channel.basicPublish(NORMAL_EXCHANGE, \"zhangsan\", properties, message.getBytes());\n            System.out.println(\"生产者发送消息:\" + message);\n        }\n\n    }\n}\n```\n\n启动 C1 ，之后关闭消费者，模拟其接收不到消息。再启动 Producer\n\n![RabbitMQ-00000049](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000049.png)\n\n消费者 C2 代码：\n\n以上步骤完成后，启动 C2 消费者，它消费死信队列里面的消息\n\n```java\npublic class Consumer02 {\n    //死信交换机名称\n    private static final String DEAD_EXCHANGE = \"dead_exchange\";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtils.getChannel();\n\n        //声明交换机\n        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);\n        //声明队列\n        String deadQueue = \"dead-queue\";\n        channel.queueDeclare(deadQueue, false, false, false, null);\n        channel.queueBind(deadQueue, DEAD_EXCHANGE, \"lisi\");\n\n        System.out.println(\"等待接收死信消息........... \");\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody(), \"UTF-8\");\n            System.out.println(\"Consumer02 接收到消息\" + message);\n        };\n        channel.basicConsume(deadQueue, true, deliverCallback, consumerTag -> {\n        });\n    }\n}\n```\n\n![RabbitMQ-00000050](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000050.png)\n\n### 死信之最大长度\n\n1、消息生产者代码去掉 TTL 属性\n\n![image-20210628101337825](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210628101337825.png)\n\n2、C1 消费者修改以下代码**(启动之后关闭该消费者 模拟其接收不到消息)**\n\n![RabbitMQ-00000051](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000051.png)\n\n```java\n//设置正常队列的长度限制，例如发10个，4个则为死信\nparams.put(\"x-max-length\",6);\n```\n\n<mark>注意此时需要把原先队列删除 因为参数改变了</mark>\n\n3、C2 消费者代码不变(启动 C2 消费者) \n\n![RabbitMQ-00000052](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000052.png)\n\n### 死信之消息被拒\n\n1、消息生产者代码同上生产者一致\n\n2、C1 消费者代码(启动之后关闭该消费者 模拟其接收不到消息)\n\n拒收消息 \"info5\" \n\n```java\npublic class Consumer01 {\n\n    //普通交换机名称\n    private static final String NORMAL_EXCHANGE = \"normal_exchange\";\n    //死信交换机名称\n    private static final String DEAD_EXCHANGE = \"dead_exchange\";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtils.getChannel();\n\n        //声明死信和普通交换机 类型为 direct\n        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);\n        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);\n\n        //声明死信队列\n        String deadQueue = \"dead-queue\";\n        channel.queueDeclare(deadQueue, false, false, false, null);\n        //死信队列绑定：队列、交换机、路由键（routingKey）\n        channel.queueBind(deadQueue, DEAD_EXCHANGE, \"lisi\");\n        \n        //正常队列绑定死信队列信息\n        Map<String, Object> params = new HashMap<>();\n        //正常队列设置死信交换机 参数 key 是固定值\n        params.put(\"x-dead-letter-exchange\", DEAD_EXCHANGE);\n        //正常队列设置死信 routing-key 参数 key 是固定值\n        params.put(\"x-dead-letter-routing-key\", \"lisi\");\n//        //设置正常队列的长度限制，例如发10个，4个则为死信\n//        params.put(\"x-max-length\",6);\n        \n        //正常队列\n        String normalQueue = \"normal-queue\";\n        channel.queueDeclare(normalQueue, false, false, false, params);\n        channel.queueBind(normalQueue, NORMAL_EXCHANGE, \"zhangsan\");\n\n        System.out.println(\"等待接收消息........... \");\n        \n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody(), \"UTF-8\");\n            if (message.equals(\"info5\")) {\n                System.out.println(\"Consumer01 接收到消息\" + message + \"并拒绝签收该消息\");\n                //requeue 设置为 false 代表拒绝重新入队 该队列如果配置了死信交换机将发送到死信队列中\n                channel.basicReject(delivery.getEnvelope().getDeliveryTag(), false);\n            } else {\n                System.out.println(\"Consumer01 接收到消息\" + message);\n                channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);\n            }\n\n        };\n        //开启手动应答\n        channel.basicConsume(normalQueue, false, deliverCallback, consumerTag -> {\n        });\n    }\n\n}\n```\n\n![RabbitMQ-00000053](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000053.png)\n\n3、C2 消费者代码不变\n\n启动消费者 1 然后再启动消费者 2 \n\n![RabbitMQ-00000054](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000054.png)\n\n\n# 延迟队列\n\n## 延迟队列介绍\n\n- **延迟队列概念：**\n\n延时队列,队列内部是有序的，最重要的特性就体现在它的延时属性上，延时队列中的元素是希望 在指定时间到了以后或之前取出和处理，简单来说，延时队列就是用来存放需要在指定时间被处理的 元素的队列。\n\n- **延迟队列使用场景：**\n\n1.订单在十分钟之内未支付则自动取消\n2.新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒。\n3.用户注册成功后，如果三天内没有登陆则进行短信提醒。\n4.用户发起退款，如果三天内没有得到处理则通知相关运营人员。\n5.预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议\n\n这些场景都有一个特点，需要在某个事件发生之后或者之前的指定时间点完成某一项任务，如： 发生订单生成事件，在十分钟之后检查该订单支付状态，然后将未支付的订单进行关闭；那我们一直轮询数据，每秒查一次，取出需要被处理的数据，然后处理不就完事了吗？\n\n如果数据量比较少，确实可以这样做，比如：对于“如果账单一周内未支付则进行自动结算”这样的需求， 如果对于时间不是严格限制，而是宽松意义上的一周，那么每天晚上跑个定时任务检查一下所有未支付的账单，确实也是一个可行的方案。但对于数据量比较大，并且时效性较强的场景，如：“订单十分钟内未支付则关闭“，短期内未支付的订单数据可能会有很多，活动期间甚至会达到百万甚至千万级别，对这么庞大的数据量仍旧使用轮询的方式显然是不可取的，很可能在一秒内无法完成所有订单的检查，同时会给数据库带来很大压力，无法满足业务要求而且性能低下。\n\n![RabbitMQ-00000055](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000055.png)\n\n## RabbitMQ 中的 TTL\n\nTTL 是什么呢？TTL 是 RabbitMQ 中一个消息或者队列的属性，表明一条消息或者该队列中的所有消息的最大存活时间，单位是毫秒。\n\n换句话说，如果一条消息设置了 TTL 属性或者进入了设置TTL 属性的队列，那么这条消息如果在 TTL 设置的时间内没有被消费，则会成为\"死信\"。如果同时配置了队列的TTL 和消息的 TTL，那么较小的那个值将会被使用，有两种方式设置 TTL。\n\n\n\n- **队列设置TTL**\n\n在创建队列的时候设置队列的“x-message-ttl”属性\n\n![RabbitMQ-00000057](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000057.png)\n\n- **消息设置TTL**\n\n是针对每条消息设置TTL\n\n![RabbitMQ-00000056](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000056.png)\n\n\n\n::: tip 两者的区别 \n\n:::\n\n如果设置了队列的 TTL 属性，那么一旦消息过期，就会被队列丢弃(如果配置了死信队列被丢到死信队列中)，而第二种方式，消息即使过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者之前判定的，如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间；\n\n另外，还需要注意的一点是，如果不设置 TTL，表示消息永远不会过期，如果将 TTL 设置为 0，则表示除非此时可以直接投递该消息到消费者，否则该消息将会被丢弃。\n\n\n\n## 整合 springboot\n\n\n\n前一小节我们介绍了死信队列，刚刚又介绍了 TTL，至此利用 RabbitMQ 实现延时队列的两大要素已经集齐，接下来只需要将它们进行融合，再加入一点点调味料，延时队列就可以新鲜出炉了。想想看，延时队列，不就是想要消息延迟多久被处理吗，TTL 则刚好能让消息在延迟多久之后成为死信，另一方面， 成为死信的消息都会被投递到死信队列里，这样只需要消费者一直消费死信队列里的消息就完事了，因为里面的消息都是希望被立即处理的消息。\n\n\n\n1、创建一个空项目：\n\n![RabbitMQ-00000058](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000058.png)\n\n2、添加依赖：\n\n```xml\n<dependencies>\n   <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter</artifactId>\n    </dependency>\n    <!--RabbitMQ 依赖-->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-amqp</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-test</artifactId>\n        <scope>test</scope>\n    </dependency>\n    <dependency>\n        <groupId>com.alibaba</groupId>\n        <artifactId>fastjson</artifactId>\n        <version>1.2.47</version>\n    </dependency>\n    <dependency>\n        <groupId>org.projectlombok</groupId>\n        <artifactId>lombok</artifactId>\n    </dependency>\n    <!--swagger-->\n    <dependency>\n        <groupId>io.springfox</groupId>\n        <artifactId>springfox-swagger2</artifactId>\n        <version>3.0.0</version>\n    </dependency>\n    <dependency>\n        <groupId>io.springfox</groupId>\n        <artifactId>springfox-swagger-ui</artifactId>\n        <version>3.0.0</version>\n    </dependency>\n    <!--RabbitMQ 测试依赖-->\n    <dependency>\n        <groupId>org.springframework.amqp</groupId>\n        <artifactId>spring-rabbit-test</artifactId>\n        <scope>test</scope>\n    </dependency>\n</dependencies>\n```\n\n3、修改配置文件\n\n```properties\nspring.rabbitmq.host=42.192.149.71\nspring.rabbitmq.port=5672\nspring.rabbitmq.username=admin\nspring.rabbitmq.password=123456\n```\n\n4、添加Swagger 配置类 \n\n```java\npackage com.oddfar.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport springfox.documentation.builders.ApiInfoBuilder;\nimport springfox.documentation.service.ApiInfo;\nimport springfox.documentation.service.Contact;\nimport springfox.documentation.spi.DocumentationType;\nimport springfox.documentation.spring.web.plugins.Docket;\nimport springfox.documentation.swagger2.annotations.EnableSwagger2;\n\n\n@Configuration\n@EnableSwagger2\npublic class SwaggerConfig {\n\n    @Bean\n    public Docket webApiConfig() {\n        return new Docket(DocumentationType.SWAGGER_2)\n                .groupName(\"webApi\")\n                .apiInfo(webApiInfo())\n                .select()\n                .build();\n    }\n\n    private ApiInfo webApiInfo() {\n        return new ApiInfoBuilder()\n                .title(\"rabbitmq 接口文档\")\n                .description(\"本文档描述了 rabbitmq 微服务接口定义\")\n                .version(\"1.0\")\n                .contact(new Contact(\"zhiyuan\", \"http://oddfar.com\", \"test@qq.com\"))\n                .build();\n    }\n\n}\n```\n\n## 队列 TTL\n\n- **代码架构图** \n\n创建两个队列 QA 和 QB，两者队列 TTL 分别设置为 10S 和 40S，然后在创建一个交换机 X 和死信交 换机 Y，它们的类型都是direct，创建一个死信队列 QD，它们的绑定关系如下：\n\n![RabbitMQ-00000060](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000060.png)\n\n原先配置队列信息，写在了生产者和消费者代码中，现在可写咋配置类中，生产者只发消息，消费者只接受消息\n\n**1、配置文件类代码 ：**\n\n```java\npackage com.oddfar.config;\n\nimport org.springframework.amqp.core.*;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * @author zhiyuan\n */\n@Configuration\npublic class TtlQueueConfig {\n    public static final String X_EXCHANGE = \"X\";\n    public static final String QUEUE_A = \"QA\";\n    public static final String QUEUE_B = \"QB\";\n    //死信交换机\n    public static final String Y_DEAD_LETTER_EXCHANGE = \"Y\";\n    //死信队列\n    public static final String DEAD_LETTER_QUEUE = \"QD\";\n\n    // 声明 xExchange\n    @Bean(\"xExchange\")\n    public DirectExchange xExchange() {\n        return new DirectExchange(X_EXCHANGE);\n    }\n\n    // 声明 死信队列交换机\n    @Bean(\"yExchange\")\n    public DirectExchange yExchange() {\n        return new DirectExchange(Y_DEAD_LETTER_EXCHANGE);\n    }\n\n    //声明队列 A ttl 为 10s 并绑定到对应的死信交换机\n    @Bean(\"queueA\")\n    public Queue queueA() {\n        Map<String, Object> args = new HashMap<>(3);\n        //声明当前队列绑定的死信交换机\n        args.put(\"x-dead-letter-exchange\", Y_DEAD_LETTER_EXCHANGE);\n        //声明当前队列的死信路由 key\n        args.put(\"x-dead-letter-routing-key\", \"YD\");\n        //声明队列的 TTL\n        args.put(\"x-message-ttl\", 10000);\n        return QueueBuilder.durable(QUEUE_A).withArguments(args).build();\n    }\n\n    // 声明队列 A 绑定 X 交换机\n    @Bean\n    public Binding queueaBindingX(@Qualifier(\"queueA\") Queue queueA,\n                                  @Qualifier(\"xExchange\") DirectExchange xExchange) {\n        return BindingBuilder.bind(queueA).to(xExchange).with(\"XA\");\n    }\n\n    //声明队列 B ttl 为 40s 并绑定到对应的死信交换机\n    @Bean(\"queueB\")\n    public Queue queueB() {\n        Map<String, Object> args = new HashMap<>(3);\n        //声明当前队列绑定的死信交换机\n        args.put(\"x-dead-letter-exchange\", Y_DEAD_LETTER_EXCHANGE);\n        //声明当前队列的死信路由 key\n        args.put(\"x-dead-letter-routing-key\", \"YD\");\n        //声明队列的 TTL\n        args.put(\"x-message-ttl\", 40000);\n        return QueueBuilder.durable(QUEUE_B).withArguments(args).build();\n    }\n\n    //声明队列 B 绑定 X 交换机\n    @Bean\n    public Binding queuebBindingX(@Qualifier(\"queueB\") Queue queue1B,\n                                  @Qualifier(\"xExchange\") DirectExchange xExchange) {\n        return BindingBuilder.bind(queue1B).to(xExchange).with(\"XB\");\n    }\n\n    //声明死信队列 QD\n    @Bean(\"queueD\")\n    public Queue queueD() {\n        return new Queue(DEAD_LETTER_QUEUE);\n    }\n\n    //声明死信队列 QD 绑定关系\n    @Bean\n    public Binding deadLetterBindingQAD(@Qualifier(\"queueD\") Queue queueD,\n                                        @Qualifier(\"yExchange\") DirectExchange yExchange) {\n        return BindingBuilder.bind(queueD).to(yExchange).with(\"YD\");\n    }\n\n}\n```\n\n**2、消息生产者代码**\n\n```java\npackage com.oddfar.contorller;\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.amqp.rabbit.core.RabbitTemplate;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport java.util.Date;\n\n/**\n * @author zhiyuan\n */\n@Slf4j\n@RequestMapping(\"ttl\")\n@RestController\npublic class SendMsgController {\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n\n    @GetMapping(\"sendMsg/{message}\")\n    public void sendMsg(@PathVariable String message) {\n        log.info(\"当前时间：{},发送一条信息给两个 TTL 队列:{}\", new Date(), message);\n        rabbitTemplate.convertAndSend(\"X\", \"XA\", \"消息来自 ttl 为 10S 的队列: \" + message);\n        rabbitTemplate.convertAndSend(\"X\", \"XB\", \"消息来自 ttl 为 40S 的队列: \" + message);\n    }\n    \n}\n```\n\n**3、消息消费者代码** \n\n```java\npackage com.oddfar.consumer;\n\nimport com.rabbitmq.client.Channel;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.amqp.core.Message;\nimport org.springframework.amqp.rabbit.annotation.RabbitListener;\nimport org.springframework.stereotype.Component;\n\nimport java.io.IOException;\nimport java.util.Date;\n\n/**\n * 消费者 - 死信队列\n * @author zhiyuan\n */\n@Slf4j\n@Component\npublic class DeadLetterQueueConsumer {\n\n    @RabbitListener(queues = \"QD\")\n    public void receiveD(Message message, Channel channel) throws IOException {\n        String msg = new String(message.getBody());\n        log.info(\"当前时间：{},收到死信队列信息{}\", new Date().toString(), msg);\n    }\n\n}\n```\n\n发起一个请求 <http://localhost:8080/ttl/sendMsg/嘻嘻嘻>\n\n\n\n![image-20210628162017168](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210628162017168.png)\n\n第一条消息在 10S 后变成了死信消息，然后被消费者消费掉，第二条消息在 40S 之后变成了死信消息， 然后被消费掉，这样一个延时队列就打造完成了。\n\n\n\n不过，如果这样使用的话，岂不是每增加一个新的时间需求，就要新增一个队列，这里只有 10S 和 40S 两个时间选项，如果需要一个小时后处理，那么就需要增加TTL 为一个小时的队列，如果是预定会议室然后提前通知这样的场景，岂不是要增加无数个队列才能满足需求？\n\n## 延时队列TTL优化\n\n在这里新增了一个队列 QC,绑定关系如下,该队列不设置TTL 时间\n\n![RabbitMQ-00000062](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000062.png)\n\n配置文件类代码：\n\n```java\n@Configuration\npublic class MsgTtlQueueConfig {\n    public static final String Y_DEAD_LETTER_EXCHANGE = \"Y\";\n    public static final String QUEUE_C = \"QC\";\n\n    //声明队列 C 死信交换机\n    @Bean(\"queueC\")\n    public Queue queueB() {\n        Map<String, Object> args = new HashMap<>(3);\n        //声明当前队列绑定的死信交换机\n        args.put(\"x-dead-letter-exchange\", Y_DEAD_LETTER_EXCHANGE);\n        //声明当前队列的死信路由 key\n        args.put(\"x-dead-letter-routing-key\", \"YD\");\n        //没有声明 TTL 属性\n        return QueueBuilder.durable(QUEUE_C).withArguments(args).build();\n    }\n\n    //声明队列 B 绑定 X 交换机\n    @Bean\n    public Binding queuecBindingX(@Qualifier(\"queueC\") Queue queueC,\n                                  @Qualifier(\"xExchange\") DirectExchange xExchange) {\n        return BindingBuilder.bind(queueC).to(xExchange).with(\"XC\");\n    }\n}\n```\n\n生产者代码：\n\n```java\n/**\n * 延时队列优化\n * @param message 消息\n * @param ttlTime 延时的毫秒\n */\n@GetMapping(\"sendExpirationMsg/{message}/{ttlTime}\")\npublic void sendMsg(@PathVariable String message, @PathVariable String ttlTime) {\n    rabbitTemplate.convertAndSend(\"X\", \"XC\", message, correlationData -> {\n        correlationData.getMessageProperties().setExpiration(ttlTime);\n        return correlationData;\n    });\n    log.info(\"当前时间：{},发送一条时长{}毫秒 TTL 信息给队列 C:{}\", new Date(), ttlTime, message);\n}\n```\n\n发起请求\n\n<http://localhost:8080/ttl/sendExpirationMsg/你好1/20000>\n\n<http://localhost:8080/ttl/sendExpirationMsg/你好2/2000>\n\n![RabbitMQ-00000063](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000063.png)\n\n看起来似乎没什么问题，但是在最开始的时候，就介绍过如果使用在消息属性上设置 TTL 的方式，消息可能并不会按时“死亡“\n\n因为 RabbitMQ 只会检查第一个消息是否过期，如果过期则丢到死信队列， 如果第一个消息的延时时长很长，而第二个消息的延时时长很短，第二个消息并不会优先得到执行。\n\n这也就是为什么第二个延时2秒，却后执行。\n\n## Rabbitmq 插件实现延迟队列\n\n上文中提到的问题，确实是一个问题，如果不能实现在消息粒度上的 TTL，并使其在设置的TTL 时间及时死亡，就无法设计成一个通用的延时队列。那如何解决呢，接下来我们就去解决该问题。\n\n::: tip 安装延时队列插件\n\n:::\n\n可去[官网下载](https://www.rabbitmq.com/community-plugins.html) **rabbitmq_delayed_message_exchange** 插件，放置到 RabbitMQ 的插件目录。\n\n进入 RabbitMQ 的安装目录下的 plgins 目录，执行下面命令让该插件生效，然后重启 RabbitMQ\n\n```sh\n[root@VM-0-6-centos software]# ls\nerlang-21.3.8.21-1.el7.x86_64.rpm  rabbitmq_delayed_message_exchange-3.8.0.ez  rabbitmq-server-3.8.8-1.el7.noarch.rpm\n#移动\ncp rabbitmq_delayed_message_exchange-3.8.0.ez /usr/lib/rabbitmq/lib/rabbitmq_server-3.8.8/plugins\n#安装\nrabbitmq-plugins enable rabbitmq_delayed_message_exchange\n#重启服务\nsystemctl restart rabbitmq-server\n```\n\n![RabbitMQ-00000065](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000065.png)\n\n::: tip 代码\n\n:::\n\n在这里新增了一个队列delayed.queue,一个自定义交换机 delayed.exchange，绑定关系如下:\n\n![RabbitMQ-00000066](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000066.png)\n\n\n\n**1、配置文件类代码：**\n\n\n\n在我们自定义的交换机中，这是一种新的交换类型，该类型消息支持延迟投递机制消息传递后并不会立即投递到目标队列中，而是存储在 mnesia(一个分布式数据系统)表中，当达到投递时间时，才投递到目标队列中。\n\n```java\n@Configuration\npublic class DelayedQueueConfig {\n    public static final String DELAYED_QUEUE_NAME = \"delayed.queue\";\n    public static final String DELAYED_EXCHANGE_NAME = \"delayed.exchange\";\n    public static final String DELAYED_ROUTING_KEY = \"delayed.routingkey\";\n\n    @Bean\n    public Queue delayedQueue() {\n        return new Queue(DELAYED_QUEUE_NAME);\n    }\n\n    //自定义交换机 我们在这里定义的是一个延迟交换机\n    @Bean\n    public CustomExchange delayedExchange() {\n        Map<String, Object> args = new HashMap<>();\n        //自定义交换机的类型\n        args.put(\"x-delayed-type\", \"direct\");\n        return new CustomExchange(DELAYED_EXCHANGE_NAME, \"x-delayed-message\", true, false, args);\n    }\n\n    @Bean\n    public Binding bindingDelayedQueue(@Qualifier(\"delayedQueue\") Queue queue,\n                                       @Qualifier(\"delayedExchange\") CustomExchange delayedExchange) {\n        return BindingBuilder.bind(queue).to(delayedExchange).with(DELAYED_ROUTING_KEY).noargs();\n    }\n\n}\n```\n\n\n\n\n\n**2、生产者代码**\n\n```java\n@GetMapping(\"sendDelayMsg/{message}/{delayTime}\")\npublic void sendMsg(@PathVariable String message, @PathVariable Integer delayTime) {\n    rabbitTemplate.convertAndSend(DELAYED_EXCHANGE_NAME, DELAYED_ROUTING_KEY, message,\n            correlationData -> {\n                correlationData.getMessageProperties().setDelay(delayTime);\n                return correlationData;\n            });\n    log.info(\" 当 前 时 间 ： {}, 发 送 一 条 延 迟 {} 毫秒的信息给队列 delayed.queue:{}\", new Date(), delayTime, message);\n}\n```\n\n\n\n**3、消费者代码** \n\n```java\n/**\n * 消费者 - 基于插件的延时队列\n *\n * @author zhiyuan\n */\n@Slf4j\n@Component\npublic class DelayQueueConsumer {\n\n    public static final String DELAYED_QUEUE_NAME = \"delayed.queue\";\n\n    @RabbitListener(queues = DELAYED_QUEUE_NAME)\n    public void receiveDelayedQueue(Message message) {\n        String msg = new String(message.getBody());\n        log.info(\"当前时间：{},收到延时队列的消息：{}\", new Date().toString(), msg);\n    }\n}\n```\n\n发送请求：\n\n- <http://localhost:8080/ttl/sendDelayMsg/hello1/20000>\n- <http://localhost:8080/ttl/sendDelayMsg/hello2/2000>\n\n![image-20210628214856678](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210628214856678.png)\n\n第二个消息被先消费掉了，符合预期\n\n## 总结\n\n延时队列在需要延时处理的场景下非常有用，使用 RabbitMQ 来实现延时队列可以很好的利用 RabbitMQ 的特性，如：消息可靠发送、消息可靠投递、死信队列来保障消息至少被消费一次以及未被正确处理的消息不会被丢弃。另外，通过 RabbitMQ 集群的特性，可以很好的解决单点故障问题，不会因为 单个节点挂掉导致延时队列不可用或者消息丢失。\n\n当然，延时队列还有很多其它选择，比如利用 Java 的 DelayQueue，利用 Redis 的 zset，利用 Quartz 或者利用 kafka 的时间轮，这些方式各有特点,看需要适用的场景\n\n\n# 发布确认高级\n\n在生产环境中由于一些不明原因，导致 RabbitMQ  重启，在 RabbitMQ 重启期间生产者消息投递失败， 导致消息丢失，需要手动处理和恢复。于是，我们开始思考，如何才能进行 RabbitMQ 的消息可靠投递呢？ \n\n## 发布确认 springboot 版本\n\n确认机制方案：\n\n![RabbitMQ-00000068](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000068.png)\n\n代码架构图：\n\n\n\n![RabbitMQ-00000069](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000069.png)\n\n在配置文件当中需要添加\n\n```properties\nspring.rabbitmq.publisher-confirm-type=correlated\n```\n\n- `NONE` 值是禁用发布确认模式，是默认值\n\n- `CORRELATED` 值是发布消息成功到交换器后会触发回调方法\n\n- `SIMPLE` 值经测试有两种效果，其一效果和 CORRELATED 值一样会触发回调方法，其二在发布消息成功后使用 rabbitTemplate 调用 waitForConfirms 或 waitForConfirmsOrDie 方法等待 broker 节点返回发送结果，根据返回结果来判定下一步的逻辑，要注意的点是 waitForConfirmsOrDie 方法如果返回 false 则会关闭 channel，则接下来无法发送消息到 broker;\n\n::: tip 代码\n\n:::\n\n**1、添加配置类：**\n\n```java\n@Configuration\npublic class ConfirmConfig {\n    public static final String CONFIRM_EXCHANGE_NAME = \"confirm.exchange\";\n    public static final String CONFIRM_QUEUE_NAME = \"confirm.queue\";\n\n    //声明业务 Exchange\n    @Bean(\"confirmExchange\")\n    public DirectExchange confirmExchange() {\n        return new DirectExchange(CONFIRM_EXCHANGE_NAME);\n    }\n\n    // 声明确认队列\n    @Bean(\"confirmQueue\")\n    public Queue confirmQueue() {\n        return QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();\n    }\n\n    // 声明确认队列绑定关系\n    @Bean\n    public Binding queueBinding(@Qualifier(\"confirmQueue\") Queue queue,\n                                @Qualifier(\"confirmExchange\") DirectExchange exchange) {\n        return BindingBuilder.bind(queue).to(exchange).with(\"key1\");\n    }\n}\n```\n\n**2、消息生产者的回调接口**\n\n```java\n@Component\n@Slf4j\npublic class MyCallBack implements RabbitTemplate.ConfirmCallback {\n    /**\n     * 交换机不管是否收到消息的一个回调方法\n     *\n     * @param correlationData 消息相关数据\n     * @param ack             交换机是否收到消息\n     * @param cause           为收到消息的原因\n     */\n    @Override\n    public void confirm(CorrelationData correlationData, boolean ack, String cause) {\n        String id = correlationData != null ? correlationData.getId() : \"\";\n        if (ack) {\n            log.info(\"交换机已经收到 id 为:{}的消息\", id);\n        } else {\n            log.info(\"交换机还未收到 id 为:{}消息，原因:{}\", id, cause);\n        }\n    }\n\n}\n```\n\n**3、消息生产者** \n\n```java\n@RestController\n@RequestMapping(\"/confirm\")\n@Slf4j\npublic class ProducerController {\n    public static final String CONFIRM_EXCHANGE_NAME = \"confirm.exchange\";\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n    @Autowired\n    private MyCallBack myCallBack;\n\n    //依赖注入 rabbitTemplate 之后再设置它的回调对象\n    @PostConstruct\n    public void init() {\n        rabbitTemplate.setConfirmCallback(myCallBack);\n    }\n    \n    /**\n     * 消息回调和退回\n     *\n     * @param message\n     */\n    @GetMapping(\"sendMessage/{message}\")\n    public void sendMessage(@PathVariable String message) {\n\n        //指定消息 id 为 1\n        CorrelationData correlationData1 = new CorrelationData(\"1\");\n        String routingKey = \"key1\";\n        rabbitTemplate.convertAndSend(CONFIRM_EXCHANGE_NAME, routingKey, message + routingKey, correlationData1);\n        log.info(routingKey + \"发送消息内容:{}\", message + routingKey);\n\n        CorrelationData correlationData2 = new CorrelationData(\"2\");\n        routingKey = \"key2\";\n        rabbitTemplate.convertAndSend(CONFIRM_EXCHANGE_NAME, routingKey, message + routingKey, correlationData2);\n        log.info(routingKey + \"发送消息内容:{}\", message + routingKey);\n\n    }\n\n}\n```\n\n**4、消息消费者** \n\n```java\n@Component\n@Slf4j\npublic class ConfirmConsumer {\n    public static final String CONFIRM_QUEUE_NAME = \"confirm.queue\";\n\n    @RabbitListener(queues = CONFIRM_QUEUE_NAME)\n    public void receiveMsg(Message message) {\n        String msg = new String(message.getBody());\n        log.info(\"接受到队列 confirm.queue 消息:{}\", msg);\n    }\n\n}\n```\n\n访问： <http://localhost:8080/confirm/sendMessage/%E4%BD%A0%E5%A5%BD>\n\n结果分析：\n\n![image-20210629135636990](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210629135636990.png)\n\n可以看到，发送了两条消息，第一条消息的 RoutingKey 为 \"key1\"，第二条消息的 RoutingKey 为 \"key2\"，两条消息都成功被交换机接收，也收到了交换机的确认回调，但消费者只收到了一条消息，因为第二条消息的 RoutingKey 与队列的 BindingKey 不一致，也没有其它队列能接收这个消息，所有第二条消息被直接丢弃了。\n\n丢弃的消息交换机是不知道的，需要解决告诉生产者消息传送失败\n\n## 回退消息\n\nMandatory 参数 \n\n```java\nrabbitTemplate.setReturnsCallback(myCallBack);\n```\n\n在仅开启了生产者确认机制的情况下，交换机接收到消息后，会直接给消息生产者发送确认消息，如果发现该消息不可路由，那么消息会被直接丢弃，此时生产者是不知道消息被丢弃这个事件的。\n\n那么如何让无法被路由的消息帮我想办法处理一下？最起码通知我一声，我好自己处理啊。通过设置 mandatory 参数可以在当消息传递过程中不可达目的地时将消息返回给生产者。\n\n**1、修改配置**\n\n```properties\n#消息退回\nspring.rabbitmq.publisher-returns=true\n```\n\n**2、修改回调接口**\n\n```java\n@Component\n@Slf4j\npublic class MyCallBack implements RabbitTemplate.ConfirmCallback, RabbitTemplate.ReturnsCallback {\n\n    /**\n     * 交换机不管是否收到消息的一个回调方法\n     *\n     * @param correlationData 消息相关数据\n     * @param ack             交换机是否收到消息\n     * @param cause           为收到消息的原因\n     */\n    @Override\n    public void confirm(CorrelationData correlationData, boolean ack, String cause) {\n        String id = correlationData != null ? correlationData.getId() : \"\";\n        if (ack) {\n            log.info(\"交换机已经收到 id 为:{}的消息\", id);\n        } else {\n            log.info(\"交换机还未收到 id 为:{}消息，原因:{}\", id, cause);\n        }\n    }\n\n    //当消息无法路由的时候的回调方法\n    @Override\n    public void returnedMessage(ReturnedMessage returned) {\n\n        log.error(\"消息：{}，被交换机 {} 退回，原因：{}，路由key：{},code:{}\",\n                new String(returned.getMessage().getBody()), returned.getExchange(),\n                returned.getReplyText(), returned.getRoutingKey(),\n                returned.getReplyCode());\n\n    }\n}\n```\n\n低版本可能没有 `RabbitTemplate.ReturnsCallback` 请用 `RabbitTemplate.ReturnCallback`\n\n```java\n@Override\npublic void returnedMessage(Message message, int replyCode, String replyText, String\nexchange, String routingKey) {\n\tlog.info(\"消息:{}被服务器退回，退回原因:{}, 交换机是:{}, 路由 key:{}\",new String(message.getBody()),replyText, exchange, routingKey);\n}\n```\n\n\n\n**3、修改发送者 ProducerController**\n\n```java\n//依赖注入 rabbitTemplate 之后再设置它的回调对象\n@PostConstruct\npublic void init() {\n    //消息回调\n    rabbitTemplate.setConfirmCallback(myCallBack);\n    /**\n     * true：交换机无法将消息进行路由时，会将该消息返回给生产者\n     * false：如果发现消息无法进行路由，则直接丢弃\n     */\n    rabbitTemplate.setMandatory(true);\n    //设置回退消息交给谁处理\n    rabbitTemplate.setReturnsCallback(myCallBack);\n\n}\n```\n\n\n\n访问： <http://localhost:8080/confirm/sendMessage/%E4%BD%A0%E5%A5%BD>\n\n结果分析：\n\n![image-20210629143756078](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210629143756078.png)\n\n\n\n\n\n## 备份交换机\n\n有了 mandatory 参数和回退消息，我们获得了对无法投递消息的感知能力，在生产者的消息无法被投递时发现并处理。但有时候，我们并不知道该如何处理这些无法路由的消息，最多打个日志，然后触发报警，再来手动处理。而通过日志来处理这些无法路由的消息是很不优雅的做法，特别是当生产者所在的服务有多台机器的时候，手动复制日志会更加麻烦而且容易出错。而且设置 mandatory 参数会增加生产者的复杂性，需要添加处理这些被退回的消息的逻辑。如果既不想丢失消息，又不想增加生产者的复杂性，该怎么做呢？\n\n前面在设置死信队列的文章中，我们提到，可以为队列设置死信交换机来存储那些处理失败的消息，可是这些不可路由消息根本没有机会进入到队列，因此无法使用死信队列来保存消息。 在 RabbitMQ 中，有一种备份交换机的机制存在，可以很好的应对这个问题。\n\n什么是备份交换机呢？备份交换机可以理解为 RabbitMQ 中交换机的“备胎”，当我们为某一个交换机声明一个对应的备份交换机时，就是为它创建一个备胎，当交换机接收到一条不可路由消息时，将会把这条消息转发到备份交换机中，由备份交换机来进行转发和处理，通常备份交换机的类型为 Fanout ，这样就能把所有消息都投递到与其绑定的队列中，然后我们在备份交换机下绑定一个队列，这样所有那些原交换机无法被路由的消息，就会都进 入这个队列了。当然，我们还可以建立一个报警队列，用独立的消费者来进行监测和报警。\n\n- 代码架构图 \n\n![RabbitMQ-00000072](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000072.png)\n\n1、修改配置类\n\n```java\n@Configuration\npublic class ConfirmConfig {\n    public static final String CONFIRM_EXCHANGE_NAME = \"confirm.exchange\";\n    public static final String CONFIRM_QUEUE_NAME = \"confirm.queue\";\n    //关于备份的\n    public static final String BACKUP_EXCHANGE_NAME = \"backup.exchange\";\n    public static final String BACKUP_QUEUE_NAME = \"backup.queue\";\n    public static final String WARNING_QUEUE_NAME = \"warning.queue\";\n\n\n    /*\n    //声明业务 Exchange\n    @Bean(\"confirmExchange\")\n    public DirectExchange confirmExchange() {\n        return new DirectExchange(CONFIRM_EXCHANGE_NAME);\n    }\n    */\n\n    // 声明确认队列\n    @Bean(\"confirmQueue\")\n    public Queue confirmQueue() {\n        return QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();\n    }\n\n    // 声明确认队列绑定关系\n    @Bean\n    public Binding queueBinding(@Qualifier(\"confirmQueue\") Queue queue,\n                                @Qualifier(\"confirmExchange\") DirectExchange exchange) {\n        return BindingBuilder.bind(queue).to(exchange).with(\"key1\");\n    }\n\n    //************************以下是关于备份的******************************\n\n    //声明备份 Exchange\n    @Bean(\"backupExchange\")\n    public FanoutExchange backupExchange() {\n        return new FanoutExchange(BACKUP_EXCHANGE_NAME);\n    }\n\n    //声明确认 Exchange 交换机的备份交换机\n    @Bean(\"confirmExchange\")\n    public DirectExchange confirmExchange() {\n        ExchangeBuilder exchangeBuilder = ExchangeBuilder.directExchange(CONFIRM_EXCHANGE_NAME)\n                .durable(true)\n                //设置该交换机的备份交换机\n                .withArgument(\"alternate-exchange\", BACKUP_EXCHANGE_NAME);\n        return exchangeBuilder.build();\n    }\n\n\n    // 声明警告队列\n    @Bean(\"warningQueue\")\n    public Queue warningQueue() {\n        return QueueBuilder.durable(WARNING_QUEUE_NAME).build();\n    }\n\n    // 声明报警队列绑定关系\n    @Bean\n    public Binding warningBinding(@Qualifier(\"warningQueue\") Queue queue,\n                                  @Qualifier(\"backupExchange\") FanoutExchange backupExchange) {\n        return BindingBuilder.bind(queue).to(backupExchange);\n    }\n\n    // 声明备份队列\n    @Bean(\"backQueue\")\n    public Queue backQueue() {\n        return QueueBuilder.durable(BACKUP_QUEUE_NAME).build();\n    }\n\n    // 声明备份队列绑定关系\n    @Bean\n    public Binding backupBinding(@Qualifier(\"backQueue\") Queue queue,\n                                 @Qualifier(\"backupExchange\") FanoutExchange backupExchange) {\n        return BindingBuilder.bind(queue).to(backupExchange);\n    }\n}\n```\n\n2、报警消费者\n\n```java\n@Component\n@Slf4j\npublic class WarningConsumer {\n    public static final String WARNING_QUEUE_NAME = \"warning.queue\";\n\n    @RabbitListener(queues = WARNING_QUEUE_NAME)\n    public void receiveWarningMsg(Message message) {\n        String msg = new String(message.getBody());\n        log.error(\"报警发现不可路由消息：{}\", msg);\n    }\n}\n```\n\n之前已写过 `confirm.exchange` 交换机，由于更改配置，需要删掉，不然会报错\n\n![RabbitMQ-00000073](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000073.png)\n\n\n\n- 访问： <http://localhost:8080/confirm/sendMessage/%E4%BD%A0%E5%A5%BD>\n\n![image-20210629152752935](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210629152752935.png)\n\nmandatory 参数与备份交换机可以一起使用的时候，如果两者同时开启，消息究竟何去何从？谁优先级高，经过上面结果显示答案是**备份交换机优先级高**。\n\n\n\n# 幂等性\n\n::: tip 概念\n\n:::\n\n用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。 举个最简单的例子，那就是支付，用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常， 此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额发现多扣钱 了，流水记录也变成了两条。在以前的单应用系统中，我们只需要把数据操作放入事务中即可，发生错误立即回滚，但是再响应客户端的时候也有可能出现网络中断或者异常等等\n\n\n\n::: tip 消息重复消费\n\n:::\n\n消费者在消费 MQ 中的消息时，MQ 已把消息发送给消费者，消费者在给 MQ 返回 ack 时网络中断， 故 MQ 未收到确认信息，该条消息会重新发给其他的消费者，或者在网络重连后再次发送给该消费者，但实际上该消费者已成功消费了该条消息，造成消费者消费了重复的消息。\n\n\n\n::: tip 解决思路\n\n:::\n\nMQ 消费者的幂等性的解决一般使用全局 ID 或者写个唯一标识比如时间戳 或者 UUID 或者订单消费者消费 MQ 中的消息也可利用 MQ 的该 id 来判断，或者可按自己的规则生成一个全局唯一 id，每次消费消息时用该 id 先判断该消息是否已消费过。\n\n\n\n::: tip 消费端的幂等性保障\n\n:::\n\n在海量订单生成的业务高峰期，生产端有可能就会重复发生了消息，这时候消费端就要实现幂等性， 这就意味着我们的消息永远不会被消费多次，即使我们收到了一样的消息。\n\n业界主流的幂等性有两种操作:a. 唯一 ID+指纹码机制,利用数据库主键去重, b.利用 redis 的原子性去实现\n\n- 唯一ID+指纹码机制 \n\n\n\n指纹码：我们的一些规则或者时间戳加别的服务给到的唯一信息码,它并不一定是我们系统生成的，基本都是由我们的业务规则拼接而来，但是一定要保证唯一性，然后就利用查询语句进行判断这个 id 是否存在数据库中，优势就是实现简单就一个拼接，然后查询判断是否重复；劣势就是在高并发时，如果是单个数据库就会有写入性能瓶颈当然也可以采用分库分表提升性能，但也不是我们最推荐的方式。\n\n-  note Redis 原子性\n\n利用 redis 执行 setnx 命令，天然具有幂等性。从而实现不重复消费\n\n\n\n## 优先级队列\n\n- **使用场景**\n\n在我们系统中有一个订单催付的场景，我们的客户在天猫下的订单，淘宝会及时将订单推送给我们，如果在用户设定的时间内未付款那么就会给用户推送一条短信提醒，很简单的一个功能对吧。\n\n但是，tmall 商家对我们来说，肯定是要分大客户和小客户的对吧，比如像苹果，小米这样大商家一年起码能给我们创造很大的利润，所以理应当然，他们的订单必须得到优先处理，而曾经我们的后端系统是使用 redis 来存放的定时轮询，大家都知道 redis 只能用 List 做一个简简单单的消息队列，并不能实现一个优先级的场景，所以订单量大了后采用 RabbitMQ 进行改造和优化，如果发现是大客户的订单给一个相对比较高的优先级， 否则就是默认优先级。\n\n- **如何添加？**\n\na.控制台页面添加\n\n![RabbitMQ-00000076](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000076.png)\n\nb.队列中代码添加优先级\n\n```java\nMap<String, Object> params = new HashMap();\nparams.put(\"x-max-priority\", 10);\nchannel.queueDeclare(\"hello\", true, false, false, params);\n```\n\nc.消息中代码添加优先级\n\n```java\nAMQP.BasicProperties properties = new AMQP.BasicProperties().builder().priority(10).build();\n```\n\n**注意事项：**\n\n要让队列实现优先级需要做的事情有如下事情：队列需要设置为优先级队列，消息需要设置消息的优先级，消费者需要等待消息已经发送到队列中才去消费因为，这样才有机会对消息进行排序\n\n\n\n::: tip 实战 \n\n:::\n\n生产者：\n\n```java\npublic class PriorityProducer {\n    private static final String QUEUE_NAME = \"hello\";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtils.getChannel();\n\n        //给消息赋予一个 priority 属性\n        AMQP.BasicProperties properties = new AMQP.BasicProperties().builder().priority(10).build();\n\n        for (int i = 1; i < 11; i++) {\n            String message = \"info\" + i;\n            if (i == 5) {\n                channel.basicPublish(\"\", QUEUE_NAME, properties, message.getBytes());\n            } else {\n                channel.basicPublish(\"\", QUEUE_NAME, null, message.getBytes());\n            }\n            System.out.println(\"发送消息完成:\" + message);\n        }\n    }\n\n}\n```\n\n\n\n消费者：\n\n```java\npublic class PriorityConsumer {\n    private final static String QUEUE_NAME = \"hello\";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtils.getChannel();\n\n        //设置队列的最大优先级 最大可以设置到 255 官网推荐 1-10 如果设置太高比较吃内存和 CPU\n        Map<String, Object> params = new HashMap();\n        params.put(\"x-max-priority\", 10);\n        channel.queueDeclare(QUEUE_NAME, true, false, false, params);\n\n        //推送的消息如何进行消费的接口回调\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody());\n            System.out.println(message);\n        };\n        //取消消费的一个回调接口 如在消费的时候队列被删除掉了\n        CancelCallback cancelCallback = (consumerTag) -> {\n            System.out.println(\"消息消费被中断\");\n        };\n\n        channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);\n    }\n\n}\n```\n\n![image-20210629163922085](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210629163922085.png)\n\n\n\n## 惰性队列\n\n- **使用场景**\n\nRabbitMQ 从 3.6.0 版本开始引入了惰性队列的概念。惰性队列会尽可能的将消息存入磁盘中，而在消费者消费到相应的消息时才会被加载到内存中，它的一个重要的设计目标是能够支持更长的队列，即支持更多的消息存储。当消费者由于各种各样的原因(比如消费者下线、宕机亦或者是由于维护而关闭等)而致使长时间内不能消费消息造成堆积时，惰性队列就很有必要了。\n\n默认情况下，当生产者将消息发送到 RabbitMQ 的时候，队列中的消息会尽可能的存储在内存之中， 这样可以更加快速的将消息发送给消费者。即使是持久化的消息，在被写入磁盘的同时也会在内存中驻留一份备份。当RabbitMQ 需要释放内存的时候，会将内存中的消息换页至磁盘中，这个操作会耗费较长的时间，也会阻塞队列的操作，进而无法接收新的消息。虽然 RabbitMQ 的开发者们一直在升级相关的算法， 但是效果始终不太理想，尤其是在消息量特别大的时候。\n\n- **两种模式** \n\n队列具备两种模式：default 和 lazy。默认的为default 模式，在3.6.0 之前的版本无需做任何变更。lazy 模式即为惰性队列的模式，可以通过调用 channel.queueDeclare 方法的时候在参数中设置，也可以通过 Policy 的方式设置，如果一个队列同时使用这两种方式设置的话，那么 Policy 的方式具备更高的优先级。 如果要通过声明的方式改变已有队列的模式的话，那么只能先删除队列，然后再重新声明一个新的。\n\n在队列声明的时候可以通过“x-queue-mode”参数来设置队列的模式，取值为“default”和“lazy”。下面示例中演示了一个惰性队列的声明细节：\n\n```java\nMap<String, Object> args = new HashMap<String, Object>();\nargs.put(\"x-queue-mode\", \"lazy\");\nchannel.queueDeclare(\"myqueue\", false, false, false, args);\n```\n\n- 内存开销对比 \n\n![RabbitMQ-00000077](https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000077.png)\n\n在发送 1 百万条消息，每条消息大概占 1KB 的情况下，普通队列占用内存是 1.2GB，而惰性队列仅仅 占用 1.5MB","slug":"rabbitmq","published":1,"updated":"2022-07-21T01:48:35.534Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5w7e73u0007igvu8exm6ie0","content":"<h1 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h1><h2 id=\"MQ-的相关概念\"><a href=\"#MQ-的相关概念\" class=\"headerlink\" title=\"MQ 的相关概念\"></a>MQ 的相关概念</h2><h3 id=\"什么是MQ\"><a href=\"#什么是MQ\" class=\"headerlink\" title=\"什么是MQ\"></a>什么是MQ</h3><p>MQ(message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是 message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常 见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不 用依赖其他服务。</p>\n<h3 id=\"为什么要用MQ\"><a href=\"#为什么要用MQ\" class=\"headerlink\" title=\"为什么要用MQ\"></a>为什么要用MQ</h3><ul>\n<li><strong>流量消峰</strong></li>\n</ul>\n<p>举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体验要好。</p>\n<ul>\n<li><strong>应用解耦</strong></li>\n</ul>\n<p>以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合 调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于 消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在 这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流 系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000004.png\" alt=\"RabbitMQ-00000004\"></p>\n<ul>\n<li><strong>异步处理</strong></li>\n</ul>\n<p>有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可以执行完。</p>\n<p>以前一般有两种方式，A 过一段时间去调用 B 的查询 api 查询。或者 A 提供一个 callback api， B 执行完之后调用 api 通知 A 服务。这两种方式都不是很优雅。</p>\n<p>使用消息总线，可以很方便解决这个问题， A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此消息转发给 A 服务。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样B 服务也不用 做这些操作。A 服务还能及时的得到异步处理成功的消息。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000005.png\" alt=\"RabbitMQ-00000005\"></p>\n<h3 id=\"MQ-的分类\"><a href=\"#MQ-的分类\" class=\"headerlink\" title=\"MQ 的分类\"></a>MQ 的分类</h3><p>::: tip ActiveMQ</p>\n<p>:::</p>\n<p>优点：单机吞吐量万级，时效性 ms 级，可用性高，基于主从架构实现高可用性，消息可靠性较 低的概率丢失数据</p>\n<p>缺点：官方社区现在对 ActiveMQ 5.x 维护越来越少，高吞吐量场景较少使用。</p>\n<p>::: tip Kafka</p>\n<p>:::</p>\n<p>大数据的杀手锏，谈到大数据领域内的消息传输，则绕不开 Kafka，这款为<strong>大数据而生</strong>的消息中间件， 以其百万级 TPS 的吞吐量名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥 着举足轻重的作用。目前已经被 LinkedIn，Uber, Twitter, Netflix 等大公司所采纳。</p>\n<p><strong>优点</strong>：性能卓越，单机写入 TPS 约在百万条/秒，最大的优点，就是<strong>吞吐量高</strong>。时效性 ms 级可用性非 常高，kafka 是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用,消费者采 用 Pull 方式获取消息, 消息有序, 通过控制能够保证所有消息被消费且仅被消费一次;有优秀的第三方Kafka Web 管理界面 Kafka-Manager；在日志领域比较成熟，被多家公司和多个开源项目使用；功能支持： 功能 较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用</p>\n<p><strong>缺点</strong>：Kafka 单机超过 64 个队列/分区，Load 会发生明显的飙高现象，队列越多，load 越高，发送消 息响应时间变长，使用短轮询方式，实时性取决于轮询间隔时间，消费失败不支持重试；支持消息顺序， 但是一台代理宕机后，就会产生消息乱序，<strong>社区更新较慢</strong>；</p>\n<p>::: tip RocketMQ</p>\n<p>:::</p>\n<p>RocketMQ 出自阿里巴巴的开源产品，用 Java 语言实现，在设计时参考了 Kafka，并做出了自己的一 些改进。被阿里巴巴广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog 分发等场 景。</p>\n<p>优点：<strong>单机吞吐量十万级</strong>,可用性非常高，分布式架构，<strong>消息可以做到 0 丢失</strong>,MQ 功能较为完善，还是分 布式的，扩展性好,支<strong>持 10 亿级别的消息堆积</strong>，不会因为堆积导致性能下降,源码是 java 我们可以自己阅 读源码，定制自己公司的 MQ</p>\n<p>缺点：<strong>支持的客户端语言不多</strong>，目前是 java 及 c++，其中 c++不成熟；社区活跃度一般,没有在MQ 核心中去实现 JMS 等接口,有些系统要迁移需要修改大量代码</p>\n<p>::: note RabbitMQ</p>\n<p>:::</p>\n<p>2007 年发布，是一个在AMQP(高级消息队列协议)基础上完成的，可复用的企业消息系统，<strong>是当前最主流的消息中间件之一。</strong></p>\n<p>优点：由于 erlang 语言的高并发特性，性能较好；吞吐量到万级，MQ 功能比较完备,健壮、稳定、易 用、跨平台、支持多种语言 如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，支持 AJAX 文档齐全；开源提供的管理界面非常棒，用起来很好用,社区活跃度高；更新频率相当高 </p>\n<p>官网更新：<a href=\"https://www.rabbitmq.com/news.html\">https://www.rabbitmq.com/news.html</a></p>\n<p>缺点：商业版需要收费,学习成本较高</p>\n<h3 id=\"MQ-的选择\"><a href=\"#MQ-的选择\" class=\"headerlink\" title=\"MQ 的选择\"></a>MQ 的选择</h3><ul>\n<li><strong>Kafka</strong></li>\n</ul>\n<p>Kafka 主要特点是基于Pull 的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集 和传输，适合产生大量数据的互联网服务的数据收集业务。大型公司建议可以选用，如果有日志采集功能， 肯定是首选 kafka 了。</p>\n<p>尚硅谷官网 kafka 视频教程：<a href=\"http://www.gulixueyuan.com/course/330/tasks\">http://www.gulixueyuan.com/course/330/tasks</a></p>\n<ul>\n<li><strong>RocketMQ</strong></li>\n</ul>\n<p>天生为<strong>金融互联网</strong>领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削 峰，在大量交易涌入时，后端可能无法及时处理的情况。RoketMQ 在稳定性上可能更值得信赖，这些业务 场景在阿里双 11 已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择 RocketMQ。</p>\n<ul>\n<li>RabbitMQ</li>\n</ul>\n<p>结合 erlang 语言本身的并发优势，性能好时效性微秒级，社区活跃度也比较高，管理界面用起来十分 方便，如果你的<strong>数据量没有那么大</strong>，中小型公司优先选择功能比较完备的 RabbitMQ。</p>\n<h2 id=\"RabbitMQ\"><a href=\"#RabbitMQ\" class=\"headerlink\" title=\"RabbitMQ\"></a>RabbitMQ</h2><h3 id=\"RabbitMQ-的概念\"><a href=\"#RabbitMQ-的概念\" class=\"headerlink\" title=\"RabbitMQ 的概念\"></a>RabbitMQ 的概念</h3><p>RabbitMQ 是一个消息中间件：它接受并转发消息。</p>\n<p>你可以把它当做一个快递站点，当你要发送一个包裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑 RabbitMQ 是 一个快递站，一个快递员帮你传递快件。</p>\n<p>RabbitMQ 与快递站的主要区别在于，它不处理快件而是接收， 存储和转发消息数据。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210625230930992.png\" alt=\"image-20210625230930992\"></p>\n<p>官网：<a href=\"https://www.rabbitmq.com/#features\">https://www.rabbitmq.com/#features</a></p>\n<h3 id=\"四大核心概念\"><a href=\"#四大核心概念\" class=\"headerlink\" title=\"四大核心概念\"></a>四大核心概念</h3><ul>\n<li><p>生产者</p>\n<p>产生数据发送消息的程序是生产者</p>\n</li>\n<li><p>交换机</p>\n<p>交换机是 RabbitMQ 非常重要的一个部件，一方面它接收来自生产者的消息，另一方面它将消息 推送到队列中。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推 送到多个队列，亦或者是把消息丢弃，这个得有交换机类型决定</p>\n</li>\n<li><p>队列</p>\n<p>队列是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ 和应用程序，但它们只能存 储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可 以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。这就是我们使用队列的方式</p>\n</li>\n<li><p>消费者</p>\n<p>消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者，消费 者和消息中间件很多时候并不在同一机器上。同一个应用程序既可以是生产者又是可以是消费者。</p>\n</li>\n</ul>\n<h3 id=\"各个名词介绍\"><a href=\"#各个名词介绍\" class=\"headerlink\" title=\"各个名词介绍\"></a>各个名词介绍</h3><p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000007.png\" alt=\"RabbitMQ-00000007\"></p>\n<ul>\n<li><p>Broker</p>\n<p>接收和分发消息的应用，RabbitMQ Server 就是 Message Broker</p>\n</li>\n<li><p>Virtual host</p>\n<p>出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似 于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出 多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等</p>\n</li>\n<li><p>Connection</p>\n<p>publisher／consumer 和 broker 之间的 TCP 连接</p>\n</li>\n<li><p>Channel</p>\n<p>如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程 序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客 户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的 Connection 极大减少了操作系统建立 TCP connection 的开销 </p>\n</li>\n<li><p>Exchange</p>\n<p>message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发 消息到 queue 中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)</p>\n</li>\n<li><p>Queue</p>\n<p>消息最终被送到这里等待 consumer 取走</p>\n</li>\n<li><p>Binding</p>\n<p>exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key，Binding 信息被保 存到 exchange 中的查询表中，用于 message 的分发依据</p>\n</li>\n</ul>\n<h3 id=\"安装RabbitMQ\"><a href=\"#安装RabbitMQ\" class=\"headerlink\" title=\"安装RabbitMQ\"></a>安装RabbitMQ</h3><p><strong>1、下载</strong></p>\n<p>官网下载地址：<a href=\"https://www.rabbitmq.com/download.html\">https://www.rabbitmq.com/download.html</a></p>\n<p>这里我们选择的版本号（注意这两版本要求）</p>\n<ul>\n<li><p>rabbitmq-server-3.8.8-1.el7.noarch.rpm</p>\n<p>GitHub：<a href=\"https://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.8.8\">https://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.8.8</a></p>\n<p>加载下载：<a href=\"https://packagecloud.io/rabbitmq/rabbitmq-server/packages/el/7/rabbitmq-server-3.8.8-1.el7.noarch.rpm\">https://packagecloud.io/rabbitmq/rabbitmq-server/packages/el/7/rabbitmq-server-3.8.8-1.el7.noarch.rpm</a></p>\n</li>\n<li><p>erlang-21.3.8.21-1.el7.x86_64.rpm</p>\n<p>官网：<a href=\"https://www.erlang-solutions.com/downloads/\">https://www.erlang-solutions.com/downloads/</a></p>\n<p>加速：<a href=\"https://packagecloud.io/rabbitmq/erlang/packages/el/7/erlang-21.3.8.21-1.el7.x86_64.rpm\">https://packagecloud.io/rabbitmq/erlang/packages/el/7/erlang-21.3.8.21-1.el7.x86_64.rpm</a></p>\n</li>\n</ul>\n<p>Red Hat 8, CentOS 8 和 modern Fedora 版本，把 “el7” 替换成 “el8”</p>\n<p><strong>2、安装</strong></p>\n<p>上传到 <code>/usr/local/software</code> 目录下(如果没有 software 需要自己创建)</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">rpm -ivh erlang-21.3.8.21-1.el7.x86_64.rpm</span><br><span class=\"line\">yum install socat -y</span><br><span class=\"line\">rpm -ivh rabbitmq-server-3.8.8-1.el7.noarch.rpm</span><br></pre></td></tr></table></figure>\n\n<p><strong>3、启动</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 启动服务</span></span><br><span class=\"line\">systemctl start rabbitmq-server</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 查看服务状态</span></span><br><span class=\"line\">systemctl status rabbitmq-server</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 开机自启动</span></span><br><span class=\"line\">systemctl enable rabbitmq-server</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 停止服务</span></span><br><span class=\"line\">systemctl stop rabbitmq-server</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 重启服务</span></span><br><span class=\"line\">systemctl restart rabbitmq-server</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Web管理界面及授权操作\"><a href=\"#Web管理界面及授权操作\" class=\"headerlink\" title=\"Web管理界面及授权操作\"></a>Web管理界面及授权操作</h3><p><strong>1、安装</strong></p>\n<p>默认情况下，是没有安装web端的客户端插件，需要安装才可以生效</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure>\n\n<p>安装完毕以后，重启服务即可</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl restart rabbitmq-server</span><br></pre></td></tr></table></figure>\n\n<p>访问 <a href=\"http://42.192.149.71:15672/\">http://42.192.149.71:15672</a> ，用默认账号密码(guest)登录，出现权限问题</p>\n<p>默认情况只能在 localhost 本机下访问，所以需要添加一个远程登录的用户</p>\n<p><strong>2、添加用户</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 创建账号和密码</span></span><br><span class=\"line\">rabbitmqctl add_user admin 123456</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 设置用户角色</span></span><br><span class=\"line\">rabbitmqctl set_user_tags admin administrator</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 为用户添加资源权限</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> set_permissions [-p &lt;vhostpath&gt;] &lt;user&gt; &lt;conf&gt; &lt;write&gt; &lt;<span class=\"built_in\">read</span>&gt;</span></span><br><span class=\"line\">rabbitmqctl set_permissions -p &quot;/&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 添加配置、写、读权限</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>用户级别：</p>\n<ol>\n<li><strong>administrator</strong>：可以登录控制台、查看所有信息、可以对 rabbitmq 进行管理</li>\n<li><strong>monitoring</strong>：监控者 登录控制台，查看所有信息</li>\n<li><strong>policymaker</strong>：策略制定者 登录控制台，指定策略</li>\n<li><strong>managment</strong>：普通管理员 登录控制台</li>\n</ol>\n<p>再次登录，用 admin 用户</p>\n<p>::: tip 重置命令</p>\n<p>:::</p>\n<p>关闭应用的命令为：rabbitmqctl stop_app</p>\n<p>清除的命令为：rabbitmqctl reset</p>\n<p>重新启动命令为：rabbitmqctl start_app</p>\n<h3 id=\"Docker-安装\"><a href=\"#Docker-安装\" class=\"headerlink\" title=\"Docker 安装\"></a>Docker 安装</h3><p>官网：<a href=\"https://registry.hub.docker.com/_/rabbitmq/\">https://registry.hub.docker.com/_/rabbitmq/</a></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -id --name myrabbit -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=123456 -p 15672:15672 rabbitmq:3-management</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"Hello-world\"><a href=\"#Hello-world\" class=\"headerlink\" title=\"Hello world\"></a>Hello world</h1><p>我们将用 Java 编写两个程序。发送单个消息的生产者和接收消息并打印出来的消费者</p>\n<p>在下图中，“ P” 是我们的生产者，“ C” 是我们的消费者。中间的框是一个队列 RabbitMQ 代表使用者保留的消息缓冲区</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000012.png\" alt=\"RabbitMQ-00000012\"></p>\n<p>连接的时候，需要开启 5672 端口</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210626162052259.png\" alt=\"image-20210626162052259\"></p>\n<ul>\n<li><strong>依赖</strong></li>\n</ul>\n<p>pom.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--指定 jdk 编译版本--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.maven.plugins<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>maven-compiler-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">source</span>&gt;</span>8<span class=\"tag\">&lt;/<span class=\"name\">source</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">target</span>&gt;</span>8<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--rabbitmq 依赖客户端--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.rabbitmq<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>amqp-client<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.8.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--操作文件流的一个依赖--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>commons-io<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>commons-io<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.6<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>消息生产者</strong></li>\n</ul>\n<p>发送消息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.oddfar.one;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.rabbitmq.client.Channel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.rabbitmq.client.Connection;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> zhiyuan</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Producer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String QUEUE_NAME = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//创建一个连接工厂</span></span><br><span class=\"line\">        ConnectionFactory factory = <span class=\"keyword\">new</span> ConnectionFactory();</span><br><span class=\"line\">        factory.setHost(<span class=\"string\">&quot;42.192.149.71&quot;</span>);</span><br><span class=\"line\">        factory.setUsername(<span class=\"string\">&quot;admin&quot;</span>);</span><br><span class=\"line\">        factory.setPassword(<span class=\"string\">&quot;123456&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//channel 实现了自动 close 接口 自动关闭 不需要显示关闭</span></span><br><span class=\"line\">        <span class=\"comment\">//创建连接</span></span><br><span class=\"line\">        Connection connection = factory.newConnection();</span><br><span class=\"line\">        <span class=\"comment\">//获取信道</span></span><br><span class=\"line\">        Channel channel = connection.createChannel();</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 生成一个队列</span></span><br><span class=\"line\"><span class=\"comment\">         * 1.队列名称</span></span><br><span class=\"line\"><span class=\"comment\">         * 2.队列里面的消息是否持久化 也就是是否用完就删除</span></span><br><span class=\"line\"><span class=\"comment\">         * 3.该队列是否只供一个消费者进行消费 是否进行共享 true 可以多个消费者消费</span></span><br><span class=\"line\"><span class=\"comment\">         * 4.是否自动删除 最后一个消费者端开连接以后 该队列是否自动删除 true 自动删除</span></span><br><span class=\"line\"><span class=\"comment\">         * 5.其他参数</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        channel.queueDeclare(QUEUE_NAME, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        String message = <span class=\"string\">&quot;hello world&quot;</span>;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 发送一个消息</span></span><br><span class=\"line\"><span class=\"comment\">         * 1.发送到那个交换机</span></span><br><span class=\"line\"><span class=\"comment\">         * 2.路由的 key 是哪个</span></span><br><span class=\"line\"><span class=\"comment\">         * 3.其他的参数信息</span></span><br><span class=\"line\"><span class=\"comment\">         * 4.发送消息的消息体</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        channel.basicPublish(<span class=\"string\">&quot;&quot;</span>, QUEUE_NAME, <span class=\"keyword\">null</span>, message.getBytes());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;消息发送完毕&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li><strong>消息消费者</strong></li>\n</ul>\n<p>获取“生产者”发出的消息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.oddfar.one;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.rabbitmq.client.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> zhiyuan</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Consumer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String QUEUE_NAME = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        ConnectionFactory factory = <span class=\"keyword\">new</span> ConnectionFactory();</span><br><span class=\"line\">        factory.setHost(<span class=\"string\">&quot;42.192.149.71&quot;</span>);</span><br><span class=\"line\">        factory.setUsername(<span class=\"string\">&quot;admin&quot;</span>);</span><br><span class=\"line\">        factory.setPassword(<span class=\"string\">&quot;123456&quot;</span>);</span><br><span class=\"line\">        Connection connection = factory.newConnection();</span><br><span class=\"line\">        Channel channel = connection.createChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;等待接收消息.........&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//推送的消息如何进行消费的接口回调</span></span><br><span class=\"line\">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class=\"line\">            String message = <span class=\"keyword\">new</span> String(delivery.getBody());</span><br><span class=\"line\">            System.out.println(message);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"comment\">//取消消费的一个回调接口 如在消费的时候队列被删除掉了</span></span><br><span class=\"line\">        CancelCallback cancelCallback = (consumerTag) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;消息消费被中断&quot;</span>);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 消费者消费消息 - 接受消息</span></span><br><span class=\"line\"><span class=\"comment\">         * 1.消费哪个队列</span></span><br><span class=\"line\"><span class=\"comment\">         * 2.消费成功之后是否要自动应答 true 代表自动应答 false 手动应答</span></span><br><span class=\"line\"><span class=\"comment\">         * 3.消费者未成功消费的回调</span></span><br><span class=\"line\"><span class=\"comment\">         * 4.消息被取消时的回调</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        channel.basicConsume(QUEUE_NAME, <span class=\"keyword\">true</span>, deliverCallback, cancelCallback);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Work-Queues\"><a href=\"#Work-Queues\" class=\"headerlink\" title=\"Work Queues\"></a>Work Queues</h1><p>Work Queues——工作队列(又称任务队列)的主要思想是避免立即执行资源密集型任务，而不得不等待它完成。 相反我们安排任务在之后执行。我们把任务封装为消息并将其发送到队列。在后台运行的工作进 程将弹出任务并最终执行作业。当有多个工作线程时，这些工作线程将一起处理这些任务。</p>\n<h2 id=\"轮训分发消息\"><a href=\"#轮训分发消息\" class=\"headerlink\" title=\"轮训分发消息\"></a>轮训分发消息</h2><p>在这个案例中我们会启动两个工作线程，一个消息发送线程，我们来看看他们两个工作线程是如何工作的。</p>\n<p><strong>1、抽取工具类</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.oddfar.utils;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.rabbitmq.client.Channel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.rabbitmq.client.Connection;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RabbitMqUtils</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//得到一个连接的 channel</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Channel <span class=\"title\">getChannel</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//创建一个连接工厂</span></span><br><span class=\"line\">        ConnectionFactory factory = <span class=\"keyword\">new</span> ConnectionFactory();</span><br><span class=\"line\">        factory.setHost(<span class=\"string\">&quot;42.192.149.71&quot;</span>);</span><br><span class=\"line\">        factory.setUsername(<span class=\"string\">&quot;admin&quot;</span>);</span><br><span class=\"line\">        factory.setPassword(<span class=\"string\">&quot;123456&quot;</span>);</span><br><span class=\"line\">        Connection connection = factory.newConnection();</span><br><span class=\"line\">        Channel channel = connection.createChannel();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> channel;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>2、启动两个工作线程来接受消息</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.oddfar.two;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.oddfar.utils.RabbitMqUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.rabbitmq.client.CancelCallback;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.rabbitmq.client.Channel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 这是一个工作线程，相当于之前的消费者</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> zhiyuan</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Worker01</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String QUEUE_NAME = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//消息接受</span></span><br><span class=\"line\">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class=\"line\">            String receivedMessage = <span class=\"keyword\">new</span> String(delivery.getBody());</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;接收到消息:&quot;</span> + receivedMessage);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"comment\">//消息被取消</span></span><br><span class=\"line\">        CancelCallback cancelCallback = (consumerTag) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(consumerTag + <span class=\"string\">&quot;消费者取消消费接口回调逻辑&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;C1 消费者启动等待消费.................. &quot;</span>);</span><br><span class=\"line\">        channel.basicConsume(QUEUE_NAME, <span class=\"keyword\">true</span>, deliverCallback, cancelCallback);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>选中 <code>Allow multiple instances</code><br><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210627125840217.png\" alt=\"image-20210627125840217\"></p>\n<p>启动后</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210627130146584.png\" alt=\"image-20210627130146584\"></p>\n<p><strong>3、启动一个发送消息线程</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Task01</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String QUEUE_NAME = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">        Scanner scanner = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (scanner.hasNext()) &#123;</span><br><span class=\"line\">            String message = scanner.next();</span><br><span class=\"line\">            channel.basicPublish(<span class=\"string\">&quot;&quot;</span>, QUEUE_NAME, <span class=\"keyword\">null</span>, message.getBytes());</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;消息发送完成：&quot;</span> + message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li><strong>结果展示</strong></li>\n</ul>\n<p>通过程序执行发现生产者总共发送 4 个消息，消费者 1 和消费者 2 分别分得两个消息，并且是按照有序的一个接收一次消息</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000016.png\" alt=\"RabbitMQ-00000016\"></p>\n<h2 id=\"消息应答\"><a href=\"#消息应答\" class=\"headerlink\" title=\"消息应答\"></a>消息应答</h2><p>消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成了部分突然它挂掉了，会发生什么情况。RabbitMQ 一旦向消费者传递了一条消息，便立即将该消息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息。以及后续发送给该消费这的消息，因为它无法接收到。</p>\n<p>为了保证消息在发送过程中不丢失，引入消息应答机制，消息应答就是：<strong>消费者在接收到消息并且处理该消息之后，告诉 rabbitmq 它已经处理了，rabbitmq 可以把该消息删除了。</strong> </p>\n<h3 id=\"自动应答\"><a href=\"#自动应答\" class=\"headerlink\" title=\"自动应答\"></a>自动应答</h3><p>消息发送后立即被认为已经传送成功，这种模式需要在<strong>高吞吐量和数据传输安全性方面做权衡</strong>,因为这种模式如果消息在接收到之前，消费者那边出现连接或者 channel 关闭，那么消息就丢失 了,当然另一方面这种模式消费者那边可以传递过载的消息，<strong>没有对传递的消息数量进行限制</strong>，当然这样有可能使得消费者这边由于接收太多还来不及处理的消息，导致这些消息的积压，最终使 得内存耗尽，最终这些消费者线程被操作系统杀死，<strong>所以这种模式仅适用在消费者可以高效并以 某种速率能够处理这些消息的情况下使用。</strong></p>\n<h3 id=\"手动消息应答的方法\"><a href=\"#手动消息应答的方法\" class=\"headerlink\" title=\"手动消息应答的方法\"></a>手动消息应答的方法</h3><ul>\n<li><p>Channel.basicAck(用于肯定确认)</p>\n<p>RabbitMQ 已知道该消息并且成功的处理消息，可以将其丢弃了 </p>\n</li>\n<li><p>Channel.basicNack(用于否定确认) </p>\n</li>\n<li><p>Channel.basicReject(用于否定确认)</p>\n<p>与 Channel.basicNack 相比少一个参数，不处理该消息了直接拒绝，可以将其丢弃了</p>\n</li>\n</ul>\n<p><strong>Multiple 的解释：</strong></p>\n<p>手动应答的好处是可以批量应答并且减少网络拥堵 </p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000017.png\" alt=\"RabbitMQ-00000017\"></p>\n<ul>\n<li><p>true 代表批量应答 channel 上未应答的消息</p>\n<p>比如说 channel 上有传送 tag 的消息 5,6,7,8 当前 tag 是8 那么此时5-8 的这些还未应答的消息都会被确认收到消息应答</p>\n</li>\n<li><p>false 同上面相比只会应答 tag=8 的消息 5,6,7 这三个消息依然不会被确认收到消息应答</p>\n</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000018.png\" alt=\"RabbitMQ-00000018\"></p>\n<h3 id=\"消息自动重新入队\"><a href=\"#消息自动重新入队\" class=\"headerlink\" title=\"消息自动重新入队\"></a>消息自动重新入队</h3><p>如果消费者由于某些原因失去连接(其通道已关闭，连接已关闭或 TCP 连接丢失)，导致消息未发送 ACK 确认，RabbitMQ 将了解到消息未完全处理，并将对其重新排队。如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确保不会丢失任何消息。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000019.png\" alt=\"RabbitMQ-00000019\"></p>\n<h3 id=\"消息手动应答代码\"><a href=\"#消息手动应答代码\" class=\"headerlink\" title=\"消息手动应答代码\"></a>消息手动应答代码</h3><p>默认消息采用的是自动应答，所以我们要想实现消息消费过程中不丢失，需要把自动应答改为手动应答</p>\n<p>消费者在上面代码的基础上增加了以下内容</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class=\"keyword\">false</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>消息生产者：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.oddfar.three;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.oddfar.utils.RabbitMqUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.rabbitmq.client.Channel;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 消息生产者,消息在手动应答时是不丢失的，放回队列重新消费</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> zhiyuan</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Task02</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TASK_QUEUE_NAME = <span class=\"string\">&quot;ack_queue&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\">        <span class=\"comment\">//声明队列</span></span><br><span class=\"line\">        channel.queueDeclare(TASK_QUEUE_NAME, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        Scanner sc = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;请输入信息&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (sc.hasNext()) &#123;</span><br><span class=\"line\">            String message = sc.nextLine();</span><br><span class=\"line\">            <span class=\"comment\">//发布消息</span></span><br><span class=\"line\">            channel.basicPublish(<span class=\"string\">&quot;&quot;</span>, TASK_QUEUE_NAME, <span class=\"keyword\">null</span>, message.getBytes(<span class=\"string\">&quot;UTF-8&quot;</span>));</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;生产者发出消息&quot;</span> + message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>消费者 01：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.oddfar.three;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.oddfar.utils.RabbitMqUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.rabbitmq.client.CancelCallback;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.rabbitmq.client.Channel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 消费者01</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> zhiyuan</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Work03</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TASK_QUEUE_NAME = <span class=\"string\">&quot;ack_queue&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;C1 等待接收消息处理时间较 短&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class=\"line\">            String message = <span class=\"keyword\">new</span> String(delivery.getBody());</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;接收到消息:&quot;</span> + message);</span><br><span class=\"line\">            <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">             * 1.消息标记 tag</span></span><br><span class=\"line\"><span class=\"comment\">             * 2.是否批量应答未应答消息</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        CancelCallback cancelCallback = (s) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(s + <span class=\"string\">&quot;消费者取消消费接口回调逻辑&quot;</span>);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//采用手动应答</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> autoAck = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        channel.basicConsume(TASK_QUEUE_NAME, autoAck, deliverCallback, cancelCallback);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>消费者 02：</strong></p>\n<p>​    把时间改成30秒</p>\n<p>::: tip 手动应答效果演示</p>\n<p>:::</p>\n<p>正常情况下消息发送方发送两个消息 C1 和 C2 分别接收到消息并进行处理</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000021.png\" alt=\"RabbitMQ-00000021\"></p>\n<p>在发送者发送消息 dd，发出消息之后的把 C2 消费者停掉，按理说该 C2 来处理该消息，但是由于它处理时间较长，在还未处理完，也就是说 C2 还没有执行 ack 代码的时候，C2 被停掉了， 此时会看到消息被 C1 接收到了，说明消息 dd 被重新入队，然后分配给能处理消息的 C1 处理了</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000022.png\" alt=\"RabbitMQ-00000022\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000023.png\" alt=\"RabbitMQ-00000023\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000024.png\" alt=\"RabbitMQ-00000024\"></p>\n<h2 id=\"RabbitMQ-持久化\"><a href=\"#RabbitMQ-持久化\" class=\"headerlink\" title=\"RabbitMQ 持久化\"></a>RabbitMQ 持久化</h2><p>当 RabbitMQ 服务停掉以后，消息生产者发送过来的消息不丢失要如何保障？默认情况下 RabbitMQ 退出或由于某种原因崩溃时，它忽视队列和消息，除非告知它不要这样做。确保消息不会丢失需要做两件事：<strong>我们需要将队列和消息都标记为持久化。</strong></p>\n<p>::: tip 队列如何实现持久化</p>\n<p>:::</p>\n<p>之前我们创建的队列都是非持久化的，rabbitmq 如果重启的化，该队列就会被删除掉，如果要队列实现持久化需要在声明队列的时候把 durable 参数设置为持久化</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//让队列持久化</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> durable = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"><span class=\"comment\">//声明队列</span></span><br><span class=\"line\">channel.queueDeclare(TASK_QUEUE_NAME, durable, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>注意：如果之前声明的队列不是持久化的，需要把原先队列先删除，或者重新创建一个持久化的队列，不然就会出现错误</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000026.png\" alt=\"RabbitMQ-00000026\"></p>\n<p>以下为控制台中持久化与非持久化队列的 UI 显示区、</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000027.png\" alt=\"RabbitMQ-00000027\"></p>\n<p>::: tip 消息实现持久化</p>\n<p>:::</p>\n<p>需要在消息<strong>生产者</strong>修改代码，<code>MessageProperties.PERSISTENT_TEXT_PLAIN</code> 添加这个属性。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000028.png\" alt=\"RabbitMQ-00000028\"></p>\n<p>将消息标记为持久化并不能完全保证不会丢失消息。尽管它告诉 RabbitMQ 将消息保存到磁盘，但是这里依然存在当消息刚准备存储在磁盘的时候 但是还没有存储完，消息还在缓存的一个间隔点。此时并没 有真正写入磁盘。持久性保证并不强，但是对于我们的简单任务队列而言，这已经绰绰有余了。</p>\n<p>如果需要更强有力的持久化策略，参考后边课件发布确认章节。</p>\n<h2 id=\"不公平分发\"><a href=\"#不公平分发\" class=\"headerlink\" title=\"不公平分发\"></a>不公平分发</h2><p>在最开始的时候我们学习到 RabbitMQ 分发消息采用的轮训分发，但是在某种场景下这种策略并不是很好，比方说有两个消费者在处理任务，其中有个<strong>消费者 1</strong> 处理任务的速度非常快，而另外一个<strong>消费者 2</strong> 处理速度却很慢，这个时候我们还是采用轮训分发的化就会到这处理速度快的这个消费者很大一部分时间处于空闲状态，而处理慢的那个消费者一直在干活，这种分配方式在这种情况下其实就不太好，但是 RabbitMQ 并不知道这种情况它依然很公平的进行分发。</p>\n<p>为了避免这种情况，<strong>在消费者中消费之前</strong>，我们可以设置参数 <code>channel.basicQos(1);</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//不公平分发</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> prefetchCount = <span class=\"number\">1</span>;</span><br><span class=\"line\">channel.basicQos(prefetchCount);</span><br><span class=\"line\"><span class=\"comment\">//采用手动应答</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> autoAck = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">channel.basicConsume(TASK_QUEUE_NAME, autoAck, deliverCallback, cancelCallback);</span><br></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000030.png\" alt=\"RabbitMQ-00000030\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000031.png\" alt=\"RabbitMQ-00000031\"></p>\n<p>意思就是如果这个任务我还没有处理完或者我还没有应答你，你先别分配给我，我目前只能处理一个 任务，然后 rabbitmq 就会把该任务分配给没有那么忙的那个空闲消费者，当然如果所有的消费者都没有完 成手上任务，队列还在不停的添加新任务，队列有可能就会遇到队列被撑满的情况，这个时候就只能添加 新的 worker 或者改变其他存储任务的策略。</p>\n<h2 id=\"预取值分发\"><a href=\"#预取值分发\" class=\"headerlink\" title=\"预取值分发\"></a>预取值分发</h2><p>带权的消息分发</p>\n<p>本身消息的发送就是异步发送的，所以在任何时候，channel 上肯定不止只有一个消息另外来自消费 者的手动确认本质上也是异步的。因此这里就存在一个未确认的消息缓冲区，因此希望开发人员能<strong>限制此缓冲区的大小</strong>，<strong>以避免缓冲区里面无限制的未确认消息问题</strong>。这个时候就可以通过使用 basic.qos 方法设 置“预取计数”值来完成的。</p>\n<p>该值定义通道上允许的未确认消息的最大数量。一旦数量达到配置的数量， RabbitMQ 将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认，例如，假设在通道上有未确认的消息 5、6、7，8，并且通道的预取计数设置为 4，此时RabbitMQ 将不会在该通道上再传递任何消息，除非至少有一个未应答的消息被 ack。比方说 tag=6 这个消息刚刚被确认 ACK，RabbitMQ 将会感知 这个情况到并再发送一条消息。消息应答和 QoS 预取值对用户吞吐量有重大影响。</p>\n<p>通常，增加预取将提高 向消费者传递消息的速度。<strong>虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理的消息的数量也会增加，从而增加了消费者的 RAM 消耗</strong>(随机存取存储器)应该小心使用具有无限预处理的自动确认模式或手动确认模式，消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的 内存消耗变大，所以找到合适的预取值是一个反复试验的过程，不同的负载该值取值也不同 100 到 300 范 围内的值通常可提供最佳的吞吐量，并且不会给消费者带来太大的风险。</p>\n<p>预取值为 1 是最保守的。当然这将使吞吐量变得很低，特别是消费者连接延迟很严重的情况下，特别是在消费者连接等待时间较长的环境 中。对于大多数应用来说，稍微高一点的值将是最佳的。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000032.png\" alt=\"RabbitMQ-00000032\"></p>\n<h1 id=\"发布确认\"><a href=\"#发布确认\" class=\"headerlink\" title=\"发布确认\"></a>发布确认</h1><h2 id=\"发布确认原理\"><a href=\"#发布确认原理\" class=\"headerlink\" title=\"发布确认原理\"></a>发布确认原理</h2><p>生产者将信道设置成 confirm 模式，一旦信道进入 confirm 模式，所有在该信道上面发布的消息都将会被指派一个唯一的 ID(从 1 开始)，一旦消息被投递到所有匹配的队列之后，broker 就会发送一个确认给生产者(包含消息的唯一 ID)，这就使得生产者知道消息已经正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker 回传给生产者的确认消息中 delivery-tag 域包含了确认消息的序列号，此外 broker 也可以设置basic.ack 的 multiple 域，表示到这个序列号之前的所有消息都已经得到了处理。</p>\n<p>confirm 模式最大的好处在于他是异步的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消息， 生产者应用程序同样可以在回调方法中处理该 nack 消息。</p>\n<h2 id=\"发布确认的策略\"><a href=\"#发布确认的策略\" class=\"headerlink\" title=\"发布确认的策略\"></a>发布确认的策略</h2><p>开启发布确认的方法:</p>\n<p>发布确认默认是没有开启的，如果要开启需要调用方法 confirmSelect，每当你要想使用发布确认，都需要在 channel 上调用该方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//开启发布确认</span></span><br><span class=\"line\">channel.confirmSelect();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"单个确认发布\"><a href=\"#单个确认发布\" class=\"headerlink\" title=\"单个确认发布\"></a>单个确认发布</h3><p>这是一种简单的确认方式，它是一种<strong>同步确认发布</strong>的方式，也就是发布一个消息之后只有它被确认发布，后续的消息才能继续发布，<code>waitForConfirmsOrDie(long)</code> 这个方法只有在消息被确认的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。</p>\n<p>这种确认方式有一个最大的缺点就是：<strong>发布速度特别的慢</strong>，因为如果没有确认发布的消息就会阻塞所有后续消息的发布，这种方式最多提供每秒不超过数百条发布消息的吞吐量。当然对于某些应用程序来说这可能已经足够了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 单个发送</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">publishMessageIndividually</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\">    <span class=\"comment\">//队列声明</span></span><br><span class=\"line\">    String queueName = UUID.randomUUID().toString();</span><br><span class=\"line\">    channel.queueDeclare(queueName, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    <span class=\"comment\">//开启发布确认</span></span><br><span class=\"line\">    channel.confirmSelect();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">long</span> begin = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class=\"line\">        String message = i + <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        channel.basicPublish(<span class=\"string\">&quot;&quot;</span>, queueName, <span class=\"keyword\">null</span>, message.getBytes());</span><br><span class=\"line\">        <span class=\"comment\">//服务端返回 false 或超时时间内未返回，生产者可以消息重发</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> flag = channel.waitForConfirms();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (flag) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;消息发送成功&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">long</span> end = System.currentTimeMillis();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;发布&quot;</span> + MESSAGE_COUNT + <span class=\"string\">&quot;个单独确认消息,耗时&quot;</span> + (end - begin) + <span class=\"string\">&quot;ms&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"批量确认发布\"><a href=\"#批量确认发布\" class=\"headerlink\" title=\"批量确认发布\"></a>批量确认发布</h3><p>上面那种方式非常慢，与单个等待确认消息相比，先发布一批消息然后一起确认可以极大地提高吞吐量，当然这种方式的缺点就是：当发生故障导致发布出现问题时，不知道是哪个消息出 问题了，我们必须将整个批处理保存在内存中，以记录重要的信息而后重新发布消息。当然这种方案仍然是同步的，也一样阻塞消息的发布。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 批量</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">publishMessageBatch</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\">    <span class=\"comment\">//队列声明</span></span><br><span class=\"line\">    String queueName = UUID.randomUUID().toString();</span><br><span class=\"line\">    channel.queueDeclare(queueName, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    <span class=\"comment\">//开启发布确认</span></span><br><span class=\"line\">    channel.confirmSelect();</span><br><span class=\"line\">    <span class=\"comment\">//批量确认消息大小</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> batchSize = <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"comment\">//未确认消息个数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> outstandingMessageCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> begin = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class=\"line\">        String message = i + <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        channel.basicPublish(<span class=\"string\">&quot;&quot;</span>, queueName, <span class=\"keyword\">null</span>, message.getBytes());</span><br><span class=\"line\">        outstandingMessageCount++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (outstandingMessageCount == batchSize) &#123;</span><br><span class=\"line\">            channel.waitForConfirms();</span><br><span class=\"line\">            outstandingMessageCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//为了确保还有剩余没有确认消息 再次确认</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (outstandingMessageCount &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        channel.waitForConfirms();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> end = System.currentTimeMillis();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;发布&quot;</span> + MESSAGE_COUNT + <span class=\"string\">&quot;个批量确认消息,耗时&quot;</span> + (end - begin) + <span class=\"string\">&quot;ms&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"异步确认发布\"><a href=\"#异步确认发布\" class=\"headerlink\" title=\"异步确认发布\"></a>异步确认发布</h3><p>异步确认虽然编程逻辑比上两个要复杂，但是性价比最高，无论是可靠性还是效率都没得说， 他是利用回调函数来达到消息可靠性传递的，这个中间件也是通过函数回调来保证是否投递成功， 下面就让我们来详细讲解异步确认是怎么实现的。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000034.png\" alt=\"RabbitMQ-00000034\"></p>\n<p>如何处理异步未确认消息?</p>\n<p>最好的解决的解决方案就是把未确认的消息放到一个基于内存的能被发布线程访问的队列， 比如说用 ConcurrentLinkedQueue 这个队列在 confirm callbacks 与发布线程之间进行消息的传递。</p>\n<p><strong>以上 3 种发布确认速度对比 :</strong></p>\n<ul>\n<li><p>单独发布消息</p>\n<p>同步等待确认，简单，但吞吐量非常有限。</p>\n</li>\n<li><p>批量发布消息</p>\n<p>批量同步等待确认，简单，合理的吞吐量，一旦出现问题但很难推断出是那条消息出现了问题。</p>\n</li>\n<li><p>异步处理</p>\n<p>最佳性能和资源使用，在出现错误的情况下可以很好地控制，但是实现起来稍微难些</p>\n</li>\n</ul>\n<h1 id=\"交换机\"><a href=\"#交换机\" class=\"headerlink\" title=\"交换机\"></a>交换机</h1><h2 id=\"Exchanges\"><a href=\"#Exchanges\" class=\"headerlink\" title=\"Exchanges\"></a>Exchanges</h2><p>RabbitMQ 消息传递模型的核心思想是: <strong>生产者生产的消息从不会直接发送到队列</strong>。实际上，通常生产者甚至都不知道这些消息传递传递到了哪些队列中。</p>\n<p>相反，**生产者只能将消息发送到交换机(exchange)**，交换机工作的内容非常简单，一方面它接收来自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息。是应该把这些消息放到特定队列还是说把他们到许多队列中还是说应该丢弃它们。这就的由交换机的类型来决定。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000035.png\" alt=\"RabbitMQ-00000035\"></p>\n<p><strong>Exchanges 的类型：</strong></p>\n<p>​    直接(direct), 主题(topic) ,标题(headers) , 扇出(fanout)</p>\n<p><strong>无名exchange：</strong></p>\n<p>​    在前面部分我们对 exchange 一无所知，但仍然能够将消息发送到队列。之前能实现的 原因是因为我们使用的是默认交换，我们通过空字符串(“”)进行标识。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000036.png\" alt=\"RabbitMQ-00000036\"></p>\n<p>第一个参数是交换机的名称。空字符串表示默认或无名称交换机：消息能路由发送到队列中其实是由 routingKey(bindingkey)绑定 key 指定的，如果它存在的话</p>\n<h2 id=\"临时队列\"><a href=\"#临时队列\" class=\"headerlink\" title=\"临时队列\"></a>临时队列</h2><p>之前的章节我们使用的是具有特定名称的队列(还记得 hello 和 ack_queue 吗？)。队列的名称我们来说至关重要，我们需要指定我们的消费者去消费哪个队列的消息。</p>\n<p>每当我们连接到 Rabbit 时，我们都需要一个全新的空队列，为此我们可以创建一个具有<strong>随机名称的队列</strong>，或者能让服务器为我们选择一个随机队列名称那就更好了。其次一旦我们断开了消费者的连接，队列将被自动删除。</p>\n<p>创建临时队列的方式如下: </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">String queueName = channel.queueDeclare().getQueue();</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000037.png\" alt=\"RabbitMQ-00000037\"></p>\n<h2 id=\"绑定-bindings\"><a href=\"#绑定-bindings\" class=\"headerlink\" title=\"绑定 bindings\"></a>绑定 bindings</h2><p>什么是 bingding 呢，binding 其实是 exchange 和 queue 之间的桥梁，它告诉我们 exchange 和那个队列进行了绑定关系。比如说下面这张图告诉我们的就是 X 与 Q1 和 Q2 进行了绑定</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000038.png\" alt=\"RabbitMQ-00000038\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210627203918539.png\" alt=\"image-20210627203918539\"></p>\n<h2 id=\"Fanout-exchange\"><a href=\"#Fanout-exchange\" class=\"headerlink\" title=\"Fanout exchange\"></a>Fanout exchange</h2><h3 id=\"Fanout-介绍\"><a href=\"#Fanout-介绍\" class=\"headerlink\" title=\"Fanout 介绍\"></a>Fanout 介绍</h3><p>Fanout 这种类型非常简单。正如从名称中猜到的那样，它是将接收到的所有消息广播到它知道的 所有队列中。系统中默认有些 exchange 类型</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000039.png\" alt=\"RabbitMQ-00000039\"></p>\n<h3 id=\"Fanout-实战\"><a href=\"#Fanout-实战\" class=\"headerlink\" title=\"Fanout 实战\"></a>Fanout 实战</h3><p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000040.png\" alt=\"RabbitMQ-00000040\"></p>\n<p>Logs 和临时队列的绑定关系如下图</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000041.png\" alt=\"RabbitMQ-00000041\"></p>\n<p>为了说明这种模式，我们将构建一个简单的日志系统。它将由两个程序组成:第一个程序将发出日志消 息，第二个程序是消费者。其中我们会启动两个消费者，其中一个消费者接收到消息后把日志存储在磁盘，</p>\n<p>ReceiveLogs01 将接收到的消息打印在控制台</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.oddfar.five;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.oddfar.utils.RabbitMqUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.rabbitmq.client.Channel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> zhiyuan</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReceiveLogs01</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String EXCHANGE_NAME = <span class=\"string\">&quot;logs&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\">        channel.exchangeDeclare(EXCHANGE_NAME, <span class=\"string\">&quot;fanout&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 生成一个临时的队列 队列的名称是随机的</span></span><br><span class=\"line\"><span class=\"comment\">         * 当消费者断开和该队列的连接时 队列自动删除</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        String queueName = channel.queueDeclare().getQueue();</span><br><span class=\"line\">        <span class=\"comment\">//把该临时队列绑定我们的 exchange 其中 routingkey(也称之为 binding key)为空字符串</span></span><br><span class=\"line\">        channel.queueBind(queueName, EXCHANGE_NAME, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;等待接收消息,把接收到的消息打印在屏幕........... &quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//发送回调</span></span><br><span class=\"line\">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class=\"line\">            String message = <span class=\"keyword\">new</span> String(delivery.getBody(), <span class=\"string\">&quot;UTF-8&quot;</span>);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;控制台打印接收到的消息&quot;</span> + message);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        channel.basicConsume(queueName, <span class=\"keyword\">true</span>, deliverCallback, consumerTag -&gt; &#123;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ReceiveLogs02 把消息写出到文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReceiveLogs02</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String EXCHANGE_NAME = <span class=\"string\">&quot;logs&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\">        channel.exchangeDeclare(EXCHANGE_NAME, <span class=\"string\">&quot;fanout&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 生成一个临时的队列 队列的名称是随机的</span></span><br><span class=\"line\"><span class=\"comment\">         * 当消费者断开和该队列的连接时 队列自动删除</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        String queueName = channel.queueDeclare().getQueue();</span><br><span class=\"line\">        <span class=\"comment\">//把该临时队列绑定我们的 exchange 其中 routingkey(也称之为 binding key)为空字符串</span></span><br><span class=\"line\">        channel.queueBind(queueName, EXCHANGE_NAME, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;等待接收消息,把接收到的消息写到文件........... &quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//发送回调</span></span><br><span class=\"line\">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class=\"line\">            String message = <span class=\"keyword\">new</span> String(delivery.getBody(), <span class=\"string\">&quot;UTF-8&quot;</span>);</span><br><span class=\"line\">            File file = <span class=\"keyword\">new</span> File(<span class=\"string\">&quot;D:\\\\test\\\\rabbitmq_info.txt&quot;</span>);</span><br><span class=\"line\">            FileUtils.writeStringToFile(file,message,<span class=\"string\">&quot;UTF-8&quot;</span>);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;数据写入文件成功&quot;</span>);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        channel.basicConsume(queueName, <span class=\"keyword\">true</span>, deliverCallback, consumerTag -&gt; &#123;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p>EmitLog 发送消息给两个消费者接收：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EmitLog</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String EXCHANGE_NAME = <span class=\"string\">&quot;logs&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 声明一个 exchange</span></span><br><span class=\"line\"><span class=\"comment\">         * 1.exchange 的名称</span></span><br><span class=\"line\"><span class=\"comment\">         * 2.exchange 的类型</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        channel.exchangeDeclare(EXCHANGE_NAME, <span class=\"string\">&quot;fanout&quot;</span>);</span><br><span class=\"line\">        Scanner sc = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;请输入信息&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (sc.hasNext()) &#123;</span><br><span class=\"line\">            String message = sc.nextLine();</span><br><span class=\"line\">            channel.basicPublish(EXCHANGE_NAME, <span class=\"string\">&quot;&quot;</span>, <span class=\"keyword\">null</span>, message.getBytes(<span class=\"string\">&quot;UTF-8&quot;</span>));</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;生产者发出消息&quot;</span> + message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Direct-exchange\"><a href=\"#Direct-exchange\" class=\"headerlink\" title=\"Direct exchange\"></a>Direct exchange</h2><p>在上一节中，我们构建了一个简单的日志记录系统。我们能够向许多接收者广播日志消息。在本节我们将向其中添加一些特别的功能——让某个消费者订阅发布的部分消息。例如我们只把严重错误消息定向存储到日志文件(以节省磁盘空间)，同时仍然能够在控制台上打印所有日志消息。</p>\n<p>我们再次来回顾一下什么是 bindings，绑定是交换机和队列之间的桥梁关系。也可以这么理解： <strong>队列只对它绑定的交换机的消息感兴趣</strong>。绑定用参数：routingKey 来表示也可称该参数为 binding key， 创建绑定我们用代码:channel.queueBind(queueName, EXCHANGE_NAME, “routingKey”);</p>\n<p>绑定之后的意义由其交换类型决定。</p>\n<h3 id=\"Direct-介绍\"><a href=\"#Direct-介绍\" class=\"headerlink\" title=\"Direct 介绍\"></a>Direct 介绍</h3><p>上一节中的我们的日志系统将所有消息广播给所有消费者，对此我们想做一些改变，例如我们希 望将日志消息写入磁盘的程序仅接收严重错误(errros)，而不存储哪些警告(warning)或信息(info)日志 消息避免浪费磁盘空间。Fanout 这种交换类型并不能给我们带来很大的灵活性-它只能进行无意识的 广播，在这里我们将使用 direct 这种类型来进行替换，这种类型的工作方式是，消息只去到它绑定的 routingKey 队列中去。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000042.png\" alt=\"RabbitMQ-00000042\"></p>\n<p>在上面这张图中，我们可以看到 X 绑定了两个队列，绑定类型是 direct。队列Q1 绑定键为 orange， 队列 Q2 绑定键有两个:一个绑定键为 black，另一个绑定键为 green.</p>\n<p>在这种绑定情况下，生产者发布消息到 exchange 上，绑定键为 orange 的消息会被发布到队列 Q1。绑定键为 blackgreen 和的消息会被发布到队列 Q2，其他消息类型的消息将被丢弃。</p>\n<h3 id=\"多重绑定\"><a href=\"#多重绑定\" class=\"headerlink\" title=\"多重绑定\"></a>多重绑定</h3><p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000043.png\" alt=\"RabbitMQ-00000043\"></p>\n<p>当然如果 exchange 的绑定类型是direct，<strong>但是它绑定的多个队列的 key 如果都相同</strong>，在这种情况下虽然绑定类型是 direct <strong>但是它表现的就和 fanout 有点类似了</strong>，就跟广播差不多，如上图所示。</p>\n<h3 id=\"Direct-实战\"><a href=\"#Direct-实战\" class=\"headerlink\" title=\"Direct 实战\"></a>Direct 实战</h3><p>关系：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000044.png\" alt=\"RabbitMQ-00000044\"></p>\n<p>交换机：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000045.png\" alt=\"RabbitMQ-00000045\"></p>\n<p>c2：绑定disk，routingKey为error</p>\n<p>c1：绑定console，routingKey为info、warning</p>\n<p>1、</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.oddfar.six;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.oddfar.utils.RabbitMqUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.rabbitmq.client.BuiltinExchangeType;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.rabbitmq.client.Channel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> zhiyuan</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReceiveLogsDirect01</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String EXCHANGE_NAME = <span class=\"string\">&quot;direct_logs&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class=\"line\"></span><br><span class=\"line\">        String queueName = <span class=\"string\">&quot;disk&quot;</span>;</span><br><span class=\"line\">        <span class=\"comment\">//队列声明</span></span><br><span class=\"line\">        channel.queueDeclare(queueName, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">//队列绑定</span></span><br><span class=\"line\">        channel.queueBind(queueName, EXCHANGE_NAME, <span class=\"string\">&quot;error&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;等待接收消息...&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//发送回调</span></span><br><span class=\"line\">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class=\"line\">            String message = <span class=\"keyword\">new</span> String(delivery.getBody(), <span class=\"string\">&quot;UTF-8&quot;</span>);</span><br><span class=\"line\">            message = <span class=\"string\">&quot;接收绑定键:&quot;</span> + delivery.getEnvelope().getRoutingKey() + <span class=\"string\">&quot;,消息:&quot;</span> + message;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;error 消息已经接收：\\n&quot;</span> + message);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        channel.basicConsume(queueName, <span class=\"keyword\">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2、</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReceiveLogsDirect02</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String EXCHANGE_NAME = <span class=\"string\">&quot;direct_logs&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class=\"line\"></span><br><span class=\"line\">        String queueName = <span class=\"string\">&quot;console&quot;</span>;</span><br><span class=\"line\">        <span class=\"comment\">//队列声明</span></span><br><span class=\"line\">        channel.queueDeclare(queueName, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">//队列绑定</span></span><br><span class=\"line\">        channel.queueBind(queueName, EXCHANGE_NAME, <span class=\"string\">&quot;info&quot;</span>);</span><br><span class=\"line\">        channel.queueBind(queueName, EXCHANGE_NAME, <span class=\"string\">&quot;warning&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;等待接收消息...&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//发送回调</span></span><br><span class=\"line\">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class=\"line\">            String message = <span class=\"keyword\">new</span> String(delivery.getBody(), <span class=\"string\">&quot;UTF-8&quot;</span>);</span><br><span class=\"line\">            message = <span class=\"string\">&quot;接收绑定键:&quot;</span> + delivery.getEnvelope().getRoutingKey() + <span class=\"string\">&quot;,消息:&quot;</span> + message;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;info和warning 消息已经接收：\\n&quot;</span> + message);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        channel.basicConsume(queueName, <span class=\"keyword\">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3、</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EmitLogDirect</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String EXCHANGE_NAME = <span class=\"string\">&quot;direct_logs&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//创建多个 bindingKey</span></span><br><span class=\"line\">        Map&lt;String, String&gt; bindingKeyMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        bindingKeyMap.put(<span class=\"string\">&quot;info&quot;</span>, <span class=\"string\">&quot;普通 info 信息&quot;</span>);</span><br><span class=\"line\">        bindingKeyMap.put(<span class=\"string\">&quot;warning&quot;</span>, <span class=\"string\">&quot;警告 warning 信息&quot;</span>);</span><br><span class=\"line\">        bindingKeyMap.put(<span class=\"string\">&quot;error&quot;</span>, <span class=\"string\">&quot;错误 error 信息&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//debug 没有消费这接收这个消息 所有就丢失了</span></span><br><span class=\"line\">        bindingKeyMap.put(<span class=\"string\">&quot;debug&quot;</span>, <span class=\"string\">&quot;调试 debug 信息&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Map.Entry&lt;String, String&gt; bindingKeyEntry : bindingKeyMap.entrySet()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//获取 key value</span></span><br><span class=\"line\">            String bindingKey = bindingKeyEntry.getKey();</span><br><span class=\"line\">            String message = bindingKeyEntry.getValue();</span><br><span class=\"line\"></span><br><span class=\"line\">            channel.basicPublish(EXCHANGE_NAME, bindingKey, <span class=\"keyword\">null</span>, message.getBytes(<span class=\"string\">&quot;UTF-8&quot;</span>));</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;生产者发出消息:&quot;</span> + message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Topics-exchange\"><a href=\"#Topics-exchange\" class=\"headerlink\" title=\"Topics exchange\"></a>Topics exchange</h2><h3 id=\"Topic-的介绍\"><a href=\"#Topic-的介绍\" class=\"headerlink\" title=\"Topic 的介绍\"></a>Topic 的介绍</h3><p>在上一个小节中，我们改进了日志记录系统。我们没有使用只能进行随意广播的 fanout 交换机，而是使用了 direct 交换机，从而有能实现有选择性地接收日志。</p>\n<p>尽管使用 direct 交换机改进了我们的系统，但是它仍然存在局限性——比方说我们想接收的日志类型有 info.base 和 info.advantage，某个队列只想 info.base 的消息，那这个时候direct 就办不到了。这个时候就只能使用 <strong>topic</strong> 类型</p>\n<p>::: tip Topic的要求</p>\n<p>:::</p>\n<p>发送到类型是 topic 交换机的消息的 routing_key 不能随意写，必须满足一定的要求，它必须是<strong>一个单词列表</strong>，<strong>以点号分隔开</strong>。这些单词可以是任意单词</p>\n<p>比如说：”stock.usd.nyse”, “nyse.vmw”, “quick.orange.rabbit”.这种类型的。</p>\n<p>当然这个单词列表最多不能超过 255 个字节。</p>\n<p>在这个规则列表中，其中有两个替换符是大家需要注意的：</p>\n<ul>\n<li>***(星号)可以代替一个单词**</li>\n<li><strong>#(井号)可以替代零个或多个单词</strong></li>\n</ul>\n<h3 id=\"Topic-匹配案例\"><a href=\"#Topic-匹配案例\" class=\"headerlink\" title=\"Topic 匹配案例\"></a>Topic 匹配案例</h3><p>下图绑定关系如下</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000046.png\" alt=\"RabbitMQ-00000046\"></p>\n<ul>\n<li><p>Q1–&gt;绑定的是</p>\n<ul>\n<li>中间带 orange 带 3 个单词的字符串 <code>(*.orange.*)</code></li>\n</ul>\n</li>\n<li><p>Q2–&gt;绑定的是</p>\n<ul>\n<li>最后一个单词是 rabbit 的 3 个单词 <code>(*.*.rabbit)</code></li>\n<li>第一个单词是 lazy 的多个单词 <code>(lazy.#)</code></li>\n</ul>\n</li>\n</ul>\n<p>上图是一个队列绑定关系图，我们来看看他们之间数据接收情况是怎么样的</p>\n<table>\n<thead>\n<tr>\n<th>例子</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>quick.orange.rabbit</td>\n<td>被队列 Q1Q2 接收到</td>\n</tr>\n<tr>\n<td>azy.orange.elephant</td>\n<td>被队列 Q1Q2 接收到</td>\n</tr>\n<tr>\n<td>quick.orange.fox</td>\n<td>被队列 Q1 接收到</td>\n</tr>\n<tr>\n<td>lazy.brown.fox</td>\n<td>被队列 Q2 接收到</td>\n</tr>\n<tr>\n<td>lazy.pink.rabbit</td>\n<td>虽然满足两个绑定但只被队列 Q2 接收一次</td>\n</tr>\n<tr>\n<td>quick.brown.fox</td>\n<td>不匹配任何绑定不会被任何队列接收到会被丢弃</td>\n</tr>\n<tr>\n<td>quick.orange.male.rabbit</td>\n<td>是四个单词不匹配任何绑定会被丢弃</td>\n</tr>\n<tr>\n<td>lazy.orange.male.rabbit</td>\n<td>是四个单词但匹配 Q2</td>\n</tr>\n</tbody></table>\n<p>注意：</p>\n<ul>\n<li>当一个队列绑定键是#，那么这个队列将接收所有数据，就有点像 fanout 了</li>\n<li>如果队列绑定键当中没有#和*出现，那么该队列绑定类型就是 direct 了</li>\n</ul>\n<h3 id=\"Topic-实战\"><a href=\"#Topic-实战\" class=\"headerlink\" title=\"Topic 实战\"></a>Topic 实战</h3><p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000047.png\" alt=\"RabbitMQ-00000047\"></p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.oddfar.seven;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.oddfar.utils.RabbitMqUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.rabbitmq.client.BuiltinExchangeType;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.rabbitmq.client.Channel;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 发送端</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> zhiyuan</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EmitLogTopic</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String EXCHANGE_NAME = <span class=\"string\">&quot;topic_logs&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * Q1--&gt;绑定的是</span></span><br><span class=\"line\"><span class=\"comment\">         *      中间带 orange 带 3 个单词的字符串(*.orange.*)</span></span><br><span class=\"line\"><span class=\"comment\">         * Q2--&gt;绑定的是</span></span><br><span class=\"line\"><span class=\"comment\">         *      最后一个单词是 rabbit 的 3 个单词(*.*.rabbit)</span></span><br><span class=\"line\"><span class=\"comment\">         *      第一个单词是 lazy 的多个单词(lazy.#)</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        Map&lt;String, String&gt; bindingKeyMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        bindingKeyMap.put(<span class=\"string\">&quot;quick.orange.rabbit&quot;</span>, <span class=\"string\">&quot;被队列 Q1Q2 接收到&quot;</span>);</span><br><span class=\"line\">        bindingKeyMap.put(<span class=\"string\">&quot;lazy.orange.elephant&quot;</span>, <span class=\"string\">&quot;被队列 Q1Q2 接收到&quot;</span>);</span><br><span class=\"line\">        bindingKeyMap.put(<span class=\"string\">&quot;quick.orange.fox&quot;</span>, <span class=\"string\">&quot;被队列 Q1 接收到&quot;</span>);</span><br><span class=\"line\">        bindingKeyMap.put(<span class=\"string\">&quot;lazy.brown.fox&quot;</span>, <span class=\"string\">&quot;被队列 Q2 接收到&quot;</span>);</span><br><span class=\"line\">        bindingKeyMap.put(<span class=\"string\">&quot;lazy.pink.rabbit&quot;</span>, <span class=\"string\">&quot;虽然满足两个绑定但只被队列 Q2 接收一次&quot;</span>);</span><br><span class=\"line\">        bindingKeyMap.put(<span class=\"string\">&quot;quick.brown.fox&quot;</span>, <span class=\"string\">&quot;不匹配任何绑定不会被任何队列接收到会被丢弃&quot;</span>);</span><br><span class=\"line\">        bindingKeyMap.put(<span class=\"string\">&quot;quick.orange.male.rabbit&quot;</span>, <span class=\"string\">&quot;是四个单词不匹配任何绑定会被丢弃&quot;</span>);</span><br><span class=\"line\">        bindingKeyMap.put(<span class=\"string\">&quot;lazy.orange.male.rabbit&quot;</span>, <span class=\"string\">&quot;是四个单词但匹配 Q2&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Map.Entry&lt;String, String&gt; bindingKeyEntry : bindingKeyMap.entrySet()) &#123;</span><br><span class=\"line\">            String bindingKey = bindingKeyEntry.getKey();</span><br><span class=\"line\">            String message = bindingKeyEntry.getValue();</span><br><span class=\"line\"></span><br><span class=\"line\">            channel.basicPublish(EXCHANGE_NAME, bindingKey, <span class=\"keyword\">null</span>, message.getBytes(<span class=\"string\">&quot;UTF-8&quot;</span>));</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;生产者发出消息：&quot;</span> + message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReceiveLogsTopic01</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String EXCHANGE_NAME = <span class=\"string\">&quot;topic_logs&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);</span><br><span class=\"line\">        <span class=\"comment\">//声明 Q1 队列与绑定关系</span></span><br><span class=\"line\">        String queueName = <span class=\"string\">&quot;Q1&quot;</span>;</span><br><span class=\"line\">        <span class=\"comment\">//声明</span></span><br><span class=\"line\">        channel.queueDeclare(queueName, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">//绑定</span></span><br><span class=\"line\">        channel.queueBind(queueName, EXCHANGE_NAME, <span class=\"string\">&quot;*.orange.*&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;等待接收消息........... &quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class=\"line\">            String message = <span class=\"keyword\">new</span> String(delivery.getBody(), <span class=\"string\">&quot;UTF-8&quot;</span>);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot; 接收队列:&quot;</span> + queueName + <span class=\"string\">&quot; 绑定键:&quot;</span> + delivery.getEnvelope().getRoutingKey() + <span class=\"string\">&quot;,消息:&quot;</span> + message);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        channel.basicConsume(queueName, <span class=\"keyword\">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReceiveLogsTopic02</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String EXCHANGE_NAME = <span class=\"string\">&quot;topic_logs&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);</span><br><span class=\"line\">        <span class=\"comment\">//声明 Q2 队列与绑定关系</span></span><br><span class=\"line\">        String queueName = <span class=\"string\">&quot;Q2&quot;</span>;</span><br><span class=\"line\">        <span class=\"comment\">//声明</span></span><br><span class=\"line\">        channel.queueDeclare(queueName, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">//绑定</span></span><br><span class=\"line\">        channel.queueBind(queueName, EXCHANGE_NAME, <span class=\"string\">&quot;*.*.rabbit&quot;</span>);</span><br><span class=\"line\">        channel.queueBind(queueName, EXCHANGE_NAME, <span class=\"string\">&quot;lazy.#&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;等待接收消息........... &quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class=\"line\">            String message = <span class=\"keyword\">new</span> String(delivery.getBody(), <span class=\"string\">&quot;UTF-8&quot;</span>);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot; 接收队列:&quot;</span> + queueName + <span class=\"string\">&quot; 绑定键:&quot;</span> + delivery.getEnvelope().getRoutingKey() + <span class=\"string\">&quot;,消息:&quot;</span> + message);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        channel.basicConsume(queueName, <span class=\"keyword\">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"死信队列\"><a href=\"#死信队列\" class=\"headerlink\" title=\"死信队列\"></a>死信队列</h1><h2 id=\"死信的概念\"><a href=\"#死信的概念\" class=\"headerlink\" title=\"死信的概念\"></a>死信的概念</h2><p>先从概念解释上搞清楚这个定义，死信，顾名思义就是无法被消费的消息，字面意思可以这样理 解，一般来说，producer 将消息投递到 broker 或者直接到queue 里了，consumer 从 queue 取出消息 进行消费，但某些时候由于特定的原因<strong>导致 queue 中的某些消息无法被消费</strong>，这样的消息如果没有后续的处理，就变成了死信，有死信自然就有了死信队列。</p>\n<p>应用场景：为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息消费发生异常时，将消息投入死信队列中。还有比如说：用户在商城下单成功并点击去支付后在指定时间未支付时自动失效</p>\n<h2 id=\"死信的来源\"><a href=\"#死信的来源\" class=\"headerlink\" title=\"死信的来源\"></a>死信的来源</h2><ul>\n<li><p>消息 TTL 过期</p>\n<p>TTL是Time To Live的缩写, 也就是生存时间</p>\n</li>\n<li><p>队列达到最大长度</p>\n<p>队列满了，无法再添加数据到 mq 中</p>\n</li>\n<li><p>消息被拒绝</p>\n<p>(basic.reject 或 basic.nack) 并且 requeue=false.</p>\n</li>\n</ul>\n<h2 id=\"死信实战\"><a href=\"#死信实战\" class=\"headerlink\" title=\"死信实战\"></a>死信实战</h2><p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000048.png\" alt=\"RabbitMQ-00000048\"></p>\n<h3 id=\"死信之TTl\"><a href=\"#死信之TTl\" class=\"headerlink\" title=\"死信之TTl\"></a>死信之TTl</h3><p>消费者 C1 代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 死信队列 - 消费者01</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> zhiyuan</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Consumer01</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//普通交换机名称</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String NORMAL_EXCHANGE = <span class=\"string\">&quot;normal_exchange&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//死信交换机名称</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String DEAD_EXCHANGE = <span class=\"string\">&quot;dead_exchange&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//声明死信和普通交换机 类型为 direct</span></span><br><span class=\"line\">        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class=\"line\">        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//声明死信队列</span></span><br><span class=\"line\">        String deadQueue = <span class=\"string\">&quot;dead-queue&quot;</span>;</span><br><span class=\"line\">        channel.queueDeclare(deadQueue, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">//死信队列绑定：队列、交换机、路由键（routingKey）</span></span><br><span class=\"line\">        channel.queueBind(deadQueue, DEAD_EXCHANGE, <span class=\"string\">&quot;lisi&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//正常队列绑定死信队列信息</span></span><br><span class=\"line\">        Map&lt;String, Object&gt; params = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">//正常队列设置死信交换机 参数 key 是固定值</span></span><br><span class=\"line\">        params.put(<span class=\"string\">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE);</span><br><span class=\"line\">        <span class=\"comment\">//正常队列设置死信 routing-key 参数 key 是固定值</span></span><br><span class=\"line\">        params.put(<span class=\"string\">&quot;x-dead-letter-routing-key&quot;</span>, <span class=\"string\">&quot;lisi&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//正常队列</span></span><br><span class=\"line\">        String normalQueue = <span class=\"string\">&quot;normal-queue&quot;</span>;</span><br><span class=\"line\">        channel.queueDeclare(normalQueue, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, params);</span><br><span class=\"line\">        channel.queueBind(normalQueue, NORMAL_EXCHANGE, <span class=\"string\">&quot;zhangsan&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;等待接收消息........... &quot;</span>);</span><br><span class=\"line\">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class=\"line\">            String message = <span class=\"keyword\">new</span> String(delivery.getBody(), <span class=\"string\">&quot;UTF-8&quot;</span>);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Consumer01 接收到消息&quot;</span> + message);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        channel.basicConsume(normalQueue, <span class=\"keyword\">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>生产者代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Producer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String NORMAL_EXCHANGE = <span class=\"string\">&quot;normal_exchange&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] argv)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class=\"line\">        <span class=\"comment\">//设置消息的 TTL 时间 10s</span></span><br><span class=\"line\">        AMQP.BasicProperties properties = <span class=\"keyword\">new</span> AMQP.BasicProperties().builder().expiration(<span class=\"string\">&quot;10000&quot;</span>).build();</span><br><span class=\"line\">        <span class=\"comment\">//该信息是用作演示队列个数限制</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"number\">11</span>; i++) &#123;</span><br><span class=\"line\">            String message = <span class=\"string\">&quot;info&quot;</span> + i;</span><br><span class=\"line\">            channel.basicPublish(NORMAL_EXCHANGE, <span class=\"string\">&quot;zhangsan&quot;</span>, properties, message.getBytes());</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;生产者发送消息:&quot;</span> + message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>启动 C1 ，之后关闭消费者，模拟其接收不到消息。再启动 Producer</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000049.png\" alt=\"RabbitMQ-00000049\"></p>\n<p>消费者 C2 代码：</p>\n<p>以上步骤完成后，启动 C2 消费者，它消费死信队列里面的消息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Consumer02</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//死信交换机名称</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String DEAD_EXCHANGE = <span class=\"string\">&quot;dead_exchange&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//声明交换机</span></span><br><span class=\"line\">        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class=\"line\">        <span class=\"comment\">//声明队列</span></span><br><span class=\"line\">        String deadQueue = <span class=\"string\">&quot;dead-queue&quot;</span>;</span><br><span class=\"line\">        channel.queueDeclare(deadQueue, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        channel.queueBind(deadQueue, DEAD_EXCHANGE, <span class=\"string\">&quot;lisi&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;等待接收死信消息........... &quot;</span>);</span><br><span class=\"line\">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class=\"line\">            String message = <span class=\"keyword\">new</span> String(delivery.getBody(), <span class=\"string\">&quot;UTF-8&quot;</span>);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Consumer02 接收到消息&quot;</span> + message);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        channel.basicConsume(deadQueue, <span class=\"keyword\">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000050.png\" alt=\"RabbitMQ-00000050\"></p>\n<h3 id=\"死信之最大长度\"><a href=\"#死信之最大长度\" class=\"headerlink\" title=\"死信之最大长度\"></a>死信之最大长度</h3><p>1、消息生产者代码去掉 TTL 属性</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210628101337825.png\" alt=\"image-20210628101337825\"></p>\n<p>2、C1 消费者修改以下代码**(启动之后关闭该消费者 模拟其接收不到消息)**</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000051.png\" alt=\"RabbitMQ-00000051\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//设置正常队列的长度限制，例如发10个，4个则为死信</span></span><br><span class=\"line\">params.put(<span class=\"string\">&quot;x-max-length&quot;</span>,<span class=\"number\">6</span>);</span><br></pre></td></tr></table></figure>\n\n<p><mark>注意此时需要把原先队列删除 因为参数改变了</mark></p>\n<p>3、C2 消费者代码不变(启动 C2 消费者) </p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000052.png\" alt=\"RabbitMQ-00000052\"></p>\n<h3 id=\"死信之消息被拒\"><a href=\"#死信之消息被拒\" class=\"headerlink\" title=\"死信之消息被拒\"></a>死信之消息被拒</h3><p>1、消息生产者代码同上生产者一致</p>\n<p>2、C1 消费者代码(启动之后关闭该消费者 模拟其接收不到消息)</p>\n<p>拒收消息 “info5” </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Consumer01</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//普通交换机名称</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String NORMAL_EXCHANGE = <span class=\"string\">&quot;normal_exchange&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//死信交换机名称</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String DEAD_EXCHANGE = <span class=\"string\">&quot;dead_exchange&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//声明死信和普通交换机 类型为 direct</span></span><br><span class=\"line\">        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class=\"line\">        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//声明死信队列</span></span><br><span class=\"line\">        String deadQueue = <span class=\"string\">&quot;dead-queue&quot;</span>;</span><br><span class=\"line\">        channel.queueDeclare(deadQueue, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">//死信队列绑定：队列、交换机、路由键（routingKey）</span></span><br><span class=\"line\">        channel.queueBind(deadQueue, DEAD_EXCHANGE, <span class=\"string\">&quot;lisi&quot;</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//正常队列绑定死信队列信息</span></span><br><span class=\"line\">        Map&lt;String, Object&gt; params = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">//正常队列设置死信交换机 参数 key 是固定值</span></span><br><span class=\"line\">        params.put(<span class=\"string\">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE);</span><br><span class=\"line\">        <span class=\"comment\">//正常队列设置死信 routing-key 参数 key 是固定值</span></span><br><span class=\"line\">        params.put(<span class=\"string\">&quot;x-dead-letter-routing-key&quot;</span>, <span class=\"string\">&quot;lisi&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//        //设置正常队列的长度限制，例如发10个，4个则为死信</span></span><br><span class=\"line\"><span class=\"comment\">//        params.put(&quot;x-max-length&quot;,6);</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//正常队列</span></span><br><span class=\"line\">        String normalQueue = <span class=\"string\">&quot;normal-queue&quot;</span>;</span><br><span class=\"line\">        channel.queueDeclare(normalQueue, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, params);</span><br><span class=\"line\">        channel.queueBind(normalQueue, NORMAL_EXCHANGE, <span class=\"string\">&quot;zhangsan&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;等待接收消息........... &quot;</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class=\"line\">            String message = <span class=\"keyword\">new</span> String(delivery.getBody(), <span class=\"string\">&quot;UTF-8&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (message.equals(<span class=\"string\">&quot;info5&quot;</span>)) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;Consumer01 接收到消息&quot;</span> + message + <span class=\"string\">&quot;并拒绝签收该消息&quot;</span>);</span><br><span class=\"line\">                <span class=\"comment\">//requeue 设置为 false 代表拒绝重新入队 该队列如果配置了死信交换机将发送到死信队列中</span></span><br><span class=\"line\">                channel.basicReject(delivery.getEnvelope().getDeliveryTag(), <span class=\"keyword\">false</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;Consumer01 接收到消息&quot;</span> + message);</span><br><span class=\"line\">                channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class=\"keyword\">false</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"comment\">//开启手动应答</span></span><br><span class=\"line\">        channel.basicConsume(normalQueue, <span class=\"keyword\">false</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000053.png\" alt=\"RabbitMQ-00000053\"></p>\n<p>3、C2 消费者代码不变</p>\n<p>启动消费者 1 然后再启动消费者 2 </p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000054.png\" alt=\"RabbitMQ-00000054\"></p>\n<h1 id=\"延迟队列\"><a href=\"#延迟队列\" class=\"headerlink\" title=\"延迟队列\"></a>延迟队列</h1><h2 id=\"延迟队列介绍\"><a href=\"#延迟队列介绍\" class=\"headerlink\" title=\"延迟队列介绍\"></a>延迟队列介绍</h2><ul>\n<li><strong>延迟队列概念：</strong></li>\n</ul>\n<p>延时队列,队列内部是有序的，最重要的特性就体现在它的延时属性上，延时队列中的元素是希望 在指定时间到了以后或之前取出和处理，简单来说，延时队列就是用来存放需要在指定时间被处理的 元素的队列。</p>\n<ul>\n<li><strong>延迟队列使用场景：</strong></li>\n</ul>\n<p>1.订单在十分钟之内未支付则自动取消<br>2.新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒。<br>3.用户注册成功后，如果三天内没有登陆则进行短信提醒。<br>4.用户发起退款，如果三天内没有得到处理则通知相关运营人员。<br>5.预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议</p>\n<p>这些场景都有一个特点，需要在某个事件发生之后或者之前的指定时间点完成某一项任务，如： 发生订单生成事件，在十分钟之后检查该订单支付状态，然后将未支付的订单进行关闭；那我们一直轮询数据，每秒查一次，取出需要被处理的数据，然后处理不就完事了吗？</p>\n<p>如果数据量比较少，确实可以这样做，比如：对于“如果账单一周内未支付则进行自动结算”这样的需求， 如果对于时间不是严格限制，而是宽松意义上的一周，那么每天晚上跑个定时任务检查一下所有未支付的账单，确实也是一个可行的方案。但对于数据量比较大，并且时效性较强的场景，如：“订单十分钟内未支付则关闭“，短期内未支付的订单数据可能会有很多，活动期间甚至会达到百万甚至千万级别，对这么庞大的数据量仍旧使用轮询的方式显然是不可取的，很可能在一秒内无法完成所有订单的检查，同时会给数据库带来很大压力，无法满足业务要求而且性能低下。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000055.png\" alt=\"RabbitMQ-00000055\"></p>\n<h2 id=\"RabbitMQ-中的-TTL\"><a href=\"#RabbitMQ-中的-TTL\" class=\"headerlink\" title=\"RabbitMQ 中的 TTL\"></a>RabbitMQ 中的 TTL</h2><p>TTL 是什么呢？TTL 是 RabbitMQ 中一个消息或者队列的属性，表明一条消息或者该队列中的所有消息的最大存活时间，单位是毫秒。</p>\n<p>换句话说，如果一条消息设置了 TTL 属性或者进入了设置TTL 属性的队列，那么这条消息如果在 TTL 设置的时间内没有被消费，则会成为”死信”。如果同时配置了队列的TTL 和消息的 TTL，那么较小的那个值将会被使用，有两种方式设置 TTL。</p>\n<ul>\n<li><strong>队列设置TTL</strong></li>\n</ul>\n<p>在创建队列的时候设置队列的“x-message-ttl”属性</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000057.png\" alt=\"RabbitMQ-00000057\"></p>\n<ul>\n<li><strong>消息设置TTL</strong></li>\n</ul>\n<p>是针对每条消息设置TTL</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000056.png\" alt=\"RabbitMQ-00000056\"></p>\n<p>::: tip 两者的区别 </p>\n<p>:::</p>\n<p>如果设置了队列的 TTL 属性，那么一旦消息过期，就会被队列丢弃(如果配置了死信队列被丢到死信队列中)，而第二种方式，消息即使过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者之前判定的，如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间；</p>\n<p>另外，还需要注意的一点是，如果不设置 TTL，表示消息永远不会过期，如果将 TTL 设置为 0，则表示除非此时可以直接投递该消息到消费者，否则该消息将会被丢弃。</p>\n<h2 id=\"整合-springboot\"><a href=\"#整合-springboot\" class=\"headerlink\" title=\"整合 springboot\"></a>整合 springboot</h2><p>前一小节我们介绍了死信队列，刚刚又介绍了 TTL，至此利用 RabbitMQ 实现延时队列的两大要素已经集齐，接下来只需要将它们进行融合，再加入一点点调味料，延时队列就可以新鲜出炉了。想想看，延时队列，不就是想要消息延迟多久被处理吗，TTL 则刚好能让消息在延迟多久之后成为死信，另一方面， 成为死信的消息都会被投递到死信队列里，这样只需要消费者一直消费死信队列里的消息就完事了，因为里面的消息都是希望被立即处理的消息。</p>\n<p>1、创建一个空项目：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000058.png\" alt=\"RabbitMQ-00000058\"></p>\n<p>2、添加依赖：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--RabbitMQ 依赖--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-test<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.alibaba<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>fastjson<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.2.47<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.projectlombok<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>lombok<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--swagger--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>io.springfox<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>springfox-swagger2<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.0.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>io.springfox<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>springfox-swagger-ui<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.0.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--RabbitMQ 测试依赖--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.amqp<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-rabbit-test<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>3、修改配置文件</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">spring.rabbitmq.host</span>=<span class=\"string\">42.192.149.71</span></span><br><span class=\"line\"><span class=\"meta\">spring.rabbitmq.port</span>=<span class=\"string\">5672</span></span><br><span class=\"line\"><span class=\"meta\">spring.rabbitmq.username</span>=<span class=\"string\">admin</span></span><br><span class=\"line\"><span class=\"meta\">spring.rabbitmq.password</span>=<span class=\"string\">123456</span></span><br></pre></td></tr></table></figure>\n\n<p>4、添加Swagger 配置类 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.oddfar.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> springfox.documentation.builders.ApiInfoBuilder;</span><br><span class=\"line\"><span class=\"keyword\">import</span> springfox.documentation.service.ApiInfo;</span><br><span class=\"line\"><span class=\"keyword\">import</span> springfox.documentation.service.Contact;</span><br><span class=\"line\"><span class=\"keyword\">import</span> springfox.documentation.spi.DocumentationType;</span><br><span class=\"line\"><span class=\"keyword\">import</span> springfox.documentation.spring.web.plugins.Docket;</span><br><span class=\"line\"><span class=\"keyword\">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableSwagger2</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SwaggerConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Docket <span class=\"title\">webApiConfig</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class=\"line\">                .groupName(<span class=\"string\">&quot;webApi&quot;</span>)</span><br><span class=\"line\">                .apiInfo(webApiInfo())</span><br><span class=\"line\">                .select()</span><br><span class=\"line\">                .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> ApiInfo <span class=\"title\">webApiInfo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ApiInfoBuilder()</span><br><span class=\"line\">                .title(<span class=\"string\">&quot;rabbitmq 接口文档&quot;</span>)</span><br><span class=\"line\">                .description(<span class=\"string\">&quot;本文档描述了 rabbitmq 微服务接口定义&quot;</span>)</span><br><span class=\"line\">                .version(<span class=\"string\">&quot;1.0&quot;</span>)</span><br><span class=\"line\">                .contact(<span class=\"keyword\">new</span> Contact(<span class=\"string\">&quot;zhiyuan&quot;</span>, <span class=\"string\">&quot;http://oddfar.com&quot;</span>, <span class=\"string\">&quot;test@qq.com&quot;</span>))</span><br><span class=\"line\">                .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"队列-TTL\"><a href=\"#队列-TTL\" class=\"headerlink\" title=\"队列 TTL\"></a>队列 TTL</h2><ul>\n<li><strong>代码架构图</strong> </li>\n</ul>\n<p>创建两个队列 QA 和 QB，两者队列 TTL 分别设置为 10S 和 40S，然后在创建一个交换机 X 和死信交 换机 Y，它们的类型都是direct，创建一个死信队列 QD，它们的绑定关系如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000060.png\" alt=\"RabbitMQ-00000060\"></p>\n<p>原先配置队列信息，写在了生产者和消费者代码中，现在可写咋配置类中，生产者只发消息，消费者只接受消息</p>\n<p><strong>1、配置文件类代码 ：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.oddfar.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.core.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> zhiyuan</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TtlQueueConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String X_EXCHANGE = <span class=\"string\">&quot;X&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String QUEUE_A = <span class=\"string\">&quot;QA&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String QUEUE_B = <span class=\"string\">&quot;QB&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//死信交换机</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String Y_DEAD_LETTER_EXCHANGE = <span class=\"string\">&quot;Y&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//死信队列</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String DEAD_LETTER_QUEUE = <span class=\"string\">&quot;QD&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 声明 xExchange</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;xExchange&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DirectExchange <span class=\"title\">xExchange</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DirectExchange(X_EXCHANGE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 声明 死信队列交换机</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;yExchange&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DirectExchange <span class=\"title\">yExchange</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DirectExchange(Y_DEAD_LETTER_EXCHANGE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//声明队列 A ttl 为 10s 并绑定到对应的死信交换机</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;queueA&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">queueA</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;String, Object&gt; args = <span class=\"keyword\">new</span> HashMap&lt;&gt;(<span class=\"number\">3</span>);</span><br><span class=\"line\">        <span class=\"comment\">//声明当前队列绑定的死信交换机</span></span><br><span class=\"line\">        args.put(<span class=\"string\">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);</span><br><span class=\"line\">        <span class=\"comment\">//声明当前队列的死信路由 key</span></span><br><span class=\"line\">        args.put(<span class=\"string\">&quot;x-dead-letter-routing-key&quot;</span>, <span class=\"string\">&quot;YD&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//声明队列的 TTL</span></span><br><span class=\"line\">        args.put(<span class=\"string\">&quot;x-message-ttl&quot;</span>, <span class=\"number\">10000</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> QueueBuilder.durable(QUEUE_A).withArguments(args).build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 声明队列 A 绑定 X 交换机</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">queueaBindingX</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;queueA&quot;)</span> Queue queueA,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                  <span class=\"meta\">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(queueA).to(xExchange).with(<span class=\"string\">&quot;XA&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//声明队列 B ttl 为 40s 并绑定到对应的死信交换机</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;queueB&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">queueB</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;String, Object&gt; args = <span class=\"keyword\">new</span> HashMap&lt;&gt;(<span class=\"number\">3</span>);</span><br><span class=\"line\">        <span class=\"comment\">//声明当前队列绑定的死信交换机</span></span><br><span class=\"line\">        args.put(<span class=\"string\">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);</span><br><span class=\"line\">        <span class=\"comment\">//声明当前队列的死信路由 key</span></span><br><span class=\"line\">        args.put(<span class=\"string\">&quot;x-dead-letter-routing-key&quot;</span>, <span class=\"string\">&quot;YD&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//声明队列的 TTL</span></span><br><span class=\"line\">        args.put(<span class=\"string\">&quot;x-message-ttl&quot;</span>, <span class=\"number\">40000</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> QueueBuilder.durable(QUEUE_B).withArguments(args).build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//声明队列 B 绑定 X 交换机</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">queuebBindingX</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;queueB&quot;)</span> Queue queue1B,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                  <span class=\"meta\">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(queue1B).to(xExchange).with(<span class=\"string\">&quot;XB&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//声明死信队列 QD</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;queueD&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">queueD</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(DEAD_LETTER_QUEUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//声明死信队列 QD 绑定关系</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">deadLetterBindingQAD</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;queueD&quot;)</span> Queue queueD,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                        <span class=\"meta\">@Qualifier(&quot;yExchange&quot;)</span> DirectExchange yExchange)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(queueD).to(yExchange).with(<span class=\"string\">&quot;YD&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>2、消息生产者代码</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.oddfar.contorller;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Controller;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Date;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> zhiyuan</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping(&quot;ttl&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SendMsgController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;sendMsg/&#123;message&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sendMsg</span><span class=\"params\">(<span class=\"meta\">@PathVariable</span> String message)</span> </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;当前时间：&#123;&#125;,发送一条信息给两个 TTL 队列:&#123;&#125;&quot;</span>, <span class=\"keyword\">new</span> Date(), message);</span><br><span class=\"line\">        rabbitTemplate.convertAndSend(<span class=\"string\">&quot;X&quot;</span>, <span class=\"string\">&quot;XA&quot;</span>, <span class=\"string\">&quot;消息来自 ttl 为 10S 的队列: &quot;</span> + message);</span><br><span class=\"line\">        rabbitTemplate.convertAndSend(<span class=\"string\">&quot;X&quot;</span>, <span class=\"string\">&quot;XB&quot;</span>, <span class=\"string\">&quot;消息来自 ttl 为 40S 的队列: &quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>3、消息消费者代码</strong> </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.oddfar.consumer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.rabbitmq.client.Channel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.core.Message;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Date;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 消费者 - 死信队列</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> zhiyuan</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DeadLetterQueueConsumer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;QD&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">receiveD</span><span class=\"params\">(Message message, Channel channel)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        String msg = <span class=\"keyword\">new</span> String(message.getBody());</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;当前时间：&#123;&#125;,收到死信队列信息&#123;&#125;&quot;</span>, <span class=\"keyword\">new</span> Date().toString(), msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>发起一个请求 <a href=\"http://localhost:8080/ttl/sendMsg/%E5%98%BB%E5%98%BB%E5%98%BB\">http://localhost:8080/ttl/sendMsg/嘻嘻嘻</a></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210628162017168.png\" alt=\"image-20210628162017168\"></p>\n<p>第一条消息在 10S 后变成了死信消息，然后被消费者消费掉，第二条消息在 40S 之后变成了死信消息， 然后被消费掉，这样一个延时队列就打造完成了。</p>\n<p>不过，如果这样使用的话，岂不是每增加一个新的时间需求，就要新增一个队列，这里只有 10S 和 40S 两个时间选项，如果需要一个小时后处理，那么就需要增加TTL 为一个小时的队列，如果是预定会议室然后提前通知这样的场景，岂不是要增加无数个队列才能满足需求？</p>\n<h2 id=\"延时队列TTL优化\"><a href=\"#延时队列TTL优化\" class=\"headerlink\" title=\"延时队列TTL优化\"></a>延时队列TTL优化</h2><p>在这里新增了一个队列 QC,绑定关系如下,该队列不设置TTL 时间</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000062.png\" alt=\"RabbitMQ-00000062\"></p>\n<p>配置文件类代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MsgTtlQueueConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String Y_DEAD_LETTER_EXCHANGE = <span class=\"string\">&quot;Y&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String QUEUE_C = <span class=\"string\">&quot;QC&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//声明队列 C 死信交换机</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;queueC&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">queueB</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;String, Object&gt; args = <span class=\"keyword\">new</span> HashMap&lt;&gt;(<span class=\"number\">3</span>);</span><br><span class=\"line\">        <span class=\"comment\">//声明当前队列绑定的死信交换机</span></span><br><span class=\"line\">        args.put(<span class=\"string\">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);</span><br><span class=\"line\">        <span class=\"comment\">//声明当前队列的死信路由 key</span></span><br><span class=\"line\">        args.put(<span class=\"string\">&quot;x-dead-letter-routing-key&quot;</span>, <span class=\"string\">&quot;YD&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//没有声明 TTL 属性</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> QueueBuilder.durable(QUEUE_C).withArguments(args).build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//声明队列 B 绑定 X 交换机</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">queuecBindingX</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;queueC&quot;)</span> Queue queueC,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                  <span class=\"meta\">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(queueC).to(xExchange).with(<span class=\"string\">&quot;XC&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>生产者代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 延时队列优化</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> message 消息</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> ttlTime 延时的毫秒</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@GetMapping(&quot;sendExpirationMsg/&#123;message&#125;/&#123;ttlTime&#125;&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sendMsg</span><span class=\"params\">(<span class=\"meta\">@PathVariable</span> String message, <span class=\"meta\">@PathVariable</span> String ttlTime)</span> </span>&#123;</span><br><span class=\"line\">    rabbitTemplate.convertAndSend(<span class=\"string\">&quot;X&quot;</span>, <span class=\"string\">&quot;XC&quot;</span>, message, correlationData -&gt; &#123;</span><br><span class=\"line\">        correlationData.getMessageProperties().setExpiration(ttlTime);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> correlationData;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    log.info(<span class=\"string\">&quot;当前时间：&#123;&#125;,发送一条时长&#123;&#125;毫秒 TTL 信息给队列 C:&#123;&#125;&quot;</span>, <span class=\"keyword\">new</span> Date(), ttlTime, message);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>发起请求</p>\n<p><a href=\"http://localhost:8080/ttl/sendExpirationMsg/%E4%BD%A0%E5%A5%BD1/20000\">http://localhost:8080/ttl/sendExpirationMsg/你好1/20000</a></p>\n<p><a href=\"http://localhost:8080/ttl/sendExpirationMsg/%E4%BD%A0%E5%A5%BD2/2000\">http://localhost:8080/ttl/sendExpirationMsg/你好2/2000</a></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000063.png\" alt=\"RabbitMQ-00000063\"></p>\n<p>看起来似乎没什么问题，但是在最开始的时候，就介绍过如果使用在消息属性上设置 TTL 的方式，消息可能并不会按时“死亡“</p>\n<p>因为 RabbitMQ 只会检查第一个消息是否过期，如果过期则丢到死信队列， 如果第一个消息的延时时长很长，而第二个消息的延时时长很短，第二个消息并不会优先得到执行。</p>\n<p>这也就是为什么第二个延时2秒，却后执行。</p>\n<h2 id=\"Rabbitmq-插件实现延迟队列\"><a href=\"#Rabbitmq-插件实现延迟队列\" class=\"headerlink\" title=\"Rabbitmq 插件实现延迟队列\"></a>Rabbitmq 插件实现延迟队列</h2><p>上文中提到的问题，确实是一个问题，如果不能实现在消息粒度上的 TTL，并使其在设置的TTL 时间及时死亡，就无法设计成一个通用的延时队列。那如何解决呢，接下来我们就去解决该问题。</p>\n<p>::: tip 安装延时队列插件</p>\n<p>:::</p>\n<p>可去<a href=\"https://www.rabbitmq.com/community-plugins.html\">官网下载</a> <strong>rabbitmq_delayed_message_exchange</strong> 插件，放置到 RabbitMQ 的插件目录。</p>\n<p>进入 RabbitMQ 的安装目录下的 plgins 目录，执行下面命令让该插件生效，然后重启 RabbitMQ</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@VM-0-6-centos software]<span class=\"comment\"># ls</span></span><br><span class=\"line\">erlang-21.3.8.21-1.el7.x86_64.rpm  rabbitmq_delayed_message_exchange-3.8.0.ez  rabbitmq-server-3.8.8-1.el7.noarch.rpm</span><br><span class=\"line\"><span class=\"comment\">#移动</span></span><br><span class=\"line\">cp rabbitmq_delayed_message_exchange-3.8.0.ez /usr/lib/rabbitmq/lib/rabbitmq_server-3.8.8/plugins</span><br><span class=\"line\"><span class=\"comment\">#安装</span></span><br><span class=\"line\">rabbitmq-plugins <span class=\"built_in\">enable</span> rabbitmq_delayed_message_exchange</span><br><span class=\"line\"><span class=\"comment\">#重启服务</span></span><br><span class=\"line\">systemctl restart rabbitmq-server</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000065.png\" alt=\"RabbitMQ-00000065\"></p>\n<p>::: tip 代码</p>\n<p>:::</p>\n<p>在这里新增了一个队列delayed.queue,一个自定义交换机 delayed.exchange，绑定关系如下:</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000066.png\" alt=\"RabbitMQ-00000066\"></p>\n<p><strong>1、配置文件类代码：</strong></p>\n<p>在我们自定义的交换机中，这是一种新的交换类型，该类型消息支持延迟投递机制消息传递后并不会立即投递到目标队列中，而是存储在 mnesia(一个分布式数据系统)表中，当达到投递时间时，才投递到目标队列中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DelayedQueueConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String DELAYED_QUEUE_NAME = <span class=\"string\">&quot;delayed.queue&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String DELAYED_EXCHANGE_NAME = <span class=\"string\">&quot;delayed.exchange&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String DELAYED_ROUTING_KEY = <span class=\"string\">&quot;delayed.routingkey&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">delayedQueue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(DELAYED_QUEUE_NAME);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//自定义交换机 我们在这里定义的是一个延迟交换机</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> CustomExchange <span class=\"title\">delayedExchange</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;String, Object&gt; args = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">//自定义交换机的类型</span></span><br><span class=\"line\">        args.put(<span class=\"string\">&quot;x-delayed-type&quot;</span>, <span class=\"string\">&quot;direct&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> CustomExchange(DELAYED_EXCHANGE_NAME, <span class=\"string\">&quot;x-delayed-message&quot;</span>, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">bindingDelayedQueue</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;delayedQueue&quot;)</span> Queue queue,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                       <span class=\"meta\">@Qualifier(&quot;delayedExchange&quot;)</span> CustomExchange delayedExchange)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(queue).to(delayedExchange).with(DELAYED_ROUTING_KEY).noargs();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p><strong>2、生产者代码</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GetMapping(&quot;sendDelayMsg/&#123;message&#125;/&#123;delayTime&#125;&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sendMsg</span><span class=\"params\">(<span class=\"meta\">@PathVariable</span> String message, <span class=\"meta\">@PathVariable</span> Integer delayTime)</span> </span>&#123;</span><br><span class=\"line\">    rabbitTemplate.convertAndSend(DELAYED_EXCHANGE_NAME, DELAYED_ROUTING_KEY, message,</span><br><span class=\"line\">            correlationData -&gt; &#123;</span><br><span class=\"line\">                correlationData.getMessageProperties().setDelay(delayTime);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> correlationData;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">    log.info(<span class=\"string\">&quot; 当 前 时 间 ： &#123;&#125;, 发 送 一 条 延 迟 &#123;&#125; 毫秒的信息给队列 delayed.queue:&#123;&#125;&quot;</span>, <span class=\"keyword\">new</span> Date(), delayTime, message);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>3、消费者代码</strong> </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 消费者 - 基于插件的延时队列</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> zhiyuan</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DelayQueueConsumer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String DELAYED_QUEUE_NAME = <span class=\"string\">&quot;delayed.queue&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = DELAYED_QUEUE_NAME)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">receiveDelayedQueue</span><span class=\"params\">(Message message)</span> </span>&#123;</span><br><span class=\"line\">        String msg = <span class=\"keyword\">new</span> String(message.getBody());</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;当前时间：&#123;&#125;,收到延时队列的消息：&#123;&#125;&quot;</span>, <span class=\"keyword\">new</span> Date().toString(), msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>发送请求：</p>\n<ul>\n<li><a href=\"http://localhost:8080/ttl/sendDelayMsg/hello1/20000\">http://localhost:8080/ttl/sendDelayMsg/hello1/20000</a></li>\n<li><a href=\"http://localhost:8080/ttl/sendDelayMsg/hello2/2000\">http://localhost:8080/ttl/sendDelayMsg/hello2/2000</a></li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210628214856678.png\" alt=\"image-20210628214856678\"></p>\n<p>第二个消息被先消费掉了，符合预期</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>延时队列在需要延时处理的场景下非常有用，使用 RabbitMQ 来实现延时队列可以很好的利用 RabbitMQ 的特性，如：消息可靠发送、消息可靠投递、死信队列来保障消息至少被消费一次以及未被正确处理的消息不会被丢弃。另外，通过 RabbitMQ 集群的特性，可以很好的解决单点故障问题，不会因为 单个节点挂掉导致延时队列不可用或者消息丢失。</p>\n<p>当然，延时队列还有很多其它选择，比如利用 Java 的 DelayQueue，利用 Redis 的 zset，利用 Quartz 或者利用 kafka 的时间轮，这些方式各有特点,看需要适用的场景</p>\n<h1 id=\"发布确认高级\"><a href=\"#发布确认高级\" class=\"headerlink\" title=\"发布确认高级\"></a>发布确认高级</h1><p>在生产环境中由于一些不明原因，导致 RabbitMQ  重启，在 RabbitMQ 重启期间生产者消息投递失败， 导致消息丢失，需要手动处理和恢复。于是，我们开始思考，如何才能进行 RabbitMQ 的消息可靠投递呢？ </p>\n<h2 id=\"发布确认-springboot-版本\"><a href=\"#发布确认-springboot-版本\" class=\"headerlink\" title=\"发布确认 springboot 版本\"></a>发布确认 springboot 版本</h2><p>确认机制方案：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000068.png\" alt=\"RabbitMQ-00000068\"></p>\n<p>代码架构图：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000069.png\" alt=\"RabbitMQ-00000069\"></p>\n<p>在配置文件当中需要添加</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">spring.rabbitmq.publisher-confirm-type</span>=<span class=\"string\">correlated</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>NONE</code> 值是禁用发布确认模式，是默认值</p>\n</li>\n<li><p><code>CORRELATED</code> 值是发布消息成功到交换器后会触发回调方法</p>\n</li>\n<li><p><code>SIMPLE</code> 值经测试有两种效果，其一效果和 CORRELATED 值一样会触发回调方法，其二在发布消息成功后使用 rabbitTemplate 调用 waitForConfirms 或 waitForConfirmsOrDie 方法等待 broker 节点返回发送结果，根据返回结果来判定下一步的逻辑，要注意的点是 waitForConfirmsOrDie 方法如果返回 false 则会关闭 channel，则接下来无法发送消息到 broker;</p>\n</li>\n</ul>\n<p>::: tip 代码</p>\n<p>:::</p>\n<p><strong>1、添加配置类：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConfirmConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String CONFIRM_EXCHANGE_NAME = <span class=\"string\">&quot;confirm.exchange&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String CONFIRM_QUEUE_NAME = <span class=\"string\">&quot;confirm.queue&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//声明业务 Exchange</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;confirmExchange&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DirectExchange <span class=\"title\">confirmExchange</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DirectExchange(CONFIRM_EXCHANGE_NAME);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 声明确认队列</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;confirmQueue&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">confirmQueue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 声明确认队列绑定关系</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">queueBinding</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;confirmQueue&quot;)</span> Queue queue,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                <span class=\"meta\">@Qualifier(&quot;confirmExchange&quot;)</span> DirectExchange exchange)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class=\"string\">&quot;key1&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>2、消息生产者的回调接口</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyCallBack</span> <span class=\"keyword\">implements</span> <span class=\"title\">RabbitTemplate</span>.<span class=\"title\">ConfirmCallback</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 交换机不管是否收到消息的一个回调方法</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> correlationData 消息相关数据</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> ack             交换机是否收到消息</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> cause           为收到消息的原因</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">confirm</span><span class=\"params\">(CorrelationData correlationData, <span class=\"keyword\">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class=\"line\">        String id = correlationData != <span class=\"keyword\">null</span> ? correlationData.getId() : <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ack) &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;交换机已经收到 id 为:&#123;&#125;的消息&quot;</span>, id);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;交换机还未收到 id 为:&#123;&#125;消息，原因:&#123;&#125;&quot;</span>, id, cause);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>3、消息生产者</strong> </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping(&quot;/confirm&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProducerController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String CONFIRM_EXCHANGE_NAME = <span class=\"string\">&quot;confirm.exchange&quot;</span>;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> MyCallBack myCallBack;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//依赖注入 rabbitTemplate 之后再设置它的回调对象</span></span><br><span class=\"line\">    <span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        rabbitTemplate.setConfirmCallback(myCallBack);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 消息回调和退回</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> message</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;sendMessage/&#123;message&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sendMessage</span><span class=\"params\">(<span class=\"meta\">@PathVariable</span> String message)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//指定消息 id 为 1</span></span><br><span class=\"line\">        CorrelationData correlationData1 = <span class=\"keyword\">new</span> CorrelationData(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">        String routingKey = <span class=\"string\">&quot;key1&quot;</span>;</span><br><span class=\"line\">        rabbitTemplate.convertAndSend(CONFIRM_EXCHANGE_NAME, routingKey, message + routingKey, correlationData1);</span><br><span class=\"line\">        log.info(routingKey + <span class=\"string\">&quot;发送消息内容:&#123;&#125;&quot;</span>, message + routingKey);</span><br><span class=\"line\"></span><br><span class=\"line\">        CorrelationData correlationData2 = <span class=\"keyword\">new</span> CorrelationData(<span class=\"string\">&quot;2&quot;</span>);</span><br><span class=\"line\">        routingKey = <span class=\"string\">&quot;key2&quot;</span>;</span><br><span class=\"line\">        rabbitTemplate.convertAndSend(CONFIRM_EXCHANGE_NAME, routingKey, message + routingKey, correlationData2);</span><br><span class=\"line\">        log.info(routingKey + <span class=\"string\">&quot;发送消息内容:&#123;&#125;&quot;</span>, message + routingKey);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>4、消息消费者</strong> </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConfirmConsumer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String CONFIRM_QUEUE_NAME = <span class=\"string\">&quot;confirm.queue&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = CONFIRM_QUEUE_NAME)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">receiveMsg</span><span class=\"params\">(Message message)</span> </span>&#123;</span><br><span class=\"line\">        String msg = <span class=\"keyword\">new</span> String(message.getBody());</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;接受到队列 confirm.queue 消息:&#123;&#125;&quot;</span>, msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>访问： <a href=\"http://localhost:8080/confirm/sendMessage/%E4%BD%A0%E5%A5%BD\">http://localhost:8080/confirm/sendMessage/%E4%BD%A0%E5%A5%BD</a></p>\n<p>结果分析：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210629135636990.png\" alt=\"image-20210629135636990\"></p>\n<p>可以看到，发送了两条消息，第一条消息的 RoutingKey 为 “key1”，第二条消息的 RoutingKey 为 “key2”，两条消息都成功被交换机接收，也收到了交换机的确认回调，但消费者只收到了一条消息，因为第二条消息的 RoutingKey 与队列的 BindingKey 不一致，也没有其它队列能接收这个消息，所有第二条消息被直接丢弃了。</p>\n<p>丢弃的消息交换机是不知道的，需要解决告诉生产者消息传送失败</p>\n<h2 id=\"回退消息\"><a href=\"#回退消息\" class=\"headerlink\" title=\"回退消息\"></a>回退消息</h2><p>Mandatory 参数 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">rabbitTemplate.setReturnsCallback(myCallBack);</span><br></pre></td></tr></table></figure>\n\n<p>在仅开启了生产者确认机制的情况下，交换机接收到消息后，会直接给消息生产者发送确认消息，如果发现该消息不可路由，那么消息会被直接丢弃，此时生产者是不知道消息被丢弃这个事件的。</p>\n<p>那么如何让无法被路由的消息帮我想办法处理一下？最起码通知我一声，我好自己处理啊。通过设置 mandatory 参数可以在当消息传递过程中不可达目的地时将消息返回给生产者。</p>\n<p><strong>1、修改配置</strong></p>\n<figure class=\"highlight properties\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#消息退回</span></span><br><span class=\"line\"><span class=\"meta\">spring.rabbitmq.publisher-returns</span>=<span class=\"string\">true</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>2、修改回调接口</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyCallBack</span> <span class=\"keyword\">implements</span> <span class=\"title\">RabbitTemplate</span>.<span class=\"title\">ConfirmCallback</span>, <span class=\"title\">RabbitTemplate</span>.<span class=\"title\">ReturnsCallback</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 交换机不管是否收到消息的一个回调方法</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> correlationData 消息相关数据</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> ack             交换机是否收到消息</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> cause           为收到消息的原因</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">confirm</span><span class=\"params\">(CorrelationData correlationData, <span class=\"keyword\">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class=\"line\">        String id = correlationData != <span class=\"keyword\">null</span> ? correlationData.getId() : <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ack) &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;交换机已经收到 id 为:&#123;&#125;的消息&quot;</span>, id);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;交换机还未收到 id 为:&#123;&#125;消息，原因:&#123;&#125;&quot;</span>, id, cause);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//当消息无法路由的时候的回调方法</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">returnedMessage</span><span class=\"params\">(ReturnedMessage returned)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        log.error(<span class=\"string\">&quot;消息：&#123;&#125;，被交换机 &#123;&#125; 退回，原因：&#123;&#125;，路由key：&#123;&#125;,code:&#123;&#125;&quot;</span>,</span><br><span class=\"line\">                <span class=\"keyword\">new</span> String(returned.getMessage().getBody()), returned.getExchange(),</span><br><span class=\"line\">                returned.getReplyText(), returned.getRoutingKey(),</span><br><span class=\"line\">                returned.getReplyCode());</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>低版本可能没有 <code>RabbitTemplate.ReturnsCallback</code> 请用 <code>RabbitTemplate.ReturnCallback</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">returnedMessage</span><span class=\"params\">(Message message, <span class=\"keyword\">int</span> replyCode, String replyText, String</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">exchange, String routingKey)</span> </span>&#123;</span><br><span class=\"line\">\tlog.info(<span class=\"string\">&quot;消息:&#123;&#125;被服务器退回，退回原因:&#123;&#125;, 交换机是:&#123;&#125;, 路由 key:&#123;&#125;&quot;</span>,<span class=\"keyword\">new</span> String(message.getBody()),replyText, exchange, routingKey);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>3、修改发送者 ProducerController</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//依赖注入 rabbitTemplate 之后再设置它的回调对象</span></span><br><span class=\"line\"><span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//消息回调</span></span><br><span class=\"line\">    rabbitTemplate.setConfirmCallback(myCallBack);</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * true：交换机无法将消息进行路由时，会将该消息返回给生产者</span></span><br><span class=\"line\"><span class=\"comment\">     * false：如果发现消息无法进行路由，则直接丢弃</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    rabbitTemplate.setMandatory(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    <span class=\"comment\">//设置回退消息交给谁处理</span></span><br><span class=\"line\">    rabbitTemplate.setReturnsCallback(myCallBack);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>访问： <a href=\"http://localhost:8080/confirm/sendMessage/%E4%BD%A0%E5%A5%BD\">http://localhost:8080/confirm/sendMessage/%E4%BD%A0%E5%A5%BD</a></p>\n<p>结果分析：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210629143756078.png\" alt=\"image-20210629143756078\"></p>\n<h2 id=\"备份交换机\"><a href=\"#备份交换机\" class=\"headerlink\" title=\"备份交换机\"></a>备份交换机</h2><p>有了 mandatory 参数和回退消息，我们获得了对无法投递消息的感知能力，在生产者的消息无法被投递时发现并处理。但有时候，我们并不知道该如何处理这些无法路由的消息，最多打个日志，然后触发报警，再来手动处理。而通过日志来处理这些无法路由的消息是很不优雅的做法，特别是当生产者所在的服务有多台机器的时候，手动复制日志会更加麻烦而且容易出错。而且设置 mandatory 参数会增加生产者的复杂性，需要添加处理这些被退回的消息的逻辑。如果既不想丢失消息，又不想增加生产者的复杂性，该怎么做呢？</p>\n<p>前面在设置死信队列的文章中，我们提到，可以为队列设置死信交换机来存储那些处理失败的消息，可是这些不可路由消息根本没有机会进入到队列，因此无法使用死信队列来保存消息。 在 RabbitMQ 中，有一种备份交换机的机制存在，可以很好的应对这个问题。</p>\n<p>什么是备份交换机呢？备份交换机可以理解为 RabbitMQ 中交换机的“备胎”，当我们为某一个交换机声明一个对应的备份交换机时，就是为它创建一个备胎，当交换机接收到一条不可路由消息时，将会把这条消息转发到备份交换机中，由备份交换机来进行转发和处理，通常备份交换机的类型为 Fanout ，这样就能把所有消息都投递到与其绑定的队列中，然后我们在备份交换机下绑定一个队列，这样所有那些原交换机无法被路由的消息，就会都进 入这个队列了。当然，我们还可以建立一个报警队列，用独立的消费者来进行监测和报警。</p>\n<ul>\n<li>代码架构图 </li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000072.png\" alt=\"RabbitMQ-00000072\"></p>\n<p>1、修改配置类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConfirmConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String CONFIRM_EXCHANGE_NAME = <span class=\"string\">&quot;confirm.exchange&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String CONFIRM_QUEUE_NAME = <span class=\"string\">&quot;confirm.queue&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//关于备份的</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String BACKUP_EXCHANGE_NAME = <span class=\"string\">&quot;backup.exchange&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String BACKUP_QUEUE_NAME = <span class=\"string\">&quot;backup.queue&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String WARNING_QUEUE_NAME = <span class=\"string\">&quot;warning.queue&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    //声明业务 Exchange</span></span><br><span class=\"line\"><span class=\"comment\">    @Bean(&quot;confirmExchange&quot;)</span></span><br><span class=\"line\"><span class=\"comment\">    public DirectExchange confirmExchange() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        return new DirectExchange(CONFIRM_EXCHANGE_NAME);</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 声明确认队列</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;confirmQueue&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">confirmQueue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 声明确认队列绑定关系</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">queueBinding</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;confirmQueue&quot;)</span> Queue queue,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                <span class=\"meta\">@Qualifier(&quot;confirmExchange&quot;)</span> DirectExchange exchange)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class=\"string\">&quot;key1&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//************************以下是关于备份的******************************</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//声明备份 Exchange</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;backupExchange&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> FanoutExchange <span class=\"title\">backupExchange</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> FanoutExchange(BACKUP_EXCHANGE_NAME);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//声明确认 Exchange 交换机的备份交换机</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;confirmExchange&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DirectExchange <span class=\"title\">confirmExchange</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ExchangeBuilder exchangeBuilder = ExchangeBuilder.directExchange(CONFIRM_EXCHANGE_NAME)</span><br><span class=\"line\">                .durable(<span class=\"keyword\">true</span>)</span><br><span class=\"line\">                <span class=\"comment\">//设置该交换机的备份交换机</span></span><br><span class=\"line\">                .withArgument(<span class=\"string\">&quot;alternate-exchange&quot;</span>, BACKUP_EXCHANGE_NAME);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> exchangeBuilder.build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 声明警告队列</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;warningQueue&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">warningQueue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> QueueBuilder.durable(WARNING_QUEUE_NAME).build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 声明报警队列绑定关系</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">warningBinding</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;warningQueue&quot;)</span> Queue queue,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                  <span class=\"meta\">@Qualifier(&quot;backupExchange&quot;)</span> FanoutExchange backupExchange)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(queue).to(backupExchange);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 声明备份队列</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;backQueue&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">backQueue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> QueueBuilder.durable(BACKUP_QUEUE_NAME).build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 声明备份队列绑定关系</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">backupBinding</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;backQueue&quot;)</span> Queue queue,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                 <span class=\"meta\">@Qualifier(&quot;backupExchange&quot;)</span> FanoutExchange backupExchange)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(queue).to(backupExchange);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2、报警消费者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WarningConsumer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String WARNING_QUEUE_NAME = <span class=\"string\">&quot;warning.queue&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = WARNING_QUEUE_NAME)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">receiveWarningMsg</span><span class=\"params\">(Message message)</span> </span>&#123;</span><br><span class=\"line\">        String msg = <span class=\"keyword\">new</span> String(message.getBody());</span><br><span class=\"line\">        log.error(<span class=\"string\">&quot;报警发现不可路由消息：&#123;&#125;&quot;</span>, msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>之前已写过 <code>confirm.exchange</code> 交换机，由于更改配置，需要删掉，不然会报错</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000073.png\" alt=\"RabbitMQ-00000073\"></p>\n<ul>\n<li>访问： <a href=\"http://localhost:8080/confirm/sendMessage/%E4%BD%A0%E5%A5%BD\">http://localhost:8080/confirm/sendMessage/%E4%BD%A0%E5%A5%BD</a></li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210629152752935.png\" alt=\"image-20210629152752935\"></p>\n<p>mandatory 参数与备份交换机可以一起使用的时候，如果两者同时开启，消息究竟何去何从？谁优先级高，经过上面结果显示答案是<strong>备份交换机优先级高</strong>。</p>\n<h1 id=\"幂等性\"><a href=\"#幂等性\" class=\"headerlink\" title=\"幂等性\"></a>幂等性</h1><p>::: tip 概念</p>\n<p>:::</p>\n<p>用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。 举个最简单的例子，那就是支付，用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常， 此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额发现多扣钱 了，流水记录也变成了两条。在以前的单应用系统中，我们只需要把数据操作放入事务中即可，发生错误立即回滚，但是再响应客户端的时候也有可能出现网络中断或者异常等等</p>\n<p>::: tip 消息重复消费</p>\n<p>:::</p>\n<p>消费者在消费 MQ 中的消息时，MQ 已把消息发送给消费者，消费者在给 MQ 返回 ack 时网络中断， 故 MQ 未收到确认信息，该条消息会重新发给其他的消费者，或者在网络重连后再次发送给该消费者，但实际上该消费者已成功消费了该条消息，造成消费者消费了重复的消息。</p>\n<p>::: tip 解决思路</p>\n<p>:::</p>\n<p>MQ 消费者的幂等性的解决一般使用全局 ID 或者写个唯一标识比如时间戳 或者 UUID 或者订单消费者消费 MQ 中的消息也可利用 MQ 的该 id 来判断，或者可按自己的规则生成一个全局唯一 id，每次消费消息时用该 id 先判断该消息是否已消费过。</p>\n<p>::: tip 消费端的幂等性保障</p>\n<p>:::</p>\n<p>在海量订单生成的业务高峰期，生产端有可能就会重复发生了消息，这时候消费端就要实现幂等性， 这就意味着我们的消息永远不会被消费多次，即使我们收到了一样的消息。</p>\n<p>业界主流的幂等性有两种操作:a. 唯一 ID+指纹码机制,利用数据库主键去重, b.利用 redis 的原子性去实现</p>\n<ul>\n<li>唯一ID+指纹码机制 </li>\n</ul>\n<p>指纹码：我们的一些规则或者时间戳加别的服务给到的唯一信息码,它并不一定是我们系统生成的，基本都是由我们的业务规则拼接而来，但是一定要保证唯一性，然后就利用查询语句进行判断这个 id 是否存在数据库中，优势就是实现简单就一个拼接，然后查询判断是否重复；劣势就是在高并发时，如果是单个数据库就会有写入性能瓶颈当然也可以采用分库分表提升性能，但也不是我们最推荐的方式。</p>\n<ul>\n<li> note Redis 原子性</li>\n</ul>\n<p>利用 redis 执行 setnx 命令，天然具有幂等性。从而实现不重复消费</p>\n<h2 id=\"优先级队列\"><a href=\"#优先级队列\" class=\"headerlink\" title=\"优先级队列\"></a>优先级队列</h2><ul>\n<li><strong>使用场景</strong></li>\n</ul>\n<p>在我们系统中有一个订单催付的场景，我们的客户在天猫下的订单，淘宝会及时将订单推送给我们，如果在用户设定的时间内未付款那么就会给用户推送一条短信提醒，很简单的一个功能对吧。</p>\n<p>但是，tmall 商家对我们来说，肯定是要分大客户和小客户的对吧，比如像苹果，小米这样大商家一年起码能给我们创造很大的利润，所以理应当然，他们的订单必须得到优先处理，而曾经我们的后端系统是使用 redis 来存放的定时轮询，大家都知道 redis 只能用 List 做一个简简单单的消息队列，并不能实现一个优先级的场景，所以订单量大了后采用 RabbitMQ 进行改造和优化，如果发现是大客户的订单给一个相对比较高的优先级， 否则就是默认优先级。</p>\n<ul>\n<li><strong>如何添加？</strong></li>\n</ul>\n<p>a.控制台页面添加</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000076.png\" alt=\"RabbitMQ-00000076\"></p>\n<p>b.队列中代码添加优先级</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Map&lt;String, Object&gt; params = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\">params.put(<span class=\"string\">&quot;x-max-priority&quot;</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\">channel.queueDeclare(<span class=\"string\">&quot;hello&quot;</span>, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, params);</span><br></pre></td></tr></table></figure>\n\n<p>c.消息中代码添加优先级</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">AMQP.BasicProperties properties = <span class=\"keyword\">new</span> AMQP.BasicProperties().builder().priority(<span class=\"number\">10</span>).build();</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意事项：</strong></p>\n<p>要让队列实现优先级需要做的事情有如下事情：队列需要设置为优先级队列，消息需要设置消息的优先级，消费者需要等待消息已经发送到队列中才去消费因为，这样才有机会对消息进行排序</p>\n<p>::: tip 实战 </p>\n<p>:::</p>\n<p>生产者：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PriorityProducer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String QUEUE_NAME = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//给消息赋予一个 priority 属性</span></span><br><span class=\"line\">        AMQP.BasicProperties properties = <span class=\"keyword\">new</span> AMQP.BasicProperties().builder().priority(<span class=\"number\">10</span>).build();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"number\">11</span>; i++) &#123;</span><br><span class=\"line\">            String message = <span class=\"string\">&quot;info&quot;</span> + i;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i == <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">                channel.basicPublish(<span class=\"string\">&quot;&quot;</span>, QUEUE_NAME, properties, message.getBytes());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                channel.basicPublish(<span class=\"string\">&quot;&quot;</span>, QUEUE_NAME, <span class=\"keyword\">null</span>, message.getBytes());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;发送消息完成:&quot;</span> + message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>消费者：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PriorityConsumer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String QUEUE_NAME = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//设置队列的最大优先级 最大可以设置到 255 官网推荐 1-10 如果设置太高比较吃内存和 CPU</span></span><br><span class=\"line\">        Map&lt;String, Object&gt; params = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\">        params.put(<span class=\"string\">&quot;x-max-priority&quot;</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\">        channel.queueDeclare(QUEUE_NAME, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, params);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//推送的消息如何进行消费的接口回调</span></span><br><span class=\"line\">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class=\"line\">            String message = <span class=\"keyword\">new</span> String(delivery.getBody());</span><br><span class=\"line\">            System.out.println(message);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"comment\">//取消消费的一个回调接口 如在消费的时候队列被删除掉了</span></span><br><span class=\"line\">        CancelCallback cancelCallback = (consumerTag) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;消息消费被中断&quot;</span>);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        channel.basicConsume(QUEUE_NAME, <span class=\"keyword\">true</span>, deliverCallback, cancelCallback);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210629163922085.png\" alt=\"image-20210629163922085\"></p>\n<h2 id=\"惰性队列\"><a href=\"#惰性队列\" class=\"headerlink\" title=\"惰性队列\"></a>惰性队列</h2><ul>\n<li><strong>使用场景</strong></li>\n</ul>\n<p>RabbitMQ 从 3.6.0 版本开始引入了惰性队列的概念。惰性队列会尽可能的将消息存入磁盘中，而在消费者消费到相应的消息时才会被加载到内存中，它的一个重要的设计目标是能够支持更长的队列，即支持更多的消息存储。当消费者由于各种各样的原因(比如消费者下线、宕机亦或者是由于维护而关闭等)而致使长时间内不能消费消息造成堆积时，惰性队列就很有必要了。</p>\n<p>默认情况下，当生产者将消息发送到 RabbitMQ 的时候，队列中的消息会尽可能的存储在内存之中， 这样可以更加快速的将消息发送给消费者。即使是持久化的消息，在被写入磁盘的同时也会在内存中驻留一份备份。当RabbitMQ 需要释放内存的时候，会将内存中的消息换页至磁盘中，这个操作会耗费较长的时间，也会阻塞队列的操作，进而无法接收新的消息。虽然 RabbitMQ 的开发者们一直在升级相关的算法， 但是效果始终不太理想，尤其是在消息量特别大的时候。</p>\n<ul>\n<li><strong>两种模式</strong> </li>\n</ul>\n<p>队列具备两种模式：default 和 lazy。默认的为default 模式，在3.6.0 之前的版本无需做任何变更。lazy 模式即为惰性队列的模式，可以通过调用 channel.queueDeclare 方法的时候在参数中设置，也可以通过 Policy 的方式设置，如果一个队列同时使用这两种方式设置的话，那么 Policy 的方式具备更高的优先级。 如果要通过声明的方式改变已有队列的模式的话，那么只能先删除队列，然后再重新声明一个新的。</p>\n<p>在队列声明的时候可以通过“x-queue-mode”参数来设置队列的模式，取值为“default”和“lazy”。下面示例中演示了一个惰性队列的声明细节：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Map&lt;String, Object&gt; args = <span class=\"keyword\">new</span> HashMap&lt;String, Object&gt;();</span><br><span class=\"line\">args.put(<span class=\"string\">&quot;x-queue-mode&quot;</span>, <span class=\"string\">&quot;lazy&quot;</span>);</span><br><span class=\"line\">channel.queueDeclare(<span class=\"string\">&quot;myqueue&quot;</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, args);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>内存开销对比 </li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000077.png\" alt=\"RabbitMQ-00000077\"></p>\n<p>在发送 1 百万条消息，每条消息大概占 1KB 的情况下，普通队列占用内存是 1.2GB，而惰性队列仅仅 占用 1.5MB</p>\n","site":{"data":{"bangumis":{"wantWatch":[],"watching":[{"title":"凡人修仙传","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/70d11dfab23a3ee81ccf64f18efa139416a633ff.jpg@220w_280h.webp","totalCount":"未完结","id":28223043,"follow":"615.7 万","view":"8.9 亿","danmaku":"490.9 万","coin":"1186.9 万","score":9.7,"des":"看机智的凡人小子韩立如何稳健发展、步步为营，战魔道、夺至宝、驰骋星海、快意恩仇，成为纵横三界的强者。他日仙界重相逢，一声道友尽沧桑。..."},{"title":"恋爱游戏世界对路人角色很不友好","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/c9723d8c77d881a8debba2852d580e97826b43d0.png@220w_280h.webp","totalCount":"全12话","id":28237300,"follow":"151.2 万","view":"5120.4 万","danmaku":"40.6 万","coin":"24.5 万","score":9.1,"des":"从现代日本转生到“恋爱游戏”世界的里昂，发现这里女尊男卑，对男性很不友好。身为路人角色的他，为了摆脱自己因地位低下而被肆意决定的人生，决定活用从游戏中得到的知识，保持路人角色的身份，取得“失落物品”来..."},{"title":"魔法纪录 魔法少女小圆外传 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/9eef1df9ab157be52d2c4d70d3500442f00cafc3.png@220w_280h.webp","totalCount":"全12话","id":28234642,"follow":"237.1 万","view":"907.6 万","danmaku":"5.0 万","coin":"4.9 万","score":7.7,"des":"愿望的代价，究竟是希望还是绝望——。"},{"title":"小林家的龙女仆 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/847e9dbb6876fb37a30199a5c88910704976d45b.png@220w_280h.webp","totalCount":"全13话","id":28234613,"follow":"855.7 万","view":"1.1 亿","danmaku":"49.0 万","coin":"69.0 万","score":9.6,"des":"那位不可思议的龙女仆再度登场！\n因为各种奇妙的原因而作为小林家的女仆而工作中的龙·托尔。\n偶尔（胡说，是经常）给亲爱的小林添麻烦，总算是融入了人类社会，成为了一个完美的（骗人，也就还行）女仆。\n同样是..."},{"title":"国王排名","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/376d7e69a667bcb1c0b934a4e35e07e7fa23110b.png@220w_280h.webp","totalCount":"全23话","id":28235154,"follow":"927.7 万","view":"4.8 亿","danmaku":"250.1 万","coin":"260.9 万","score":7,"des":"国家的丰饶、麾下勇者的数量、\n以及国王本人如何像勇者一般强大，\n这些要素的综合排名，便是所谓的“国王排名”。\n主人公波吉是国王排名第七名的伯斯王治下王国的第一王子。\n但是波吉却生来又聋又哑，贫弱到挥不..."},{"title":"阿松 第三季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0212baa8898d0c819c7fb84015e95b8fca621435.png@220w_280h.webp","totalCount":"全25话","id":28229892,"follow":"67.6 万","view":"938.0 万","danmaku":"13.0 万","coin":"5.4 万","score":9.6,"des":"日本最有名的六胞胎的传说，第三次开幕！！这次会有怎样意想不到的新展开！？..."},{"title":"命运-冠位指定 冠位时间神殿所罗门","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0e094b798388da19a4feffa6a6dabc1dc1dc90cd.jpg@220w_280h.webp","totalCount":"全1话","id":28236225,"follow":"525.5 万","view":"1220.0 万","danmaku":"8.9 万","coin":"15.1 万","score":8.5,"des":"在经过七个特异点的大战后，\n人理存续保障机关迦勒底，终于到达了圣杯探索的最终地点——终局特异点 冠位时间神殿所罗门。\n他们要击败身为罪魁祸首的魔术王所罗门，夺回未来。\n在开战的前一刻，一行人各自度过了..."},{"title":"JOJO的奇妙冒险 星尘远征军","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/47c0108259355d6d2c517ed97f6b90fb777f844f.png@220w_280h.webp","totalCount":"全24话","id":28223481,"follow":"444.2 万","view":"1.5 亿","danmaku":"463.4 万","coin":"45.7 万","score":9.8,"des":"时为1987年，乔瑟夫·乔斯达与“柱之男”们之间的死战后过了50年……乔瑟夫为了为了帮助“被恶灵附身了”的外孙子·空条承太郎而来到了日本。原来那并不是恶灵而是幽波纹（替身）。替身突然出现的原因在于，从..."},{"title":"JOJO的奇妙冒险 星尘远征军 埃及篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f6709b76e88f50aa132d1e09e2d8de9663a09b3e.png@220w_280h.webp","totalCount":"全24话","id":28223483,"follow":"421.9 万","view":"1.3 亿","danmaku":"468.7 万","coin":"44.3 万","score":9.9,"des":"在乔斯达家的宿敌·迪奥（DIO）复活的影响下，一位年轻人——空条承太郎，得到了名为“幽波纹（替身）”的能力。为了拯救因迪奥的诅咒而倒下的母亲荷莉，空条承太郎与外祖父·乔瑟夫以及伙伴们，一起为了打倒迪奥..."},{"title":"JOJO的奇妙冒险 不灭钻石","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/6a04c87e990ab74cd8d555ef45a863de0993b161.png@220w_280h.webp","totalCount":"全39话","id":140552,"follow":"302.3 万","view":"2.1 亿","danmaku":"813.8 万","coin":"55.9 万","score":9.8,"des":"在埃及与宿敌DIO的死斗之后过了11年。1999年，空条承太郎为了与祖父乔瑟夫·乔斯达的私生子东方仗助见面，而来到了日本M县S市杜王町。但，仗助却持有与承太郎相同的特殊能力“替身”。之后，以承太郎的来..."},{"title":"命运-冠位嘉年华","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/c660976f4502a544d990a882ae62194b57753a71.png@220w_280h.webp","totalCount":"全2话","id":28234639,"follow":"479.8 万","view":"862.4 万","danmaku":"4.1 万","coin":"9.1 万","score":9.8,"des":"一起庆祝吧！为了这奇迹般的嘉年华！"},{"title":"伍六七","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/b69e26d9e50514f3fa99eac9ab5aabf2a6e28c88.jpg@220w_280h.webp","totalCount":"全13话","id":6360,"follow":"585.8 万","view":"3.3 亿","danmaku":"227.1 万","coin":"191.8 万","score":9.8,"des":"在某个小岛上，有一个可以伪装成任何东西的廉价刺客，名叫伍六七。平时看上去是个理发师，其实背地里却做着刺客生意。热爱理发事业，喜欢给人剪头发，善用剪刀——剪刀也是他的刺杀武器。由于初入刺客行当，行情十分..."},{"title":"命运-冠位指定 -月光／失落之室-","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3fa5fd2b7afae827b0bf150d7f0cbfc54eda1ff2.png@220w_280h.webp","totalCount":"全1话","id":28234950,"follow":"483.3 万","view":"551.2 万","danmaku":9696,"coin":"2.9 万","score":9.5,"des":"失落之室——。\n这是一个可以看到被夺去亦或是遗失之物的地方。\n这是位于迦勒底被遗忘的角落，不属于任何人的地方。..."},{"title":"致不灭的你","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/1ae94fbb35d8e23bb84926b694509f8b057f96e6.png@220w_280h.webp","totalCount":"全20话","id":28233896,"follow":"476.3 万","view":"1.3 亿","danmaku":"140.1 万","coin":"95.0 万","score":9.6,"des":"本剧讲述了一个情节跌宕、场面宏大的奇幻故事，通过拥有不灭之身的主人公“不死”来探索人生哲理。\n不死起初是一个被投放到人世间的“球”。\n\n它具有“幻化为刺激源形态的能力”和“死后重生的能力”。\n\n先后从..."},{"title":"来自新世界","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/aaa60f9cb17fb4a38df464f1064ca9623e0769cc.jpg@220w_280h.webp","totalCount":"全25话","id":1598,"follow":"115.9 万","view":"1540.9 万","danmaku":"76.3 万","coin":"5.7 万","score":9.5,"des":"1000年后的日本，孩子们不断地消失，只存在想象中的恐怖动物与人类展开殊死战争。反乌托邦式的未来超级社会“新世界”，是口吐真言凭藉“咒力”就能移动物体的人类，与有着等同于普通人智力的生物“妖鼠”共存的..."},{"title":"转生成蜘蛛又怎样！","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f0796e37abac25ba2aa9f23120646aaa9a3d5ea7.png@220w_280h.webp","totalCount":"全24话","id":28231809,"follow":"600.0 万","view":"3.7 亿","danmaku":"190.3 万","coin":"164.6 万","score":7.8,"des":"曾经是一名女高中生的“我”，突然转生变成了幻想世界中的蜘蛛魔物。\n而且，出生地点还是各种凶恶魔物所盘踞的大迷宫。\n“我”以人类的智慧和非同寻常的积极心态为武器，使用蜘蛛的丝网以及陷阱打倒比自己等级高得..."},{"title":"装甲重拳/MEGALOBOX 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/e14dc4a935397fc074c7a12d9520225615209025.png@220w_280h.webp","totalCount":"全13话","id":28233916,"follow":"244.9 万","view":"3435.4 万","danmaku":"19.7 万","coin":"53.1 万","score":9.9,"des":"再一次，为梦想而活——\n\n将肉体与“装甲技术”融合的究极格斗技“装甲拳击”。\n在决出其顶点之人的大会“重拳之巅”上，身穿装甲用自己肉身挑战一切的拳击手“JOE”。\n\n从最下层的比赛开始仅仅花了三个月就..."},{"title":"机动战士高达SEED HD","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/855c88677267d707ebfe4040403692ff2c0938f0.png@220w_280h.webp","totalCount":"全48话","id":497,"follow":"54.8 万","view":"4044.4 万","danmaku":"114.4 万","coin":"6.0 万","score":9.6,"des":"《机动战士高达SEED》是高达系列在2002年至2003年度放映的动画。续作为《机动战士高达SEED Destiny》在2004年播放。因各具魅力的角色，明星云集的声优阵容和高度商业化的宣传而受到较低..."},{"title":"夏目友人帐 唤石者与怪异的访客","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6cf43708b779cde84ad285ff4e3a080de98df0af.png@220w_280h.webp","totalCount":"全1话","id":28234316,"follow":"567.1 万","view":"1374.8 万","danmaku":"18.1 万","coin":"17.9 万","score":9.9,"des":"本作由【唤石者】与【怪异的访客】两个人气短篇集锦而成。讲述生来便能看见各种妖怪的夏目，与自称保镖的猫咪老师一同邂逅的一系列温暖故事。\n【唤石者】一天夏目在森林中遇到一只小妖怪——密实。密实称自己肩负「..."},{"title":"Fate/Grand Order ‐First Order‐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/b75c55d209d156c8631f5ceb21e5c52c834dbb60.jpg@220w_280h.webp","totalCount":"全1话","id":5747,"follow":"250.9 万","view":"3329.7 万","danmaku":"76.7 万","coin":"10.7 万","score":8.3,"des":"【2016年12月31日bilibili独播】2015年。示巴所观测到的未来领域毫无前兆地消失。根据计算，发现——不，是证明了人类将于2017年灭绝。人理延续保障机构·迦勒底将“无法观测的领域”假定为..."},{"title":"伍六七之玄武国篇","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/00843865ea13702eccc4efd64c313fd4c8029c6b.jpg@220w_280h.webp","totalCount":"全10话","id":28232253,"follow":"999.4 万","view":"4.0 亿","danmaku":"177.7 万","coin":"385.3 万","score":9.8,"des":"为了保护小鸡岛居民和这里平静的生活，伍六七和他的伙伴大保和小飞开启了去往玄武国的冒险旅程，去寻找身世的真相和解救小岛的办法，等待他们的又将是更多的未知与奇遇。..."},{"title":"堀与宫村","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/039c4e0b14e27c7a9e5cce2f20a6efd3c8909401.png@220w_280h.webp","totalCount":"全13话","id":28231840,"follow":"695.2 万","view":"2.2 亿","danmaku":"242.1 万","coin":"361.4 万","score":9.8,"des":"不论是谁，都会有不想被人知道的一面。\n\n在学校中漂亮大方、成绩优秀的人气女生堀，私下却打扮土气、忙于家务和照顾弟弟。\n在学校中是阴暗宅男形象的宫村，生活中却是打扮时尚、带耳钉的帅气男生。\n因为一次特别..."},{"title":"奇蛋物语 / WONDER EGG PRIORITY","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/10e0bbc1047b2c45f0f881de334a6f3bfb42a3b6.png@220w_280h.webp","totalCount":"全12话","id":28231851,"follow":"254.9 万","view":"4686.8 万","danmaku":"47.6 万","coin":"65.5 万","score":9.7,"des":"14岁少女·大户爱在深夜散步的途中，\n随着神秘声音的指引，获得了一枚「蛋」。\n\n「如果想要改变世界的话」\n「那么就在现在做出选择」\n「请相信自己——」\n「打破这枚蛋——」\n\n而在打破「蛋」之后，等待着..."},{"title":"Re：从零开始的异世界生活 第二季 后半","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/4f3edbede7fc0bdb52842075cf8faaa1c5953eaa.png@220w_280h.webp","totalCount":"全12话","id":28232073,"follow":"849.9 万","view":"9308.1 万","danmaku":"108.1 万","coin":"230.1 万","score":9.9,"des":"我一定会拯救你。\n在打倒了魔女教大罪司教「怠惰」担当——培提其乌斯·罗曼尼康帝之后，菜月昴和爱蜜莉雅又得以重新开始。\n克服了艰难的诀别，两人终于和解，然而这只是新一轮风波的序幕。\n超乎想象的绝境危机，..."},{"title":"灰与幻想的格林姆迦尔","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/7fb4945f864e9e988212b7d20f206df2677053f8.jpg@220w_280h.webp","totalCount":"全12话","id":106512,"follow":"172.0 万","view":"2343.4 万","danmaku":"63.8 万","coin":"18.3 万","score":9.8,"des":"电视动画《灰与幻想的格林姆迦尔》改编自日本轻小说家十文字青原作白井锐利插画的同名轻小说。\n我们为什么要这么做…？\n哈尔希洛回过神来，才发现自己身处在黑暗当中，他完全不知道自己人在何处，也不明白这个地方..."},{"title":"龙与虎","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/144910805f172d16c5f544f43939a05d8ca20576.jpg@220w_280h.webp","totalCount":"全26话","id":1672,"follow":"336.9 万","view":"6671.9 万","danmaku":"511.9 万","coin":"61.5 万","score":9.7,"des":"樱花飞舞的四月，全新的高中二年级，新的班级……\n眼神凶恶的普通男孩——高须龙儿，遇上了众人害怕、凶暴残忍的“掌中老虎”逢坂大河，还知道了她不欲为人知的秘密。这就是龙虎相争爱与战斗的序幕。\n再加上总是笑..."},{"title":"机动战士高达 铁血的奥尔芬斯 第一季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/f84a80d731d0431c00903d8951fd66623d8237f7.png@220w_280h.webp","totalCount":"全25话","id":4310042,"follow":"62.4 万","view":"2318.6 万","danmaku":"52.2 万","coin":"5.4 万","score":9.5,"des":"主人公三日月·奥古斯，从所属的民间警备公司克律塞安保公司（下称CGS）那里，接受了对少女库德莉亚·蓝那·伯恩斯坦的护卫任务。但CGS受到了摘取反叛之芽的武力组织加拉尔霍恩的袭击，于是在把三日月当做诱饵..."},{"title":"机动战士高达00 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1d7a969e8f1045739c596de89a963e30475aff0e.jpg@220w_280h.webp","totalCount":"全25话","id":1193,"follow":"37.2 万","view":"2458.1 万","danmaku":"61.4 万","coin":"4.1 万","score":9.8,"des":"天人与联合国军的最终决战后过了四年。建立地球联邦政府的人类，为了追求更进一步的国家间之统合，以及人类意识的统一，在联合正规军之外，设立了独立治安维持部队“A-Laws”，目的为对所有危害联合的势力与主..."},{"title":"机动战士高达00","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/35b11bf59eb3fd12f0387951510a5d722d7435e5.jpg@220w_280h.webp","totalCount":"全25话","id":1192,"follow":"62.1 万","view":"2465.5 万","danmaku":"53.6 万","coin":"4.6 万","score":9.7,"des":"在西历2307年，虽然化石燃料枯竭了，但是人类得到了截然不同的新型能源。三台巨大的轨道升降机以及伴随它们的大规模的太阳光发电系统。但是能得到这个系统恩惠的，只有一部分大国和其同盟国而已。\n拥有三台轨道..."},{"title":"Re：从零开始的异世界生活 第二季 前半","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f2425cbdb07cc93bd0d3ba1c0099bfe78f5dc58a.png@220w_280h.webp","totalCount":"全13话","id":28229233,"follow":"774.2 万","view":"1.3 亿","danmaku":"201.4 万","coin":"126.7 万","score":9.7,"des":"我一定会拯救你。\n在打倒了魔女教大罪司教「怠惰」担当——培提其乌斯·罗曼尼康帝之后，菜月昴和爱蜜莉雅又得以重新开始。\n克服了艰难的诀别，两人终于和解，然而这只是新一轮风波的序幕。\n超乎想象的绝境危机，..."},{"title":"超级小白","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3d3e8257d22596f5d3e4395ca759bd1e0fe9b873.jpg@220w_280h.webp","totalCount":"全48话","id":28222671,"follow":"27.4 万","view":"978.0 万","danmaku":"3.6 万","coin":"3.6 万","score":9.6,"des":"为了阻止企图霸占世界的黑暗势力，野原家的普通小狗——小白接肩负重大使命，变身成为了守护世界的“超级小白”。小白将要面对的不仅是发明狗，还有其他意想不到的对手。当然，面对邪恶势力，小白也有着令人惊讶的超..."},{"title":"Re：从零开始的异世界生活 新编集版","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3c125e1aad08643e3eff2fb7d45e740c1a052725.png@220w_280h.webp","totalCount":"全13话","id":28224394,"follow":"631.1 万","view":"7674.2 万","danmaku":"166.2 万","coin":"51.1 万","score":9.6,"des":"在从便利商店回家的路上，突然被异世界召唤的少年菜月昴。在无法依靠任何东西的异世界，无力的少年手唯一的力量……那是“死去然后重新开始”的力量。为了守护最重要的人们，为了取回确实存在着又无可替代的时间，少..."},{"title":"因为太怕痛就全点防御力了","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/8021d3f6b0df6dbba6d32f76eb9cfe2531e166c4.png@220w_280h.webp","totalCount":"全12话","id":28224137,"follow":"620.6 万","view":"2.3 亿","danmaku":"326.8 万","coin":"103.8 万","score":9,"des":"主角本条枫在好友白峰理沙推荐下开始游玩游戏“NewWorld Online”，创建了名为“梅普露”的角色。然而作为游戏初学者，梅普露选择了不受欢迎的大盾当武器，同时因为怕痛而把所有状态点加到防御力的极..."},{"title":"冰海战记","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/c30401817895e67399094b4e669785a104270cdf.jpg@220w_280h.webp","totalCount":"全24话","id":28220475,"follow":"174.4 万","view":"4893.8 万","danmaku":"48.7 万","coin":"36.7 万","score":9.8,"des":"公元10世纪末期，出现了在世界各地出没的最强民族。被讴歌为最强战士的托尔兹，其子托尔芬幼时便生活在战场上，并向往着梦幻大陆“文兰”。这是一个发生在激荡时代的，真正的英雄物语。..."},{"title":"齐木楠雄的灾难 始动篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ba59822eded39b5254fb01448a7f1502101d5624.png@220w_280h.webp","totalCount":"全6话","id":28223748,"follow":"372.4 万","view":"3054.5 万","danmaku":"20.0 万","coin":"17.8 万","score":9.8,"des":"在电视剧中堪称帅气的超能力，对于高中生齐木楠雄来说只是招致灾难的元凶。作为新动画系列展开的楠雄的日常又会如何！？..."},{"title":"OVERLORD Ⅱ","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/851f979c8ebcc7583a43abd4b786c4e2e66b746b.jpg@220w_280h.webp","totalCount":"全13话","id":8792,"follow":"539.3 万","view":"3.8 亿","danmaku":"413.9 万","coin":"114.1 万","score":9.6,"des":"时为2138年。曾卷起一大风潮的虚拟现实体感型网络游戏《YGGDRASIL》即将迎来停服。玩家飞鼠在曾经以同伴和荣华自傲的根据地纳萨力克地下大坟墓，独自一人安静等待着那一刻。但是，不料发生了结束时间已..."},{"title":"夏目友人帐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/99c549494d9425f6455bd45a151f4d26397d6151.png@220w_280h.webp","totalCount":"全13话","id":1660,"follow":"324.0 万","view":"4975.2 万","danmaku":"278.7 万","coin":"15.5 万","score":9.8,"des":"夏目贵志生来拥有强大的灵力，能感知平常人所无法接触的妖怪神明的存在。因父母双亡，他多年间辗转于互相推卸责任的亲戚之间，又受到同龄人的欺负，未曾与任何人深交，造成性格一定程度上的孤僻。夏目本性和善，对于..."}],"watched":[{"title":"装甲重拳/MEGALOBOX","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0c44785cb5d25cc9f648800d251f21a2e236bb8a.png@220w_280h.webp","totalCount":"全13话","id":79472,"follow":"221.9 万","view":"6162.0 万","danmaku":"48.6 万","coin":"32.9 万","score":9.8,"des":"将肉体与“装甲技术”融合的究极格斗技——“MEGALOBOX”，将自己的全部赌在上面的男人们的热血战斗开始！\n今天也立于未认可地区的赌博比赛赛场上的MEGALO拳击手“JNK DOG”。虽然具备实力，..."},{"title":"超能力女儿","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/152c536f8ecaad8f3d7d568d33da81c963a4a722.png@220w_280h.webp","totalCount":"全12话","id":78352,"follow":"293.8 万","view":"9252.2 万","danmaku":"98.5 万","coin":"35.4 万","score":9.6,"des":"支持着芦川组的年轻智力型黑道新田义史，过着被喜欢的壶所包围的悠然自得单身生活。但某一天，随着装在神秘物体里的少女雏来到他家，他的生活为之一变。他被能使用念动力的雏所胁迫，迫不得已开始和她同居！\n容易暴..."},{"title":"OVERLORD Ⅲ","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/dd7a9d0a0bee32b1f43c2656398d8463d12b3069.jpg@220w_280h.webp","totalCount":"全13话","id":102252,"follow":"551.6 万","view":"4.0 亿","danmaku":"399.7 万","coin":"129.2 万","score":9.4,"des":"时间为2138年。曾卷起一大风潮的虚拟现实体感型网络游戏《YGGDRASIL》即将迎来停服。玩家飞鼠在曾经以同伴和荣华自傲的根据地纳萨力克地下大坟墓，独自一人安静等待着那一刻。\n但是，不料发生了“过了..."},{"title":"路人超能100 第一次灵能咨询所员工旅游～舒缓心灵的疗愈之旅~（OVA2）","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/1271324d51634b68980704731987724a1afc60aa.jpg@220w_280h.webp","totalCount":"全1话","id":28222715,"follow":"318.8 万","view":"520.7 万","danmaku":"3.6 万","coin":"4.6 万","score":9.8,"des":"由原作ONE老师担任原案的完全新作OVA！「灵能咨询所」一行人，龙套与灵幻、小酒窝以及新同伴芹泽的目的地，正是缟马县深山中鲜为人知的温泉·疣神温泉。因为灵幻接受了旅馆老板娘的委托，「弄清温泉的恐怖传闻..."},{"title":"少女终末旅行","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1431ca5bb2f7143062e3df8f21b8448cf8cccc13.jpg@220w_280h.webp","totalCount":"全12话","id":6463,"follow":"239.8 万","view":"3714.7 万","danmaku":"100.7 万","coin":"37.2 万","score":9.8,"des":"本作舞台在人类繁华的文明迎来终结的很久以后，人类基本灭绝，甚至生物都不再存在的末日世界。复杂够高的都市成为迷宫般的废墟，得不到维护的机械渐渐停止运转。连何时终结了，何时开始终结的思考都不复存在的这个世..."},{"title":"齐木楠雄的灾难（日播&精选版）","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/eb4f17335f48951945fb9da47e6ee0bc65fa2fbb.jpg@220w_280h.webp","totalCount":"全120话","id":5070,"follow":"187.0 万","view":"2.3 亿","danmaku":"130.7 万","coin":"32.7 万","score":9.6,"des":"高中生·齐木楠雄是超能力者。心灵感应、念动力、透视、预知、瞬间移动、千里眼等，不论任何事情都自由自在。但这任谁都羡慕不已的最强能力，实际上对于本人而言是引来灾难的不幸元凶。因此，他在别人面前封印了超能..."},{"title":"比宇宙更远的地方","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/c9eca3cbc386c63b27461074b8b218898cb7440e.jpg@220w_280h.webp","totalCount":"全13话","id":13032,"follow":"156.0 万","view":"2298.0 万","danmaku":"45.9 万","coin":"23.9 万","score":9.8,"des":"无论何时，我们的第一步总是从好奇心开始。\n不曾看过的风景，不曾听过的声音，不曾闻过的味道，不曾摸过的质感，不曾尝过的食物，以及不曾感受过的澎湃。\n为了重拾不知何时忘却的记忆碎片和不知何时舍弃的感动的旅..."},{"title":"OVERLORD","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/b8e72ea69e57e0b7ac85d8b4d366554fd866df1a.jpg@220w_280h.webp","totalCount":"全13话","id":2576,"follow":"626.2 万","view":"4.1 亿","danmaku":"385.2 万","coin":"84.4 万","score":9.6,"des":"作品主要讲述了某天，一款曾经掀起过大热潮的VRMMORPG「YGGDRASIL」停止了运营。游戏原本会停止一切服务，但过了结束时间后，玩家们却发现不能退出，NPC也产生了各自的思想。现实世界中喜爱电玩..."},{"title":"路人超能100 II(灵能百分百 第二季)","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/216e1bdaf88244215a13b1154116805ee9adbe07.png@220w_280h.webp","totalCount":"全13话","id":4762734,"follow":"284.9 万","view":"1.0 亿","danmaku":"97.8 万","coin":"56.1 万","score":9.9,"des":"当有什么东西达到“100”的时候，就会爆发的少年·路人（龙套）。外表极其普通——不如说是不起眼。不擅长迎合气氛的他，实际上拥有着强力的超能力。盯上了这样的他的能力，而接连现身的伪灵能力者以及宗教团体、..."},{"title":"多罗罗","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3fc16a667502cbff226e585eb660a96a20c7458c.png@220w_280h.webp","totalCount":"全24话","id":4312482,"follow":"452.1 万","view":"1.8 亿","danmaku":"143.9 万","coin":"73.9 万","score":9.4,"des":"他们向着命运抗争，在那尽头等待他们的是人心，还是业障。\n时值乱世。\n名为景光的醍醐将军，向某个寺庙殿堂中的12尊魔神像祈求早日结束战乱。\n作为代价，他的嫡子在出生时就失去了身体的某些部位，被丢弃在河流..."},{"title":"魔法少女小圆","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/7fcaa0e98b561611538ae4deba7949cec4ca39a8.png@220w_280h.webp","totalCount":"全12话","id":2539,"follow":"218.7 万","view":"4199.0 万","danmaku":"201.5 万","coin":"20.0 万","score":9.8,"des":"就读初中二年级的鹿目圆，过着平凡幸福的生活。神秘转学生晓美焰的出现，开始让小圆的命运有了巨大转变。某日一只名为丘比的神秘生物，希望小圆能够与它签订魔法契约，成为“魔法少女”以对抗邪恶的魔女保护世界。正..."}]},"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h1 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h1><h2 id=\"MQ-的相关概念\"><a href=\"#MQ-的相关概念\" class=\"headerlink\" title=\"MQ 的相关概念\"></a>MQ 的相关概念</h2><h3 id=\"什么是MQ\"><a href=\"#什么是MQ\" class=\"headerlink\" title=\"什么是MQ\"></a>什么是MQ</h3><p>MQ(message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是 message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常 见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不 用依赖其他服务。</p>\n<h3 id=\"为什么要用MQ\"><a href=\"#为什么要用MQ\" class=\"headerlink\" title=\"为什么要用MQ\"></a>为什么要用MQ</h3><ul>\n<li><strong>流量消峰</strong></li>\n</ul>\n<p>举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体验要好。</p>\n<ul>\n<li><strong>应用解耦</strong></li>\n</ul>\n<p>以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合 调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于 消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在 这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流 系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000004.png\" alt=\"RabbitMQ-00000004\"></p>\n<ul>\n<li><strong>异步处理</strong></li>\n</ul>\n<p>有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可以执行完。</p>\n<p>以前一般有两种方式，A 过一段时间去调用 B 的查询 api 查询。或者 A 提供一个 callback api， B 执行完之后调用 api 通知 A 服务。这两种方式都不是很优雅。</p>\n<p>使用消息总线，可以很方便解决这个问题， A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此消息转发给 A 服务。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样B 服务也不用 做这些操作。A 服务还能及时的得到异步处理成功的消息。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000005.png\" alt=\"RabbitMQ-00000005\"></p>\n<h3 id=\"MQ-的分类\"><a href=\"#MQ-的分类\" class=\"headerlink\" title=\"MQ 的分类\"></a>MQ 的分类</h3><p>::: tip ActiveMQ</p>\n<p>:::</p>\n<p>优点：单机吞吐量万级，时效性 ms 级，可用性高，基于主从架构实现高可用性，消息可靠性较 低的概率丢失数据</p>\n<p>缺点：官方社区现在对 ActiveMQ 5.x 维护越来越少，高吞吐量场景较少使用。</p>\n<p>::: tip Kafka</p>\n<p>:::</p>\n<p>大数据的杀手锏，谈到大数据领域内的消息传输，则绕不开 Kafka，这款为<strong>大数据而生</strong>的消息中间件， 以其百万级 TPS 的吞吐量名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥 着举足轻重的作用。目前已经被 LinkedIn，Uber, Twitter, Netflix 等大公司所采纳。</p>\n<p><strong>优点</strong>：性能卓越，单机写入 TPS 约在百万条/秒，最大的优点，就是<strong>吞吐量高</strong>。时效性 ms 级可用性非 常高，kafka 是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用,消费者采 用 Pull 方式获取消息, 消息有序, 通过控制能够保证所有消息被消费且仅被消费一次;有优秀的第三方Kafka Web 管理界面 Kafka-Manager；在日志领域比较成熟，被多家公司和多个开源项目使用；功能支持： 功能 较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用</p>\n<p><strong>缺点</strong>：Kafka 单机超过 64 个队列/分区，Load 会发生明显的飙高现象，队列越多，load 越高，发送消 息响应时间变长，使用短轮询方式，实时性取决于轮询间隔时间，消费失败不支持重试；支持消息顺序， 但是一台代理宕机后，就会产生消息乱序，<strong>社区更新较慢</strong>；</p>\n<p>::: tip RocketMQ</p>\n<p>:::</p>\n<p>RocketMQ 出自阿里巴巴的开源产品，用 Java 语言实现，在设计时参考了 Kafka，并做出了自己的一 些改进。被阿里巴巴广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog 分发等场 景。</p>\n<p>优点：<strong>单机吞吐量十万级</strong>,可用性非常高，分布式架构，<strong>消息可以做到 0 丢失</strong>,MQ 功能较为完善，还是分 布式的，扩展性好,支<strong>持 10 亿级别的消息堆积</strong>，不会因为堆积导致性能下降,源码是 java 我们可以自己阅 读源码，定制自己公司的 MQ</p>\n<p>缺点：<strong>支持的客户端语言不多</strong>，目前是 java 及 c++，其中 c++不成熟；社区活跃度一般,没有在MQ 核心中去实现 JMS 等接口,有些系统要迁移需要修改大量代码</p>\n<p>::: note RabbitMQ</p>\n<p>:::</p>\n<p>2007 年发布，是一个在AMQP(高级消息队列协议)基础上完成的，可复用的企业消息系统，<strong>是当前最主流的消息中间件之一。</strong></p>\n<p>优点：由于 erlang 语言的高并发特性，性能较好；吞吐量到万级，MQ 功能比较完备,健壮、稳定、易 用、跨平台、支持多种语言 如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，支持 AJAX 文档齐全；开源提供的管理界面非常棒，用起来很好用,社区活跃度高；更新频率相当高 </p>\n<p>官网更新：<a href=\"https://www.rabbitmq.com/news.html\">https://www.rabbitmq.com/news.html</a></p>\n<p>缺点：商业版需要收费,学习成本较高</p>\n<h3 id=\"MQ-的选择\"><a href=\"#MQ-的选择\" class=\"headerlink\" title=\"MQ 的选择\"></a>MQ 的选择</h3><ul>\n<li><strong>Kafka</strong></li>\n</ul>\n<p>Kafka 主要特点是基于Pull 的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集 和传输，适合产生大量数据的互联网服务的数据收集业务。大型公司建议可以选用，如果有日志采集功能， 肯定是首选 kafka 了。</p>\n<p>尚硅谷官网 kafka 视频教程：<a href=\"http://www.gulixueyuan.com/course/330/tasks\">http://www.gulixueyuan.com/course/330/tasks</a></p>\n<ul>\n<li><strong>RocketMQ</strong></li>\n</ul>\n<p>天生为<strong>金融互联网</strong>领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削 峰，在大量交易涌入时，后端可能无法及时处理的情况。RoketMQ 在稳定性上可能更值得信赖，这些业务 场景在阿里双 11 已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择 RocketMQ。</p>\n<ul>\n<li>RabbitMQ</li>\n</ul>\n<p>结合 erlang 语言本身的并发优势，性能好时效性微秒级，社区活跃度也比较高，管理界面用起来十分 方便，如果你的<strong>数据量没有那么大</strong>，中小型公司优先选择功能比较完备的 RabbitMQ。</p>\n<h2 id=\"RabbitMQ\"><a href=\"#RabbitMQ\" class=\"headerlink\" title=\"RabbitMQ\"></a>RabbitMQ</h2><h3 id=\"RabbitMQ-的概念\"><a href=\"#RabbitMQ-的概念\" class=\"headerlink\" title=\"RabbitMQ 的概念\"></a>RabbitMQ 的概念</h3><p>RabbitMQ 是一个消息中间件：它接受并转发消息。</p>\n<p>你可以把它当做一个快递站点，当你要发送一个包裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑 RabbitMQ 是 一个快递站，一个快递员帮你传递快件。</p>\n<p>RabbitMQ 与快递站的主要区别在于，它不处理快件而是接收， 存储和转发消息数据。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210625230930992.png\" alt=\"image-20210625230930992\"></p>\n<p>官网：<a href=\"https://www.rabbitmq.com/#features\">https://www.rabbitmq.com/#features</a></p>\n<h3 id=\"四大核心概念\"><a href=\"#四大核心概念\" class=\"headerlink\" title=\"四大核心概念\"></a>四大核心概念</h3><ul>\n<li><p>生产者</p>\n<p>产生数据发送消息的程序是生产者</p>\n</li>\n<li><p>交换机</p>\n<p>交换机是 RabbitMQ 非常重要的一个部件，一方面它接收来自生产者的消息，另一方面它将消息 推送到队列中。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推 送到多个队列，亦或者是把消息丢弃，这个得有交换机类型决定</p>\n</li>\n<li><p>队列</p>\n<p>队列是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ 和应用程序，但它们只能存 储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可 以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。这就是我们使用队列的方式</p>\n</li>\n<li><p>消费者</p>\n<p>消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者，消费 者和消息中间件很多时候并不在同一机器上。同一个应用程序既可以是生产者又是可以是消费者。</p>\n</li>\n</ul>\n<h3 id=\"各个名词介绍\"><a href=\"#各个名词介绍\" class=\"headerlink\" title=\"各个名词介绍\"></a>各个名词介绍</h3><p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000007.png\" alt=\"RabbitMQ-00000007\"></p>\n<ul>\n<li><p>Broker</p>\n<p>接收和分发消息的应用，RabbitMQ Server 就是 Message Broker</p>\n</li>\n<li><p>Virtual host</p>\n<p>出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似 于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出 多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等</p>\n</li>\n<li><p>Connection</p>\n<p>publisher／consumer 和 broker 之间的 TCP 连接</p>\n</li>\n<li><p>Channel</p>\n<p>如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程 序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客 户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的 Connection 极大减少了操作系统建立 TCP connection 的开销 </p>\n</li>\n<li><p>Exchange</p>\n<p>message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发 消息到 queue 中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)</p>\n</li>\n<li><p>Queue</p>\n<p>消息最终被送到这里等待 consumer 取走</p>\n</li>\n<li><p>Binding</p>\n<p>exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key，Binding 信息被保 存到 exchange 中的查询表中，用于 message 的分发依据</p>\n</li>\n</ul>\n<h3 id=\"安装RabbitMQ\"><a href=\"#安装RabbitMQ\" class=\"headerlink\" title=\"安装RabbitMQ\"></a>安装RabbitMQ</h3><p><strong>1、下载</strong></p>\n<p>官网下载地址：<a href=\"https://www.rabbitmq.com/download.html\">https://www.rabbitmq.com/download.html</a></p>\n<p>这里我们选择的版本号（注意这两版本要求）</p>\n<ul>\n<li><p>rabbitmq-server-3.8.8-1.el7.noarch.rpm</p>\n<p>GitHub：<a href=\"https://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.8.8\">https://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.8.8</a></p>\n<p>加载下载：<a href=\"https://packagecloud.io/rabbitmq/rabbitmq-server/packages/el/7/rabbitmq-server-3.8.8-1.el7.noarch.rpm\">https://packagecloud.io/rabbitmq/rabbitmq-server/packages/el/7/rabbitmq-server-3.8.8-1.el7.noarch.rpm</a></p>\n</li>\n<li><p>erlang-21.3.8.21-1.el7.x86_64.rpm</p>\n<p>官网：<a href=\"https://www.erlang-solutions.com/downloads/\">https://www.erlang-solutions.com/downloads/</a></p>\n<p>加速：<a href=\"https://packagecloud.io/rabbitmq/erlang/packages/el/7/erlang-21.3.8.21-1.el7.x86_64.rpm\">https://packagecloud.io/rabbitmq/erlang/packages/el/7/erlang-21.3.8.21-1.el7.x86_64.rpm</a></p>\n</li>\n</ul>\n<p>Red Hat 8, CentOS 8 和 modern Fedora 版本，把 “el7” 替换成 “el8”</p>\n<p><strong>2、安装</strong></p>\n<p>上传到 <code>/usr/local/software</code> 目录下(如果没有 software 需要自己创建)</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">rpm -ivh erlang-21.3.8.21-1.el7.x86_64.rpm</span><br><span class=\"line\">yum install socat -y</span><br><span class=\"line\">rpm -ivh rabbitmq-server-3.8.8-1.el7.noarch.rpm</span><br></pre></td></tr></table></figure>\n\n<p><strong>3、启动</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 启动服务</span></span><br><span class=\"line\">systemctl start rabbitmq-server</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 查看服务状态</span></span><br><span class=\"line\">systemctl status rabbitmq-server</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 开机自启动</span></span><br><span class=\"line\">systemctl enable rabbitmq-server</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 停止服务</span></span><br><span class=\"line\">systemctl stop rabbitmq-server</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 重启服务</span></span><br><span class=\"line\">systemctl restart rabbitmq-server</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Web管理界面及授权操作\"><a href=\"#Web管理界面及授权操作\" class=\"headerlink\" title=\"Web管理界面及授权操作\"></a>Web管理界面及授权操作</h3><p><strong>1、安装</strong></p>\n<p>默认情况下，是没有安装web端的客户端插件，需要安装才可以生效</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure>\n\n<p>安装完毕以后，重启服务即可</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl restart rabbitmq-server</span><br></pre></td></tr></table></figure>\n\n<p>访问 <a href=\"http://42.192.149.71:15672/\">http://42.192.149.71:15672</a> ，用默认账号密码(guest)登录，出现权限问题</p>\n<p>默认情况只能在 localhost 本机下访问，所以需要添加一个远程登录的用户</p>\n<p><strong>2、添加用户</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 创建账号和密码</span></span><br><span class=\"line\">rabbitmqctl add_user admin 123456</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 设置用户角色</span></span><br><span class=\"line\">rabbitmqctl set_user_tags admin administrator</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 为用户添加资源权限</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> set_permissions [-p &lt;vhostpath&gt;] &lt;user&gt; &lt;conf&gt; &lt;write&gt; &lt;<span class=\"built_in\">read</span>&gt;</span></span><br><span class=\"line\">rabbitmqctl set_permissions -p &quot;/&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 添加配置、写、读权限</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>用户级别：</p>\n<ol>\n<li><strong>administrator</strong>：可以登录控制台、查看所有信息、可以对 rabbitmq 进行管理</li>\n<li><strong>monitoring</strong>：监控者 登录控制台，查看所有信息</li>\n<li><strong>policymaker</strong>：策略制定者 登录控制台，指定策略</li>\n<li><strong>managment</strong>：普通管理员 登录控制台</li>\n</ol>\n<p>再次登录，用 admin 用户</p>\n<p>::: tip 重置命令</p>\n<p>:::</p>\n<p>关闭应用的命令为：rabbitmqctl stop_app</p>\n<p>清除的命令为：rabbitmqctl reset</p>\n<p>重新启动命令为：rabbitmqctl start_app</p>\n<h3 id=\"Docker-安装\"><a href=\"#Docker-安装\" class=\"headerlink\" title=\"Docker 安装\"></a>Docker 安装</h3><p>官网：<a href=\"https://registry.hub.docker.com/_/rabbitmq/\">https://registry.hub.docker.com/_/rabbitmq/</a></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -id --name myrabbit -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=123456 -p 15672:15672 rabbitmq:3-management</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"Hello-world\"><a href=\"#Hello-world\" class=\"headerlink\" title=\"Hello world\"></a>Hello world</h1><p>我们将用 Java 编写两个程序。发送单个消息的生产者和接收消息并打印出来的消费者</p>\n<p>在下图中，“ P” 是我们的生产者，“ C” 是我们的消费者。中间的框是一个队列 RabbitMQ 代表使用者保留的消息缓冲区</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000012.png\" alt=\"RabbitMQ-00000012\"></p>\n<p>连接的时候，需要开启 5672 端口</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210626162052259.png\" alt=\"image-20210626162052259\"></p>\n<ul>\n<li><strong>依赖</strong></li>\n</ul>\n<p>pom.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--指定 jdk 编译版本--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.maven.plugins<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>maven-compiler-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">source</span>&gt;</span>8<span class=\"tag\">&lt;/<span class=\"name\">source</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">target</span>&gt;</span>8<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--rabbitmq 依赖客户端--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.rabbitmq<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>amqp-client<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.8.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--操作文件流的一个依赖--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>commons-io<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>commons-io<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.6<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>消息生产者</strong></li>\n</ul>\n<p>发送消息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.oddfar.one;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.rabbitmq.client.Channel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.rabbitmq.client.Connection;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> zhiyuan</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Producer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String QUEUE_NAME = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//创建一个连接工厂</span></span><br><span class=\"line\">        ConnectionFactory factory = <span class=\"keyword\">new</span> ConnectionFactory();</span><br><span class=\"line\">        factory.setHost(<span class=\"string\">&quot;42.192.149.71&quot;</span>);</span><br><span class=\"line\">        factory.setUsername(<span class=\"string\">&quot;admin&quot;</span>);</span><br><span class=\"line\">        factory.setPassword(<span class=\"string\">&quot;123456&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//channel 实现了自动 close 接口 自动关闭 不需要显示关闭</span></span><br><span class=\"line\">        <span class=\"comment\">//创建连接</span></span><br><span class=\"line\">        Connection connection = factory.newConnection();</span><br><span class=\"line\">        <span class=\"comment\">//获取信道</span></span><br><span class=\"line\">        Channel channel = connection.createChannel();</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 生成一个队列</span></span><br><span class=\"line\"><span class=\"comment\">         * 1.队列名称</span></span><br><span class=\"line\"><span class=\"comment\">         * 2.队列里面的消息是否持久化 也就是是否用完就删除</span></span><br><span class=\"line\"><span class=\"comment\">         * 3.该队列是否只供一个消费者进行消费 是否进行共享 true 可以多个消费者消费</span></span><br><span class=\"line\"><span class=\"comment\">         * 4.是否自动删除 最后一个消费者端开连接以后 该队列是否自动删除 true 自动删除</span></span><br><span class=\"line\"><span class=\"comment\">         * 5.其他参数</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        channel.queueDeclare(QUEUE_NAME, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        String message = <span class=\"string\">&quot;hello world&quot;</span>;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 发送一个消息</span></span><br><span class=\"line\"><span class=\"comment\">         * 1.发送到那个交换机</span></span><br><span class=\"line\"><span class=\"comment\">         * 2.路由的 key 是哪个</span></span><br><span class=\"line\"><span class=\"comment\">         * 3.其他的参数信息</span></span><br><span class=\"line\"><span class=\"comment\">         * 4.发送消息的消息体</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        channel.basicPublish(<span class=\"string\">&quot;&quot;</span>, QUEUE_NAME, <span class=\"keyword\">null</span>, message.getBytes());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;消息发送完毕&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li><strong>消息消费者</strong></li>\n</ul>\n<p>获取“生产者”发出的消息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.oddfar.one;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.rabbitmq.client.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> zhiyuan</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Consumer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String QUEUE_NAME = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        ConnectionFactory factory = <span class=\"keyword\">new</span> ConnectionFactory();</span><br><span class=\"line\">        factory.setHost(<span class=\"string\">&quot;42.192.149.71&quot;</span>);</span><br><span class=\"line\">        factory.setUsername(<span class=\"string\">&quot;admin&quot;</span>);</span><br><span class=\"line\">        factory.setPassword(<span class=\"string\">&quot;123456&quot;</span>);</span><br><span class=\"line\">        Connection connection = factory.newConnection();</span><br><span class=\"line\">        Channel channel = connection.createChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;等待接收消息.........&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//推送的消息如何进行消费的接口回调</span></span><br><span class=\"line\">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class=\"line\">            String message = <span class=\"keyword\">new</span> String(delivery.getBody());</span><br><span class=\"line\">            System.out.println(message);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"comment\">//取消消费的一个回调接口 如在消费的时候队列被删除掉了</span></span><br><span class=\"line\">        CancelCallback cancelCallback = (consumerTag) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;消息消费被中断&quot;</span>);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 消费者消费消息 - 接受消息</span></span><br><span class=\"line\"><span class=\"comment\">         * 1.消费哪个队列</span></span><br><span class=\"line\"><span class=\"comment\">         * 2.消费成功之后是否要自动应答 true 代表自动应答 false 手动应答</span></span><br><span class=\"line\"><span class=\"comment\">         * 3.消费者未成功消费的回调</span></span><br><span class=\"line\"><span class=\"comment\">         * 4.消息被取消时的回调</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        channel.basicConsume(QUEUE_NAME, <span class=\"keyword\">true</span>, deliverCallback, cancelCallback);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Work-Queues\"><a href=\"#Work-Queues\" class=\"headerlink\" title=\"Work Queues\"></a>Work Queues</h1><p>Work Queues——工作队列(又称任务队列)的主要思想是避免立即执行资源密集型任务，而不得不等待它完成。 相反我们安排任务在之后执行。我们把任务封装为消息并将其发送到队列。在后台运行的工作进 程将弹出任务并最终执行作业。当有多个工作线程时，这些工作线程将一起处理这些任务。</p>\n<h2 id=\"轮训分发消息\"><a href=\"#轮训分发消息\" class=\"headerlink\" title=\"轮训分发消息\"></a>轮训分发消息</h2><p>在这个案例中我们会启动两个工作线程，一个消息发送线程，我们来看看他们两个工作线程是如何工作的。</p>\n<p><strong>1、抽取工具类</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.oddfar.utils;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.rabbitmq.client.Channel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.rabbitmq.client.Connection;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RabbitMqUtils</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//得到一个连接的 channel</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Channel <span class=\"title\">getChannel</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//创建一个连接工厂</span></span><br><span class=\"line\">        ConnectionFactory factory = <span class=\"keyword\">new</span> ConnectionFactory();</span><br><span class=\"line\">        factory.setHost(<span class=\"string\">&quot;42.192.149.71&quot;</span>);</span><br><span class=\"line\">        factory.setUsername(<span class=\"string\">&quot;admin&quot;</span>);</span><br><span class=\"line\">        factory.setPassword(<span class=\"string\">&quot;123456&quot;</span>);</span><br><span class=\"line\">        Connection connection = factory.newConnection();</span><br><span class=\"line\">        Channel channel = connection.createChannel();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> channel;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>2、启动两个工作线程来接受消息</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.oddfar.two;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.oddfar.utils.RabbitMqUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.rabbitmq.client.CancelCallback;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.rabbitmq.client.Channel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 这是一个工作线程，相当于之前的消费者</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> zhiyuan</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Worker01</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String QUEUE_NAME = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//消息接受</span></span><br><span class=\"line\">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class=\"line\">            String receivedMessage = <span class=\"keyword\">new</span> String(delivery.getBody());</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;接收到消息:&quot;</span> + receivedMessage);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"comment\">//消息被取消</span></span><br><span class=\"line\">        CancelCallback cancelCallback = (consumerTag) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(consumerTag + <span class=\"string\">&quot;消费者取消消费接口回调逻辑&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;C1 消费者启动等待消费.................. &quot;</span>);</span><br><span class=\"line\">        channel.basicConsume(QUEUE_NAME, <span class=\"keyword\">true</span>, deliverCallback, cancelCallback);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>选中 <code>Allow multiple instances</code><br><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210627125840217.png\" alt=\"image-20210627125840217\"></p>\n<p>启动后</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210627130146584.png\" alt=\"image-20210627130146584\"></p>\n<p><strong>3、启动一个发送消息线程</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Task01</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String QUEUE_NAME = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">        Scanner scanner = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (scanner.hasNext()) &#123;</span><br><span class=\"line\">            String message = scanner.next();</span><br><span class=\"line\">            channel.basicPublish(<span class=\"string\">&quot;&quot;</span>, QUEUE_NAME, <span class=\"keyword\">null</span>, message.getBytes());</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;消息发送完成：&quot;</span> + message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li><strong>结果展示</strong></li>\n</ul>\n<p>通过程序执行发现生产者总共发送 4 个消息，消费者 1 和消费者 2 分别分得两个消息，并且是按照有序的一个接收一次消息</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000016.png\" alt=\"RabbitMQ-00000016\"></p>\n<h2 id=\"消息应答\"><a href=\"#消息应答\" class=\"headerlink\" title=\"消息应答\"></a>消息应答</h2><p>消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成了部分突然它挂掉了，会发生什么情况。RabbitMQ 一旦向消费者传递了一条消息，便立即将该消息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息。以及后续发送给该消费这的消息，因为它无法接收到。</p>\n<p>为了保证消息在发送过程中不丢失，引入消息应答机制，消息应答就是：<strong>消费者在接收到消息并且处理该消息之后，告诉 rabbitmq 它已经处理了，rabbitmq 可以把该消息删除了。</strong> </p>\n<h3 id=\"自动应答\"><a href=\"#自动应答\" class=\"headerlink\" title=\"自动应答\"></a>自动应答</h3><p>消息发送后立即被认为已经传送成功，这种模式需要在<strong>高吞吐量和数据传输安全性方面做权衡</strong>,因为这种模式如果消息在接收到之前，消费者那边出现连接或者 channel 关闭，那么消息就丢失 了,当然另一方面这种模式消费者那边可以传递过载的消息，<strong>没有对传递的消息数量进行限制</strong>，当然这样有可能使得消费者这边由于接收太多还来不及处理的消息，导致这些消息的积压，最终使 得内存耗尽，最终这些消费者线程被操作系统杀死，<strong>所以这种模式仅适用在消费者可以高效并以 某种速率能够处理这些消息的情况下使用。</strong></p>\n<h3 id=\"手动消息应答的方法\"><a href=\"#手动消息应答的方法\" class=\"headerlink\" title=\"手动消息应答的方法\"></a>手动消息应答的方法</h3><ul>\n<li><p>Channel.basicAck(用于肯定确认)</p>\n<p>RabbitMQ 已知道该消息并且成功的处理消息，可以将其丢弃了 </p>\n</li>\n<li><p>Channel.basicNack(用于否定确认) </p>\n</li>\n<li><p>Channel.basicReject(用于否定确认)</p>\n<p>与 Channel.basicNack 相比少一个参数，不处理该消息了直接拒绝，可以将其丢弃了</p>\n</li>\n</ul>\n<p><strong>Multiple 的解释：</strong></p>\n<p>手动应答的好处是可以批量应答并且减少网络拥堵 </p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000017.png\" alt=\"RabbitMQ-00000017\"></p>\n<ul>\n<li><p>true 代表批量应答 channel 上未应答的消息</p>\n<p>比如说 channel 上有传送 tag 的消息 5,6,7,8 当前 tag 是8 那么此时5-8 的这些还未应答的消息都会被确认收到消息应答</p>\n</li>\n<li><p>false 同上面相比只会应答 tag=8 的消息 5,6,7 这三个消息依然不会被确认收到消息应答</p>\n</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000018.png\" alt=\"RabbitMQ-00000018\"></p>\n<h3 id=\"消息自动重新入队\"><a href=\"#消息自动重新入队\" class=\"headerlink\" title=\"消息自动重新入队\"></a>消息自动重新入队</h3><p>如果消费者由于某些原因失去连接(其通道已关闭，连接已关闭或 TCP 连接丢失)，导致消息未发送 ACK 确认，RabbitMQ 将了解到消息未完全处理，并将对其重新排队。如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确保不会丢失任何消息。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000019.png\" alt=\"RabbitMQ-00000019\"></p>\n<h3 id=\"消息手动应答代码\"><a href=\"#消息手动应答代码\" class=\"headerlink\" title=\"消息手动应答代码\"></a>消息手动应答代码</h3><p>默认消息采用的是自动应答，所以我们要想实现消息消费过程中不丢失，需要把自动应答改为手动应答</p>\n<p>消费者在上面代码的基础上增加了以下内容</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class=\"keyword\">false</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>消息生产者：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.oddfar.three;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.oddfar.utils.RabbitMqUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.rabbitmq.client.Channel;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 消息生产者,消息在手动应答时是不丢失的，放回队列重新消费</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> zhiyuan</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Task02</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TASK_QUEUE_NAME = <span class=\"string\">&quot;ack_queue&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\">        <span class=\"comment\">//声明队列</span></span><br><span class=\"line\">        channel.queueDeclare(TASK_QUEUE_NAME, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        Scanner sc = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;请输入信息&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (sc.hasNext()) &#123;</span><br><span class=\"line\">            String message = sc.nextLine();</span><br><span class=\"line\">            <span class=\"comment\">//发布消息</span></span><br><span class=\"line\">            channel.basicPublish(<span class=\"string\">&quot;&quot;</span>, TASK_QUEUE_NAME, <span class=\"keyword\">null</span>, message.getBytes(<span class=\"string\">&quot;UTF-8&quot;</span>));</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;生产者发出消息&quot;</span> + message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>消费者 01：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.oddfar.three;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.oddfar.utils.RabbitMqUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.rabbitmq.client.CancelCallback;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.rabbitmq.client.Channel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 消费者01</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> zhiyuan</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Work03</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TASK_QUEUE_NAME = <span class=\"string\">&quot;ack_queue&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;C1 等待接收消息处理时间较 短&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class=\"line\">            String message = <span class=\"keyword\">new</span> String(delivery.getBody());</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;接收到消息:&quot;</span> + message);</span><br><span class=\"line\">            <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">             * 1.消息标记 tag</span></span><br><span class=\"line\"><span class=\"comment\">             * 2.是否批量应答未应答消息</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        CancelCallback cancelCallback = (s) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(s + <span class=\"string\">&quot;消费者取消消费接口回调逻辑&quot;</span>);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//采用手动应答</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> autoAck = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        channel.basicConsume(TASK_QUEUE_NAME, autoAck, deliverCallback, cancelCallback);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>消费者 02：</strong></p>\n<p>​    把时间改成30秒</p>\n<p>::: tip 手动应答效果演示</p>\n<p>:::</p>\n<p>正常情况下消息发送方发送两个消息 C1 和 C2 分别接收到消息并进行处理</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000021.png\" alt=\"RabbitMQ-00000021\"></p>\n<p>在发送者发送消息 dd，发出消息之后的把 C2 消费者停掉，按理说该 C2 来处理该消息，但是由于它处理时间较长，在还未处理完，也就是说 C2 还没有执行 ack 代码的时候，C2 被停掉了， 此时会看到消息被 C1 接收到了，说明消息 dd 被重新入队，然后分配给能处理消息的 C1 处理了</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000022.png\" alt=\"RabbitMQ-00000022\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000023.png\" alt=\"RabbitMQ-00000023\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000024.png\" alt=\"RabbitMQ-00000024\"></p>\n<h2 id=\"RabbitMQ-持久化\"><a href=\"#RabbitMQ-持久化\" class=\"headerlink\" title=\"RabbitMQ 持久化\"></a>RabbitMQ 持久化</h2><p>当 RabbitMQ 服务停掉以后，消息生产者发送过来的消息不丢失要如何保障？默认情况下 RabbitMQ 退出或由于某种原因崩溃时，它忽视队列和消息，除非告知它不要这样做。确保消息不会丢失需要做两件事：<strong>我们需要将队列和消息都标记为持久化。</strong></p>\n<p>::: tip 队列如何实现持久化</p>\n<p>:::</p>\n<p>之前我们创建的队列都是非持久化的，rabbitmq 如果重启的化，该队列就会被删除掉，如果要队列实现持久化需要在声明队列的时候把 durable 参数设置为持久化</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//让队列持久化</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> durable = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"><span class=\"comment\">//声明队列</span></span><br><span class=\"line\">channel.queueDeclare(TASK_QUEUE_NAME, durable, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>注意：如果之前声明的队列不是持久化的，需要把原先队列先删除，或者重新创建一个持久化的队列，不然就会出现错误</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000026.png\" alt=\"RabbitMQ-00000026\"></p>\n<p>以下为控制台中持久化与非持久化队列的 UI 显示区、</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000027.png\" alt=\"RabbitMQ-00000027\"></p>\n<p>::: tip 消息实现持久化</p>\n<p>:::</p>\n<p>需要在消息<strong>生产者</strong>修改代码，<code>MessageProperties.PERSISTENT_TEXT_PLAIN</code> 添加这个属性。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000028.png\" alt=\"RabbitMQ-00000028\"></p>\n<p>将消息标记为持久化并不能完全保证不会丢失消息。尽管它告诉 RabbitMQ 将消息保存到磁盘，但是这里依然存在当消息刚准备存储在磁盘的时候 但是还没有存储完，消息还在缓存的一个间隔点。此时并没 有真正写入磁盘。持久性保证并不强，但是对于我们的简单任务队列而言，这已经绰绰有余了。</p>\n<p>如果需要更强有力的持久化策略，参考后边课件发布确认章节。</p>\n<h2 id=\"不公平分发\"><a href=\"#不公平分发\" class=\"headerlink\" title=\"不公平分发\"></a>不公平分发</h2><p>在最开始的时候我们学习到 RabbitMQ 分发消息采用的轮训分发，但是在某种场景下这种策略并不是很好，比方说有两个消费者在处理任务，其中有个<strong>消费者 1</strong> 处理任务的速度非常快，而另外一个<strong>消费者 2</strong> 处理速度却很慢，这个时候我们还是采用轮训分发的化就会到这处理速度快的这个消费者很大一部分时间处于空闲状态，而处理慢的那个消费者一直在干活，这种分配方式在这种情况下其实就不太好，但是 RabbitMQ 并不知道这种情况它依然很公平的进行分发。</p>\n<p>为了避免这种情况，<strong>在消费者中消费之前</strong>，我们可以设置参数 <code>channel.basicQos(1);</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//不公平分发</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> prefetchCount = <span class=\"number\">1</span>;</span><br><span class=\"line\">channel.basicQos(prefetchCount);</span><br><span class=\"line\"><span class=\"comment\">//采用手动应答</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> autoAck = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">channel.basicConsume(TASK_QUEUE_NAME, autoAck, deliverCallback, cancelCallback);</span><br></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000030.png\" alt=\"RabbitMQ-00000030\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000031.png\" alt=\"RabbitMQ-00000031\"></p>\n<p>意思就是如果这个任务我还没有处理完或者我还没有应答你，你先别分配给我，我目前只能处理一个 任务，然后 rabbitmq 就会把该任务分配给没有那么忙的那个空闲消费者，当然如果所有的消费者都没有完 成手上任务，队列还在不停的添加新任务，队列有可能就会遇到队列被撑满的情况，这个时候就只能添加 新的 worker 或者改变其他存储任务的策略。</p>\n<h2 id=\"预取值分发\"><a href=\"#预取值分发\" class=\"headerlink\" title=\"预取值分发\"></a>预取值分发</h2><p>带权的消息分发</p>\n<p>本身消息的发送就是异步发送的，所以在任何时候，channel 上肯定不止只有一个消息另外来自消费 者的手动确认本质上也是异步的。因此这里就存在一个未确认的消息缓冲区，因此希望开发人员能<strong>限制此缓冲区的大小</strong>，<strong>以避免缓冲区里面无限制的未确认消息问题</strong>。这个时候就可以通过使用 basic.qos 方法设 置“预取计数”值来完成的。</p>\n<p>该值定义通道上允许的未确认消息的最大数量。一旦数量达到配置的数量， RabbitMQ 将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认，例如，假设在通道上有未确认的消息 5、6、7，8，并且通道的预取计数设置为 4，此时RabbitMQ 将不会在该通道上再传递任何消息，除非至少有一个未应答的消息被 ack。比方说 tag=6 这个消息刚刚被确认 ACK，RabbitMQ 将会感知 这个情况到并再发送一条消息。消息应答和 QoS 预取值对用户吞吐量有重大影响。</p>\n<p>通常，增加预取将提高 向消费者传递消息的速度。<strong>虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理的消息的数量也会增加，从而增加了消费者的 RAM 消耗</strong>(随机存取存储器)应该小心使用具有无限预处理的自动确认模式或手动确认模式，消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的 内存消耗变大，所以找到合适的预取值是一个反复试验的过程，不同的负载该值取值也不同 100 到 300 范 围内的值通常可提供最佳的吞吐量，并且不会给消费者带来太大的风险。</p>\n<p>预取值为 1 是最保守的。当然这将使吞吐量变得很低，特别是消费者连接延迟很严重的情况下，特别是在消费者连接等待时间较长的环境 中。对于大多数应用来说，稍微高一点的值将是最佳的。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000032.png\" alt=\"RabbitMQ-00000032\"></p>\n<h1 id=\"发布确认\"><a href=\"#发布确认\" class=\"headerlink\" title=\"发布确认\"></a>发布确认</h1><h2 id=\"发布确认原理\"><a href=\"#发布确认原理\" class=\"headerlink\" title=\"发布确认原理\"></a>发布确认原理</h2><p>生产者将信道设置成 confirm 模式，一旦信道进入 confirm 模式，所有在该信道上面发布的消息都将会被指派一个唯一的 ID(从 1 开始)，一旦消息被投递到所有匹配的队列之后，broker 就会发送一个确认给生产者(包含消息的唯一 ID)，这就使得生产者知道消息已经正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker 回传给生产者的确认消息中 delivery-tag 域包含了确认消息的序列号，此外 broker 也可以设置basic.ack 的 multiple 域，表示到这个序列号之前的所有消息都已经得到了处理。</p>\n<p>confirm 模式最大的好处在于他是异步的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消息， 生产者应用程序同样可以在回调方法中处理该 nack 消息。</p>\n<h2 id=\"发布确认的策略\"><a href=\"#发布确认的策略\" class=\"headerlink\" title=\"发布确认的策略\"></a>发布确认的策略</h2><p>开启发布确认的方法:</p>\n<p>发布确认默认是没有开启的，如果要开启需要调用方法 confirmSelect，每当你要想使用发布确认，都需要在 channel 上调用该方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//开启发布确认</span></span><br><span class=\"line\">channel.confirmSelect();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"单个确认发布\"><a href=\"#单个确认发布\" class=\"headerlink\" title=\"单个确认发布\"></a>单个确认发布</h3><p>这是一种简单的确认方式，它是一种<strong>同步确认发布</strong>的方式，也就是发布一个消息之后只有它被确认发布，后续的消息才能继续发布，<code>waitForConfirmsOrDie(long)</code> 这个方法只有在消息被确认的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。</p>\n<p>这种确认方式有一个最大的缺点就是：<strong>发布速度特别的慢</strong>，因为如果没有确认发布的消息就会阻塞所有后续消息的发布，这种方式最多提供每秒不超过数百条发布消息的吞吐量。当然对于某些应用程序来说这可能已经足够了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 单个发送</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">publishMessageIndividually</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\">    <span class=\"comment\">//队列声明</span></span><br><span class=\"line\">    String queueName = UUID.randomUUID().toString();</span><br><span class=\"line\">    channel.queueDeclare(queueName, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    <span class=\"comment\">//开启发布确认</span></span><br><span class=\"line\">    channel.confirmSelect();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">long</span> begin = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class=\"line\">        String message = i + <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        channel.basicPublish(<span class=\"string\">&quot;&quot;</span>, queueName, <span class=\"keyword\">null</span>, message.getBytes());</span><br><span class=\"line\">        <span class=\"comment\">//服务端返回 false 或超时时间内未返回，生产者可以消息重发</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> flag = channel.waitForConfirms();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (flag) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;消息发送成功&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">long</span> end = System.currentTimeMillis();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;发布&quot;</span> + MESSAGE_COUNT + <span class=\"string\">&quot;个单独确认消息,耗时&quot;</span> + (end - begin) + <span class=\"string\">&quot;ms&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"批量确认发布\"><a href=\"#批量确认发布\" class=\"headerlink\" title=\"批量确认发布\"></a>批量确认发布</h3><p>上面那种方式非常慢，与单个等待确认消息相比，先发布一批消息然后一起确认可以极大地提高吞吐量，当然这种方式的缺点就是：当发生故障导致发布出现问题时，不知道是哪个消息出 问题了，我们必须将整个批处理保存在内存中，以记录重要的信息而后重新发布消息。当然这种方案仍然是同步的，也一样阻塞消息的发布。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 批量</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">publishMessageBatch</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\">    <span class=\"comment\">//队列声明</span></span><br><span class=\"line\">    String queueName = UUID.randomUUID().toString();</span><br><span class=\"line\">    channel.queueDeclare(queueName, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    <span class=\"comment\">//开启发布确认</span></span><br><span class=\"line\">    channel.confirmSelect();</span><br><span class=\"line\">    <span class=\"comment\">//批量确认消息大小</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> batchSize = <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"comment\">//未确认消息个数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> outstandingMessageCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> begin = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class=\"line\">        String message = i + <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        channel.basicPublish(<span class=\"string\">&quot;&quot;</span>, queueName, <span class=\"keyword\">null</span>, message.getBytes());</span><br><span class=\"line\">        outstandingMessageCount++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (outstandingMessageCount == batchSize) &#123;</span><br><span class=\"line\">            channel.waitForConfirms();</span><br><span class=\"line\">            outstandingMessageCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//为了确保还有剩余没有确认消息 再次确认</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (outstandingMessageCount &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        channel.waitForConfirms();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> end = System.currentTimeMillis();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;发布&quot;</span> + MESSAGE_COUNT + <span class=\"string\">&quot;个批量确认消息,耗时&quot;</span> + (end - begin) + <span class=\"string\">&quot;ms&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"异步确认发布\"><a href=\"#异步确认发布\" class=\"headerlink\" title=\"异步确认发布\"></a>异步确认发布</h3><p>异步确认虽然编程逻辑比上两个要复杂，但是性价比最高，无论是可靠性还是效率都没得说， 他是利用回调函数来达到消息可靠性传递的，这个中间件也是通过函数回调来保证是否投递成功， 下面就让我们来详细讲解异步确认是怎么实现的。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000034.png\" alt=\"RabbitMQ-00000034\"></p>\n<p>如何处理异步未确认消息?</p>\n<p>最好的解决的解决方案就是把未确认的消息放到一个基于内存的能被发布线程访问的队列， 比如说用 ConcurrentLinkedQueue 这个队列在 confirm callbacks 与发布线程之间进行消息的传递。</p>\n<p><strong>以上 3 种发布确认速度对比 :</strong></p>\n<ul>\n<li><p>单独发布消息</p>\n<p>同步等待确认，简单，但吞吐量非常有限。</p>\n</li>\n<li><p>批量发布消息</p>\n<p>批量同步等待确认，简单，合理的吞吐量，一旦出现问题但很难推断出是那条消息出现了问题。</p>\n</li>\n<li><p>异步处理</p>\n<p>最佳性能和资源使用，在出现错误的情况下可以很好地控制，但是实现起来稍微难些</p>\n</li>\n</ul>\n<h1 id=\"交换机\"><a href=\"#交换机\" class=\"headerlink\" title=\"交换机\"></a>交换机</h1><h2 id=\"Exchanges\"><a href=\"#Exchanges\" class=\"headerlink\" title=\"Exchanges\"></a>Exchanges</h2><p>RabbitMQ 消息传递模型的核心思想是: <strong>生产者生产的消息从不会直接发送到队列</strong>。实际上，通常生产者甚至都不知道这些消息传递传递到了哪些队列中。</p>\n<p>相反，**生产者只能将消息发送到交换机(exchange)**，交换机工作的内容非常简单，一方面它接收来自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息。是应该把这些消息放到特定队列还是说把他们到许多队列中还是说应该丢弃它们。这就的由交换机的类型来决定。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000035.png\" alt=\"RabbitMQ-00000035\"></p>\n<p><strong>Exchanges 的类型：</strong></p>\n<p>​    直接(direct), 主题(topic) ,标题(headers) , 扇出(fanout)</p>\n<p><strong>无名exchange：</strong></p>\n<p>​    在前面部分我们对 exchange 一无所知，但仍然能够将消息发送到队列。之前能实现的 原因是因为我们使用的是默认交换，我们通过空字符串(“”)进行标识。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000036.png\" alt=\"RabbitMQ-00000036\"></p>\n<p>第一个参数是交换机的名称。空字符串表示默认或无名称交换机：消息能路由发送到队列中其实是由 routingKey(bindingkey)绑定 key 指定的，如果它存在的话</p>\n<h2 id=\"临时队列\"><a href=\"#临时队列\" class=\"headerlink\" title=\"临时队列\"></a>临时队列</h2><p>之前的章节我们使用的是具有特定名称的队列(还记得 hello 和 ack_queue 吗？)。队列的名称我们来说至关重要，我们需要指定我们的消费者去消费哪个队列的消息。</p>\n<p>每当我们连接到 Rabbit 时，我们都需要一个全新的空队列，为此我们可以创建一个具有<strong>随机名称的队列</strong>，或者能让服务器为我们选择一个随机队列名称那就更好了。其次一旦我们断开了消费者的连接，队列将被自动删除。</p>\n<p>创建临时队列的方式如下: </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">String queueName = channel.queueDeclare().getQueue();</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000037.png\" alt=\"RabbitMQ-00000037\"></p>\n<h2 id=\"绑定-bindings\"><a href=\"#绑定-bindings\" class=\"headerlink\" title=\"绑定 bindings\"></a>绑定 bindings</h2><p>什么是 bingding 呢，binding 其实是 exchange 和 queue 之间的桥梁，它告诉我们 exchange 和那个队列进行了绑定关系。比如说下面这张图告诉我们的就是 X 与 Q1 和 Q2 进行了绑定</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000038.png\" alt=\"RabbitMQ-00000038\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210627203918539.png\" alt=\"image-20210627203918539\"></p>\n<h2 id=\"Fanout-exchange\"><a href=\"#Fanout-exchange\" class=\"headerlink\" title=\"Fanout exchange\"></a>Fanout exchange</h2><h3 id=\"Fanout-介绍\"><a href=\"#Fanout-介绍\" class=\"headerlink\" title=\"Fanout 介绍\"></a>Fanout 介绍</h3><p>Fanout 这种类型非常简单。正如从名称中猜到的那样，它是将接收到的所有消息广播到它知道的 所有队列中。系统中默认有些 exchange 类型</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000039.png\" alt=\"RabbitMQ-00000039\"></p>\n<h3 id=\"Fanout-实战\"><a href=\"#Fanout-实战\" class=\"headerlink\" title=\"Fanout 实战\"></a>Fanout 实战</h3><p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000040.png\" alt=\"RabbitMQ-00000040\"></p>\n<p>Logs 和临时队列的绑定关系如下图</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000041.png\" alt=\"RabbitMQ-00000041\"></p>\n<p>为了说明这种模式，我们将构建一个简单的日志系统。它将由两个程序组成:第一个程序将发出日志消 息，第二个程序是消费者。其中我们会启动两个消费者，其中一个消费者接收到消息后把日志存储在磁盘，</p>\n<p>ReceiveLogs01 将接收到的消息打印在控制台</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.oddfar.five;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.oddfar.utils.RabbitMqUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.rabbitmq.client.Channel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> zhiyuan</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReceiveLogs01</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String EXCHANGE_NAME = <span class=\"string\">&quot;logs&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\">        channel.exchangeDeclare(EXCHANGE_NAME, <span class=\"string\">&quot;fanout&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 生成一个临时的队列 队列的名称是随机的</span></span><br><span class=\"line\"><span class=\"comment\">         * 当消费者断开和该队列的连接时 队列自动删除</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        String queueName = channel.queueDeclare().getQueue();</span><br><span class=\"line\">        <span class=\"comment\">//把该临时队列绑定我们的 exchange 其中 routingkey(也称之为 binding key)为空字符串</span></span><br><span class=\"line\">        channel.queueBind(queueName, EXCHANGE_NAME, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;等待接收消息,把接收到的消息打印在屏幕........... &quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//发送回调</span></span><br><span class=\"line\">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class=\"line\">            String message = <span class=\"keyword\">new</span> String(delivery.getBody(), <span class=\"string\">&quot;UTF-8&quot;</span>);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;控制台打印接收到的消息&quot;</span> + message);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        channel.basicConsume(queueName, <span class=\"keyword\">true</span>, deliverCallback, consumerTag -&gt; &#123;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ReceiveLogs02 把消息写出到文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReceiveLogs02</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String EXCHANGE_NAME = <span class=\"string\">&quot;logs&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\">        channel.exchangeDeclare(EXCHANGE_NAME, <span class=\"string\">&quot;fanout&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 生成一个临时的队列 队列的名称是随机的</span></span><br><span class=\"line\"><span class=\"comment\">         * 当消费者断开和该队列的连接时 队列自动删除</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        String queueName = channel.queueDeclare().getQueue();</span><br><span class=\"line\">        <span class=\"comment\">//把该临时队列绑定我们的 exchange 其中 routingkey(也称之为 binding key)为空字符串</span></span><br><span class=\"line\">        channel.queueBind(queueName, EXCHANGE_NAME, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;等待接收消息,把接收到的消息写到文件........... &quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//发送回调</span></span><br><span class=\"line\">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class=\"line\">            String message = <span class=\"keyword\">new</span> String(delivery.getBody(), <span class=\"string\">&quot;UTF-8&quot;</span>);</span><br><span class=\"line\">            File file = <span class=\"keyword\">new</span> File(<span class=\"string\">&quot;D:\\\\test\\\\rabbitmq_info.txt&quot;</span>);</span><br><span class=\"line\">            FileUtils.writeStringToFile(file,message,<span class=\"string\">&quot;UTF-8&quot;</span>);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;数据写入文件成功&quot;</span>);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        channel.basicConsume(queueName, <span class=\"keyword\">true</span>, deliverCallback, consumerTag -&gt; &#123;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p>EmitLog 发送消息给两个消费者接收：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EmitLog</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String EXCHANGE_NAME = <span class=\"string\">&quot;logs&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 声明一个 exchange</span></span><br><span class=\"line\"><span class=\"comment\">         * 1.exchange 的名称</span></span><br><span class=\"line\"><span class=\"comment\">         * 2.exchange 的类型</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        channel.exchangeDeclare(EXCHANGE_NAME, <span class=\"string\">&quot;fanout&quot;</span>);</span><br><span class=\"line\">        Scanner sc = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;请输入信息&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (sc.hasNext()) &#123;</span><br><span class=\"line\">            String message = sc.nextLine();</span><br><span class=\"line\">            channel.basicPublish(EXCHANGE_NAME, <span class=\"string\">&quot;&quot;</span>, <span class=\"keyword\">null</span>, message.getBytes(<span class=\"string\">&quot;UTF-8&quot;</span>));</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;生产者发出消息&quot;</span> + message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Direct-exchange\"><a href=\"#Direct-exchange\" class=\"headerlink\" title=\"Direct exchange\"></a>Direct exchange</h2><p>在上一节中，我们构建了一个简单的日志记录系统。我们能够向许多接收者广播日志消息。在本节我们将向其中添加一些特别的功能——让某个消费者订阅发布的部分消息。例如我们只把严重错误消息定向存储到日志文件(以节省磁盘空间)，同时仍然能够在控制台上打印所有日志消息。</p>\n<p>我们再次来回顾一下什么是 bindings，绑定是交换机和队列之间的桥梁关系。也可以这么理解： <strong>队列只对它绑定的交换机的消息感兴趣</strong>。绑定用参数：routingKey 来表示也可称该参数为 binding key， 创建绑定我们用代码:channel.queueBind(queueName, EXCHANGE_NAME, “routingKey”);</p>\n<p>绑定之后的意义由其交换类型决定。</p>\n<h3 id=\"Direct-介绍\"><a href=\"#Direct-介绍\" class=\"headerlink\" title=\"Direct 介绍\"></a>Direct 介绍</h3><p>上一节中的我们的日志系统将所有消息广播给所有消费者，对此我们想做一些改变，例如我们希 望将日志消息写入磁盘的程序仅接收严重错误(errros)，而不存储哪些警告(warning)或信息(info)日志 消息避免浪费磁盘空间。Fanout 这种交换类型并不能给我们带来很大的灵活性-它只能进行无意识的 广播，在这里我们将使用 direct 这种类型来进行替换，这种类型的工作方式是，消息只去到它绑定的 routingKey 队列中去。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000042.png\" alt=\"RabbitMQ-00000042\"></p>\n<p>在上面这张图中，我们可以看到 X 绑定了两个队列，绑定类型是 direct。队列Q1 绑定键为 orange， 队列 Q2 绑定键有两个:一个绑定键为 black，另一个绑定键为 green.</p>\n<p>在这种绑定情况下，生产者发布消息到 exchange 上，绑定键为 orange 的消息会被发布到队列 Q1。绑定键为 blackgreen 和的消息会被发布到队列 Q2，其他消息类型的消息将被丢弃。</p>\n<h3 id=\"多重绑定\"><a href=\"#多重绑定\" class=\"headerlink\" title=\"多重绑定\"></a>多重绑定</h3><p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000043.png\" alt=\"RabbitMQ-00000043\"></p>\n<p>当然如果 exchange 的绑定类型是direct，<strong>但是它绑定的多个队列的 key 如果都相同</strong>，在这种情况下虽然绑定类型是 direct <strong>但是它表现的就和 fanout 有点类似了</strong>，就跟广播差不多，如上图所示。</p>\n<h3 id=\"Direct-实战\"><a href=\"#Direct-实战\" class=\"headerlink\" title=\"Direct 实战\"></a>Direct 实战</h3><p>关系：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000044.png\" alt=\"RabbitMQ-00000044\"></p>\n<p>交换机：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000045.png\" alt=\"RabbitMQ-00000045\"></p>\n<p>c2：绑定disk，routingKey为error</p>\n<p>c1：绑定console，routingKey为info、warning</p>\n<p>1、</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.oddfar.six;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.oddfar.utils.RabbitMqUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.rabbitmq.client.BuiltinExchangeType;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.rabbitmq.client.Channel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> zhiyuan</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReceiveLogsDirect01</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String EXCHANGE_NAME = <span class=\"string\">&quot;direct_logs&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class=\"line\"></span><br><span class=\"line\">        String queueName = <span class=\"string\">&quot;disk&quot;</span>;</span><br><span class=\"line\">        <span class=\"comment\">//队列声明</span></span><br><span class=\"line\">        channel.queueDeclare(queueName, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">//队列绑定</span></span><br><span class=\"line\">        channel.queueBind(queueName, EXCHANGE_NAME, <span class=\"string\">&quot;error&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;等待接收消息...&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//发送回调</span></span><br><span class=\"line\">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class=\"line\">            String message = <span class=\"keyword\">new</span> String(delivery.getBody(), <span class=\"string\">&quot;UTF-8&quot;</span>);</span><br><span class=\"line\">            message = <span class=\"string\">&quot;接收绑定键:&quot;</span> + delivery.getEnvelope().getRoutingKey() + <span class=\"string\">&quot;,消息:&quot;</span> + message;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;error 消息已经接收：\\n&quot;</span> + message);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        channel.basicConsume(queueName, <span class=\"keyword\">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2、</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReceiveLogsDirect02</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String EXCHANGE_NAME = <span class=\"string\">&quot;direct_logs&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class=\"line\"></span><br><span class=\"line\">        String queueName = <span class=\"string\">&quot;console&quot;</span>;</span><br><span class=\"line\">        <span class=\"comment\">//队列声明</span></span><br><span class=\"line\">        channel.queueDeclare(queueName, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">//队列绑定</span></span><br><span class=\"line\">        channel.queueBind(queueName, EXCHANGE_NAME, <span class=\"string\">&quot;info&quot;</span>);</span><br><span class=\"line\">        channel.queueBind(queueName, EXCHANGE_NAME, <span class=\"string\">&quot;warning&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;等待接收消息...&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//发送回调</span></span><br><span class=\"line\">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class=\"line\">            String message = <span class=\"keyword\">new</span> String(delivery.getBody(), <span class=\"string\">&quot;UTF-8&quot;</span>);</span><br><span class=\"line\">            message = <span class=\"string\">&quot;接收绑定键:&quot;</span> + delivery.getEnvelope().getRoutingKey() + <span class=\"string\">&quot;,消息:&quot;</span> + message;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;info和warning 消息已经接收：\\n&quot;</span> + message);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        channel.basicConsume(queueName, <span class=\"keyword\">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3、</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EmitLogDirect</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String EXCHANGE_NAME = <span class=\"string\">&quot;direct_logs&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//创建多个 bindingKey</span></span><br><span class=\"line\">        Map&lt;String, String&gt; bindingKeyMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        bindingKeyMap.put(<span class=\"string\">&quot;info&quot;</span>, <span class=\"string\">&quot;普通 info 信息&quot;</span>);</span><br><span class=\"line\">        bindingKeyMap.put(<span class=\"string\">&quot;warning&quot;</span>, <span class=\"string\">&quot;警告 warning 信息&quot;</span>);</span><br><span class=\"line\">        bindingKeyMap.put(<span class=\"string\">&quot;error&quot;</span>, <span class=\"string\">&quot;错误 error 信息&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//debug 没有消费这接收这个消息 所有就丢失了</span></span><br><span class=\"line\">        bindingKeyMap.put(<span class=\"string\">&quot;debug&quot;</span>, <span class=\"string\">&quot;调试 debug 信息&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Map.Entry&lt;String, String&gt; bindingKeyEntry : bindingKeyMap.entrySet()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//获取 key value</span></span><br><span class=\"line\">            String bindingKey = bindingKeyEntry.getKey();</span><br><span class=\"line\">            String message = bindingKeyEntry.getValue();</span><br><span class=\"line\"></span><br><span class=\"line\">            channel.basicPublish(EXCHANGE_NAME, bindingKey, <span class=\"keyword\">null</span>, message.getBytes(<span class=\"string\">&quot;UTF-8&quot;</span>));</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;生产者发出消息:&quot;</span> + message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Topics-exchange\"><a href=\"#Topics-exchange\" class=\"headerlink\" title=\"Topics exchange\"></a>Topics exchange</h2><h3 id=\"Topic-的介绍\"><a href=\"#Topic-的介绍\" class=\"headerlink\" title=\"Topic 的介绍\"></a>Topic 的介绍</h3><p>在上一个小节中，我们改进了日志记录系统。我们没有使用只能进行随意广播的 fanout 交换机，而是使用了 direct 交换机，从而有能实现有选择性地接收日志。</p>\n<p>尽管使用 direct 交换机改进了我们的系统，但是它仍然存在局限性——比方说我们想接收的日志类型有 info.base 和 info.advantage，某个队列只想 info.base 的消息，那这个时候direct 就办不到了。这个时候就只能使用 <strong>topic</strong> 类型</p>\n<p>::: tip Topic的要求</p>\n<p>:::</p>\n<p>发送到类型是 topic 交换机的消息的 routing_key 不能随意写，必须满足一定的要求，它必须是<strong>一个单词列表</strong>，<strong>以点号分隔开</strong>。这些单词可以是任意单词</p>\n<p>比如说：”stock.usd.nyse”, “nyse.vmw”, “quick.orange.rabbit”.这种类型的。</p>\n<p>当然这个单词列表最多不能超过 255 个字节。</p>\n<p>在这个规则列表中，其中有两个替换符是大家需要注意的：</p>\n<ul>\n<li>***(星号)可以代替一个单词**</li>\n<li><strong>#(井号)可以替代零个或多个单词</strong></li>\n</ul>\n<h3 id=\"Topic-匹配案例\"><a href=\"#Topic-匹配案例\" class=\"headerlink\" title=\"Topic 匹配案例\"></a>Topic 匹配案例</h3><p>下图绑定关系如下</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000046.png\" alt=\"RabbitMQ-00000046\"></p>\n<ul>\n<li><p>Q1–&gt;绑定的是</p>\n<ul>\n<li>中间带 orange 带 3 个单词的字符串 <code>(*.orange.*)</code></li>\n</ul>\n</li>\n<li><p>Q2–&gt;绑定的是</p>\n<ul>\n<li>最后一个单词是 rabbit 的 3 个单词 <code>(*.*.rabbit)</code></li>\n<li>第一个单词是 lazy 的多个单词 <code>(lazy.#)</code></li>\n</ul>\n</li>\n</ul>\n<p>上图是一个队列绑定关系图，我们来看看他们之间数据接收情况是怎么样的</p>\n<table>\n<thead>\n<tr>\n<th>例子</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>quick.orange.rabbit</td>\n<td>被队列 Q1Q2 接收到</td>\n</tr>\n<tr>\n<td>azy.orange.elephant</td>\n<td>被队列 Q1Q2 接收到</td>\n</tr>\n<tr>\n<td>quick.orange.fox</td>\n<td>被队列 Q1 接收到</td>\n</tr>\n<tr>\n<td>lazy.brown.fox</td>\n<td>被队列 Q2 接收到</td>\n</tr>\n<tr>\n<td>lazy.pink.rabbit</td>\n<td>虽然满足两个绑定但只被队列 Q2 接收一次</td>\n</tr>\n<tr>\n<td>quick.brown.fox</td>\n<td>不匹配任何绑定不会被任何队列接收到会被丢弃</td>\n</tr>\n<tr>\n<td>quick.orange.male.rabbit</td>\n<td>是四个单词不匹配任何绑定会被丢弃</td>\n</tr>\n<tr>\n<td>lazy.orange.male.rabbit</td>\n<td>是四个单词但匹配 Q2</td>\n</tr>\n</tbody></table>\n<p>注意：</p>\n<ul>\n<li>当一个队列绑定键是#，那么这个队列将接收所有数据，就有点像 fanout 了</li>\n<li>如果队列绑定键当中没有#和*出现，那么该队列绑定类型就是 direct 了</li>\n</ul>\n<h3 id=\"Topic-实战\"><a href=\"#Topic-实战\" class=\"headerlink\" title=\"Topic 实战\"></a>Topic 实战</h3><p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000047.png\" alt=\"RabbitMQ-00000047\"></p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.oddfar.seven;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.oddfar.utils.RabbitMqUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.rabbitmq.client.BuiltinExchangeType;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.rabbitmq.client.Channel;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 发送端</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> zhiyuan</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EmitLogTopic</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String EXCHANGE_NAME = <span class=\"string\">&quot;topic_logs&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * Q1--&gt;绑定的是</span></span><br><span class=\"line\"><span class=\"comment\">         *      中间带 orange 带 3 个单词的字符串(*.orange.*)</span></span><br><span class=\"line\"><span class=\"comment\">         * Q2--&gt;绑定的是</span></span><br><span class=\"line\"><span class=\"comment\">         *      最后一个单词是 rabbit 的 3 个单词(*.*.rabbit)</span></span><br><span class=\"line\"><span class=\"comment\">         *      第一个单词是 lazy 的多个单词(lazy.#)</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        Map&lt;String, String&gt; bindingKeyMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        bindingKeyMap.put(<span class=\"string\">&quot;quick.orange.rabbit&quot;</span>, <span class=\"string\">&quot;被队列 Q1Q2 接收到&quot;</span>);</span><br><span class=\"line\">        bindingKeyMap.put(<span class=\"string\">&quot;lazy.orange.elephant&quot;</span>, <span class=\"string\">&quot;被队列 Q1Q2 接收到&quot;</span>);</span><br><span class=\"line\">        bindingKeyMap.put(<span class=\"string\">&quot;quick.orange.fox&quot;</span>, <span class=\"string\">&quot;被队列 Q1 接收到&quot;</span>);</span><br><span class=\"line\">        bindingKeyMap.put(<span class=\"string\">&quot;lazy.brown.fox&quot;</span>, <span class=\"string\">&quot;被队列 Q2 接收到&quot;</span>);</span><br><span class=\"line\">        bindingKeyMap.put(<span class=\"string\">&quot;lazy.pink.rabbit&quot;</span>, <span class=\"string\">&quot;虽然满足两个绑定但只被队列 Q2 接收一次&quot;</span>);</span><br><span class=\"line\">        bindingKeyMap.put(<span class=\"string\">&quot;quick.brown.fox&quot;</span>, <span class=\"string\">&quot;不匹配任何绑定不会被任何队列接收到会被丢弃&quot;</span>);</span><br><span class=\"line\">        bindingKeyMap.put(<span class=\"string\">&quot;quick.orange.male.rabbit&quot;</span>, <span class=\"string\">&quot;是四个单词不匹配任何绑定会被丢弃&quot;</span>);</span><br><span class=\"line\">        bindingKeyMap.put(<span class=\"string\">&quot;lazy.orange.male.rabbit&quot;</span>, <span class=\"string\">&quot;是四个单词但匹配 Q2&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Map.Entry&lt;String, String&gt; bindingKeyEntry : bindingKeyMap.entrySet()) &#123;</span><br><span class=\"line\">            String bindingKey = bindingKeyEntry.getKey();</span><br><span class=\"line\">            String message = bindingKeyEntry.getValue();</span><br><span class=\"line\"></span><br><span class=\"line\">            channel.basicPublish(EXCHANGE_NAME, bindingKey, <span class=\"keyword\">null</span>, message.getBytes(<span class=\"string\">&quot;UTF-8&quot;</span>));</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;生产者发出消息：&quot;</span> + message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReceiveLogsTopic01</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String EXCHANGE_NAME = <span class=\"string\">&quot;topic_logs&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);</span><br><span class=\"line\">        <span class=\"comment\">//声明 Q1 队列与绑定关系</span></span><br><span class=\"line\">        String queueName = <span class=\"string\">&quot;Q1&quot;</span>;</span><br><span class=\"line\">        <span class=\"comment\">//声明</span></span><br><span class=\"line\">        channel.queueDeclare(queueName, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">//绑定</span></span><br><span class=\"line\">        channel.queueBind(queueName, EXCHANGE_NAME, <span class=\"string\">&quot;*.orange.*&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;等待接收消息........... &quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class=\"line\">            String message = <span class=\"keyword\">new</span> String(delivery.getBody(), <span class=\"string\">&quot;UTF-8&quot;</span>);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot; 接收队列:&quot;</span> + queueName + <span class=\"string\">&quot; 绑定键:&quot;</span> + delivery.getEnvelope().getRoutingKey() + <span class=\"string\">&quot;,消息:&quot;</span> + message);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        channel.basicConsume(queueName, <span class=\"keyword\">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReceiveLogsTopic02</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String EXCHANGE_NAME = <span class=\"string\">&quot;topic_logs&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);</span><br><span class=\"line\">        <span class=\"comment\">//声明 Q2 队列与绑定关系</span></span><br><span class=\"line\">        String queueName = <span class=\"string\">&quot;Q2&quot;</span>;</span><br><span class=\"line\">        <span class=\"comment\">//声明</span></span><br><span class=\"line\">        channel.queueDeclare(queueName, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">//绑定</span></span><br><span class=\"line\">        channel.queueBind(queueName, EXCHANGE_NAME, <span class=\"string\">&quot;*.*.rabbit&quot;</span>);</span><br><span class=\"line\">        channel.queueBind(queueName, EXCHANGE_NAME, <span class=\"string\">&quot;lazy.#&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;等待接收消息........... &quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class=\"line\">            String message = <span class=\"keyword\">new</span> String(delivery.getBody(), <span class=\"string\">&quot;UTF-8&quot;</span>);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot; 接收队列:&quot;</span> + queueName + <span class=\"string\">&quot; 绑定键:&quot;</span> + delivery.getEnvelope().getRoutingKey() + <span class=\"string\">&quot;,消息:&quot;</span> + message);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        channel.basicConsume(queueName, <span class=\"keyword\">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"死信队列\"><a href=\"#死信队列\" class=\"headerlink\" title=\"死信队列\"></a>死信队列</h1><h2 id=\"死信的概念\"><a href=\"#死信的概念\" class=\"headerlink\" title=\"死信的概念\"></a>死信的概念</h2><p>先从概念解释上搞清楚这个定义，死信，顾名思义就是无法被消费的消息，字面意思可以这样理 解，一般来说，producer 将消息投递到 broker 或者直接到queue 里了，consumer 从 queue 取出消息 进行消费，但某些时候由于特定的原因<strong>导致 queue 中的某些消息无法被消费</strong>，这样的消息如果没有后续的处理，就变成了死信，有死信自然就有了死信队列。</p>\n<p>应用场景：为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息消费发生异常时，将消息投入死信队列中。还有比如说：用户在商城下单成功并点击去支付后在指定时间未支付时自动失效</p>\n<h2 id=\"死信的来源\"><a href=\"#死信的来源\" class=\"headerlink\" title=\"死信的来源\"></a>死信的来源</h2><ul>\n<li><p>消息 TTL 过期</p>\n<p>TTL是Time To Live的缩写, 也就是生存时间</p>\n</li>\n<li><p>队列达到最大长度</p>\n<p>队列满了，无法再添加数据到 mq 中</p>\n</li>\n<li><p>消息被拒绝</p>\n<p>(basic.reject 或 basic.nack) 并且 requeue=false.</p>\n</li>\n</ul>\n<h2 id=\"死信实战\"><a href=\"#死信实战\" class=\"headerlink\" title=\"死信实战\"></a>死信实战</h2><p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000048.png\" alt=\"RabbitMQ-00000048\"></p>\n<h3 id=\"死信之TTl\"><a href=\"#死信之TTl\" class=\"headerlink\" title=\"死信之TTl\"></a>死信之TTl</h3><p>消费者 C1 代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 死信队列 - 消费者01</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> zhiyuan</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Consumer01</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//普通交换机名称</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String NORMAL_EXCHANGE = <span class=\"string\">&quot;normal_exchange&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//死信交换机名称</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String DEAD_EXCHANGE = <span class=\"string\">&quot;dead_exchange&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//声明死信和普通交换机 类型为 direct</span></span><br><span class=\"line\">        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class=\"line\">        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//声明死信队列</span></span><br><span class=\"line\">        String deadQueue = <span class=\"string\">&quot;dead-queue&quot;</span>;</span><br><span class=\"line\">        channel.queueDeclare(deadQueue, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">//死信队列绑定：队列、交换机、路由键（routingKey）</span></span><br><span class=\"line\">        channel.queueBind(deadQueue, DEAD_EXCHANGE, <span class=\"string\">&quot;lisi&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//正常队列绑定死信队列信息</span></span><br><span class=\"line\">        Map&lt;String, Object&gt; params = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">//正常队列设置死信交换机 参数 key 是固定值</span></span><br><span class=\"line\">        params.put(<span class=\"string\">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE);</span><br><span class=\"line\">        <span class=\"comment\">//正常队列设置死信 routing-key 参数 key 是固定值</span></span><br><span class=\"line\">        params.put(<span class=\"string\">&quot;x-dead-letter-routing-key&quot;</span>, <span class=\"string\">&quot;lisi&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//正常队列</span></span><br><span class=\"line\">        String normalQueue = <span class=\"string\">&quot;normal-queue&quot;</span>;</span><br><span class=\"line\">        channel.queueDeclare(normalQueue, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, params);</span><br><span class=\"line\">        channel.queueBind(normalQueue, NORMAL_EXCHANGE, <span class=\"string\">&quot;zhangsan&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;等待接收消息........... &quot;</span>);</span><br><span class=\"line\">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class=\"line\">            String message = <span class=\"keyword\">new</span> String(delivery.getBody(), <span class=\"string\">&quot;UTF-8&quot;</span>);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Consumer01 接收到消息&quot;</span> + message);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        channel.basicConsume(normalQueue, <span class=\"keyword\">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>生产者代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Producer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String NORMAL_EXCHANGE = <span class=\"string\">&quot;normal_exchange&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] argv)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class=\"line\">        <span class=\"comment\">//设置消息的 TTL 时间 10s</span></span><br><span class=\"line\">        AMQP.BasicProperties properties = <span class=\"keyword\">new</span> AMQP.BasicProperties().builder().expiration(<span class=\"string\">&quot;10000&quot;</span>).build();</span><br><span class=\"line\">        <span class=\"comment\">//该信息是用作演示队列个数限制</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"number\">11</span>; i++) &#123;</span><br><span class=\"line\">            String message = <span class=\"string\">&quot;info&quot;</span> + i;</span><br><span class=\"line\">            channel.basicPublish(NORMAL_EXCHANGE, <span class=\"string\">&quot;zhangsan&quot;</span>, properties, message.getBytes());</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;生产者发送消息:&quot;</span> + message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>启动 C1 ，之后关闭消费者，模拟其接收不到消息。再启动 Producer</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000049.png\" alt=\"RabbitMQ-00000049\"></p>\n<p>消费者 C2 代码：</p>\n<p>以上步骤完成后，启动 C2 消费者，它消费死信队列里面的消息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Consumer02</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//死信交换机名称</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String DEAD_EXCHANGE = <span class=\"string\">&quot;dead_exchange&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//声明交换机</span></span><br><span class=\"line\">        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class=\"line\">        <span class=\"comment\">//声明队列</span></span><br><span class=\"line\">        String deadQueue = <span class=\"string\">&quot;dead-queue&quot;</span>;</span><br><span class=\"line\">        channel.queueDeclare(deadQueue, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        channel.queueBind(deadQueue, DEAD_EXCHANGE, <span class=\"string\">&quot;lisi&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;等待接收死信消息........... &quot;</span>);</span><br><span class=\"line\">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class=\"line\">            String message = <span class=\"keyword\">new</span> String(delivery.getBody(), <span class=\"string\">&quot;UTF-8&quot;</span>);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Consumer02 接收到消息&quot;</span> + message);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        channel.basicConsume(deadQueue, <span class=\"keyword\">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000050.png\" alt=\"RabbitMQ-00000050\"></p>\n<h3 id=\"死信之最大长度\"><a href=\"#死信之最大长度\" class=\"headerlink\" title=\"死信之最大长度\"></a>死信之最大长度</h3><p>1、消息生产者代码去掉 TTL 属性</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210628101337825.png\" alt=\"image-20210628101337825\"></p>\n<p>2、C1 消费者修改以下代码**(启动之后关闭该消费者 模拟其接收不到消息)**</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000051.png\" alt=\"RabbitMQ-00000051\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//设置正常队列的长度限制，例如发10个，4个则为死信</span></span><br><span class=\"line\">params.put(<span class=\"string\">&quot;x-max-length&quot;</span>,<span class=\"number\">6</span>);</span><br></pre></td></tr></table></figure>\n\n<p><mark>注意此时需要把原先队列删除 因为参数改变了</mark></p>\n<p>3、C2 消费者代码不变(启动 C2 消费者) </p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000052.png\" alt=\"RabbitMQ-00000052\"></p>\n<h3 id=\"死信之消息被拒\"><a href=\"#死信之消息被拒\" class=\"headerlink\" title=\"死信之消息被拒\"></a>死信之消息被拒</h3><p>1、消息生产者代码同上生产者一致</p>\n<p>2、C1 消费者代码(启动之后关闭该消费者 模拟其接收不到消息)</p>\n<p>拒收消息 “info5” </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Consumer01</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//普通交换机名称</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String NORMAL_EXCHANGE = <span class=\"string\">&quot;normal_exchange&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//死信交换机名称</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String DEAD_EXCHANGE = <span class=\"string\">&quot;dead_exchange&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//声明死信和普通交换机 类型为 direct</span></span><br><span class=\"line\">        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class=\"line\">        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//声明死信队列</span></span><br><span class=\"line\">        String deadQueue = <span class=\"string\">&quot;dead-queue&quot;</span>;</span><br><span class=\"line\">        channel.queueDeclare(deadQueue, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">//死信队列绑定：队列、交换机、路由键（routingKey）</span></span><br><span class=\"line\">        channel.queueBind(deadQueue, DEAD_EXCHANGE, <span class=\"string\">&quot;lisi&quot;</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//正常队列绑定死信队列信息</span></span><br><span class=\"line\">        Map&lt;String, Object&gt; params = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">//正常队列设置死信交换机 参数 key 是固定值</span></span><br><span class=\"line\">        params.put(<span class=\"string\">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE);</span><br><span class=\"line\">        <span class=\"comment\">//正常队列设置死信 routing-key 参数 key 是固定值</span></span><br><span class=\"line\">        params.put(<span class=\"string\">&quot;x-dead-letter-routing-key&quot;</span>, <span class=\"string\">&quot;lisi&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//        //设置正常队列的长度限制，例如发10个，4个则为死信</span></span><br><span class=\"line\"><span class=\"comment\">//        params.put(&quot;x-max-length&quot;,6);</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//正常队列</span></span><br><span class=\"line\">        String normalQueue = <span class=\"string\">&quot;normal-queue&quot;</span>;</span><br><span class=\"line\">        channel.queueDeclare(normalQueue, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, params);</span><br><span class=\"line\">        channel.queueBind(normalQueue, NORMAL_EXCHANGE, <span class=\"string\">&quot;zhangsan&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;等待接收消息........... &quot;</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class=\"line\">            String message = <span class=\"keyword\">new</span> String(delivery.getBody(), <span class=\"string\">&quot;UTF-8&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (message.equals(<span class=\"string\">&quot;info5&quot;</span>)) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;Consumer01 接收到消息&quot;</span> + message + <span class=\"string\">&quot;并拒绝签收该消息&quot;</span>);</span><br><span class=\"line\">                <span class=\"comment\">//requeue 设置为 false 代表拒绝重新入队 该队列如果配置了死信交换机将发送到死信队列中</span></span><br><span class=\"line\">                channel.basicReject(delivery.getEnvelope().getDeliveryTag(), <span class=\"keyword\">false</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;Consumer01 接收到消息&quot;</span> + message);</span><br><span class=\"line\">                channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class=\"keyword\">false</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"comment\">//开启手动应答</span></span><br><span class=\"line\">        channel.basicConsume(normalQueue, <span class=\"keyword\">false</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000053.png\" alt=\"RabbitMQ-00000053\"></p>\n<p>3、C2 消费者代码不变</p>\n<p>启动消费者 1 然后再启动消费者 2 </p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000054.png\" alt=\"RabbitMQ-00000054\"></p>\n<h1 id=\"延迟队列\"><a href=\"#延迟队列\" class=\"headerlink\" title=\"延迟队列\"></a>延迟队列</h1><h2 id=\"延迟队列介绍\"><a href=\"#延迟队列介绍\" class=\"headerlink\" title=\"延迟队列介绍\"></a>延迟队列介绍</h2><ul>\n<li><strong>延迟队列概念：</strong></li>\n</ul>\n<p>延时队列,队列内部是有序的，最重要的特性就体现在它的延时属性上，延时队列中的元素是希望 在指定时间到了以后或之前取出和处理，简单来说，延时队列就是用来存放需要在指定时间被处理的 元素的队列。</p>\n<ul>\n<li><strong>延迟队列使用场景：</strong></li>\n</ul>\n<p>1.订单在十分钟之内未支付则自动取消<br>2.新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒。<br>3.用户注册成功后，如果三天内没有登陆则进行短信提醒。<br>4.用户发起退款，如果三天内没有得到处理则通知相关运营人员。<br>5.预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议</p>\n<p>这些场景都有一个特点，需要在某个事件发生之后或者之前的指定时间点完成某一项任务，如： 发生订单生成事件，在十分钟之后检查该订单支付状态，然后将未支付的订单进行关闭；那我们一直轮询数据，每秒查一次，取出需要被处理的数据，然后处理不就完事了吗？</p>\n<p>如果数据量比较少，确实可以这样做，比如：对于“如果账单一周内未支付则进行自动结算”这样的需求， 如果对于时间不是严格限制，而是宽松意义上的一周，那么每天晚上跑个定时任务检查一下所有未支付的账单，确实也是一个可行的方案。但对于数据量比较大，并且时效性较强的场景，如：“订单十分钟内未支付则关闭“，短期内未支付的订单数据可能会有很多，活动期间甚至会达到百万甚至千万级别，对这么庞大的数据量仍旧使用轮询的方式显然是不可取的，很可能在一秒内无法完成所有订单的检查，同时会给数据库带来很大压力，无法满足业务要求而且性能低下。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000055.png\" alt=\"RabbitMQ-00000055\"></p>\n<h2 id=\"RabbitMQ-中的-TTL\"><a href=\"#RabbitMQ-中的-TTL\" class=\"headerlink\" title=\"RabbitMQ 中的 TTL\"></a>RabbitMQ 中的 TTL</h2><p>TTL 是什么呢？TTL 是 RabbitMQ 中一个消息或者队列的属性，表明一条消息或者该队列中的所有消息的最大存活时间，单位是毫秒。</p>\n<p>换句话说，如果一条消息设置了 TTL 属性或者进入了设置TTL 属性的队列，那么这条消息如果在 TTL 设置的时间内没有被消费，则会成为”死信”。如果同时配置了队列的TTL 和消息的 TTL，那么较小的那个值将会被使用，有两种方式设置 TTL。</p>\n<ul>\n<li><strong>队列设置TTL</strong></li>\n</ul>\n<p>在创建队列的时候设置队列的“x-message-ttl”属性</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000057.png\" alt=\"RabbitMQ-00000057\"></p>\n<ul>\n<li><strong>消息设置TTL</strong></li>\n</ul>\n<p>是针对每条消息设置TTL</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000056.png\" alt=\"RabbitMQ-00000056\"></p>\n<p>::: tip 两者的区别 </p>\n<p>:::</p>\n<p>如果设置了队列的 TTL 属性，那么一旦消息过期，就会被队列丢弃(如果配置了死信队列被丢到死信队列中)，而第二种方式，消息即使过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者之前判定的，如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间；</p>\n<p>另外，还需要注意的一点是，如果不设置 TTL，表示消息永远不会过期，如果将 TTL 设置为 0，则表示除非此时可以直接投递该消息到消费者，否则该消息将会被丢弃。</p>\n<h2 id=\"整合-springboot\"><a href=\"#整合-springboot\" class=\"headerlink\" title=\"整合 springboot\"></a>整合 springboot</h2><p>前一小节我们介绍了死信队列，刚刚又介绍了 TTL，至此利用 RabbitMQ 实现延时队列的两大要素已经集齐，接下来只需要将它们进行融合，再加入一点点调味料，延时队列就可以新鲜出炉了。想想看，延时队列，不就是想要消息延迟多久被处理吗，TTL 则刚好能让消息在延迟多久之后成为死信，另一方面， 成为死信的消息都会被投递到死信队列里，这样只需要消费者一直消费死信队列里的消息就完事了，因为里面的消息都是希望被立即处理的消息。</p>\n<p>1、创建一个空项目：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000058.png\" alt=\"RabbitMQ-00000058\"></p>\n<p>2、添加依赖：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--RabbitMQ 依赖--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-test<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.alibaba<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>fastjson<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.2.47<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.projectlombok<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>lombok<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--swagger--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>io.springfox<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>springfox-swagger2<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.0.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>io.springfox<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>springfox-swagger-ui<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.0.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--RabbitMQ 测试依赖--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.amqp<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-rabbit-test<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>3、修改配置文件</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">spring.rabbitmq.host</span>=<span class=\"string\">42.192.149.71</span></span><br><span class=\"line\"><span class=\"meta\">spring.rabbitmq.port</span>=<span class=\"string\">5672</span></span><br><span class=\"line\"><span class=\"meta\">spring.rabbitmq.username</span>=<span class=\"string\">admin</span></span><br><span class=\"line\"><span class=\"meta\">spring.rabbitmq.password</span>=<span class=\"string\">123456</span></span><br></pre></td></tr></table></figure>\n\n<p>4、添加Swagger 配置类 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.oddfar.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> springfox.documentation.builders.ApiInfoBuilder;</span><br><span class=\"line\"><span class=\"keyword\">import</span> springfox.documentation.service.ApiInfo;</span><br><span class=\"line\"><span class=\"keyword\">import</span> springfox.documentation.service.Contact;</span><br><span class=\"line\"><span class=\"keyword\">import</span> springfox.documentation.spi.DocumentationType;</span><br><span class=\"line\"><span class=\"keyword\">import</span> springfox.documentation.spring.web.plugins.Docket;</span><br><span class=\"line\"><span class=\"keyword\">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableSwagger2</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SwaggerConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Docket <span class=\"title\">webApiConfig</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class=\"line\">                .groupName(<span class=\"string\">&quot;webApi&quot;</span>)</span><br><span class=\"line\">                .apiInfo(webApiInfo())</span><br><span class=\"line\">                .select()</span><br><span class=\"line\">                .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> ApiInfo <span class=\"title\">webApiInfo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ApiInfoBuilder()</span><br><span class=\"line\">                .title(<span class=\"string\">&quot;rabbitmq 接口文档&quot;</span>)</span><br><span class=\"line\">                .description(<span class=\"string\">&quot;本文档描述了 rabbitmq 微服务接口定义&quot;</span>)</span><br><span class=\"line\">                .version(<span class=\"string\">&quot;1.0&quot;</span>)</span><br><span class=\"line\">                .contact(<span class=\"keyword\">new</span> Contact(<span class=\"string\">&quot;zhiyuan&quot;</span>, <span class=\"string\">&quot;http://oddfar.com&quot;</span>, <span class=\"string\">&quot;test@qq.com&quot;</span>))</span><br><span class=\"line\">                .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"队列-TTL\"><a href=\"#队列-TTL\" class=\"headerlink\" title=\"队列 TTL\"></a>队列 TTL</h2><ul>\n<li><strong>代码架构图</strong> </li>\n</ul>\n<p>创建两个队列 QA 和 QB，两者队列 TTL 分别设置为 10S 和 40S，然后在创建一个交换机 X 和死信交 换机 Y，它们的类型都是direct，创建一个死信队列 QD，它们的绑定关系如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000060.png\" alt=\"RabbitMQ-00000060\"></p>\n<p>原先配置队列信息，写在了生产者和消费者代码中，现在可写咋配置类中，生产者只发消息，消费者只接受消息</p>\n<p><strong>1、配置文件类代码 ：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.oddfar.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.core.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> zhiyuan</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TtlQueueConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String X_EXCHANGE = <span class=\"string\">&quot;X&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String QUEUE_A = <span class=\"string\">&quot;QA&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String QUEUE_B = <span class=\"string\">&quot;QB&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//死信交换机</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String Y_DEAD_LETTER_EXCHANGE = <span class=\"string\">&quot;Y&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//死信队列</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String DEAD_LETTER_QUEUE = <span class=\"string\">&quot;QD&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 声明 xExchange</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;xExchange&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DirectExchange <span class=\"title\">xExchange</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DirectExchange(X_EXCHANGE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 声明 死信队列交换机</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;yExchange&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DirectExchange <span class=\"title\">yExchange</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DirectExchange(Y_DEAD_LETTER_EXCHANGE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//声明队列 A ttl 为 10s 并绑定到对应的死信交换机</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;queueA&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">queueA</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;String, Object&gt; args = <span class=\"keyword\">new</span> HashMap&lt;&gt;(<span class=\"number\">3</span>);</span><br><span class=\"line\">        <span class=\"comment\">//声明当前队列绑定的死信交换机</span></span><br><span class=\"line\">        args.put(<span class=\"string\">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);</span><br><span class=\"line\">        <span class=\"comment\">//声明当前队列的死信路由 key</span></span><br><span class=\"line\">        args.put(<span class=\"string\">&quot;x-dead-letter-routing-key&quot;</span>, <span class=\"string\">&quot;YD&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//声明队列的 TTL</span></span><br><span class=\"line\">        args.put(<span class=\"string\">&quot;x-message-ttl&quot;</span>, <span class=\"number\">10000</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> QueueBuilder.durable(QUEUE_A).withArguments(args).build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 声明队列 A 绑定 X 交换机</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">queueaBindingX</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;queueA&quot;)</span> Queue queueA,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                  <span class=\"meta\">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(queueA).to(xExchange).with(<span class=\"string\">&quot;XA&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//声明队列 B ttl 为 40s 并绑定到对应的死信交换机</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;queueB&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">queueB</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;String, Object&gt; args = <span class=\"keyword\">new</span> HashMap&lt;&gt;(<span class=\"number\">3</span>);</span><br><span class=\"line\">        <span class=\"comment\">//声明当前队列绑定的死信交换机</span></span><br><span class=\"line\">        args.put(<span class=\"string\">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);</span><br><span class=\"line\">        <span class=\"comment\">//声明当前队列的死信路由 key</span></span><br><span class=\"line\">        args.put(<span class=\"string\">&quot;x-dead-letter-routing-key&quot;</span>, <span class=\"string\">&quot;YD&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//声明队列的 TTL</span></span><br><span class=\"line\">        args.put(<span class=\"string\">&quot;x-message-ttl&quot;</span>, <span class=\"number\">40000</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> QueueBuilder.durable(QUEUE_B).withArguments(args).build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//声明队列 B 绑定 X 交换机</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">queuebBindingX</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;queueB&quot;)</span> Queue queue1B,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                  <span class=\"meta\">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(queue1B).to(xExchange).with(<span class=\"string\">&quot;XB&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//声明死信队列 QD</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;queueD&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">queueD</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(DEAD_LETTER_QUEUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//声明死信队列 QD 绑定关系</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">deadLetterBindingQAD</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;queueD&quot;)</span> Queue queueD,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                        <span class=\"meta\">@Qualifier(&quot;yExchange&quot;)</span> DirectExchange yExchange)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(queueD).to(yExchange).with(<span class=\"string\">&quot;YD&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>2、消息生产者代码</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.oddfar.contorller;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Controller;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Date;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> zhiyuan</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping(&quot;ttl&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SendMsgController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;sendMsg/&#123;message&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sendMsg</span><span class=\"params\">(<span class=\"meta\">@PathVariable</span> String message)</span> </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;当前时间：&#123;&#125;,发送一条信息给两个 TTL 队列:&#123;&#125;&quot;</span>, <span class=\"keyword\">new</span> Date(), message);</span><br><span class=\"line\">        rabbitTemplate.convertAndSend(<span class=\"string\">&quot;X&quot;</span>, <span class=\"string\">&quot;XA&quot;</span>, <span class=\"string\">&quot;消息来自 ttl 为 10S 的队列: &quot;</span> + message);</span><br><span class=\"line\">        rabbitTemplate.convertAndSend(<span class=\"string\">&quot;X&quot;</span>, <span class=\"string\">&quot;XB&quot;</span>, <span class=\"string\">&quot;消息来自 ttl 为 40S 的队列: &quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>3、消息消费者代码</strong> </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.oddfar.consumer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.rabbitmq.client.Channel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.core.Message;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Date;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 消费者 - 死信队列</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> zhiyuan</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DeadLetterQueueConsumer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;QD&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">receiveD</span><span class=\"params\">(Message message, Channel channel)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        String msg = <span class=\"keyword\">new</span> String(message.getBody());</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;当前时间：&#123;&#125;,收到死信队列信息&#123;&#125;&quot;</span>, <span class=\"keyword\">new</span> Date().toString(), msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>发起一个请求 <a href=\"http://localhost:8080/ttl/sendMsg/%E5%98%BB%E5%98%BB%E5%98%BB\">http://localhost:8080/ttl/sendMsg/嘻嘻嘻</a></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210628162017168.png\" alt=\"image-20210628162017168\"></p>\n<p>第一条消息在 10S 后变成了死信消息，然后被消费者消费掉，第二条消息在 40S 之后变成了死信消息， 然后被消费掉，这样一个延时队列就打造完成了。</p>\n<p>不过，如果这样使用的话，岂不是每增加一个新的时间需求，就要新增一个队列，这里只有 10S 和 40S 两个时间选项，如果需要一个小时后处理，那么就需要增加TTL 为一个小时的队列，如果是预定会议室然后提前通知这样的场景，岂不是要增加无数个队列才能满足需求？</p>\n<h2 id=\"延时队列TTL优化\"><a href=\"#延时队列TTL优化\" class=\"headerlink\" title=\"延时队列TTL优化\"></a>延时队列TTL优化</h2><p>在这里新增了一个队列 QC,绑定关系如下,该队列不设置TTL 时间</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000062.png\" alt=\"RabbitMQ-00000062\"></p>\n<p>配置文件类代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MsgTtlQueueConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String Y_DEAD_LETTER_EXCHANGE = <span class=\"string\">&quot;Y&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String QUEUE_C = <span class=\"string\">&quot;QC&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//声明队列 C 死信交换机</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;queueC&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">queueB</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;String, Object&gt; args = <span class=\"keyword\">new</span> HashMap&lt;&gt;(<span class=\"number\">3</span>);</span><br><span class=\"line\">        <span class=\"comment\">//声明当前队列绑定的死信交换机</span></span><br><span class=\"line\">        args.put(<span class=\"string\">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);</span><br><span class=\"line\">        <span class=\"comment\">//声明当前队列的死信路由 key</span></span><br><span class=\"line\">        args.put(<span class=\"string\">&quot;x-dead-letter-routing-key&quot;</span>, <span class=\"string\">&quot;YD&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//没有声明 TTL 属性</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> QueueBuilder.durable(QUEUE_C).withArguments(args).build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//声明队列 B 绑定 X 交换机</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">queuecBindingX</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;queueC&quot;)</span> Queue queueC,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                  <span class=\"meta\">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(queueC).to(xExchange).with(<span class=\"string\">&quot;XC&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>生产者代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 延时队列优化</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> message 消息</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> ttlTime 延时的毫秒</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@GetMapping(&quot;sendExpirationMsg/&#123;message&#125;/&#123;ttlTime&#125;&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sendMsg</span><span class=\"params\">(<span class=\"meta\">@PathVariable</span> String message, <span class=\"meta\">@PathVariable</span> String ttlTime)</span> </span>&#123;</span><br><span class=\"line\">    rabbitTemplate.convertAndSend(<span class=\"string\">&quot;X&quot;</span>, <span class=\"string\">&quot;XC&quot;</span>, message, correlationData -&gt; &#123;</span><br><span class=\"line\">        correlationData.getMessageProperties().setExpiration(ttlTime);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> correlationData;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    log.info(<span class=\"string\">&quot;当前时间：&#123;&#125;,发送一条时长&#123;&#125;毫秒 TTL 信息给队列 C:&#123;&#125;&quot;</span>, <span class=\"keyword\">new</span> Date(), ttlTime, message);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>发起请求</p>\n<p><a href=\"http://localhost:8080/ttl/sendExpirationMsg/%E4%BD%A0%E5%A5%BD1/20000\">http://localhost:8080/ttl/sendExpirationMsg/你好1/20000</a></p>\n<p><a href=\"http://localhost:8080/ttl/sendExpirationMsg/%E4%BD%A0%E5%A5%BD2/2000\">http://localhost:8080/ttl/sendExpirationMsg/你好2/2000</a></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000063.png\" alt=\"RabbitMQ-00000063\"></p>\n<p>看起来似乎没什么问题，但是在最开始的时候，就介绍过如果使用在消息属性上设置 TTL 的方式，消息可能并不会按时“死亡“</p>\n<p>因为 RabbitMQ 只会检查第一个消息是否过期，如果过期则丢到死信队列， 如果第一个消息的延时时长很长，而第二个消息的延时时长很短，第二个消息并不会优先得到执行。</p>\n<p>这也就是为什么第二个延时2秒，却后执行。</p>\n<h2 id=\"Rabbitmq-插件实现延迟队列\"><a href=\"#Rabbitmq-插件实现延迟队列\" class=\"headerlink\" title=\"Rabbitmq 插件实现延迟队列\"></a>Rabbitmq 插件实现延迟队列</h2><p>上文中提到的问题，确实是一个问题，如果不能实现在消息粒度上的 TTL，并使其在设置的TTL 时间及时死亡，就无法设计成一个通用的延时队列。那如何解决呢，接下来我们就去解决该问题。</p>\n<p>::: tip 安装延时队列插件</p>\n<p>:::</p>\n<p>可去<a href=\"https://www.rabbitmq.com/community-plugins.html\">官网下载</a> <strong>rabbitmq_delayed_message_exchange</strong> 插件，放置到 RabbitMQ 的插件目录。</p>\n<p>进入 RabbitMQ 的安装目录下的 plgins 目录，执行下面命令让该插件生效，然后重启 RabbitMQ</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@VM-0-6-centos software]<span class=\"comment\"># ls</span></span><br><span class=\"line\">erlang-21.3.8.21-1.el7.x86_64.rpm  rabbitmq_delayed_message_exchange-3.8.0.ez  rabbitmq-server-3.8.8-1.el7.noarch.rpm</span><br><span class=\"line\"><span class=\"comment\">#移动</span></span><br><span class=\"line\">cp rabbitmq_delayed_message_exchange-3.8.0.ez /usr/lib/rabbitmq/lib/rabbitmq_server-3.8.8/plugins</span><br><span class=\"line\"><span class=\"comment\">#安装</span></span><br><span class=\"line\">rabbitmq-plugins <span class=\"built_in\">enable</span> rabbitmq_delayed_message_exchange</span><br><span class=\"line\"><span class=\"comment\">#重启服务</span></span><br><span class=\"line\">systemctl restart rabbitmq-server</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000065.png\" alt=\"RabbitMQ-00000065\"></p>\n<p>::: tip 代码</p>\n<p>:::</p>\n<p>在这里新增了一个队列delayed.queue,一个自定义交换机 delayed.exchange，绑定关系如下:</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000066.png\" alt=\"RabbitMQ-00000066\"></p>\n<p><strong>1、配置文件类代码：</strong></p>\n<p>在我们自定义的交换机中，这是一种新的交换类型，该类型消息支持延迟投递机制消息传递后并不会立即投递到目标队列中，而是存储在 mnesia(一个分布式数据系统)表中，当达到投递时间时，才投递到目标队列中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DelayedQueueConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String DELAYED_QUEUE_NAME = <span class=\"string\">&quot;delayed.queue&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String DELAYED_EXCHANGE_NAME = <span class=\"string\">&quot;delayed.exchange&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String DELAYED_ROUTING_KEY = <span class=\"string\">&quot;delayed.routingkey&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">delayedQueue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(DELAYED_QUEUE_NAME);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//自定义交换机 我们在这里定义的是一个延迟交换机</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> CustomExchange <span class=\"title\">delayedExchange</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;String, Object&gt; args = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">//自定义交换机的类型</span></span><br><span class=\"line\">        args.put(<span class=\"string\">&quot;x-delayed-type&quot;</span>, <span class=\"string\">&quot;direct&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> CustomExchange(DELAYED_EXCHANGE_NAME, <span class=\"string\">&quot;x-delayed-message&quot;</span>, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">bindingDelayedQueue</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;delayedQueue&quot;)</span> Queue queue,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                       <span class=\"meta\">@Qualifier(&quot;delayedExchange&quot;)</span> CustomExchange delayedExchange)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(queue).to(delayedExchange).with(DELAYED_ROUTING_KEY).noargs();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p><strong>2、生产者代码</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GetMapping(&quot;sendDelayMsg/&#123;message&#125;/&#123;delayTime&#125;&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sendMsg</span><span class=\"params\">(<span class=\"meta\">@PathVariable</span> String message, <span class=\"meta\">@PathVariable</span> Integer delayTime)</span> </span>&#123;</span><br><span class=\"line\">    rabbitTemplate.convertAndSend(DELAYED_EXCHANGE_NAME, DELAYED_ROUTING_KEY, message,</span><br><span class=\"line\">            correlationData -&gt; &#123;</span><br><span class=\"line\">                correlationData.getMessageProperties().setDelay(delayTime);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> correlationData;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">    log.info(<span class=\"string\">&quot; 当 前 时 间 ： &#123;&#125;, 发 送 一 条 延 迟 &#123;&#125; 毫秒的信息给队列 delayed.queue:&#123;&#125;&quot;</span>, <span class=\"keyword\">new</span> Date(), delayTime, message);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>3、消费者代码</strong> </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 消费者 - 基于插件的延时队列</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> zhiyuan</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DelayQueueConsumer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String DELAYED_QUEUE_NAME = <span class=\"string\">&quot;delayed.queue&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = DELAYED_QUEUE_NAME)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">receiveDelayedQueue</span><span class=\"params\">(Message message)</span> </span>&#123;</span><br><span class=\"line\">        String msg = <span class=\"keyword\">new</span> String(message.getBody());</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;当前时间：&#123;&#125;,收到延时队列的消息：&#123;&#125;&quot;</span>, <span class=\"keyword\">new</span> Date().toString(), msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>发送请求：</p>\n<ul>\n<li><a href=\"http://localhost:8080/ttl/sendDelayMsg/hello1/20000\">http://localhost:8080/ttl/sendDelayMsg/hello1/20000</a></li>\n<li><a href=\"http://localhost:8080/ttl/sendDelayMsg/hello2/2000\">http://localhost:8080/ttl/sendDelayMsg/hello2/2000</a></li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210628214856678.png\" alt=\"image-20210628214856678\"></p>\n<p>第二个消息被先消费掉了，符合预期</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>延时队列在需要延时处理的场景下非常有用，使用 RabbitMQ 来实现延时队列可以很好的利用 RabbitMQ 的特性，如：消息可靠发送、消息可靠投递、死信队列来保障消息至少被消费一次以及未被正确处理的消息不会被丢弃。另外，通过 RabbitMQ 集群的特性，可以很好的解决单点故障问题，不会因为 单个节点挂掉导致延时队列不可用或者消息丢失。</p>\n<p>当然，延时队列还有很多其它选择，比如利用 Java 的 DelayQueue，利用 Redis 的 zset，利用 Quartz 或者利用 kafka 的时间轮，这些方式各有特点,看需要适用的场景</p>\n<h1 id=\"发布确认高级\"><a href=\"#发布确认高级\" class=\"headerlink\" title=\"发布确认高级\"></a>发布确认高级</h1><p>在生产环境中由于一些不明原因，导致 RabbitMQ  重启，在 RabbitMQ 重启期间生产者消息投递失败， 导致消息丢失，需要手动处理和恢复。于是，我们开始思考，如何才能进行 RabbitMQ 的消息可靠投递呢？ </p>\n<h2 id=\"发布确认-springboot-版本\"><a href=\"#发布确认-springboot-版本\" class=\"headerlink\" title=\"发布确认 springboot 版本\"></a>发布确认 springboot 版本</h2><p>确认机制方案：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000068.png\" alt=\"RabbitMQ-00000068\"></p>\n<p>代码架构图：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000069.png\" alt=\"RabbitMQ-00000069\"></p>\n<p>在配置文件当中需要添加</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">spring.rabbitmq.publisher-confirm-type</span>=<span class=\"string\">correlated</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>NONE</code> 值是禁用发布确认模式，是默认值</p>\n</li>\n<li><p><code>CORRELATED</code> 值是发布消息成功到交换器后会触发回调方法</p>\n</li>\n<li><p><code>SIMPLE</code> 值经测试有两种效果，其一效果和 CORRELATED 值一样会触发回调方法，其二在发布消息成功后使用 rabbitTemplate 调用 waitForConfirms 或 waitForConfirmsOrDie 方法等待 broker 节点返回发送结果，根据返回结果来判定下一步的逻辑，要注意的点是 waitForConfirmsOrDie 方法如果返回 false 则会关闭 channel，则接下来无法发送消息到 broker;</p>\n</li>\n</ul>\n<p>::: tip 代码</p>\n<p>:::</p>\n<p><strong>1、添加配置类：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConfirmConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String CONFIRM_EXCHANGE_NAME = <span class=\"string\">&quot;confirm.exchange&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String CONFIRM_QUEUE_NAME = <span class=\"string\">&quot;confirm.queue&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//声明业务 Exchange</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;confirmExchange&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DirectExchange <span class=\"title\">confirmExchange</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DirectExchange(CONFIRM_EXCHANGE_NAME);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 声明确认队列</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;confirmQueue&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">confirmQueue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 声明确认队列绑定关系</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">queueBinding</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;confirmQueue&quot;)</span> Queue queue,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                <span class=\"meta\">@Qualifier(&quot;confirmExchange&quot;)</span> DirectExchange exchange)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class=\"string\">&quot;key1&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>2、消息生产者的回调接口</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyCallBack</span> <span class=\"keyword\">implements</span> <span class=\"title\">RabbitTemplate</span>.<span class=\"title\">ConfirmCallback</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 交换机不管是否收到消息的一个回调方法</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> correlationData 消息相关数据</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> ack             交换机是否收到消息</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> cause           为收到消息的原因</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">confirm</span><span class=\"params\">(CorrelationData correlationData, <span class=\"keyword\">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class=\"line\">        String id = correlationData != <span class=\"keyword\">null</span> ? correlationData.getId() : <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ack) &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;交换机已经收到 id 为:&#123;&#125;的消息&quot;</span>, id);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;交换机还未收到 id 为:&#123;&#125;消息，原因:&#123;&#125;&quot;</span>, id, cause);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>3、消息生产者</strong> </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping(&quot;/confirm&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProducerController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String CONFIRM_EXCHANGE_NAME = <span class=\"string\">&quot;confirm.exchange&quot;</span>;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> MyCallBack myCallBack;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//依赖注入 rabbitTemplate 之后再设置它的回调对象</span></span><br><span class=\"line\">    <span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        rabbitTemplate.setConfirmCallback(myCallBack);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 消息回调和退回</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> message</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;sendMessage/&#123;message&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sendMessage</span><span class=\"params\">(<span class=\"meta\">@PathVariable</span> String message)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//指定消息 id 为 1</span></span><br><span class=\"line\">        CorrelationData correlationData1 = <span class=\"keyword\">new</span> CorrelationData(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">        String routingKey = <span class=\"string\">&quot;key1&quot;</span>;</span><br><span class=\"line\">        rabbitTemplate.convertAndSend(CONFIRM_EXCHANGE_NAME, routingKey, message + routingKey, correlationData1);</span><br><span class=\"line\">        log.info(routingKey + <span class=\"string\">&quot;发送消息内容:&#123;&#125;&quot;</span>, message + routingKey);</span><br><span class=\"line\"></span><br><span class=\"line\">        CorrelationData correlationData2 = <span class=\"keyword\">new</span> CorrelationData(<span class=\"string\">&quot;2&quot;</span>);</span><br><span class=\"line\">        routingKey = <span class=\"string\">&quot;key2&quot;</span>;</span><br><span class=\"line\">        rabbitTemplate.convertAndSend(CONFIRM_EXCHANGE_NAME, routingKey, message + routingKey, correlationData2);</span><br><span class=\"line\">        log.info(routingKey + <span class=\"string\">&quot;发送消息内容:&#123;&#125;&quot;</span>, message + routingKey);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>4、消息消费者</strong> </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConfirmConsumer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String CONFIRM_QUEUE_NAME = <span class=\"string\">&quot;confirm.queue&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = CONFIRM_QUEUE_NAME)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">receiveMsg</span><span class=\"params\">(Message message)</span> </span>&#123;</span><br><span class=\"line\">        String msg = <span class=\"keyword\">new</span> String(message.getBody());</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;接受到队列 confirm.queue 消息:&#123;&#125;&quot;</span>, msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>访问： <a href=\"http://localhost:8080/confirm/sendMessage/%E4%BD%A0%E5%A5%BD\">http://localhost:8080/confirm/sendMessage/%E4%BD%A0%E5%A5%BD</a></p>\n<p>结果分析：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210629135636990.png\" alt=\"image-20210629135636990\"></p>\n<p>可以看到，发送了两条消息，第一条消息的 RoutingKey 为 “key1”，第二条消息的 RoutingKey 为 “key2”，两条消息都成功被交换机接收，也收到了交换机的确认回调，但消费者只收到了一条消息，因为第二条消息的 RoutingKey 与队列的 BindingKey 不一致，也没有其它队列能接收这个消息，所有第二条消息被直接丢弃了。</p>\n<p>丢弃的消息交换机是不知道的，需要解决告诉生产者消息传送失败</p>\n<h2 id=\"回退消息\"><a href=\"#回退消息\" class=\"headerlink\" title=\"回退消息\"></a>回退消息</h2><p>Mandatory 参数 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">rabbitTemplate.setReturnsCallback(myCallBack);</span><br></pre></td></tr></table></figure>\n\n<p>在仅开启了生产者确认机制的情况下，交换机接收到消息后，会直接给消息生产者发送确认消息，如果发现该消息不可路由，那么消息会被直接丢弃，此时生产者是不知道消息被丢弃这个事件的。</p>\n<p>那么如何让无法被路由的消息帮我想办法处理一下？最起码通知我一声，我好自己处理啊。通过设置 mandatory 参数可以在当消息传递过程中不可达目的地时将消息返回给生产者。</p>\n<p><strong>1、修改配置</strong></p>\n<figure class=\"highlight properties\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#消息退回</span></span><br><span class=\"line\"><span class=\"meta\">spring.rabbitmq.publisher-returns</span>=<span class=\"string\">true</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>2、修改回调接口</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyCallBack</span> <span class=\"keyword\">implements</span> <span class=\"title\">RabbitTemplate</span>.<span class=\"title\">ConfirmCallback</span>, <span class=\"title\">RabbitTemplate</span>.<span class=\"title\">ReturnsCallback</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 交换机不管是否收到消息的一个回调方法</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> correlationData 消息相关数据</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> ack             交换机是否收到消息</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> cause           为收到消息的原因</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">confirm</span><span class=\"params\">(CorrelationData correlationData, <span class=\"keyword\">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class=\"line\">        String id = correlationData != <span class=\"keyword\">null</span> ? correlationData.getId() : <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ack) &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;交换机已经收到 id 为:&#123;&#125;的消息&quot;</span>, id);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;交换机还未收到 id 为:&#123;&#125;消息，原因:&#123;&#125;&quot;</span>, id, cause);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//当消息无法路由的时候的回调方法</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">returnedMessage</span><span class=\"params\">(ReturnedMessage returned)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        log.error(<span class=\"string\">&quot;消息：&#123;&#125;，被交换机 &#123;&#125; 退回，原因：&#123;&#125;，路由key：&#123;&#125;,code:&#123;&#125;&quot;</span>,</span><br><span class=\"line\">                <span class=\"keyword\">new</span> String(returned.getMessage().getBody()), returned.getExchange(),</span><br><span class=\"line\">                returned.getReplyText(), returned.getRoutingKey(),</span><br><span class=\"line\">                returned.getReplyCode());</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>低版本可能没有 <code>RabbitTemplate.ReturnsCallback</code> 请用 <code>RabbitTemplate.ReturnCallback</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">returnedMessage</span><span class=\"params\">(Message message, <span class=\"keyword\">int</span> replyCode, String replyText, String</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">exchange, String routingKey)</span> </span>&#123;</span><br><span class=\"line\">\tlog.info(<span class=\"string\">&quot;消息:&#123;&#125;被服务器退回，退回原因:&#123;&#125;, 交换机是:&#123;&#125;, 路由 key:&#123;&#125;&quot;</span>,<span class=\"keyword\">new</span> String(message.getBody()),replyText, exchange, routingKey);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>3、修改发送者 ProducerController</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//依赖注入 rabbitTemplate 之后再设置它的回调对象</span></span><br><span class=\"line\"><span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//消息回调</span></span><br><span class=\"line\">    rabbitTemplate.setConfirmCallback(myCallBack);</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * true：交换机无法将消息进行路由时，会将该消息返回给生产者</span></span><br><span class=\"line\"><span class=\"comment\">     * false：如果发现消息无法进行路由，则直接丢弃</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    rabbitTemplate.setMandatory(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    <span class=\"comment\">//设置回退消息交给谁处理</span></span><br><span class=\"line\">    rabbitTemplate.setReturnsCallback(myCallBack);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>访问： <a href=\"http://localhost:8080/confirm/sendMessage/%E4%BD%A0%E5%A5%BD\">http://localhost:8080/confirm/sendMessage/%E4%BD%A0%E5%A5%BD</a></p>\n<p>结果分析：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210629143756078.png\" alt=\"image-20210629143756078\"></p>\n<h2 id=\"备份交换机\"><a href=\"#备份交换机\" class=\"headerlink\" title=\"备份交换机\"></a>备份交换机</h2><p>有了 mandatory 参数和回退消息，我们获得了对无法投递消息的感知能力，在生产者的消息无法被投递时发现并处理。但有时候，我们并不知道该如何处理这些无法路由的消息，最多打个日志，然后触发报警，再来手动处理。而通过日志来处理这些无法路由的消息是很不优雅的做法，特别是当生产者所在的服务有多台机器的时候，手动复制日志会更加麻烦而且容易出错。而且设置 mandatory 参数会增加生产者的复杂性，需要添加处理这些被退回的消息的逻辑。如果既不想丢失消息，又不想增加生产者的复杂性，该怎么做呢？</p>\n<p>前面在设置死信队列的文章中，我们提到，可以为队列设置死信交换机来存储那些处理失败的消息，可是这些不可路由消息根本没有机会进入到队列，因此无法使用死信队列来保存消息。 在 RabbitMQ 中，有一种备份交换机的机制存在，可以很好的应对这个问题。</p>\n<p>什么是备份交换机呢？备份交换机可以理解为 RabbitMQ 中交换机的“备胎”，当我们为某一个交换机声明一个对应的备份交换机时，就是为它创建一个备胎，当交换机接收到一条不可路由消息时，将会把这条消息转发到备份交换机中，由备份交换机来进行转发和处理，通常备份交换机的类型为 Fanout ，这样就能把所有消息都投递到与其绑定的队列中，然后我们在备份交换机下绑定一个队列，这样所有那些原交换机无法被路由的消息，就会都进 入这个队列了。当然，我们还可以建立一个报警队列，用独立的消费者来进行监测和报警。</p>\n<ul>\n<li>代码架构图 </li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000072.png\" alt=\"RabbitMQ-00000072\"></p>\n<p>1、修改配置类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConfirmConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String CONFIRM_EXCHANGE_NAME = <span class=\"string\">&quot;confirm.exchange&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String CONFIRM_QUEUE_NAME = <span class=\"string\">&quot;confirm.queue&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//关于备份的</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String BACKUP_EXCHANGE_NAME = <span class=\"string\">&quot;backup.exchange&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String BACKUP_QUEUE_NAME = <span class=\"string\">&quot;backup.queue&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String WARNING_QUEUE_NAME = <span class=\"string\">&quot;warning.queue&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    //声明业务 Exchange</span></span><br><span class=\"line\"><span class=\"comment\">    @Bean(&quot;confirmExchange&quot;)</span></span><br><span class=\"line\"><span class=\"comment\">    public DirectExchange confirmExchange() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        return new DirectExchange(CONFIRM_EXCHANGE_NAME);</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 声明确认队列</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;confirmQueue&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">confirmQueue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 声明确认队列绑定关系</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">queueBinding</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;confirmQueue&quot;)</span> Queue queue,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                <span class=\"meta\">@Qualifier(&quot;confirmExchange&quot;)</span> DirectExchange exchange)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class=\"string\">&quot;key1&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//************************以下是关于备份的******************************</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//声明备份 Exchange</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;backupExchange&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> FanoutExchange <span class=\"title\">backupExchange</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> FanoutExchange(BACKUP_EXCHANGE_NAME);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//声明确认 Exchange 交换机的备份交换机</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;confirmExchange&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DirectExchange <span class=\"title\">confirmExchange</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ExchangeBuilder exchangeBuilder = ExchangeBuilder.directExchange(CONFIRM_EXCHANGE_NAME)</span><br><span class=\"line\">                .durable(<span class=\"keyword\">true</span>)</span><br><span class=\"line\">                <span class=\"comment\">//设置该交换机的备份交换机</span></span><br><span class=\"line\">                .withArgument(<span class=\"string\">&quot;alternate-exchange&quot;</span>, BACKUP_EXCHANGE_NAME);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> exchangeBuilder.build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 声明警告队列</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;warningQueue&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">warningQueue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> QueueBuilder.durable(WARNING_QUEUE_NAME).build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 声明报警队列绑定关系</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">warningBinding</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;warningQueue&quot;)</span> Queue queue,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                  <span class=\"meta\">@Qualifier(&quot;backupExchange&quot;)</span> FanoutExchange backupExchange)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(queue).to(backupExchange);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 声明备份队列</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;backQueue&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">backQueue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> QueueBuilder.durable(BACKUP_QUEUE_NAME).build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 声明备份队列绑定关系</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">backupBinding</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;backQueue&quot;)</span> Queue queue,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                 <span class=\"meta\">@Qualifier(&quot;backupExchange&quot;)</span> FanoutExchange backupExchange)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(queue).to(backupExchange);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2、报警消费者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WarningConsumer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String WARNING_QUEUE_NAME = <span class=\"string\">&quot;warning.queue&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = WARNING_QUEUE_NAME)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">receiveWarningMsg</span><span class=\"params\">(Message message)</span> </span>&#123;</span><br><span class=\"line\">        String msg = <span class=\"keyword\">new</span> String(message.getBody());</span><br><span class=\"line\">        log.error(<span class=\"string\">&quot;报警发现不可路由消息：&#123;&#125;&quot;</span>, msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>之前已写过 <code>confirm.exchange</code> 交换机，由于更改配置，需要删掉，不然会报错</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000073.png\" alt=\"RabbitMQ-00000073\"></p>\n<ul>\n<li>访问： <a href=\"http://localhost:8080/confirm/sendMessage/%E4%BD%A0%E5%A5%BD\">http://localhost:8080/confirm/sendMessage/%E4%BD%A0%E5%A5%BD</a></li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210629152752935.png\" alt=\"image-20210629152752935\"></p>\n<p>mandatory 参数与备份交换机可以一起使用的时候，如果两者同时开启，消息究竟何去何从？谁优先级高，经过上面结果显示答案是<strong>备份交换机优先级高</strong>。</p>\n<h1 id=\"幂等性\"><a href=\"#幂等性\" class=\"headerlink\" title=\"幂等性\"></a>幂等性</h1><p>::: tip 概念</p>\n<p>:::</p>\n<p>用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。 举个最简单的例子，那就是支付，用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常， 此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额发现多扣钱 了，流水记录也变成了两条。在以前的单应用系统中，我们只需要把数据操作放入事务中即可，发生错误立即回滚，但是再响应客户端的时候也有可能出现网络中断或者异常等等</p>\n<p>::: tip 消息重复消费</p>\n<p>:::</p>\n<p>消费者在消费 MQ 中的消息时，MQ 已把消息发送给消费者，消费者在给 MQ 返回 ack 时网络中断， 故 MQ 未收到确认信息，该条消息会重新发给其他的消费者，或者在网络重连后再次发送给该消费者，但实际上该消费者已成功消费了该条消息，造成消费者消费了重复的消息。</p>\n<p>::: tip 解决思路</p>\n<p>:::</p>\n<p>MQ 消费者的幂等性的解决一般使用全局 ID 或者写个唯一标识比如时间戳 或者 UUID 或者订单消费者消费 MQ 中的消息也可利用 MQ 的该 id 来判断，或者可按自己的规则生成一个全局唯一 id，每次消费消息时用该 id 先判断该消息是否已消费过。</p>\n<p>::: tip 消费端的幂等性保障</p>\n<p>:::</p>\n<p>在海量订单生成的业务高峰期，生产端有可能就会重复发生了消息，这时候消费端就要实现幂等性， 这就意味着我们的消息永远不会被消费多次，即使我们收到了一样的消息。</p>\n<p>业界主流的幂等性有两种操作:a. 唯一 ID+指纹码机制,利用数据库主键去重, b.利用 redis 的原子性去实现</p>\n<ul>\n<li>唯一ID+指纹码机制 </li>\n</ul>\n<p>指纹码：我们的一些规则或者时间戳加别的服务给到的唯一信息码,它并不一定是我们系统生成的，基本都是由我们的业务规则拼接而来，但是一定要保证唯一性，然后就利用查询语句进行判断这个 id 是否存在数据库中，优势就是实现简单就一个拼接，然后查询判断是否重复；劣势就是在高并发时，如果是单个数据库就会有写入性能瓶颈当然也可以采用分库分表提升性能，但也不是我们最推荐的方式。</p>\n<ul>\n<li> note Redis 原子性</li>\n</ul>\n<p>利用 redis 执行 setnx 命令，天然具有幂等性。从而实现不重复消费</p>\n<h2 id=\"优先级队列\"><a href=\"#优先级队列\" class=\"headerlink\" title=\"优先级队列\"></a>优先级队列</h2><ul>\n<li><strong>使用场景</strong></li>\n</ul>\n<p>在我们系统中有一个订单催付的场景，我们的客户在天猫下的订单，淘宝会及时将订单推送给我们，如果在用户设定的时间内未付款那么就会给用户推送一条短信提醒，很简单的一个功能对吧。</p>\n<p>但是，tmall 商家对我们来说，肯定是要分大客户和小客户的对吧，比如像苹果，小米这样大商家一年起码能给我们创造很大的利润，所以理应当然，他们的订单必须得到优先处理，而曾经我们的后端系统是使用 redis 来存放的定时轮询，大家都知道 redis 只能用 List 做一个简简单单的消息队列，并不能实现一个优先级的场景，所以订单量大了后采用 RabbitMQ 进行改造和优化，如果发现是大客户的订单给一个相对比较高的优先级， 否则就是默认优先级。</p>\n<ul>\n<li><strong>如何添加？</strong></li>\n</ul>\n<p>a.控制台页面添加</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000076.png\" alt=\"RabbitMQ-00000076\"></p>\n<p>b.队列中代码添加优先级</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Map&lt;String, Object&gt; params = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\">params.put(<span class=\"string\">&quot;x-max-priority&quot;</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\">channel.queueDeclare(<span class=\"string\">&quot;hello&quot;</span>, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, params);</span><br></pre></td></tr></table></figure>\n\n<p>c.消息中代码添加优先级</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">AMQP.BasicProperties properties = <span class=\"keyword\">new</span> AMQP.BasicProperties().builder().priority(<span class=\"number\">10</span>).build();</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意事项：</strong></p>\n<p>要让队列实现优先级需要做的事情有如下事情：队列需要设置为优先级队列，消息需要设置消息的优先级，消费者需要等待消息已经发送到队列中才去消费因为，这样才有机会对消息进行排序</p>\n<p>::: tip 实战 </p>\n<p>:::</p>\n<p>生产者：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PriorityProducer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String QUEUE_NAME = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//给消息赋予一个 priority 属性</span></span><br><span class=\"line\">        AMQP.BasicProperties properties = <span class=\"keyword\">new</span> AMQP.BasicProperties().builder().priority(<span class=\"number\">10</span>).build();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"number\">11</span>; i++) &#123;</span><br><span class=\"line\">            String message = <span class=\"string\">&quot;info&quot;</span> + i;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i == <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">                channel.basicPublish(<span class=\"string\">&quot;&quot;</span>, QUEUE_NAME, properties, message.getBytes());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                channel.basicPublish(<span class=\"string\">&quot;&quot;</span>, QUEUE_NAME, <span class=\"keyword\">null</span>, message.getBytes());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;发送消息完成:&quot;</span> + message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>消费者：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PriorityConsumer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String QUEUE_NAME = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//设置队列的最大优先级 最大可以设置到 255 官网推荐 1-10 如果设置太高比较吃内存和 CPU</span></span><br><span class=\"line\">        Map&lt;String, Object&gt; params = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\">        params.put(<span class=\"string\">&quot;x-max-priority&quot;</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\">        channel.queueDeclare(QUEUE_NAME, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, params);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//推送的消息如何进行消费的接口回调</span></span><br><span class=\"line\">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class=\"line\">            String message = <span class=\"keyword\">new</span> String(delivery.getBody());</span><br><span class=\"line\">            System.out.println(message);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"comment\">//取消消费的一个回调接口 如在消费的时候队列被删除掉了</span></span><br><span class=\"line\">        CancelCallback cancelCallback = (consumerTag) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;消息消费被中断&quot;</span>);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        channel.basicConsume(QUEUE_NAME, <span class=\"keyword\">true</span>, deliverCallback, cancelCallback);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/image-20210629163922085.png\" alt=\"image-20210629163922085\"></p>\n<h2 id=\"惰性队列\"><a href=\"#惰性队列\" class=\"headerlink\" title=\"惰性队列\"></a>惰性队列</h2><ul>\n<li><strong>使用场景</strong></li>\n</ul>\n<p>RabbitMQ 从 3.6.0 版本开始引入了惰性队列的概念。惰性队列会尽可能的将消息存入磁盘中，而在消费者消费到相应的消息时才会被加载到内存中，它的一个重要的设计目标是能够支持更长的队列，即支持更多的消息存储。当消费者由于各种各样的原因(比如消费者下线、宕机亦或者是由于维护而关闭等)而致使长时间内不能消费消息造成堆积时，惰性队列就很有必要了。</p>\n<p>默认情况下，当生产者将消息发送到 RabbitMQ 的时候，队列中的消息会尽可能的存储在内存之中， 这样可以更加快速的将消息发送给消费者。即使是持久化的消息，在被写入磁盘的同时也会在内存中驻留一份备份。当RabbitMQ 需要释放内存的时候，会将内存中的消息换页至磁盘中，这个操作会耗费较长的时间，也会阻塞队列的操作，进而无法接收新的消息。虽然 RabbitMQ 的开发者们一直在升级相关的算法， 但是效果始终不太理想，尤其是在消息量特别大的时候。</p>\n<ul>\n<li><strong>两种模式</strong> </li>\n</ul>\n<p>队列具备两种模式：default 和 lazy。默认的为default 模式，在3.6.0 之前的版本无需做任何变更。lazy 模式即为惰性队列的模式，可以通过调用 channel.queueDeclare 方法的时候在参数中设置，也可以通过 Policy 的方式设置，如果一个队列同时使用这两种方式设置的话，那么 Policy 的方式具备更高的优先级。 如果要通过声明的方式改变已有队列的模式的话，那么只能先删除队列，然后再重新声明一个新的。</p>\n<p>在队列声明的时候可以通过“x-queue-mode”参数来设置队列的模式，取值为“default”和“lazy”。下面示例中演示了一个惰性队列的声明细节：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Map&lt;String, Object&gt; args = <span class=\"keyword\">new</span> HashMap&lt;String, Object&gt;();</span><br><span class=\"line\">args.put(<span class=\"string\">&quot;x-queue-mode&quot;</span>, <span class=\"string\">&quot;lazy&quot;</span>);</span><br><span class=\"line\">channel.queueDeclare(<span class=\"string\">&quot;myqueue&quot;</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, args);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>内存开销对比 </li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/oddfar/static/img/RabbitMQ/RabbitMQ-00000077.png\" alt=\"RabbitMQ-00000077\"></p>\n<p>在发送 1 百万条消息，每条消息大概占 1KB 的情况下，普通队列占用内存是 1.2GB，而惰性队列仅仅 占用 1.5MB</p>\n"},{"title":"面试问题整理","date":"2022-06-08T07:21:52.000Z","_content":"\n### Spring是什么\n\n是一个容器框架 用来装JAVA bean \n\n是一个中间层框架 （万能胶） 起到一个连接作用，比如MVC和mybatis 粘合在一起，开发更快、更简洁\n\n是一个生态：可以构建Java应用所需的一切基础设施\n\nSpring 是一个轻量级的控制反转(IOC)和面向切面(AOP)的容器框架\n\n​\t--轻量级 （大小和开销）相比EJB\n\n​\t--IOC达到松耦合\n\n​\t--AOP 允许分离应用的业务逻辑与系统级服务进行内聚性（切面）的开发 （日志等）\n\n​\t--管理对象（BEAN）的生命周期\n\n​\t--将组件（Mybatis等）整合（集成）到整个应用中来\n\n\n\n### Spring的优缺点是什么？\n\n（IOC）集中管理了对象，对象和对象之间的耦合度减低。方便维护对象，（单例多例等）\n\n（AOC）在不修改代码的情况下，可以对业务代码进行增加（减少重复代码、提高开发效率、方便维护）：如日志、监控等与业务方法不相关的代码\n\n（声明事务）提高开发效率，只要一个简单注解（@Transactional）\n\n（方便测试）Spring使用Junit4非常方便测试SpringBean SpringMVC\n\n（集成了各种优秀框架） 拥有非常强大的粘合度（集成能力强），只要简单的配置就可以集成第三方框架\n\n（降低了JAVA API的使用难度）对很多API（功能性代码）进行了简易封装，使用更加简单方便（如JDBC、JAVAMail、远程调用等）\n\n（设计模式）通过源码，spring底层的实现、反射。。设计模式都是值得我们学习，提供了非常多的扩展接口供外部进行扩展\n\n缺点：\n\n​\t从应用层面来说没有多大的缺点\n\n​\t简化了开发，如果想深入到底层去了解就非常困难（上层使用越简单、底层封装的越复杂）\n\n​\t源码缺点：由于Spring大而全（要集成这么多框架、提供了非常多的扩展点，经过十多年的迭代），代码量非常庞大，一百多万 对于深入学习源码带来一定困难。\n\n\n\n### IOC是什么？有什么作用？优点是什么？\n\n控制反转：控制了什么，？\n\n​\t\t```--UserService service = new UserService(); //耦合度高（比如说 改成别的对象，要将每个依赖了User Service的类进行更改，），维护不方便 （要将UserService变成单例对象，每个依赖都new一个的话，性能损耗，维护不方便）```\n\n引入IOC 就是将对象的控制权交给了Spring的IOC，以前是自己创建new ，现在就交给Spring的IOC去创建，如果要去使用，需要通过DI（依赖注入）@AutoWired 自动注入 就可以使用对象\n\n优点：集中管理了对象、方便维护、降低耦合度；支持加载服务时的饿汉式和懒汉式\n\nIOC的实现机制是什么？\n\n工厂+反射实现   ：工厂（beanFactory）加反射 帮助我们创建对象\n\nIOC和DI 的区别是什么？\n\n### 紧耦合和松耦合的区别？如何编写松耦合的代码？\n\n紧耦合：\n\n​\t紧密耦合是指类之间高度依赖\n\n松耦合：\n\n​\t是通过促进<u>单一职责</u>和<u>关注点分离</u>、<u>依赖倒置</u>的设计原则来实现\n\n### BeanFactory的作用\n\nspring中非常核心的一个顶层接口\n\n它的主要职责就是生产Bean\n\n它实现了简单工厂的设计模式，通过getBean传入标识生产一个Bean\n","source":"_posts/Spring是什么.md","raw":"---\ntitle: 面试问题整理\ndate: 2022-06-08 15:21:52\ntags: \n - spring\n - 面试\ncategories: 面试\n---\n\n### Spring是什么\n\n是一个容器框架 用来装JAVA bean \n\n是一个中间层框架 （万能胶） 起到一个连接作用，比如MVC和mybatis 粘合在一起，开发更快、更简洁\n\n是一个生态：可以构建Java应用所需的一切基础设施\n\nSpring 是一个轻量级的控制反转(IOC)和面向切面(AOP)的容器框架\n\n​\t--轻量级 （大小和开销）相比EJB\n\n​\t--IOC达到松耦合\n\n​\t--AOP 允许分离应用的业务逻辑与系统级服务进行内聚性（切面）的开发 （日志等）\n\n​\t--管理对象（BEAN）的生命周期\n\n​\t--将组件（Mybatis等）整合（集成）到整个应用中来\n\n\n\n### Spring的优缺点是什么？\n\n（IOC）集中管理了对象，对象和对象之间的耦合度减低。方便维护对象，（单例多例等）\n\n（AOC）在不修改代码的情况下，可以对业务代码进行增加（减少重复代码、提高开发效率、方便维护）：如日志、监控等与业务方法不相关的代码\n\n（声明事务）提高开发效率，只要一个简单注解（@Transactional）\n\n（方便测试）Spring使用Junit4非常方便测试SpringBean SpringMVC\n\n（集成了各种优秀框架） 拥有非常强大的粘合度（集成能力强），只要简单的配置就可以集成第三方框架\n\n（降低了JAVA API的使用难度）对很多API（功能性代码）进行了简易封装，使用更加简单方便（如JDBC、JAVAMail、远程调用等）\n\n（设计模式）通过源码，spring底层的实现、反射。。设计模式都是值得我们学习，提供了非常多的扩展接口供外部进行扩展\n\n缺点：\n\n​\t从应用层面来说没有多大的缺点\n\n​\t简化了开发，如果想深入到底层去了解就非常困难（上层使用越简单、底层封装的越复杂）\n\n​\t源码缺点：由于Spring大而全（要集成这么多框架、提供了非常多的扩展点，经过十多年的迭代），代码量非常庞大，一百多万 对于深入学习源码带来一定困难。\n\n\n\n### IOC是什么？有什么作用？优点是什么？\n\n控制反转：控制了什么，？\n\n​\t\t```--UserService service = new UserService(); //耦合度高（比如说 改成别的对象，要将每个依赖了User Service的类进行更改，），维护不方便 （要将UserService变成单例对象，每个依赖都new一个的话，性能损耗，维护不方便）```\n\n引入IOC 就是将对象的控制权交给了Spring的IOC，以前是自己创建new ，现在就交给Spring的IOC去创建，如果要去使用，需要通过DI（依赖注入）@AutoWired 自动注入 就可以使用对象\n\n优点：集中管理了对象、方便维护、降低耦合度；支持加载服务时的饿汉式和懒汉式\n\nIOC的实现机制是什么？\n\n工厂+反射实现   ：工厂（beanFactory）加反射 帮助我们创建对象\n\nIOC和DI 的区别是什么？\n\n### 紧耦合和松耦合的区别？如何编写松耦合的代码？\n\n紧耦合：\n\n​\t紧密耦合是指类之间高度依赖\n\n松耦合：\n\n​\t是通过促进<u>单一职责</u>和<u>关注点分离</u>、<u>依赖倒置</u>的设计原则来实现\n\n### BeanFactory的作用\n\nspring中非常核心的一个顶层接口\n\n它的主要职责就是生产Bean\n\n它实现了简单工厂的设计模式，通过getBean传入标识生产一个Bean\n","slug":"Spring是什么","published":1,"updated":"2022-07-21T02:00:25.904Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5w7e73w0009igvuho0t842y","content":"<h3 id=\"Spring是什么\"><a href=\"#Spring是什么\" class=\"headerlink\" title=\"Spring是什么\"></a>Spring是什么</h3><p>是一个容器框架 用来装JAVA bean </p>\n<p>是一个中间层框架 （万能胶） 起到一个连接作用，比如MVC和mybatis 粘合在一起，开发更快、更简洁</p>\n<p>是一个生态：可以构建Java应用所需的一切基础设施</p>\n<p>Spring 是一个轻量级的控制反转(IOC)和面向切面(AOP)的容器框架</p>\n<p>​    –轻量级 （大小和开销）相比EJB</p>\n<p>​    –IOC达到松耦合</p>\n<p>​    –AOP 允许分离应用的业务逻辑与系统级服务进行内聚性（切面）的开发 （日志等）</p>\n<p>​    –管理对象（BEAN）的生命周期</p>\n<p>​    –将组件（Mybatis等）整合（集成）到整个应用中来</p>\n<h3 id=\"Spring的优缺点是什么？\"><a href=\"#Spring的优缺点是什么？\" class=\"headerlink\" title=\"Spring的优缺点是什么？\"></a>Spring的优缺点是什么？</h3><p>（IOC）集中管理了对象，对象和对象之间的耦合度减低。方便维护对象，（单例多例等）</p>\n<p>（AOC）在不修改代码的情况下，可以对业务代码进行增加（减少重复代码、提高开发效率、方便维护）：如日志、监控等与业务方法不相关的代码</p>\n<p>（声明事务）提高开发效率，只要一个简单注解（@Transactional）</p>\n<p>（方便测试）Spring使用Junit4非常方便测试SpringBean SpringMVC</p>\n<p>（集成了各种优秀框架） 拥有非常强大的粘合度（集成能力强），只要简单的配置就可以集成第三方框架</p>\n<p>（降低了JAVA API的使用难度）对很多API（功能性代码）进行了简易封装，使用更加简单方便（如JDBC、JAVAMail、远程调用等）</p>\n<p>（设计模式）通过源码，spring底层的实现、反射。。设计模式都是值得我们学习，提供了非常多的扩展接口供外部进行扩展</p>\n<p>缺点：</p>\n<p>​    从应用层面来说没有多大的缺点</p>\n<p>​    简化了开发，如果想深入到底层去了解就非常困难（上层使用越简单、底层封装的越复杂）</p>\n<p>​    源码缺点：由于Spring大而全（要集成这么多框架、提供了非常多的扩展点，经过十多年的迭代），代码量非常庞大，一百多万 对于深入学习源码带来一定困难。</p>\n<h3 id=\"IOC是什么？有什么作用？优点是什么？\"><a href=\"#IOC是什么？有什么作用？优点是什么？\" class=\"headerlink\" title=\"IOC是什么？有什么作用？优点是什么？\"></a>IOC是什么？有什么作用？优点是什么？</h3><p>控制反转：控制了什么，？</p>\n<p>​        <code>--UserService service = new UserService(); //耦合度高（比如说 改成别的对象，要将每个依赖了User Service的类进行更改，），维护不方便 （要将UserService变成单例对象，每个依赖都new一个的话，性能损耗，维护不方便）</code></p>\n<p>引入IOC 就是将对象的控制权交给了Spring的IOC，以前是自己创建new ，现在就交给Spring的IOC去创建，如果要去使用，需要通过DI（依赖注入）@AutoWired 自动注入 就可以使用对象</p>\n<p>优点：集中管理了对象、方便维护、降低耦合度；支持加载服务时的饿汉式和懒汉式</p>\n<p>IOC的实现机制是什么？</p>\n<p>工厂+反射实现   ：工厂（beanFactory）加反射 帮助我们创建对象</p>\n<p>IOC和DI 的区别是什么？</p>\n<h3 id=\"紧耦合和松耦合的区别？如何编写松耦合的代码？\"><a href=\"#紧耦合和松耦合的区别？如何编写松耦合的代码？\" class=\"headerlink\" title=\"紧耦合和松耦合的区别？如何编写松耦合的代码？\"></a>紧耦合和松耦合的区别？如何编写松耦合的代码？</h3><p>紧耦合：</p>\n<p>​    紧密耦合是指类之间高度依赖</p>\n<p>松耦合：</p>\n<p>​    是通过促进<u>单一职责</u>和<u>关注点分离</u>、<u>依赖倒置</u>的设计原则来实现</p>\n<h3 id=\"BeanFactory的作用\"><a href=\"#BeanFactory的作用\" class=\"headerlink\" title=\"BeanFactory的作用\"></a>BeanFactory的作用</h3><p>spring中非常核心的一个顶层接口</p>\n<p>它的主要职责就是生产Bean</p>\n<p>它实现了简单工厂的设计模式，通过getBean传入标识生产一个Bean</p>\n","site":{"data":{"bangumis":{"wantWatch":[],"watching":[{"title":"凡人修仙传","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/70d11dfab23a3ee81ccf64f18efa139416a633ff.jpg@220w_280h.webp","totalCount":"未完结","id":28223043,"follow":"615.7 万","view":"8.9 亿","danmaku":"490.9 万","coin":"1186.9 万","score":9.7,"des":"看机智的凡人小子韩立如何稳健发展、步步为营，战魔道、夺至宝、驰骋星海、快意恩仇，成为纵横三界的强者。他日仙界重相逢，一声道友尽沧桑。..."},{"title":"恋爱游戏世界对路人角色很不友好","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/c9723d8c77d881a8debba2852d580e97826b43d0.png@220w_280h.webp","totalCount":"全12话","id":28237300,"follow":"151.2 万","view":"5120.4 万","danmaku":"40.6 万","coin":"24.5 万","score":9.1,"des":"从现代日本转生到“恋爱游戏”世界的里昂，发现这里女尊男卑，对男性很不友好。身为路人角色的他，为了摆脱自己因地位低下而被肆意决定的人生，决定活用从游戏中得到的知识，保持路人角色的身份，取得“失落物品”来..."},{"title":"魔法纪录 魔法少女小圆外传 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/9eef1df9ab157be52d2c4d70d3500442f00cafc3.png@220w_280h.webp","totalCount":"全12话","id":28234642,"follow":"237.1 万","view":"907.6 万","danmaku":"5.0 万","coin":"4.9 万","score":7.7,"des":"愿望的代价，究竟是希望还是绝望——。"},{"title":"小林家的龙女仆 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/847e9dbb6876fb37a30199a5c88910704976d45b.png@220w_280h.webp","totalCount":"全13话","id":28234613,"follow":"855.7 万","view":"1.1 亿","danmaku":"49.0 万","coin":"69.0 万","score":9.6,"des":"那位不可思议的龙女仆再度登场！\n因为各种奇妙的原因而作为小林家的女仆而工作中的龙·托尔。\n偶尔（胡说，是经常）给亲爱的小林添麻烦，总算是融入了人类社会，成为了一个完美的（骗人，也就还行）女仆。\n同样是..."},{"title":"国王排名","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/376d7e69a667bcb1c0b934a4e35e07e7fa23110b.png@220w_280h.webp","totalCount":"全23话","id":28235154,"follow":"927.7 万","view":"4.8 亿","danmaku":"250.1 万","coin":"260.9 万","score":7,"des":"国家的丰饶、麾下勇者的数量、\n以及国王本人如何像勇者一般强大，\n这些要素的综合排名，便是所谓的“国王排名”。\n主人公波吉是国王排名第七名的伯斯王治下王国的第一王子。\n但是波吉却生来又聋又哑，贫弱到挥不..."},{"title":"阿松 第三季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0212baa8898d0c819c7fb84015e95b8fca621435.png@220w_280h.webp","totalCount":"全25话","id":28229892,"follow":"67.6 万","view":"938.0 万","danmaku":"13.0 万","coin":"5.4 万","score":9.6,"des":"日本最有名的六胞胎的传说，第三次开幕！！这次会有怎样意想不到的新展开！？..."},{"title":"命运-冠位指定 冠位时间神殿所罗门","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0e094b798388da19a4feffa6a6dabc1dc1dc90cd.jpg@220w_280h.webp","totalCount":"全1话","id":28236225,"follow":"525.5 万","view":"1220.0 万","danmaku":"8.9 万","coin":"15.1 万","score":8.5,"des":"在经过七个特异点的大战后，\n人理存续保障机关迦勒底，终于到达了圣杯探索的最终地点——终局特异点 冠位时间神殿所罗门。\n他们要击败身为罪魁祸首的魔术王所罗门，夺回未来。\n在开战的前一刻，一行人各自度过了..."},{"title":"JOJO的奇妙冒险 星尘远征军","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/47c0108259355d6d2c517ed97f6b90fb777f844f.png@220w_280h.webp","totalCount":"全24话","id":28223481,"follow":"444.2 万","view":"1.5 亿","danmaku":"463.4 万","coin":"45.7 万","score":9.8,"des":"时为1987年，乔瑟夫·乔斯达与“柱之男”们之间的死战后过了50年……乔瑟夫为了为了帮助“被恶灵附身了”的外孙子·空条承太郎而来到了日本。原来那并不是恶灵而是幽波纹（替身）。替身突然出现的原因在于，从..."},{"title":"JOJO的奇妙冒险 星尘远征军 埃及篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f6709b76e88f50aa132d1e09e2d8de9663a09b3e.png@220w_280h.webp","totalCount":"全24话","id":28223483,"follow":"421.9 万","view":"1.3 亿","danmaku":"468.7 万","coin":"44.3 万","score":9.9,"des":"在乔斯达家的宿敌·迪奥（DIO）复活的影响下，一位年轻人——空条承太郎，得到了名为“幽波纹（替身）”的能力。为了拯救因迪奥的诅咒而倒下的母亲荷莉，空条承太郎与外祖父·乔瑟夫以及伙伴们，一起为了打倒迪奥..."},{"title":"JOJO的奇妙冒险 不灭钻石","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/6a04c87e990ab74cd8d555ef45a863de0993b161.png@220w_280h.webp","totalCount":"全39话","id":140552,"follow":"302.3 万","view":"2.1 亿","danmaku":"813.8 万","coin":"55.9 万","score":9.8,"des":"在埃及与宿敌DIO的死斗之后过了11年。1999年，空条承太郎为了与祖父乔瑟夫·乔斯达的私生子东方仗助见面，而来到了日本M县S市杜王町。但，仗助却持有与承太郎相同的特殊能力“替身”。之后，以承太郎的来..."},{"title":"命运-冠位嘉年华","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/c660976f4502a544d990a882ae62194b57753a71.png@220w_280h.webp","totalCount":"全2话","id":28234639,"follow":"479.8 万","view":"862.4 万","danmaku":"4.1 万","coin":"9.1 万","score":9.8,"des":"一起庆祝吧！为了这奇迹般的嘉年华！"},{"title":"伍六七","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/b69e26d9e50514f3fa99eac9ab5aabf2a6e28c88.jpg@220w_280h.webp","totalCount":"全13话","id":6360,"follow":"585.8 万","view":"3.3 亿","danmaku":"227.1 万","coin":"191.8 万","score":9.8,"des":"在某个小岛上，有一个可以伪装成任何东西的廉价刺客，名叫伍六七。平时看上去是个理发师，其实背地里却做着刺客生意。热爱理发事业，喜欢给人剪头发，善用剪刀——剪刀也是他的刺杀武器。由于初入刺客行当，行情十分..."},{"title":"命运-冠位指定 -月光／失落之室-","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3fa5fd2b7afae827b0bf150d7f0cbfc54eda1ff2.png@220w_280h.webp","totalCount":"全1话","id":28234950,"follow":"483.3 万","view":"551.2 万","danmaku":9696,"coin":"2.9 万","score":9.5,"des":"失落之室——。\n这是一个可以看到被夺去亦或是遗失之物的地方。\n这是位于迦勒底被遗忘的角落，不属于任何人的地方。..."},{"title":"致不灭的你","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/1ae94fbb35d8e23bb84926b694509f8b057f96e6.png@220w_280h.webp","totalCount":"全20话","id":28233896,"follow":"476.3 万","view":"1.3 亿","danmaku":"140.1 万","coin":"95.0 万","score":9.6,"des":"本剧讲述了一个情节跌宕、场面宏大的奇幻故事，通过拥有不灭之身的主人公“不死”来探索人生哲理。\n不死起初是一个被投放到人世间的“球”。\n\n它具有“幻化为刺激源形态的能力”和“死后重生的能力”。\n\n先后从..."},{"title":"来自新世界","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/aaa60f9cb17fb4a38df464f1064ca9623e0769cc.jpg@220w_280h.webp","totalCount":"全25话","id":1598,"follow":"115.9 万","view":"1540.9 万","danmaku":"76.3 万","coin":"5.7 万","score":9.5,"des":"1000年后的日本，孩子们不断地消失，只存在想象中的恐怖动物与人类展开殊死战争。反乌托邦式的未来超级社会“新世界”，是口吐真言凭藉“咒力”就能移动物体的人类，与有着等同于普通人智力的生物“妖鼠”共存的..."},{"title":"转生成蜘蛛又怎样！","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f0796e37abac25ba2aa9f23120646aaa9a3d5ea7.png@220w_280h.webp","totalCount":"全24话","id":28231809,"follow":"600.0 万","view":"3.7 亿","danmaku":"190.3 万","coin":"164.6 万","score":7.8,"des":"曾经是一名女高中生的“我”，突然转生变成了幻想世界中的蜘蛛魔物。\n而且，出生地点还是各种凶恶魔物所盘踞的大迷宫。\n“我”以人类的智慧和非同寻常的积极心态为武器，使用蜘蛛的丝网以及陷阱打倒比自己等级高得..."},{"title":"装甲重拳/MEGALOBOX 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/e14dc4a935397fc074c7a12d9520225615209025.png@220w_280h.webp","totalCount":"全13话","id":28233916,"follow":"244.9 万","view":"3435.4 万","danmaku":"19.7 万","coin":"53.1 万","score":9.9,"des":"再一次，为梦想而活——\n\n将肉体与“装甲技术”融合的究极格斗技“装甲拳击”。\n在决出其顶点之人的大会“重拳之巅”上，身穿装甲用自己肉身挑战一切的拳击手“JOE”。\n\n从最下层的比赛开始仅仅花了三个月就..."},{"title":"机动战士高达SEED HD","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/855c88677267d707ebfe4040403692ff2c0938f0.png@220w_280h.webp","totalCount":"全48话","id":497,"follow":"54.8 万","view":"4044.4 万","danmaku":"114.4 万","coin":"6.0 万","score":9.6,"des":"《机动战士高达SEED》是高达系列在2002年至2003年度放映的动画。续作为《机动战士高达SEED Destiny》在2004年播放。因各具魅力的角色，明星云集的声优阵容和高度商业化的宣传而受到较低..."},{"title":"夏目友人帐 唤石者与怪异的访客","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6cf43708b779cde84ad285ff4e3a080de98df0af.png@220w_280h.webp","totalCount":"全1话","id":28234316,"follow":"567.1 万","view":"1374.8 万","danmaku":"18.1 万","coin":"17.9 万","score":9.9,"des":"本作由【唤石者】与【怪异的访客】两个人气短篇集锦而成。讲述生来便能看见各种妖怪的夏目，与自称保镖的猫咪老师一同邂逅的一系列温暖故事。\n【唤石者】一天夏目在森林中遇到一只小妖怪——密实。密实称自己肩负「..."},{"title":"Fate/Grand Order ‐First Order‐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/b75c55d209d156c8631f5ceb21e5c52c834dbb60.jpg@220w_280h.webp","totalCount":"全1话","id":5747,"follow":"250.9 万","view":"3329.7 万","danmaku":"76.7 万","coin":"10.7 万","score":8.3,"des":"【2016年12月31日bilibili独播】2015年。示巴所观测到的未来领域毫无前兆地消失。根据计算，发现——不，是证明了人类将于2017年灭绝。人理延续保障机构·迦勒底将“无法观测的领域”假定为..."},{"title":"伍六七之玄武国篇","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/00843865ea13702eccc4efd64c313fd4c8029c6b.jpg@220w_280h.webp","totalCount":"全10话","id":28232253,"follow":"999.4 万","view":"4.0 亿","danmaku":"177.7 万","coin":"385.3 万","score":9.8,"des":"为了保护小鸡岛居民和这里平静的生活，伍六七和他的伙伴大保和小飞开启了去往玄武国的冒险旅程，去寻找身世的真相和解救小岛的办法，等待他们的又将是更多的未知与奇遇。..."},{"title":"堀与宫村","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/039c4e0b14e27c7a9e5cce2f20a6efd3c8909401.png@220w_280h.webp","totalCount":"全13话","id":28231840,"follow":"695.2 万","view":"2.2 亿","danmaku":"242.1 万","coin":"361.4 万","score":9.8,"des":"不论是谁，都会有不想被人知道的一面。\n\n在学校中漂亮大方、成绩优秀的人气女生堀，私下却打扮土气、忙于家务和照顾弟弟。\n在学校中是阴暗宅男形象的宫村，生活中却是打扮时尚、带耳钉的帅气男生。\n因为一次特别..."},{"title":"奇蛋物语 / WONDER EGG PRIORITY","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/10e0bbc1047b2c45f0f881de334a6f3bfb42a3b6.png@220w_280h.webp","totalCount":"全12话","id":28231851,"follow":"254.9 万","view":"4686.8 万","danmaku":"47.6 万","coin":"65.5 万","score":9.7,"des":"14岁少女·大户爱在深夜散步的途中，\n随着神秘声音的指引，获得了一枚「蛋」。\n\n「如果想要改变世界的话」\n「那么就在现在做出选择」\n「请相信自己——」\n「打破这枚蛋——」\n\n而在打破「蛋」之后，等待着..."},{"title":"Re：从零开始的异世界生活 第二季 后半","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/4f3edbede7fc0bdb52842075cf8faaa1c5953eaa.png@220w_280h.webp","totalCount":"全12话","id":28232073,"follow":"849.9 万","view":"9308.1 万","danmaku":"108.1 万","coin":"230.1 万","score":9.9,"des":"我一定会拯救你。\n在打倒了魔女教大罪司教「怠惰」担当——培提其乌斯·罗曼尼康帝之后，菜月昴和爱蜜莉雅又得以重新开始。\n克服了艰难的诀别，两人终于和解，然而这只是新一轮风波的序幕。\n超乎想象的绝境危机，..."},{"title":"灰与幻想的格林姆迦尔","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/7fb4945f864e9e988212b7d20f206df2677053f8.jpg@220w_280h.webp","totalCount":"全12话","id":106512,"follow":"172.0 万","view":"2343.4 万","danmaku":"63.8 万","coin":"18.3 万","score":9.8,"des":"电视动画《灰与幻想的格林姆迦尔》改编自日本轻小说家十文字青原作白井锐利插画的同名轻小说。\n我们为什么要这么做…？\n哈尔希洛回过神来，才发现自己身处在黑暗当中，他完全不知道自己人在何处，也不明白这个地方..."},{"title":"龙与虎","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/144910805f172d16c5f544f43939a05d8ca20576.jpg@220w_280h.webp","totalCount":"全26话","id":1672,"follow":"336.9 万","view":"6671.9 万","danmaku":"511.9 万","coin":"61.5 万","score":9.7,"des":"樱花飞舞的四月，全新的高中二年级，新的班级……\n眼神凶恶的普通男孩——高须龙儿，遇上了众人害怕、凶暴残忍的“掌中老虎”逢坂大河，还知道了她不欲为人知的秘密。这就是龙虎相争爱与战斗的序幕。\n再加上总是笑..."},{"title":"机动战士高达 铁血的奥尔芬斯 第一季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/f84a80d731d0431c00903d8951fd66623d8237f7.png@220w_280h.webp","totalCount":"全25话","id":4310042,"follow":"62.4 万","view":"2318.6 万","danmaku":"52.2 万","coin":"5.4 万","score":9.5,"des":"主人公三日月·奥古斯，从所属的民间警备公司克律塞安保公司（下称CGS）那里，接受了对少女库德莉亚·蓝那·伯恩斯坦的护卫任务。但CGS受到了摘取反叛之芽的武力组织加拉尔霍恩的袭击，于是在把三日月当做诱饵..."},{"title":"机动战士高达00 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1d7a969e8f1045739c596de89a963e30475aff0e.jpg@220w_280h.webp","totalCount":"全25话","id":1193,"follow":"37.2 万","view":"2458.1 万","danmaku":"61.4 万","coin":"4.1 万","score":9.8,"des":"天人与联合国军的最终决战后过了四年。建立地球联邦政府的人类，为了追求更进一步的国家间之统合，以及人类意识的统一，在联合正规军之外，设立了独立治安维持部队“A-Laws”，目的为对所有危害联合的势力与主..."},{"title":"机动战士高达00","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/35b11bf59eb3fd12f0387951510a5d722d7435e5.jpg@220w_280h.webp","totalCount":"全25话","id":1192,"follow":"62.1 万","view":"2465.5 万","danmaku":"53.6 万","coin":"4.6 万","score":9.7,"des":"在西历2307年，虽然化石燃料枯竭了，但是人类得到了截然不同的新型能源。三台巨大的轨道升降机以及伴随它们的大规模的太阳光发电系统。但是能得到这个系统恩惠的，只有一部分大国和其同盟国而已。\n拥有三台轨道..."},{"title":"Re：从零开始的异世界生活 第二季 前半","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f2425cbdb07cc93bd0d3ba1c0099bfe78f5dc58a.png@220w_280h.webp","totalCount":"全13话","id":28229233,"follow":"774.2 万","view":"1.3 亿","danmaku":"201.4 万","coin":"126.7 万","score":9.7,"des":"我一定会拯救你。\n在打倒了魔女教大罪司教「怠惰」担当——培提其乌斯·罗曼尼康帝之后，菜月昴和爱蜜莉雅又得以重新开始。\n克服了艰难的诀别，两人终于和解，然而这只是新一轮风波的序幕。\n超乎想象的绝境危机，..."},{"title":"超级小白","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3d3e8257d22596f5d3e4395ca759bd1e0fe9b873.jpg@220w_280h.webp","totalCount":"全48话","id":28222671,"follow":"27.4 万","view":"978.0 万","danmaku":"3.6 万","coin":"3.6 万","score":9.6,"des":"为了阻止企图霸占世界的黑暗势力，野原家的普通小狗——小白接肩负重大使命，变身成为了守护世界的“超级小白”。小白将要面对的不仅是发明狗，还有其他意想不到的对手。当然，面对邪恶势力，小白也有着令人惊讶的超..."},{"title":"Re：从零开始的异世界生活 新编集版","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3c125e1aad08643e3eff2fb7d45e740c1a052725.png@220w_280h.webp","totalCount":"全13话","id":28224394,"follow":"631.1 万","view":"7674.2 万","danmaku":"166.2 万","coin":"51.1 万","score":9.6,"des":"在从便利商店回家的路上，突然被异世界召唤的少年菜月昴。在无法依靠任何东西的异世界，无力的少年手唯一的力量……那是“死去然后重新开始”的力量。为了守护最重要的人们，为了取回确实存在着又无可替代的时间，少..."},{"title":"因为太怕痛就全点防御力了","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/8021d3f6b0df6dbba6d32f76eb9cfe2531e166c4.png@220w_280h.webp","totalCount":"全12话","id":28224137,"follow":"620.6 万","view":"2.3 亿","danmaku":"326.8 万","coin":"103.8 万","score":9,"des":"主角本条枫在好友白峰理沙推荐下开始游玩游戏“NewWorld Online”，创建了名为“梅普露”的角色。然而作为游戏初学者，梅普露选择了不受欢迎的大盾当武器，同时因为怕痛而把所有状态点加到防御力的极..."},{"title":"冰海战记","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/c30401817895e67399094b4e669785a104270cdf.jpg@220w_280h.webp","totalCount":"全24话","id":28220475,"follow":"174.4 万","view":"4893.8 万","danmaku":"48.7 万","coin":"36.7 万","score":9.8,"des":"公元10世纪末期，出现了在世界各地出没的最强民族。被讴歌为最强战士的托尔兹，其子托尔芬幼时便生活在战场上，并向往着梦幻大陆“文兰”。这是一个发生在激荡时代的，真正的英雄物语。..."},{"title":"齐木楠雄的灾难 始动篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ba59822eded39b5254fb01448a7f1502101d5624.png@220w_280h.webp","totalCount":"全6话","id":28223748,"follow":"372.4 万","view":"3054.5 万","danmaku":"20.0 万","coin":"17.8 万","score":9.8,"des":"在电视剧中堪称帅气的超能力，对于高中生齐木楠雄来说只是招致灾难的元凶。作为新动画系列展开的楠雄的日常又会如何！？..."},{"title":"OVERLORD Ⅱ","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/851f979c8ebcc7583a43abd4b786c4e2e66b746b.jpg@220w_280h.webp","totalCount":"全13话","id":8792,"follow":"539.3 万","view":"3.8 亿","danmaku":"413.9 万","coin":"114.1 万","score":9.6,"des":"时为2138年。曾卷起一大风潮的虚拟现实体感型网络游戏《YGGDRASIL》即将迎来停服。玩家飞鼠在曾经以同伴和荣华自傲的根据地纳萨力克地下大坟墓，独自一人安静等待着那一刻。但是，不料发生了结束时间已..."},{"title":"夏目友人帐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/99c549494d9425f6455bd45a151f4d26397d6151.png@220w_280h.webp","totalCount":"全13话","id":1660,"follow":"324.0 万","view":"4975.2 万","danmaku":"278.7 万","coin":"15.5 万","score":9.8,"des":"夏目贵志生来拥有强大的灵力，能感知平常人所无法接触的妖怪神明的存在。因父母双亡，他多年间辗转于互相推卸责任的亲戚之间，又受到同龄人的欺负，未曾与任何人深交，造成性格一定程度上的孤僻。夏目本性和善，对于..."}],"watched":[{"title":"装甲重拳/MEGALOBOX","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0c44785cb5d25cc9f648800d251f21a2e236bb8a.png@220w_280h.webp","totalCount":"全13话","id":79472,"follow":"221.9 万","view":"6162.0 万","danmaku":"48.6 万","coin":"32.9 万","score":9.8,"des":"将肉体与“装甲技术”融合的究极格斗技——“MEGALOBOX”，将自己的全部赌在上面的男人们的热血战斗开始！\n今天也立于未认可地区的赌博比赛赛场上的MEGALO拳击手“JNK DOG”。虽然具备实力，..."},{"title":"超能力女儿","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/152c536f8ecaad8f3d7d568d33da81c963a4a722.png@220w_280h.webp","totalCount":"全12话","id":78352,"follow":"293.8 万","view":"9252.2 万","danmaku":"98.5 万","coin":"35.4 万","score":9.6,"des":"支持着芦川组的年轻智力型黑道新田义史，过着被喜欢的壶所包围的悠然自得单身生活。但某一天，随着装在神秘物体里的少女雏来到他家，他的生活为之一变。他被能使用念动力的雏所胁迫，迫不得已开始和她同居！\n容易暴..."},{"title":"OVERLORD Ⅲ","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/dd7a9d0a0bee32b1f43c2656398d8463d12b3069.jpg@220w_280h.webp","totalCount":"全13话","id":102252,"follow":"551.6 万","view":"4.0 亿","danmaku":"399.7 万","coin":"129.2 万","score":9.4,"des":"时间为2138年。曾卷起一大风潮的虚拟现实体感型网络游戏《YGGDRASIL》即将迎来停服。玩家飞鼠在曾经以同伴和荣华自傲的根据地纳萨力克地下大坟墓，独自一人安静等待着那一刻。\n但是，不料发生了“过了..."},{"title":"路人超能100 第一次灵能咨询所员工旅游～舒缓心灵的疗愈之旅~（OVA2）","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/1271324d51634b68980704731987724a1afc60aa.jpg@220w_280h.webp","totalCount":"全1话","id":28222715,"follow":"318.8 万","view":"520.7 万","danmaku":"3.6 万","coin":"4.6 万","score":9.8,"des":"由原作ONE老师担任原案的完全新作OVA！「灵能咨询所」一行人，龙套与灵幻、小酒窝以及新同伴芹泽的目的地，正是缟马县深山中鲜为人知的温泉·疣神温泉。因为灵幻接受了旅馆老板娘的委托，「弄清温泉的恐怖传闻..."},{"title":"少女终末旅行","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1431ca5bb2f7143062e3df8f21b8448cf8cccc13.jpg@220w_280h.webp","totalCount":"全12话","id":6463,"follow":"239.8 万","view":"3714.7 万","danmaku":"100.7 万","coin":"37.2 万","score":9.8,"des":"本作舞台在人类繁华的文明迎来终结的很久以后，人类基本灭绝，甚至生物都不再存在的末日世界。复杂够高的都市成为迷宫般的废墟，得不到维护的机械渐渐停止运转。连何时终结了，何时开始终结的思考都不复存在的这个世..."},{"title":"齐木楠雄的灾难（日播&精选版）","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/eb4f17335f48951945fb9da47e6ee0bc65fa2fbb.jpg@220w_280h.webp","totalCount":"全120话","id":5070,"follow":"187.0 万","view":"2.3 亿","danmaku":"130.7 万","coin":"32.7 万","score":9.6,"des":"高中生·齐木楠雄是超能力者。心灵感应、念动力、透视、预知、瞬间移动、千里眼等，不论任何事情都自由自在。但这任谁都羡慕不已的最强能力，实际上对于本人而言是引来灾难的不幸元凶。因此，他在别人面前封印了超能..."},{"title":"比宇宙更远的地方","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/c9eca3cbc386c63b27461074b8b218898cb7440e.jpg@220w_280h.webp","totalCount":"全13话","id":13032,"follow":"156.0 万","view":"2298.0 万","danmaku":"45.9 万","coin":"23.9 万","score":9.8,"des":"无论何时，我们的第一步总是从好奇心开始。\n不曾看过的风景，不曾听过的声音，不曾闻过的味道，不曾摸过的质感，不曾尝过的食物，以及不曾感受过的澎湃。\n为了重拾不知何时忘却的记忆碎片和不知何时舍弃的感动的旅..."},{"title":"OVERLORD","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/b8e72ea69e57e0b7ac85d8b4d366554fd866df1a.jpg@220w_280h.webp","totalCount":"全13话","id":2576,"follow":"626.2 万","view":"4.1 亿","danmaku":"385.2 万","coin":"84.4 万","score":9.6,"des":"作品主要讲述了某天，一款曾经掀起过大热潮的VRMMORPG「YGGDRASIL」停止了运营。游戏原本会停止一切服务，但过了结束时间后，玩家们却发现不能退出，NPC也产生了各自的思想。现实世界中喜爱电玩..."},{"title":"路人超能100 II(灵能百分百 第二季)","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/216e1bdaf88244215a13b1154116805ee9adbe07.png@220w_280h.webp","totalCount":"全13话","id":4762734,"follow":"284.9 万","view":"1.0 亿","danmaku":"97.8 万","coin":"56.1 万","score":9.9,"des":"当有什么东西达到“100”的时候，就会爆发的少年·路人（龙套）。外表极其普通——不如说是不起眼。不擅长迎合气氛的他，实际上拥有着强力的超能力。盯上了这样的他的能力，而接连现身的伪灵能力者以及宗教团体、..."},{"title":"多罗罗","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3fc16a667502cbff226e585eb660a96a20c7458c.png@220w_280h.webp","totalCount":"全24话","id":4312482,"follow":"452.1 万","view":"1.8 亿","danmaku":"143.9 万","coin":"73.9 万","score":9.4,"des":"他们向着命运抗争，在那尽头等待他们的是人心，还是业障。\n时值乱世。\n名为景光的醍醐将军，向某个寺庙殿堂中的12尊魔神像祈求早日结束战乱。\n作为代价，他的嫡子在出生时就失去了身体的某些部位，被丢弃在河流..."},{"title":"魔法少女小圆","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/7fcaa0e98b561611538ae4deba7949cec4ca39a8.png@220w_280h.webp","totalCount":"全12话","id":2539,"follow":"218.7 万","view":"4199.0 万","danmaku":"201.5 万","coin":"20.0 万","score":9.8,"des":"就读初中二年级的鹿目圆，过着平凡幸福的生活。神秘转学生晓美焰的出现，开始让小圆的命运有了巨大转变。某日一只名为丘比的神秘生物，希望小圆能够与它签订魔法契约，成为“魔法少女”以对抗邪恶的魔女保护世界。正..."}]},"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"http://rebp38war.bkt.clouddn.com/img/v2-9769ffc088ad20ee4ddd74b62cc142c7_r.jpg","excerpt":"","more":"<h3 id=\"Spring是什么\"><a href=\"#Spring是什么\" class=\"headerlink\" title=\"Spring是什么\"></a>Spring是什么</h3><p>是一个容器框架 用来装JAVA bean </p>\n<p>是一个中间层框架 （万能胶） 起到一个连接作用，比如MVC和mybatis 粘合在一起，开发更快、更简洁</p>\n<p>是一个生态：可以构建Java应用所需的一切基础设施</p>\n<p>Spring 是一个轻量级的控制反转(IOC)和面向切面(AOP)的容器框架</p>\n<p>​    –轻量级 （大小和开销）相比EJB</p>\n<p>​    –IOC达到松耦合</p>\n<p>​    –AOP 允许分离应用的业务逻辑与系统级服务进行内聚性（切面）的开发 （日志等）</p>\n<p>​    –管理对象（BEAN）的生命周期</p>\n<p>​    –将组件（Mybatis等）整合（集成）到整个应用中来</p>\n<h3 id=\"Spring的优缺点是什么？\"><a href=\"#Spring的优缺点是什么？\" class=\"headerlink\" title=\"Spring的优缺点是什么？\"></a>Spring的优缺点是什么？</h3><p>（IOC）集中管理了对象，对象和对象之间的耦合度减低。方便维护对象，（单例多例等）</p>\n<p>（AOC）在不修改代码的情况下，可以对业务代码进行增加（减少重复代码、提高开发效率、方便维护）：如日志、监控等与业务方法不相关的代码</p>\n<p>（声明事务）提高开发效率，只要一个简单注解（@Transactional）</p>\n<p>（方便测试）Spring使用Junit4非常方便测试SpringBean SpringMVC</p>\n<p>（集成了各种优秀框架） 拥有非常强大的粘合度（集成能力强），只要简单的配置就可以集成第三方框架</p>\n<p>（降低了JAVA API的使用难度）对很多API（功能性代码）进行了简易封装，使用更加简单方便（如JDBC、JAVAMail、远程调用等）</p>\n<p>（设计模式）通过源码，spring底层的实现、反射。。设计模式都是值得我们学习，提供了非常多的扩展接口供外部进行扩展</p>\n<p>缺点：</p>\n<p>​    从应用层面来说没有多大的缺点</p>\n<p>​    简化了开发，如果想深入到底层去了解就非常困难（上层使用越简单、底层封装的越复杂）</p>\n<p>​    源码缺点：由于Spring大而全（要集成这么多框架、提供了非常多的扩展点，经过十多年的迭代），代码量非常庞大，一百多万 对于深入学习源码带来一定困难。</p>\n<h3 id=\"IOC是什么？有什么作用？优点是什么？\"><a href=\"#IOC是什么？有什么作用？优点是什么？\" class=\"headerlink\" title=\"IOC是什么？有什么作用？优点是什么？\"></a>IOC是什么？有什么作用？优点是什么？</h3><p>控制反转：控制了什么，？</p>\n<p>​        <code>--UserService service = new UserService(); //耦合度高（比如说 改成别的对象，要将每个依赖了User Service的类进行更改，），维护不方便 （要将UserService变成单例对象，每个依赖都new一个的话，性能损耗，维护不方便）</code></p>\n<p>引入IOC 就是将对象的控制权交给了Spring的IOC，以前是自己创建new ，现在就交给Spring的IOC去创建，如果要去使用，需要通过DI（依赖注入）@AutoWired 自动注入 就可以使用对象</p>\n<p>优点：集中管理了对象、方便维护、降低耦合度；支持加载服务时的饿汉式和懒汉式</p>\n<p>IOC的实现机制是什么？</p>\n<p>工厂+反射实现   ：工厂（beanFactory）加反射 帮助我们创建对象</p>\n<p>IOC和DI 的区别是什么？</p>\n<h3 id=\"紧耦合和松耦合的区别？如何编写松耦合的代码？\"><a href=\"#紧耦合和松耦合的区别？如何编写松耦合的代码？\" class=\"headerlink\" title=\"紧耦合和松耦合的区别？如何编写松耦合的代码？\"></a>紧耦合和松耦合的区别？如何编写松耦合的代码？</h3><p>紧耦合：</p>\n<p>​    紧密耦合是指类之间高度依赖</p>\n<p>松耦合：</p>\n<p>​    是通过促进<u>单一职责</u>和<u>关注点分离</u>、<u>依赖倒置</u>的设计原则来实现</p>\n<h3 id=\"BeanFactory的作用\"><a href=\"#BeanFactory的作用\" class=\"headerlink\" title=\"BeanFactory的作用\"></a>BeanFactory的作用</h3><p>spring中非常核心的一个顶层接口</p>\n<p>它的主要职责就是生产Bean</p>\n<p>它实现了简单工厂的设计模式，通过getBean传入标识生产一个Bean</p>\n"},{"title":"Redis指南","date":"2022-07-19T04:21:18.000Z","_content":"\n# NoSQL概述\n\n## 为什么用NoSQL\n\n> 1 、单机MySQL的美好年代\n\n在 90 年代，一个网站的访问量一般不大，用单个数据库完全可以轻松 在那个时候，更多的都是静态网页，动态交互类型的网站不多。\n\n上述架构下，我们来看看数据存储的瓶颈是什么？\n\n*\n    1. 数据量的总大小，一个机器放*\n    *\n        2. 数据的索引（B+ Tree）一个机器的内存放*\n        *\n            3. 访问量（读写混合）一个实例不能承受\n\n如果满足了上述 1 or 3个，进化. DAL：数据库访问层\n\n![输入图片说明](redis/QQ截图20210922100205.png \"QQ截图20201229183512.png\")\n> 2 、Memcached（缓存）+ MySQL + 垂直拆分\n\n> 后来，随着访问量的上升，几乎大部分使用MySQL架构的网站在数据库上都开始出现了性能问题，web 程序不再仅仅专注在功能上，同时也在追求性能。程序猿们开始大量使用缓存技术来缓解数据库的压 力，优化数据库的结构和索引，开始比较流行的是通过文件缓存来缓解数据库压力，但是当访问量继续 增大的时候，多台web机器通过文件缓存不能共享，大量的小文件缓存也带了比较高的IO压力，在这个 时候，Memcached就自然的成为一个非常时尚的技术产品。\n\n![输入图片说明](redis/QQ截图20210922100407.png \"QQ截图20201229183512.png\")\n> 3 、MySQL主从读写分离\n\n> 由于数据库的写入压力增加，Memcached只能缓解数据库的读取压力，读写集中在一个数据库上让数 据库不堪重负，大部分网站开始使用主从复制技术来达到读写分离，以提高读写性能和读库的可扩展 性，MySQL的master-slave模式成为这个时候的网站标配了。\n\n![输入图片说明](redis/QQ截图20210924134715.png \"QQ截图20201229183512.png\")\n\n> 4 、分表分库 + 水平拆分 + Mysql 集群\n\n> 在Memcached的高速缓存，MySQL的主从复制，读写分离的基础之上，这时MySQL主库的写压力开始 出现瓶颈，而数据量的持续猛增，由于MyISAM使用表锁，在高并发下会出现严重的锁问题，大量的高 并发MySQL应用开始使用InnoDB引擎代替MyISAM。 同时，开始流行使用分表分库来缓解写压力和数据增长的扩展问题，这个时候，分表分库成了一个热门 技术，是面试的热门问题，也是业界讨论的热门技术问题。也就是在这个时候，MySQL推出了还不太稳 定的表分区，这也给技术实力一般的公司带来了希望。虽然MySQL推出了MySQL Cluster集群，但性能 也不能很好满足互联网的需求，只是在高可靠性上提供了非常大的保证。\n\n![输入图片说明](redis/QQ截图20210924134937.png \"QQ截图20201229183512.png\")\n\n> 5 、MySQL 的扩展性瓶颈\n\n> MySQL数据库也经常存储一些大文本的字段，导致数据库表非常的大，在做数据库恢复的时候就导致非 常的慢，不容易快速恢复数据库，比如 1000 万4KB大小的文本就接近40GB的大小，如果能把这些数据 从MySQL省去，MySQL将变的非常的小，关系数据库很强大，但是它并不能很好的应付所有的应用场 景，MySQL的扩展性差（需要复杂的技术来实现），大数据下IO压力大，表结构更改困难，正是当前使 用MySQL的开发人员面临的问题。\n\n> 6 、今天是什么样子？？\n\n![输入图片说明](redis/QQ截图20210924135030.png \"QQ截图20201229183512.png\")\n\n> 7 、为什么用NoSQL？\n\n> 今天我们可以通过第三方平台（如：Google，FaceBook等）可以很容易的访问和抓取数据。用户的个 人信息，社交网络，地理位置，用户生成的数据和用户操作日志已经成倍的增加、我们如果要对这些用 户数据进行挖掘，那SQL数据库已经不适合这些应用了，而NoSQL数据库的发展却能很好的处理这些大 的数据！\n\n## 什么是NoSQL\n\n> NoSQL\n\n> NoSQL = Not Only SQL，意思：不仅仅是SQL；\n\n> 泛指非关系型的数据库，随着互联网Web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别 是超大规模和高并发的社交网络服务类型的Web2.0纯动态网站已经显得力不从心，暴露了很多难以克服 的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展，NoSQL数据库的产生就是为 了解决大规模数据集合多种数据种类带来的挑战，尤其是大数据应用难题，包括超大规模数据的存储。 （例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模 式，无需多余操作就可以横向扩展。\n\n> NoSQL的特点\n\n### 1 、易扩展\n\n> NoSQL 数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。 数据之间无关系，这样就非常容易扩展，也无形之间，在架构的层面上带来了可扩展的能力。\n\n### 2 、大数据量高性能\n\n> NoSQL数据库都具有非常高的读写性能，尤其是在大数据量下，同样表现优秀。这得益于它的非关系 性，数据库的结构简单。\n\n> 一般MySQL使用Query Cache，每次表的更新Cache就失效，是一种大力度的Cache，在针对Web2.0的 交互频繁应用，Cache性能不高，而NoSQL的Cache是记录级的，是一种细粒度的Cache，所以NoSQL 在这个层面上来说就要性能高很多了。\n\n> 官方记录：Redis 一秒可以写 8 万次，读 11 万次！\n\n### 3 、多样灵活的数据模型\n\n> NoSQL无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式，而在关系数据库里，增删 字段是一件非常麻烦的事情。如果是非常大数据量的表，增加字段简直就是噩梦。\n\n### 4 、传统的RDBMS VS NoSQL\n\n![输入图片说明](redis/QQ截图20210924135616.png \"QQ截图20201229183512.png\")\n\n> 拓展：3V+3高\n\n### 大数据时代的3V ： 主要是对问题的描述\n\n* 海量 Volume\n* 多样 Variety\n* 实时 Velocity\n\n### 互联网需求的 3 高 ： 主要是对程序的要求\n\n* 高并发\n* 高可用\n* 高性能\n\n`当下的应用是 SQL 和 NoSQL 一起使用，技术没有高低之分，就看你怎么用，对吧！`\n\n## 经典应用分析\n\n### 聊聊阿里巴巴中文网站的商品信息如何存放，以女装、包包为例：\n\n![输入图片说明](redis/QQ截图20210924135616.png \"QQ截图20201229183512.png\")\n\n### 聊聊架构发展历程：推荐书籍《淘宝技术这十年》\n\n### 1 、演变过程：以下图片资料来源：阿里巴巴中文站架构设计实践\n\n![输入图片说明](redis/QQ截图20210924135855.png \"QQ截图20201229183512.png\")\n\n### 2 、第五代\n\n![输入图片说明](redis/QQ截图20210924135915.png \"QQ截图20201229183512.png\")\n\n### 3 、第 5 代架构使命\n\n![输入图片说明](redis/QQ截图20210924135957.png \"QQ截图20201229183512.png\")\n\n### 和我们相关的，多数据源多数据类型的存储问题\n\n![输入图片说明](redis/QQ截图20210924140055.png \"QQ截图20201229183512.png\")\n\n### 1 、商品的基本信息\n\n```\n名称、价格、出厂日期、生产厂商等\n关系型数据库：mysql、oracle目前淘宝在去O化（也即，拿掉Oracle）\n注意，淘宝内部用的MySQL是里面的大牛自己改造过的。\n\n为什么去IOE：\n2008 年,王坚博士加入阿里巴巴，成为首席架构师。把云计算植入阿里IT基因。\n2013 年 5 月 17 日，阿里集团最后一台IBM小机在支付宝下线。这是自 2009 年“去IOE”战略透露以来，“去\nIOE”非常重要的一个节点。“去 IOE”指的是摆脱掉IT部署中原有的IBM小型机、Oracle数据库以及EMC\n存储的过度依赖。告别最后一台小机，意味着整个阿里集团尽管还有一些Oracle数据库和EMC存储，但是\nIBM小型机已全部被替换。 2013 年 7 月 10 日，淘宝重中之重的广告系统使用的Oracle数据库下线，也是整\n个淘宝最后一个 Oracle数据库。这两件事合在一起是阿里巴巴技术发展过程中的一个重要里程碑。\n```\n\n### 2、商品描述、详情、评价信息（多文字类）\n\n```\n多文字信息描述类，IO读写性能变差 \n存在文档数据库MongDB中\n```\n\n3、商品的图片\n\n```\n商品图片展现类 \n分布式文件系统中 \n  - 淘宝自己的 TFS \n  - Google的 GFS \n  - Hadoop的 HDFS\n```\n\n4、商品的关键字\n\n```\n搜索引擎，淘宝内用 \nISearch：多隆一高兴一个人开发的 \n\n所有牛逼的人在牛逼之前,肯定有一段苦逼的岁月,但只要像傻逼一样的坚持,一定终将牛逼\n```\n\n5、商品的波段性的热点高频信息\n\n```\n内存数据库 \nTair、Redis、Memcache等\n```\n\n6、商品的交易，价格计算，积分累计！\n\n```\n外部系统，外部第三方支付接口 \n支付宝\n```\n\n> 大型互联网应用（大数据，高并发，多样数据类型）的难点和解决方案\n**难点：**\n\n* 数据类型的多样性\n* 数据源多样性和变化重构\n* 数据源改造而数据服务平台不需要大面积重构\n\n**解决办法：**\n![输入图片说明](redis/QQ截图20210924140800.png \"QQ截图20201229183512.png\")\n\n![输入图片说明](redis/QQ截图20210924140819.png \"QQ截图20201229183512.png\")\n\n![输入图片说明](redis/QQ截图20210924140833.png \"QQ截图20201229183512.png\")\n\n![输入图片说明](redis/QQ截图20210924140847.png \"QQ截图20201229183512.png\")\n\n![输入图片说明](redis/QQ截图20210924140901.png \"QQ截图20201229183512.png\")\n\n## NoSQL数据模型简介\n\n### 案例设计\n\n`以一个电商客户，订单，订购，地址模型来对比下关系型数据库和非关系型数据库`\n\n**传统的关系型数据库你如何设计？**\n\n### ER图（1:1/1:N/N:N,主外键等常见）\n\n* 用户对应多个订单多个地址\n* 每个订单对应每个商品、价格、地址\n* 每个商品对应产品\n\n  ![输入图片说明](redis/QQ截图20210924141013.png \"QQ截图20201229183512.png\")\n\n> 闲聊：用户画像分析，女人心是琢磨不透的，看了男装，剃须刀，根据她的信息找到她男朋友的生日就 在最近，后台画像已经分析完毕，准备推送广告了，结果她买了一个零食就走了~\n90 后的程序员真的在一点点的改变生活中的点点滴滴，假设你有幸进入了大厂，你会发现周围的小伙伴 都在努力，真的就是那种可以在海底捞吃着吃着饭，突然就掏出笔记本写代码的那种，别人都以为他们 是疯子，只有他们自己内心才懂。这才是对技术的痴迷。\n\n### NoSQL你如何设计\n\n可以尝试使用 BSON 。\n\nBSON是一种类json的一种二进制形式的存储格式，简称Binary JSON，它和JSON一样，支持内嵌的文档\n\n对象和数组对象\n\n用BSon画出构建的数据模型\n\n```json\n{\n  \"customer\": {\n    \"id\": 1000,\n    \"name\": \"Z3\",\n    \"billingAddress\": [\n      {\n        \"city\": \"beijing\"\n      }\n    ],\n    \"orders\": [\n      {\n        \"id\": 17,\n        \"customerId\": 1000,\n        \"orderItems\": [\n          {\n            \"productId\": 27,\n            \"price\": 77.5,\n            \"productName\": \"thinking injava\"\n          }\n        ],\n        \"shippingAddress\": [\n          {\n            \"city\": \"beijing\"\n          }\n        ]\n        \"orderPayment\": [\n          {\n            \"ccinfo\": \"111-222-333\",\n            \"txnid\": \"asdfadcd334\",\n            \"billingAddress\": {\n              \"city\": \"beijing\"\n            }\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n\n> 想想关系模型数据库你如何查？如果按照我们新设计的BSon，是不是查询起来很简单。\n\n* 高并发的操作是不太建议有关联查询的，互联网公司用冗余数据来避免关联查询\n* 分布式事务是支持不了太多的并发的\n\n## NoSQL四大分类\n\n**KV键值 ：**\n\n* 新浪：BerkeleyDB+redis\n* 美团：redis+tair\n* 阿里、百度：memcache+redis\n\n**文档型数据库(bson格式比较多) ：**\n\n* CouchDB\n* MongoDB\n    * MongoDB 是一个 基于分布式文件存储的数据库 。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。\n    * MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。\n\n### 列存储数据库：\n\n* Cassandra, HBase\n* 分布式文件系统\n\n### 图关系数据库\n\n* 它不是放图形的，放的是关系比如:朋友圈社交网络、广告推荐系统\n* 社交网络，推荐系统等。专注于构建关系图谱\n* Neo4J, InfoGrid\n\n### 四者对比\n\n![输入图片说明](redis/QQ截图20210924141532.png \"QQ截图20201229183512.png\")\n\n## CAP + BASE\n\n> 传统的ACID分别是什么？\n\n### 关系型数据库遵循ACID规则，事务在英文中是transaction，和现实世界中的交易很类似，它有如下四个特性：\n\n* A (Atomicity) 原子性\n\n```\n原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务 \n里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。 \n比如银行转账，从A账户转100元至B账户，分为两个步骤： \n1）从A账户取100元； \n2）存入100元至B账户。 \n这两步要么一起完成，要么一起不完成，如果只完成第一步，第二步失败，钱会莫名其妙少了100 元。\n```\n\n* C (Consistency) 一致性\n\n```\n事务前后数据的完整性必须保持一致。\n```\n\n* I (Isolation) 隔离性\n\n```\n所谓的独立性是指并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修 改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。比如现有有个交易是从A 账户转100元至B账户，在这个交易还未完成的情况下，如果此时B查询自己的账户，是看不到新增加 的100元的\n```\n\n* D (Durability) 持久性\n\n```\n持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。\n```\n\n### CAP（三进二）\n\n* C : Consistency（强一致性）\n* A : Availability（可用性）\n* P : Partition tolerance（分区容错性）\n\n**CAP理论就是说在分布式存储系统中，最多只能实现上面的两点 。**\n\n> 而由于当前的网络硬件肯定会出现延迟丢包等问题，所以 分区容错性是我们必须需要实现 的。 所以我们只能在一致性和可用性之间进行权衡，没有NoSQL系统能同时保证这三点。 注意：分布式架构的时候必须做出取舍。 一致性和可用性之间取一个平衡。多余大多数web应用，其实并不需要强一致性。 因此牺牲C换取P，这是目前分布式数据库产品的方向\n\n**一致性与可用性的决择**\n> 对于web2.0网站来说，关系数据库的很多主要特性却往往无用武之地\n\n**数据库事务一致性需求**\n\n> 很多web实时系统并不要求严格的数据库事务，对读一致性的要求很低， 有些场合对写一致性要求并不 高。允许实现最终一致性。\n\n**数据库的写实时性和读实时性需求**\n\n> 对关系数据库来说，插入一条数据之后立刻查询，是肯定可以读出来这条数据的，但是对于很多web应 用来说，并不要求这么高的实时性，比方说发一条消息之 后，过几秒乃至十几秒之后，我的订阅者才看 到这条动态是完全可以接受的。\n\n**对复杂的SQL查询，特别是多表关联查询的需求**\n\n> 任何大数据量的web系统，都非常忌讳多个大表的关联查询，以及复杂的数据分析类型的报表查询，特 别是SNS类型的网站，从需求以及产品设计角度，就避免了这种情况的产生。往往更多的只是单表的主 键查询，以及单表的简单条件分页查询，SQL的功能被极大的弱化了。\n\n**CAP理论的核心** 是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求， 最多只能同时较好的满足两个。因此，根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足 AP 原则三\n大类：\n\n* CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。\n* CP - 满足一致性，分区容忍必的系统，通常性能不是特别高。\n* AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。\n\n  ![输入图片说明](redis/QQ截图20210924144835.png \"QQ截图20201229183512.png\")\n\n### BASE 理论\n\n> BASE理论是由eBay架构师提出的。BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互 联网分布式系统实践的总结，是基于CAP定律逐步演化而来。其核心思想是即使无法做到强一致性，但 每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。\n\n**BASE就是为了解决关系数据库强一致性引起的问题而引起的可用性降低而提出的解决方案。**\n\n### BASE其实是下面三个术语的缩写：\n\n* 基本可用(Basically Available)：\n  基本可用是指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。电商大促时，为了应对访问量激增，部分用户可能会被引导到降级页面，服务层也可能只提供降级服务。这就是损失部分可用性的体现。\n\n* 软状态(Soft State)： 软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现。MySQL Replication\n  的异步复制也是一种体现。\n\n* 最终一致性(Eventual Consistency)： 最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。\n\n> 它的思想是通过让系统放松对某一时刻数据一致性的要求来换取系统整体伸缩性和性能上改观。为什么 这么说呢，缘由就在于大型系统往往由于地域分布和极高性能的要求，不可能采用分布式事务来完成这 些指标，要想获得这些指标，我们必须采用另外一种方式来完成，这里BASE就是解决这个问题的办法！\n**解释：**\n\n* 1 、分布式：不同的多台服务器上面部署不同的服务模块（工程），他们之间通过Rpc通信和调用，对外提供服务和组内协作。\n* 2 、集群：不同的多台服务器上面部署相同的服务模块，通过分布式调度软件进行统一的调度，对外提供服务和访问。\n\n# Redis入门\n\n## 概述\n\n### Redis是什么\n\n> Redis：REmote DIctionary Server（远程字典服务器） 是完全开源免费的，用C语言编写的，遵守BSD协议，是一个高性能的（Key/Value）分布式内存数据 库，基于内存运行，并支持持久化的NoSQL数据库，是当前最热门的NoSQL数据库之一，也被人们称为 数据结构服务器\n\n### Redis与其他key-value缓存产品有以下三个特点\n\n* Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。\n\n* Redis不仅仅支持简单的 key-value 类型的数据，同时还提供list、set、zset、hash等数据结构的存储。\n\n* Redis支持数据的备份，即master-slave模式的数据备份。\n\n### Redis能干嘛\n\n> 内存存储和持久化：redis支持异步将内存中的数据写到硬盘上，同时不影响继续服务取最新N个数据的操作，如：可以将最新的 10 条评论的ID放在Redis的List集合里面 发布、订阅消息系统 地图信息分析 定时器、计数器......\n\n### 特性\n\n数据类型、基本操作和配置\n\n持久化和复制，RDB、AOF\n\n事务的控制\n\n.....\n\n### 常用网站\n\n### https://redis.io/ 官网\n\n### http://www.redis.cn 中文网\n\n## Windows安装\n\n### 下载地址：https://github.com/dmajkic/redis/downloads ( 素材提供 )\n\n解压到自己电脑的环境目录即可\n\n![输入图片说明](redis/QQ截图20210927092007.png \"QQ截图20201229183512.png\")\n\n### 双击 redis-server.exe 启动即可\n\n![输入图片说明](redis/QQ截图20210927092027.png \"QQ截图20201229183512.png\")\n\n**通过客户端去访问 redis-cli**\n\n```shell\n# 基本的set设值\n127.0.0.1:6379> set key kuangshen\nOK\n# 取出存储的值\n127.0.0.1:6379> get key\n\"kuangshen\"\n```\n\n`重要提示`\n\n> 由于企业里面做Redis开发，99%都是Linux版的运用和安装，几乎不会涉及到Windows版，上一步的讲 解只是为了知识的完整性，Windows版不作为重点，大家可以自己玩，企业实战就认一个版：Linux版\n\n**http://www.redis.cn/topics/introduction**\n\n![输入图片说明](redis/QQ截图20210927092145.png \"QQ截图20201229183512.png\")\n\n## Linux安装\n\n### 下载地址 http://download.redis.io/releases/redis-5.0.7.tar.gz\n\n![输入图片说明](redis/QQ截图20210927092233.png \"QQ截图20201229183512.png\")\n\n### 安装步骤\n\n* 1 、下载获得 redis-5.0.7.tar.gz 后将它放到我们Linux的目录下 /opt\n* 2 、/opt 目录下，解压命令 ： tar -zxvf redis-5.0.7.tar.gz\n* 3 、解压完成后出现文件夹：redis-5.0.\n* 4 、进入目录： cd redis-5.0.\n* 5 、在 redis-5.0.7 目录下执行 make 命令\n\n```\n运行make命令时故意出现的错误解析：\n1. 安装gcc (gcc是linux下的一个编译程序，是c程序的编译工具)\n能上网: yum install gcc-c++\n版本测试: gcc-v\n2. 二次make\n3. Jemalloc/jemalloc.h: 没有那个文件或目录\n运行 make distclean 之后再make\n4. Redis Test（可以不用执行）\n```\n\n* 6 、如果make完成后继续执行 make install\n* 7 、查看默认安装目录：usr/local/bin 1 /usr 这是一个非常重要的目录，类似于windows下的Program Files,存放用户的程序\n* 8 、拷贝配置文件（备用）\n\n```shell\ncd /usr/local/bin\nls -l\n# 在redis的解压目录下备份redis.conf\nmkdir myredis\ncp redis.conf myredis  # 拷一个备份，养成良好的习惯，我们就修改这个文件\n# 修改配置保证可以后台应用\nvim redis.conf\n```\n\n![输入图片说明](redis/QQ截图20210927092451.png \"QQ截图20201229183512.png\")\n\n* A、redis.conf配置文件中daemonize守护线程，默认是NO。\n* B、daemonize是用来指定redis是否要用守护线程的方式启动。\n\n**daemonize 设置yes或者no区别**\n\n* daemonize:yes\n\n    *\n    redis采用的是单进程多线程的模式。当redis.conf中选项daemonize设置成yes时，代表开启守护进程模式。在该模式下，redis会在后台运行，并将进程pid号写入至redis.conf选项pidfile设置的文件中，此时redis将一直运行，除非手动kill该进程。\n\n* daemonize:no\n    * 当daemonize选项设置成no时，当前界面将进入redis的命令行界面，exit强制退出或者关闭连接工具(putty,xshell等)都会导致redis进程退出。\n\n### 9 、启动测试一下！\n\n```shell\n# 【shell】启动redis服务\n[root@192 bin]# cd /usr/local/bin\n[root@192 bin]# redis-server /opt/redis-5.0.7/redis.conf\n\n# redis客户端连接===> 观察地址的变化，如果连接ok,是直接连上的，redis默认端口号 6379\n[root@192 bin]# redis-cli -p 6379\n127.0.0.1:6379> ping\nPONG\n127.0.0.1:6379> set k1 helloworld\nOK\n127.0.0.1:6379> get k\n\"helloworld\"\n\n# 【shell】ps显示系统当前进程信息\n[root@192 myredis]# ps -ef|grep redis\nroot 16005  1  0 04 :45? 00 :00:00 redis-server\n127.0.0.1:\nroot 16031  15692  0 04 :47 pts/0 00 :00:00 redis-cli -p 6379\nroot 16107  16076  0 04 :51 pts/2 00 :00:00 grep --color=auto redis\n\n# 【redis】关闭连接\n127.0.0.1:6379> shutdown\nnot connected> exit\n\n# 【shell】ps显示系统当前进程信息\n[root@192 myredis]# ps -ef|grep redis\nroot 16140  16076  0 04 :53 pts/2 00 :00:00 grep --color=auto redis\n```\n\n## 基础知识说明\n\n准备工作：开启redis服务，客户端连接\n\n> redis压力测试工具-----Redis-benchmark\n\nRedis-benchmark是官方自带的Redis性能测试工具，可以有效的测试Redis服务的性能。\n\n![输入图片说明](redis/QQ截图20210927092755.png \"QQ截图20201229183512.png\")\n\n### redis 性能测试工具可选参数如下所示：\n\n|  序号   | 选项  |  描述   | 默认值  |\n|  ----  | ----  |  ----  | ----  |\n| 1  | -h | 指定服务器主机名  | 127.0.0.1 |\n| 2  | -p | 指定服务器端口  |  6379 |\n|3| -s| 指定服务器| socket|\n|4| -c| 指定并发连接数| 50|\n|5| -n| 指定请求数 |10000|\n|6| -d| 以字节的形式指定 SET/GET 值的数据大小 |2|\n|7| -k| 1=keep alive 0=reconnect |1|\n|8| -r| SET/GET/INCR 使用随机 key, SADD 使用随机值|\n|9| -P| 通过管道传输 请求 |1\n|10| -q| 强制退出 redis。仅显示 query/sec 值|\n|11| --csv| 以 CSV 格式输出|\n|12| -l| 生成循环，永久执行测试|\n|13| -t| 仅运行以逗号分隔的测试命令列表。|\n|14| -I| Idle 模式。仅打开 N 个 idle 连接并等待。|\n\n```shell\n# 测试一： 100 个并发连接， 100000 个请求，检测host为localhost 端口为 6379 的redis服务器性能\nredis-benchmark -h localhost -p 6379 -c 100 -n 100000\n# 测试出来的所有命令只举例一个！\n====== SET ======\n 100000 requests completed in 1.88 seconds # 对集合写入测试\n 100 parallel clients # 每次请求有 100 个并发客户端\n 3 bytes payload # 每次写入 3 个字节的数据，有效载荷\nkeep alive: 1 # 保持一个连接，一台服务器来处理这些请求\n\n17.05% <= 1 milliseconds\n97.35% <= 2 milliseconds\n99.97% <= 3 milliseconds\n100.00% <= 3 milliseconds # 所有请求在 3 毫秒内完成\n53248.14 requests per second # 每秒处理 53248.14 次请求\n```\n\n### 基本数据库常识\n\n### 默认 16 个数据库，类似数组下标从零开始，初始默认使用零号库\n\n```\n查看 redis.conf ，里面有默认的配置\ndatabases 16\n\n# Set the number of databases. The default database is DB 0, you can select\n# a different one on a per-connection basis using SELECT <dbid> where\n# dbid is a number between 0 and 'databases'-1\ndatabases 16\n```\n\n### Select命令切换数据库\n\n```shell\n127.0.0.1:6379> select 7\nOK\n127.0.0.1:6379[7]>\n# 不同的库可以存不同的数据\n### Dbsize查看当前数据库的key的数量\n127.0.0.1:6379> select 7\nOK\n127.0.0.1:6379[7]> DBSIZE\n(integer) 0\n127.0.0.1:6379[7]> select 0\nOK\n127.0.0.1:6379> DBSIZE\n(integer) 5\n127.0.0.1:6379> keys * # 查看具体的key\n1 ) \"counter:__rand_int__\"\n2 ) \"mylist\"\n3 ) \"k1\"\n4 ) \"myset:__rand_int__\"\n5 ) \"key:__rand_int__\"\n```\n\n### Flushdb：清空当前库\n\n### Flushall：清空全部的库\n\n```shell\n127.0.0.1:6379> DBSIZE\n(integer) 5\n127.0.0.1:6379> FLUSHDB\nOK\n127.0.0.1:6379> DBSIZE\n(integer) 0\n```\n\n### 为什么默认端口是 6379 ？粉丝效应！\n\n> 为什么redis是单线程\n\n> 我们首先要明白，Redis很快！官方表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了！\n\n\n> Redis采用的是基于内存的采用的是单进程单线程模型的 KV 数据库，由C语言编写，官方提供的数据是可以达到100000+的QPS（每秒内查询次数）。这个数据不比采用单进程多线程的同样基于内存的 KV数据库 Memcached 差！\n\n### Redis为什么这么快？\n\n* 1 ）以前一直有个误区，以为：高性能服务器 一定是多线程来实现的 原因很简单因为误区二导致的：多线程 一定比 单线程 效率高，其实不然！ 在说这个事前希望大家都能对 CPU 、 内存 、 硬盘的速度都有了解了！\n\n* 2 ）redis 核心就是 如果我的数据全都在内存里，我单线程的去操作 就是效率最高的，为什么呢，因为 多线程的本质就是 CPU 模拟出来多个线程的情况，这种模拟出来的情况就有一个代价，就是上下文的切\n  换，对于一个内存的系统来说，它没有上下文的切换就是效率最高的。redis 用 单个CPU 绑定一块内存 的数据，然后针对这块内存的数据进行多次读写的时候，都是在一个CPU上完成的，所以它是单线程处\n  理这个事。在内存的情况下，这个方案就是最佳方案。 因为一次CPU上下文的切换大概在 1500ns 左右。从内存中读取 1MB 的连续数据，耗时大约为 250us， 假设1MB的数据由多个线程读取了 1000 次，那么就有 1000\n  次时间上下文的切换，那么就有1500ns *\n  1000 = 1500us ，我单线程的读完1MB数据才250us ,你光时间上下文的切换就用了1500us了，我还不 算你每次读一点数据 的时间。\n\n# 五大数据类型\n\n> 官方文档\n![输入图片说明](redis/QQ截图20210927094518.png \"QQ截图20201229183512.png\")\n\n命令文档 http://doc.redisfans.com/\n\n### 全段翻译：\n\n> Redis是一个开放源代码（BSD许可）的内存中数据结构存储，用作数据库，缓存和消息代理。它支持数 据结构，例如字符串，哈希，列表，集合，带范围查询的排序集合，位图，超日志，带有半径查询和流 的地理空间索引。Redis具有内置的复制，Lua脚本，LRU驱逐，事务和不同级别的磁盘持久性，并通过 Redis Sentinel和Redis Cluster自动分区提供了高可用性。\n\n### String （字符串类型）\n\n> String是redis最基本的类型，你可以理解成Memcached一模一样的类型，一个key对应一个value。<br>\nString类型是二进制安全的，意思是redis的string可以包含任何数据，比如jpg图片或者序列化的对象。<br>\nString类型是redis最基本的数据类型，一个redis中字符串value最多可以是512M。<br>\n\n### Hash（哈希，类似 Java里的Map）\n\n> Redis hash 是一个键值对集合。<br>\nRedis hash 是一个String类型的field和value的映射表，hash特别适合用于存储对象。<br>\n类似Java里面的Map<String,Object><br>\n\n### List（列表）\n\n> Redis列表是简单的字符串列表，按照插入顺序排序，你可以添加一个元素到列表的头部（左边）或者尾部（右边）。<br>\n它的底层实际是个链表!\n\n### Set（集合）\n\n> Redis的Set是String类型的无序集合，它是通过HashTable实现的!\n\n### Zset（sorted set：有序集合）\n\n> Redis zset 和 set 一样，也是String类型元素的集合，且不允许重复的成员。<br>\n不同的是每个元素都会关联一个double类型的分数。<br><br>\nRedis正是通过分数来为集合中的成员进行从小到大的排序，zset的成员是唯一的，但是分数（Score）<br>\n却可以重复。<br>\n\n## Redis键（key）\n\n```shell\n# keys * 查看所有的key\n127.0.0.1:6379> keys *\n(empty list or set)\n127.0.0.1:6379> set name qinjiang\nOK\n127.0.0.1:6379> keys *\n1 ) \"name\"\n\n# exists key 的名字，判断某个key是否存在\n127.0.0.1:6379> EXISTS name\n(integer) 1\n127.0.0.1:6379> EXISTS name1\n(integer) 0\n\n# move key db ---> 当前库就没有了，被移除了\n127.0.0.1:6379> move name 1\n(integer) 1\n127.0.0.1:6379> keys *\n(empty list or set)\n\n# expire key 秒钟：为给定 key 设置生存时间，当 key 过期时(生存时间为 0 )，它会被自动删\n除。\n# ttl key 查看还有多少秒过期，-1 表示永不过期，-2 表示已过期\n127.0.0.1:6379> set name qinjiang\nOK\n\n127.0.0.1:6379> EXPIRE name 10\n(integer) 1\n127.0.0.1:6379> ttl name\n(integer) 4\n127.0.0.1:6379> ttl name\n(integer) 3\n127.0.0.1:6379> ttl name\n(integer) 2\n127.0.0.1:6379> ttl name\n(integer) 1\n127.0.0.1:6379> ttl name\n(integer) -2\n127.0.0.1:6379> keys *\n(empty list or set)\n\n# type key 查看你的key是什么类型\n127.0.0.1:6379> set name qinjiang\nOK\n127.0.0.1:6379> get name\n\"qinjiang\"\n127.0.0.1:6379> type name\nstring\n```\n\n## 字符串String\n\n`单值单Value`\n\n**常用命令说明：**\n\n```shell\n#### # ===================================================\n# set、get、del、append、strlen\n# ===================================================\n127.0.0.1:6379> set key1 value1 # 设置值\nOK\n127.0.0.1:6379> get key1  # 获得key\n\"value1\"\n127.0.0.1:6379> del key1  # 删除key\n(integer) 1\n127.0.0.1:6379> keys *  # 查看全部的key\n(empty list or set)\n127.0.0.1:6379> exists key1 # 确保 key1 不存在\n(integer) 0\n127.0.0.1:6379> append key1 \"hello\" # 对不存在的 key 进行 APPEND ，等同于 SET\nkey1 \"hello\"\n(integer) 5 # 字符长度\n127.0.0.1:6379> APPEND key1 \"-2333\" # 对已存在的字符串进行 APPEND\n(integer) 10 # 长度从 5 个字符增加到 10 个字符\n127.0.0.1:6379> get key1\n\"hello-2333\"\n127.0.0.1:6379> STRLEN key1 # # 获取字符串的长度\n(integer) 10\n\n# ===================================================\n# incr、decr 一定要是数字才能进行加减，+1 和 -1。\n# incrby、decrby 命令将 key 中储存的数字加上指定的增量值。\n# ===================================================\n\n127.0.0.1:6379> set views 0 # 设置浏览量为 0\nOK\n127.0.0.1:6379> incr views  # 浏览 + 1\n(integer) 1\n127.0.0.1:6379> incr views  # 浏览 + 1\n(integer) 2\n127.0.0.1:6379> decr views  # 浏览 - 1\n(integer) 1\n127.0.0.1:6379> incrby views 10 # +10\n(integer) 11\n127.0.0.1:6379> decrby views 10 # -10\n(integer) 1\n\n# ===================================================\n# range [范围]\n# getrange 获取指定区间范围内的值，类似between...and的关系，从零到负一表示全部\n# ===================================================\n127.0.0.1:6379> set key2 abcd123456  # 设置key2的值\nOK\n127.0.0.1:6379> getrange key2 0 -1 # 获得全部的值\n\"abcd123456\"\n127.0.0.1:6379> getrange key2 0 2 # 截取部分字符串\n\"abc\"\n\n# ===================================================\n# setrange 设置指定区间范围内的值，格式是setrange key值 具体值\n# ===================================================\n127.0.0.1:6379> get key2\n\"abcd123456\"\n127.0.0.1:6379> SETRANGE key2 1 xx # 替换值\n(integer) 10\n127.0.0.1:6379> get key2\n\"axxd123456\"\n\n# ===================================================\n# setex（set with expire）键秒值\n# setnx（set if not exist）\n# ===================================================\n127.0.0.1:6379> setex key3 60 expire  # 设置过期时间\nOK\n\n127.0.0.1:6379> ttl key3  # 查看剩余的时间\n(integer) 55\n127.0.0.1:6379> setnx mykey \"redis\" # 如果不存在就设置，成功返回 1\n(integer) 1\n127.0.0.1:6379> setnx mykey \"mongodb\" # 如果存在就设置，失败返回 0\n(integer) 0\n127.0.0.1:6379> get mykey\n\"redis\"\n\n# ===================================================\n# mset Mset 命令用于同时设置一个或多个 key-value 对。\n# mget Mget 命令返回所有(一个或多个)给定 key 的值。\n# 如果给定的 key 里面，有某个 key 不存在，那么这个 key 返回特殊值 nil 。\n# msetnx 当所有 key 都成功设置，返回 1 。\n# 如果所有给定 key 都设置失败(至少有一个 key 已经存在)，那么返回 0 。原子操\n作\n# ===================================================\n127.0.0.1:6379> mset k10 v10 k11 v11 k12 v12\nOK\n127.0.0.1:6379> keys *\n1 ) \"k12\"\n2 ) \"k11\"\n3 ) \"k10\"\n127.0.0.1:6379> mget k10 k11 k12 k13\n1 ) \"v10\"\n2 ) \"v11\"\n3 ) \"v12\"\n4 ) (nil)\n127.0.0.1:6379> msetnx k10 v10 k15 v15 # 原子性操作！\n(integer) 0\n127.0.0.1:6379> get key15\n(nil)\n\n# 传统对象缓存\nset user:1 value(json数据)\n\n# 可以用来缓存对象\nmset user:1:name zhangsan user:1:age 2\nmget user:1:name user:1:age\n\n# ===================================================\n# getset（先get再set）\n# ===================================================\n127.0.0.1:6379> getset db mongodb # 没有旧值，返回 nil\n(nil)\n127.0.0.1:6379> get db\n\"mongodb\"\n127.0.0.1:6379> getset db redis # 返回旧值 mongodb\n\"mongodb\"\n127.0.0.1:6379> get db\n\"redis\"\n```\n\nString数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。\n\n常规key-value缓存应用：\n\n常规计数：微博数，粉丝数等。\n\n## 列表List\n\n`单值多Value`\n\n```shell\n#### # ===================================================\n# Lpush：将一个或多个值插入到列表头部。（左）\n# rpush：将一个或多个值插入到列表尾部。（右）\n# lrange：返回列表中指定区间内的元素，区间以偏移量 START 和 END 指定。\n# 其中 0 表示列表的第一个元素， 1 表示列表的第二个元素，以此类推。\n# 你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此\n类推。\n# ===================================================\n127.0.0.1:6379> LPUSH list \"one\"\n(integer) 1\n127.0.0.1:6379> LPUSH list \"two\"\n(integer) 2\n\n127.0.0.1:6379> RPUSH list \"right\"\n(integer) 3\n127.0.0.1:6379> Lrange list 0 -1\n1 ) \"two\"\n2 ) \"one\"\n3 ) \"right\"\n127.0.0.1:6379> Lrange list 0 1\n1 ) \"two\"\n2 ) \"one\"\n\n# ===================================================\n# lpop 命令用于移除并返回列表的第一个元素。当列表 key 不存在时，返回 nil 。\n# rpop 移除列表的最后一个元素，返回值为移除的元素。\n# ===================================================\n127.0.0.1:6379> Lpop list\n\"two\"\n127.0.0.1:6379> Rpop list\n\"right\"\n127.0.0.1:6379> Lrange list 0 -1\n1 ) \"one\"\n\n# ===================================================\n# Lindex，按照索引下标获得元素（-1代表最后一个， 0 代表是第一个）\n# ===================================================\n127.0.0.1:6379> Lindex list 1\n(nil)\n127.0.0.1:6379> Lindex list 0\n\"one\"\n127.0.0.1:6379> Lindex list -1\n\"one\"\n\n# ===================================================\n# llen 用于返回列表的长度。\n# ===================================================\n127.0.0.1:6379> flushdb\nOK\n127.0.0.1:6379> Lpush list \"one\"\n(integer) 1\n127.0.0.1:6379> Lpush list \"two\"\n(integer) 2\n127.0.0.1:6379> Lpush list \"three\"\n(integer) 3\n127.0.0.1:6379> Llen list # 返回列表的长度\n(integer) 3\n\n# ===================================================\n# lrem key 根据参数 COUNT 的值，移除列表中与参数 VALUE 相等的元素。\n# ===================================================\n127.0.0.1:6379> lrem list 1 \"two\"\n(integer) 1\n127.0.0.1:6379> Lrange list 0 -1\n1 ) \"three\"\n2 ) \"one\"\n\n# ===================================================\n# Ltrim key 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区\n间之内的元素都将被删除。\n# ===================================================\n\n127.0.0.1:6379> RPUSH mylist \"hello\"\n(integer) 1\n127.0.0.1:6379> RPUSH mylist \"hello\"\n(integer) 2\n127.0.0.1:6379> RPUSH mylist \"hello2\"\n(integer) 3\n127.0.0.1:6379> RPUSH mylist \"hello3\"\n(integer) 4\n127.0.0.1:6379> ltrim mylist 1 2\nOK\n127.0.0.1:6379> lrange mylist 0 -1\n1 ) \"hello\"\n2 ) \"hello2\"\n\n# ===================================================\n# rpoplpush 移除列表的最后一个元素，并将该元素添加到另一个列表并返回。\n# ===================================================\n127.0.0.1:6379> rpush mylist \"hello\"\n(integer) 1\n127.0.0.1:6379> rpush mylist \"foo\"\n(integer) 2\n127.0.0.1:6379> rpush mylist \"bar\"\n(integer) 3\n127.0.0.1:6379> rpoplpush mylist myotherlist\n\"bar\"\n127.0.0.1:6379> lrange mylist 0 -1\n1 ) \"hello\"\n2 ) \"foo\"\n127.0.0.1:6379> lrange myotherlist 0 -1\n1 ) \"bar\"\n\n# ===================================================\n# lset key index value 将列表 key 下标为 index 的元素的值设置为 value 。\n# ===================================================\n127.0.0.1:6379> exists list  # 对空列表(key 不存在)进行 LSET\n(integer) 0\n127.0.0.1:6379> lset list 0 item # 报错\n(error) ERR no such key\n\n127.0.0.1:6379> lpush list \"value1\" # 对非空列表进行 LSET\n(integer) 1\n127.0.0.1:6379> lrange list 0 0\n1 ) \"value1\"\n127.0.0.1:6379> lset list 0 \"new\" # 更新值\nOK\n127.0.0.1:6379> lrange list 0 0\n1 ) \"new\"\n127.0.0.1:6379> lset list 1 \"new\" # index 超出范围报错\n(error) ERR index out of range\n\n# ===================================================\n# linsert key before/after pivot value 用于在列表的元素前或者后插入元素。\n# 将值 value 插入到列表 key 当中，位于值 pivot 之前或之后。\n# ===================================================\nredis> RPUSH mylist \"Hello\"\n(integer) 1\nredis> RPUSH mylist \"World\"\n(integer) 2\n\nredis> LINSERT mylist BEFORE \"World\" \"There\"\n(integer) 3\nredis> LRANGE mylist 0 -1\n1 ) \"Hello\"\n2 ) \"There\"\n3 ) \"World\"\n```\n\n### 性能总结\n\n* 它是一个字符串链表，left，right 都可以插入添加\n* 如果键不存在，创建新的链表\n* 如果键已存在，新增内容\n* 如果值全移除，对应的键也就消失了\n* 链表的操作无论是头和尾效率都极高，但假如是对中间元素进行操作，效率就很惨淡了。\n\n> list就是链表，略有数据结构知识的人都应该能理解其结构。使用Lists结构，我们可以轻松地实现最新消 息排行等功能。List的另一个应用就是消息队列，可以利用List的PUSH操作，将任务存在List中，然后工 作线程再用POP操作将任务取出进行执行。Redis还提供了操作List中某一段的api，你可以直接查询，删 除List中某一段的元素。\n\n> Redis的list是每个子元素都是String类型的双向链表，可以通过push和pop操作从列表的头部或者尾部添加或者删除元素，这样List即可以作为栈，也可以作为队列。\n\n## 集合Set\n\n`单值多value`\n\n```shell\n#### # ===================================================\n# sadd 将一个或多个成员元素加入到集合中，不能重复\n# smembers 返回集合中的所有的成员。\n# sismember 命令判断成员元素是否是集合的成员。\n# ===================================================\n127.0.0.1:6379> sadd myset \"hello\"\n(integer) 1\n127.0.0.1:6379> sadd myset \"kuangshen\"\n(integer) 1\n127.0.0.1:6379> sadd myset \"kuangshen\"\n(integer) 0\n127.0.0.1:6379> SMEMBERS myset\n1 ) \"kuangshen\"\n2 ) \"hello\"\n127.0.0.1:6379> SISMEMBER myset \"hello\"\n(integer) 1\n127.0.0.1:6379> SISMEMBER myset \"world\"\n(integer) 0\n\n# ===================================================\n# scard，获取集合里面的元素个数\n# ===================================================\n127.0.0.1:6379> scard myset\n(integer) 2\n\n# ===================================================\n# srem key value 用于移除集合中的一个或多个成员元素\n# ===================================================\n127.0.0.1:6379> srem myset \"kuangshen\"\n(integer) 1\n\n127.0.0.1:6379> SMEMBERS myset\n1 ) \"hello\"\n\n# ===================================================\n# srandmember key 命令用于返回集合中的一个随机元素。\n# ===================================================\n127.0.0.1:6379> SMEMBERS myset\n1 ) \"kuangshen\"\n2 ) \"world\"\n3 ) \"hello\"\n127.0.0.1:6379> SRANDMEMBER myset\n\"hello\"\n127.0.0.1:6379> SRANDMEMBER myset 2\n1 ) \"world\"\n2 ) \"kuangshen\"\n127.0.0.1:6379> SRANDMEMBER myset 2\n1 ) \"kuangshen\"\n2 ) \"hello\"\n\n# ===================================================\n# spop key 用于移除集合中的指定 key 的一个或多个随机元素\n# ===================================================\n127.0.0.1:6379> SMEMBERS myset\n1 ) \"kuangshen\"\n2 ) \"world\"\n3 ) \"hello\"\n127.0.0.1:6379> spop myset\n\"world\"\n127.0.0.1:6379> spop myset\n\"kuangshen\"\n127.0.0.1:6379> spop myset\n\"hello\"\n\n# ===================================================\n# smove SOURCE DESTINATION MEMBER\n# 将指定成员 member 元素从 source 集合移动到 destination 集合。\n# ===================================================\n127.0.0.1:6379> sadd myset \"hello\"\n(integer) 1\n127.0.0.1:6379> sadd myset \"world\"\n(integer) 1\n127.0.0.1:6379> sadd myset \"kuangshen\"\n(integer) 1\n127.0.0.1:6379> sadd myset2 \"set2\"\n(integer) 1\n127.0.0.1:6379> smove myset myset2 \"kuangshen\"\n(integer) 1\n127.0.0.1:6379> SMEMBERS myset\n1 ) \"world\"\n2 ) \"hello\"\n127.0.0.1:6379> SMEMBERS myset2\n1 ) \"kuangshen\"\n2 ) \"set2\"\n\n# ===================================================\n- 数字集合类\n  - 差集： sdiff\n  - 交集： sinter\n  - 并集： sunion\n# ===================================================\n127.0.0.1:6379> sadd key1 \"a\"\n(integer) 1\n127.0.0.1:6379> sadd key1 \"b\"\n(integer) 1\n127.0.0.1:6379> sadd key1 \"c\"\n(integer) 1\n127.0.0.1:6379> sadd key2 \"c\"\n(integer) 1\n127.0.0.1:6379> sadd key2 \"d\"\n(integer) 1\n127.0.0.1:6379> sadd key2 \"e\"\n(integer) 1\n127.0.0.1:6379> SDIFF key1 key2 # 差集\n1 ) \"a\"\n2 ) \"b\"\n127.0.0.1:6379> SINTER key1 key2 # 交集\n1 ) \"c\"\n127.0.0.1:6379> SUNION key1 key2 # 并集\n1 ) \"a\"\n2 ) \"b\"\n3 ) \"c\"\n4 ) \"e\"\n5 ) \"d\"\n```\n\n> 在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis还为集合提供了求交集、并集、差集等操作，可以非常方便的实现如共同关注、共同喜好、二度好友等功能，对上面的所有集合操作，你还可以使用不同的命令选择将结果返回给客户端还是存集到一个新的集合中。\n\n## 哈希Hash\n\n`kv模式不变，但V是一个键值对`\n\n```shell\n#### # ===================================================\n\n# hset、hget 命令用于为哈希表中的字段赋值 。\n# hmset、hmget 同时将多个field-value对设置到哈希表中。会覆盖哈希表中已存在的字段。\n# hgetall 用于返回哈希表中，所有的字段和值。\n# hdel 用于删除哈希表 key 中的一个或多个指定字段\n# ===================================================\n127.0.0.1:6379> hset myhash field1 \"kuangshen\"\n(integer) 1\n127.0.0.1:6379> hget myhash field1\n\"kuangshen\"\n127.0.0.1:6379> HMSET myhash field1 \"Hello\" field2 \"World\"\nOK\n127.0.0.1:6379> HGET myhash field1\n\"Hello\"\n127.0.0.1:6379> HGET myhash field2\n\"World\"\n127.0.0.1:6379> hgetall myhash\n1 ) \"field1\"\n2 ) \"Hello\"\n3 ) \"field2\"\n4 ) \"World\"\n127.0.0.1:6379> HDEL myhash field1\n(integer) 1\n127.0.0.1:6379> hgetall myhash\n1 ) \"field2\"\n2 ) \"World\"\n\n# ===================================================\n# hlen 获取哈希表中字段的数量。\n# ===================================================\n127.0.0.1:6379> hlen myhash\n(integer) 1\n127.0.0.1:6379> HMSET myhash field1 \"Hello\" field2 \"World\"\nOK\n127.0.0.1:6379> hlen myhash\n(integer) 2\n\n# ===================================================\n# hexists 查看哈希表的指定字段是否存在。\n# ===================================================\n127.0.0.1:6379> hexists myhash field1\n(integer) 1\n127.0.0.1:6379> hexists myhash field3\n(integer) 0\n\n# ===================================================\n# hkeys 获取哈希表中的所有域（field）。\n# hvals 返回哈希表所有域(field)的值。\n# ===================================================\n127.0.0.1:6379> HKEYS myhash\n1 ) \"field2\"\n2 ) \"field1\"\n127.0.0.1:6379> HVALS myhash\n1 ) \"World\"\n2 ) \"Hello\"\n\n# ===================================================\n# hincrby 为哈希表中的字段值加上指定增量值。\n# ===================================================\n127.0.0.1:6379> hset myhash field 5\n(integer) 1\n127.0.0.1:6379> HINCRBY myhash field 1\n(integer) 6\n127.0.0.1:6379> HINCRBY myhash field -1\n(integer) 5\n127.0.0.1:6379> HINCRBY myhash field -10\n(integer) -5\n\n# ===================================================\n# hsetnx 为哈希表中不存在的的字段赋值 。\n# ===================================================\n127.0.0.1:6379> HSETNX myhash field1 \"hello\"\n(integer) 1 # 设置成功，返回 1 。\n127.0.0.1:6379> HSETNX myhash field1 \"world\"\n(integer) 0 # 如果给定字段已经存在，返回 0 。\n127.0.0.1:6379> HGET myhash field1\n\"hello\"\n```\n\n> Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。存储部分变更的数据，如用户信息等。\n\n## 有序集合Zset\n\n`在set基础上，加一个score值。之前set是k1 v1 v2 v3，现在zset是 k1 score1 v1 score2 v2`\n\n```shell\n#### # ===================================================\n# zadd 将一个或多个成员元素及其分数值加入到有序集当中。\n# zrange 返回有序集中，指定区间内的成员\n# ===================================================\n127.0.0.1:6379> zadd myset 1 \"one\"\n(integer) 1\n127.0.0.1:6379> zadd myset 2 \"two\" 3 \"three\"\n(integer) 2\n127.0.0.1:6379> ZRANGE myset 0 -1\n1 ) \"one\"\n2 ) \"two\"\n3 ) \"three\"\n\n# ===================================================\n# zrangebyscore 返回有序集合中指定分数区间的成员列表。有序集成员按分数值递增(从小到大)\n次序排列。\n# ===================================================\n127.0.0.1:6379> zadd salary 2500 xiaoming\n(integer) 1\n127.0.0.1:6379> zadd salary 5000 xiaohong\n(integer) 1\n127.0.0.1:6379> zadd salary 500 kuangshen\n(integer) 1\n# Inf无穷大量+∞,同样地,-∞可以表示为-Inf。\n127.0.0.1:6379> ZRANGEBYSCORE salary -inf +inf # 显示整个有序集\n1 ) \"kuangshen\"\n2 ) \"xiaoming\"\n3 ) \"xiaohong\"\n127.0.0.1:6379> ZRANGEBYSCORE salary -inf +inf withscores # 递增排列\n1 ) \"kuangshen\"\n2 ) \"500\"\n3 ) \"xiaoming\"\n4 ) \"2500\"\n5 ) \"xiaohong\"\n6 ) \"5000\"\n127.0.0.1:6379> ZREVRANGE salary 0 -1 WITHSCORES  # 递减排列\n1 ) \"xiaohong\"\n2 ) \"5000\"\n3 ) \"xiaoming\"\n4 ) \"2500\"\n5 ) \"kuangshen\"\n6 ) \"500\"\n127.0.0.1:6379> ZRANGEBYSCORE salary -inf 2500 WITHSCORES # 显示工资 <=2500\n的所有成员\n1 ) \"kuangshen\"\n2 ) \"500\"\n3 ) \"xiaoming\"\n4 ) \"2500\"\n\n#### # ===================================================\n# zrem 移除有序集中的一个或多个成员\n# ===================================================\n127.0.0.1:6379> ZRANGE salary 0 -1\n1 ) \"kuangshen\"\n2 ) \"xiaoming\"\n3 ) \"xiaohong\"\n127.0.0.1:6379> zrem salary kuangshen\n(integer) 1\n127.0.0.1:6379> ZRANGE salary 0 -1\n1 ) \"xiaoming\"\n2 ) \"xiaohong\"\n\n# ===================================================\n# zcard 命令用于计算集合中元素的数量。\n# ===================================================\n127.0.0.1:6379> zcard salary\n(integer) 2\nOK\n\n# ===================================================\n# zcount 计算有序集合中指定分数区间的成员数量。\n# ===================================================\n127.0.0.1:6379> zadd myset 1 \"hello\"\n(integer) 1\n127.0.0.1:6379> zadd myset 2 \"world\" 3 \"kuangshen\"\n(integer) 2\n127.0.0.1:6379> ZCOUNT myset 1 3\n(integer) 3\n127.0.0.1:6379> ZCOUNT myset 1 2\n(integer) 2\n\n# ===================================================\n# zrank 返回有序集中指定成员的排名。其中有序集成员按分数值递增(从小到大)顺序排列。\n# ===================================================\n127.0.0.1:6379> zadd salary 2500 xiaoming\n(integer) 1\n127.0.0.1:6379> zadd salary 5000 xiaohong\n(integer) 1\n127.0.0.1:6379> zadd salary 500 kuangshen\n(integer) 1\n127.0.0.1:6379> ZRANGE salary 0 -1 WITHSCORES  # 显示所有成员及其 score 值\n1 ) \"kuangshen\"\n2 ) \"500\"\n3 ) \"xiaoming\"\n4 ) \"2500\"\n5 ) \"xiaohong\"\n6 ) \"5000\"\n127.0.0.1:6379> zrank salary kuangshen  # 显示 kuangshen 的薪水排名，最少\n(integer) 0\n127.0.0.1:6379> zrank salary xiaohong # 显示 xiaohong 的薪水排名，第三\n(integer) 2\n\n# ===================================================\n# zrevrank 返回有序集中成员的排名。其中有序集成员按分数值递减(从大到小)排序。\n# ===================================================\n127.0.0.1:6379> ZREVRANK salary bright\n```\n\n> 和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列，比如一个存储全班同学成绩的sorted set，其集合value可以是同学的学号，而score就可以是其考试得分，这样在数据插入集合的时候，就已经进行了天然的排序。可以用sorted set来做带权重的队列，比如普通消息的score为 1 ，重要消息的score为 2 ，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。\n\n> 排行榜应用，取TOP N操作 ！\n\n# 三种特殊数据类型\n\n## GEO地理位置\n\n> 简介\n\n> Redis 的 GEO 特性在 Redis 3.2 版本中推出， 这个功能可以将用户给定的地理位置信息储存起来， 并对这些信息进行操作。来实现诸如附近位置、摇一摇这类依赖于地理位置信息的功能。geo的数据类型为zset。\n\n> GEO 的数据结构总共有六个常用命令：geoadd、geopos、geodist、georadius、georadiusbymember、gethash\n\n### 官方文档：https://www.redis.net.cn/order/3685.html\n\n### geoadd\n\n**解析：**\n\n```shell\n#### # 语法\ngeoadd key longitude latitude member...\n\n# 将给定的空间元素(纬度、经度、名字)添加到指定的键里面。\n# 这些数据会以有序集he的形式被储存在键里面，从而使得georadius和georadiusbymember这样的命令可以在之后通过位置查询取得这些元素。\n# geoadd命令以标准的x,y格式接受参数,所以用户必须先输入经度,然后再输入纬度。\n# geoadd能够记录的坐标是有限的:非常接近两极的区域无法被索引。\n# 有效的经度介于-180-180度之间，有效的纬度介于-85.05112878 度至 85.05112878 度之间。，当用户尝试输入一个超出范围的经度或者纬度时,geoadd命令将返回一个错误。\n```\n\n### 测试：百度搜索经纬度查询，模拟真实数据\n\n```shell\n127.0.0.1:6379> geoadd china:city 116.23 40.22 北京\n(integer) 1\n127.0.0.1:6379> geoadd china:city 121.48 31.40 上海 113.88 22.55 深圳 120.21\n30.20 杭州\n(integer) 3\n127.0.0.1:6379> geoadd china:city 106.54 29.40 重庆 108.93 34.23 西安 114.02\n30.58 武汉\n(integer) 3\n```\n\n### geopos\n\n**解析：**\n\n```shell\ngeopos key member [member...]\n\n#从key里返回所有给定位置元素的位置（经度和纬度）\n```\n\n### 测试：\n\n```shell\n127.0.0.1:6379> geopos china:city 北京\n1 ) 1 ) \"116.23000055551528931\"\n2 ) \"40.2200010338739844\"\n127.0.0.1:6379> geopos china:city 上海 重庆\n1 ) 1 ) \"121.48000091314315796\"\n2 ) \"31.40000025319353938\"\n2 ) 1 ) \"106.54000014066696167\"\n2 ) \"29.39999880018641676\"\n127.0.0.1:6379> geopos china:city 新疆\n1 ) (nil)\n```\n\n### geodist\n\n**解析：**\n\n```shell\ngeodist key member1 member2 [unit]\n\n# 返回两个给定位置之间的距离，如果两个位置之间的其中一个不存在,那么命令返回空值。\n# 指定单位的参数unit必须是以下单位的其中一个：\n# m表示单位为米\n# km表示单位为千米\n# mi表示单位为英里\n# ft表示单位为英尺\n# 如果用户没有显式地指定单位参数,那么geodist默认使用米作为单位。\n#geodist命令在计算距离时会假设地球为完美的球形,在极限情况下,这一假设最大会造成0.5%的误差。\n```\n\n### 测试：\n\n```shell\n127.0.0.1:6379> geodist china:city 北京 上海\n\"1088785.4302\"\n127.0.0.1:6379> geodist china:city 北京 上海 km\n\"1088.7854\"\n127.0.0.1:6379> geodist china:city 重庆 北京 km\n\"1491.6716\"\n```\n\n### georadius\n\n### 解析：\n\n```shell\n#### # 语法\ngeoradius key longitude latitude radius m|km|ft|mi [withcoord][withdist]\n[withhash][asc|desc][count count]\n# 以给定的经纬度为中心， 找出某一半径内的元素\n```\n\n### 测试：重新连接 redis-cli，增加参数 --raw ，可以强制输出中文，不然会乱码\n\n```shell\n[root@kuangshen bin]# redis-cli --raw -p 6379\n# 在 china:city 中寻找坐标 100 30 半径为 1000km 的城市\n127.0.0.1:6379> georadius china:city 100 30 1000 km\n重庆\n西安\n\n# withdist 返回位置名称和中心距离\n127.0.0.1:6379> georadius china:city 100 30 1000 km withdist\n重庆\n635.2850\n西安\n963.3171\n\n# withcoord 返回位置名称和经纬度\n127.0.0.1:6379> georadius china:city 100 30 1000 km withcoord\n重庆\n106.54000014066696167\n29.39999880018641676\n西安\n108.92999857664108276\n34.23000121926852302\n\n# withdist withcoord 返回位置名称 距离 和经纬度 count 限定寻找个数\n127.0.0.1:6379> georadius china:city 100 30 1000 km withcoord withdist count\n1\n重庆\n635.2850\n106.54000014066696167\n29.39999880018641676\n127.0.0.1:6379> georadius china:city 100 30 1000 km withcoord withdist count\n2\n重庆\n635.2850\n106.54000014066696167\n29.39999880018641676\n西安\n963.3171\n108.92999857664108276\n34.23000121926852302\n```\n\n### georadiusbymember\n\n### 解析：\n\n```shell\n#### # 语法\ngeoradiusbymember key member radius m|km|ft|mi [withcoord][withdist]\n[withhash][asc|desc][count count]\n# 找出位于指定范围内的元素，中心点是由给定的位置元素决定\n```\n\n### 测试：\n\n```\n127.0.0.1:6379> GEORADIUSBYMEMBER china:city 北京 1000 km\n北京\n西安\n127.0.0.1:6379> GEORADIUSBYMEMBER china:city 上海 400 km\n杭州\n上海\n```\n\n### geohash\n\n### 解析：\n\n```\n#### # 语法\ngeohash key member [member...]\n# Redis使用geohash将二维经纬度转换为一维字符串，字符串越长表示位置更精确,两个字符串越相似\n表示距离越近。\n```\n\n### 测试：\n\n```\n127.0.0.1:6379> geohash china:city 北京 重庆\nwx4sucu47r0\nwm5z22h53v0\n127.0.0.1:6379> geohash china:city 北京 上海\nwx4sucu47r0\nwtw6sk5n300\n```\n\n### zrem\n\n> GEO没有提供删除成员的命令，但是因为GEO的底层实现是zset，所以可以借用zrem命令实现对地理位置信息的删除.\n\n```shell\n127.0.0.1:6379> geoadd china:city 116.23 40.22 beijin\n1\n127.0.0.1:6379> zrange china:city 0 -1 # 查看全部的元素\n重庆\n西安\n深圳\n武汉\n杭州\n上海\nbeijin\n北京\n127.0.0.1:6379> zrem china:city beijin  # 移除元素\n1\n127.0.0.1:6379> zrem china:city 北京 # 移除元素\n1\n127.0.0.1:6379> zrange china:city 0 -1\n重庆\n西安\n深圳\n武汉\n杭州\n上海\n```\n\n## HyperLogLog\n\n### 简介\n\nRedis 在 2.8.9 版本添加了 HyperLogLog 结构。\n\nRedis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积 非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。\n\n在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。\n\n> HyperLogLog则是一种算法，它提供了不精确的去重计数方案。举个栗子：假如我要统计网页的UV（浏览用户数量，一天内同一个用户多次访问只能算一次），传统的解决方案是使用Set来保存用户id，然后统计Set中的元素数量来获取页面UV。但这种方案只能承载少量用户，一旦用户数量大起来就需要消耗大量的空间来存储用户id。我的目的是统计用户数量而不是保存用户，这简直是个吃力不讨好的方案！而使用Redis的HyperLogLog最多需要12k就可以统计大量的用户数，尽管它大概有0.81%的错误率，但对于统计UV这种不需要很精确的数据是可以忽略不计的。\n\n### 什么是基数？\n\n> 比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为 5 。基数估计就是在误差可接受的范围内，快速计算基数。\n\n### 基本命令\n\n|  命令   | 描述  |\n|  ----  | ----  |\n| [PFADD key element [element...]  | 添加指定元素到 HyperLogLog 中。 |\n| [PFCOUNT key [key...]  | 返回给定 HyperLogLog 的基数估算值。 |\n|[PFMERGE destkey sourcekey[sourcekey...]  | 将多个 HyperLogLog 合并为一个 HyperLogLog，并集计算 |\n\n### 测试\n\n```\n127.0.0.1: 6379 > PFADD mykey a b c d e f g h i j\n1\n127.0.0.1: 6379 > PFCOUNT mykey\n10\n127.0.0.1: 6379 > PFADD mykey2 i j z x c v b n m\n1\n127.0.0.1: 6379 > PFMERGE mykey3 mykey mykey2\nOK\n127.0.0.1: 6379 > PFCOUNT mykey3\n15\n```\n\n## BitMap\n\n> 简介\n\n> 在开发中，可能会遇到这种情况：需要统计用户的某些信息，如活跃或不活跃，登录或者不登录；又如需要记录用户一年的打卡情况，打卡了是 1 ， 没有打卡是 0 ，如果使用普通的 key/value存储，则要记录365 条记录，如果用户量很大，需要的空间也会很大，所以 Redis 提供了 Bitmap 位图这中数据结构，Bitmap 就是通过操作二进制位来进行记录，即为 0 和 1 ；如果要记录 365 天的打卡情况，使用 Bitmap表示的形式大概如下：0101000111000111...........................，这样有什么好处呢？当然就是节约内存了， 365 天相当于 365 bit，又 1 字节 = 8 bit , 所以相当于使用 46 个字节即可。\n\n> BitMap 就是通过一个 bit 位来表示某个元素对应的值或者状态, 其中的 key 就是对应元素本身，实际上底层也是通过对字符串的操作来实现。Redis 从 2.2 版本之后新增了setbit, getbit, bitcount 等几个bitmap 相关命令。\n\n### setbit 设置操作\n\nSETBIT key offset value : 设置 key 的第 offset 位为value (1或0)\n\n```shell\n# 使用 bitmap 来记录上述事例中一周的打卡记录如下所示：\n# 周一： 1 ，周二： 0 ，周三： 0 ，周四： 1 ，周五： 1 ，周六： 0 ，周天： 0 （ 1 为打卡， 0 为不打卡）\n127.0.0.1:6379> setbit sign 0 1\n0\n127.0.0.1:6379> setbit sign 1 0\n0\n127.0.0.1:6379> setbit sign 2 0\n0\n127.0.0.1:6379> setbit sign 3 1\n0\n127.0.0.1:6379> setbit sign 4 1\n0\n127.0.0.1:6379> setbit sign 5 0\n0\n127.0.0.1:6379> setbit sign 6 0\n0\n```\n\n### getbit 获取操作\n\nGETBIT key offset 获取offset设置的值，未设置过默认返回 0\n\n```shell\n127.0.0.1:6379> getbit sign 3 # 查看周四是否打卡\n1\n127.0.0.1:6379> getbit sign 6 # 查看周七是否打卡\n0\n```\n\n### bitcount 统计操作\n\nbitcount key [start, end] 统计 key 上位为 1 的个数\n\n```\n127.0.0.1:6379> bitcount sign\n3\n```\n\n# Redis事务\n\n## 理论\n\n### Redis事务的概念：\n\n> Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。\n\n总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。\n**Redis事务没有隔离级别的概念：**\n\n批量操作在发送 EXEC 命令前被放入队列缓存，并不会被实际执行！\n\n**Redis不保证原子性：**\n\nRedis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。\n\n**Redis事务的三个阶段：**\n\n* 开始事务\n* 命令入队\n* 执行事务\n\n### Redis事务相关命令：\n\n```\nwatch key1 key2...  #监视一或多个key,如果在事务执行之前，被监视的key被其他命令改动，则\n事务被打断 （ 类似乐观锁 ）\nmulti # 标记一个事务块的开始（ queued ）\nexec # 执行所有事务块的命令 （ 一旦执行exec后，之前加的监控锁都会被取消掉 ）\ndiscard # 取消事务，放弃事务块中的所有命令\nunwatch # 取消watch对所有key的监控\n```\n\n## 实践\n\n### 正常执行\n\n![输入图片说明](redis/QQ截图20210927112345.png \"QQ截图20201229183512.png\")\n\n### 放弃事务\n\n![输入图片说明](redis/QQ截图20210927112358.png \"QQ截图20201229183512.png\")\n\n若在事务队列中存在命令性错误（类似于java编译性错误），则执行EXEC命令时，所有命令都不会执行\n![输入图片说明](redis/QQ截图20210927112441.png \"QQ截图20201229183512.png\")\n\n若在事务队列中存在语法性错误（类似于java的1/0的运行时异常），则执行EXEC命令时，其他正确命令会被执行，错误命令抛出异常。\n\n![输入图片说明](redis/QQ截图20210927112511.png \"QQ截图20201229183512.png\")\n\n## Watch 监控\n\n### 悲观锁：\n\n> 悲观锁(Pessimistic Lock),顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿到这个数据就会block直到它拿到锁。传统的关系型数据库里面就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在操作之前先上锁。\n\n### 乐观锁：\n\n> 乐观锁(Optimistic Lock),顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁。但是在更新的时候会判断一下再此期间别人有没有去更新这个数据，可以使用版本号等机制，乐观锁适用于多读的应用类型，这样可以提高吞吐量，乐观锁策略：提交版本必须大于记录当前版本才能执行更新。\n\n### 测试：\n\n* 1 、初始化信用卡可用余额和欠额\n\n```\n127.0.0.1:6379> set balance 100\nOK\n127.0.0.1:6379> set debt 0\nOK\n```\n\n* 2 、使用watch检测balance，事务期间balance数据未变动，事务执行成功\n\n```\n127.0.0.1:6379> watch balance\nOK\n127.0.0.1:6379> MULTI\nOK\n127.0.0.1:6379> decrby balance 20\nQUEUED\n127.0.0.1:6379> incrby debt 20\nQUEUED\n127.0.0.1:6379> exec\n1 ) (integer) 80\n2 ) (integer) 20\n```\n\n* 3 、使用watch检测balance，事务期间balance数据变动，事务执行失败！\n\n```shell\n#### # 窗口一\n127.0.0.1:6379> watch balance\nOK\n127.0.0.1:6379> MULTI  # 执行完毕后，执行窗口二代码测试\nOK\n127.0.0.1:6379> decrby balance 20\nQUEUED\n127.0.0.1:6379> incrby debt 20\nQUEUED\n127.0.0.1:6379> exec  # 修改失败！\n(nil)\n\n# 窗口二\n127.0.0.1:6379> get balance\n\"80\"\n127.0.0.1:6379> set balance 200\nOK\n\n# 窗口一：出现问题后放弃监视，然后重来！\n127.0.0.1:6379> UNWATCH  # 放弃监视\nOK\n127.0.0.1:6379> watch balance\nOK\n127.0.0.1:6379> MULTI\nOK\n127.0.0.1:6379> decrby balance 20\nQUEUED\n127.0.0.1:6379> incrby debt 20\n```\n\n### 说明：\n\n一但执行 EXEC 开启事务的执行后，无论事务使用执行成功， WARCH 对变量的监控都将被取消。故当事务执行失败后，需重新执行WATCH命令对变量进行监控，并开启新的事务进行操作。\n\n## 小结\n\nwatch指令类似于乐观锁，在事务提交时，如果watch监控的多个KEY中任何KEY的值已经被其他客户端更改，则使用EXEC执行事务时，事务队列将不会被执行，同时返回Nullmulti-bulk应答以通知调用者事务执行失败。\n\n# Jedis\n\n> Jedis是Redis官方推荐的Java连接开发工具。要在Java开发中使用好Redis中间件，必须对Jedis熟悉才能写成漂亮的代码\n\n## 测试联通\n\n* 1 、新建一个普通的Maven项目\n* 2 、导入redis的依赖！\n\n```xml\n<!-- https://mvnrepository.com/artifact/redis.clients/jedis -->\n<dependency>\n    <groupId>redis.clients</groupId>\n    <artifactId>jedis</artifactId>\n    <version>3.2.0</version>\n</dependency>\n<dependency>\n<groupId>com.alibaba</groupId>\n<artifactId>fastjson</artifactId>\n<version>1.2.58</version>\n</dependency>\n```\n\n* 3 、编写测试代码\n\n```java\npackage com.kuang.ping;\n\nimport redis.clients.jedis.Jedis;\n\npublic class Ping {\n    public static void main(String[] args) {\n        Jedis jedis = new Jedis(\"127.0.0.1\", 6379);\n        System.out.println(\"连接成功\");\n        //查看服务是否运行\n        System.out.println(\"服务正在运行: \" + jedis.ping());\n    }\n}\n*4 、启动redis服务\n        *5 、启动测试，结果\n        ```shell\n        连接成功\n        服务正在运行:PONG\n```\n\n## 常用API\n\n### 基本操作\n\n```java\npublic class TestPassword {\n    public static void main(String[] args) {\n        Jedis jedis = new Jedis(\"127.0.0.1\", 6379);\n\n        //验证密码，如果没有设置密码这段代码省略\n        // jedis.auth(\"password\");\n\n        jedis.connect(); //连接\n        jedis.disconnect(); //断开连接\n\n        jedis.flushAll(); //清空所有的key\n    }\n}\n```\n\n### 对key操作的命令\n\n```java\npublic class TestKey {\n    public static void main(String[] args) {\n        Jedis jedis = new Jedis(\"127.0.0.1\", 6379);\n\n        System.out.println(\"清空数据：\" + jedis.flushDB());\n        System.out.println(\"判断某个键是否存在：\" + jedis.exists(\"username\"));\n        System.out.println(\"新增<'username','kuangshen'>的键值对：\" + jedis.set(\"username\", \"kuangshen\"));\n        System.out.println(\"新增<'password','password'>的键值对：\" + jedis.set(\"password\", \"password\"));\n        System.out.print(\"系统中所有的键如下：\");\n        Set<String> keys = jedis.keys(\"*\");\n        System.out.println(keys);\n        System.out.println(\"删除键password:\" + jedis.del(\"password\"));\n        System.out.println(\"判断键password是否存在：\" + jedis.exists(\"password\"));\n        System.out.println(\"查看键username所存储的值的类型：\" + jedis.type(\"username\"));\n        System.out.println(\"随机返回key空间的一个：\" + jedis.randomKey());\n        System.out.println(\"重命名key：\" + jedis.rename(\"username\", \"name\"));\n        System.out.println(\"取出改后的name：\" + jedis.get(\"name\"));\n        System.out.println(\"按索引查询：\" + jedis.select(0));\n        System.out.println(\"删除当前选择数据库中的所有key：\" + jedis.flushDB());\n        System.out.println(\"返回当前数据库中key的数目：\" + jedis.dbSize());\n        System.out.println(\"删除所有数据库中的所有key：\" + jedis.flushAll());\n    }\n}\n```\n\n### 对String操作的命令\n\n```java\npublic class TestString {\n    public static void main(String[] args) {\n        Jedis jedis = new Jedis(\"127.0.0.1\", 6379);\n\n        jedis.flushDB();\n        System.out.println(\"===========增加数据===========\");\n        System.out.println(jedis.set(\"key1\", \"value1\"));\n        System.out.println(jedis.set(\"key2\", \"value2\"));\n        System.out.println(jedis.set(\"key3\", \"value3\"));\n\n        System.out.println(\"删除键key2:\" + jedis.del(\"key2\"));\n        System.out.println(\"获取键key2:\" + jedis.get(\"key2\"));\n        System.out.println(\"修改key1:\" + jedis.set(\"key1\", \"value1Changed\"));\n        System.out.println(\"获取key1的值：\" + jedis.get(\"key1\"));\n        System.out.println(\"在key3后面加入值：\" + jedis.append(\"key3\", \"End\"));\n        System.out.println(\"key3的值：\" + jedis.get(\"key3\"));\n        System.out.println(\"增加多个键值对：\" + jedis.mset(\"key01\", \"value01\", \"key02\", \"value02\", \"key03\", \"value03\"));\n        System.out.println(\"获取多个键值对：\" + jedis.mget(\"key01\", \"key02\", \"key03\"));\n        System.out.println(\"获取多个键值对：\" + jedis.mget(\"key01\", \"key02\", \"key03\", \"key04\"));\n        System.out.println(\"删除多个键值对：\" + jedis.del(\"key01\", \"key02\"));\n        System.out.println(\"获取多个键值对：\" + jedis.mget(\"key01\", \"key02\", \"key03\"));\n\n        jedis.flushDB();\n        System.out.println(\"===========新增键值对防止覆盖原先值==============\");\n        System.out.println(jedis.setnx(\"key1\", \"value1\"));\n        System.out.println(jedis.setnx(\"key2\", \"value2\"));\n        System.out.println(jedis.setnx(\"key2\", \"value2-new\"));\n        System.out.println(jedis.get(\"key1\"));\n        System.out.println(jedis.get(\"key2\"));\n\n        System.out.println(\"===========新增键值对并设置有效时间=============\");\n        System.out.println(jedis.setex(\"key3\", 2, \"value3\"));\n        System.out.println(jedis.get(\"key3\"));\n        try {\n            TimeUnit.SECONDS.sleep(3);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(jedis.get(\"key3\"));\n\n        System.out.println(\"===========获取原值，更新为新值==========\");\n        System.out.println(jedis.getSet(\"key2\", \"key2GetSet\"));\n        System.out.println(jedis.get(\"key2\"));\n\n        System.out.println(\"获得key2的值的字串：\" + jedis.getrange(\"key2\", 2, 4));\n    }\n}\n```\n\n### 对List操作命令\n\n```java\npublic class TestList {\n    public static void main(String[] args) {\n        Jedis jedis = new Jedis(\"127.0.0.1\", 6379);\n        jedis.flushDB();\n        System.out.println(\"===========添加一个list===========\");\n        jedis.lpush(\"collections\", \"ArrayList\", \"Vector\", \"Stack\", \"HashMap\", \"WeakHashMap\", \"LinkedHashMap\");\n        jedis.lpush(\"collections\", \"HashSet\");\n        jedis.lpush(\"collections\", \"TreeSet\");\n        jedis.lpush(\"collections\", \"TreeMap\");\n        System.out.println(\"collections的内容：\" + jedis.lrange(\"collections\", 0, -1));//-1代表倒数第一个元素，-2代表倒数第二个元素,end为-1表示查询全部\n\n        System.out.println(\"collections区间0-3的元素：\" + jedis.lrange(\"collections\", 0, 3));\n        System.out.println(\"===============================\");\n        // 删除列表指定的值 ，第二个参数为删除的个数（有重复时），后add进去的值先被删，类似于出栈\n        System.out.println(\"删除指定元素个数：\" + jedis.lrem(\"collections\", 2, \"HashMap\"));\n        System.out.println(\"collections的内容：\" + jedis.lrange(\"collections\", 0, -1));\n        System.out.println(\"删除下表0-3区间之外的元素：\" + jedis.ltrim(\"collections\", 0, 3));\n        System.out.println(\"collections的内容：\" + jedis.lrange(\"collections\", 0, -1));\n        System.out.println(\"collections列表出栈（左端）：\" + jedis.lpop(\"collections\"));\n        System.out.println(\"collections的内容：\" + jedis.lrange(\"collections\", 0, -1));\n        System.out.println(\"collections添加元素，从列表右端，与lpush相对应：\" + jedis.rpush(\"collections\", \"EnumMap\"));\n        System.out.println(\"collections的内容：\" + jedis.lrange(\"collections\", 0, -1));\n        System.out.println(\"collections列表出栈（右端）：\" + jedis.rpop(\"collections\"));\n        System.out.println(\"collections的内容：\" + jedis.lrange(\"collections\", 0, -1));\n        System.out.println(\"修改collections指定下标 1 的内容：\" + jedis.lset(\"collections\", 1, \"LinkedArrayList\"));\n        System.out.println(\"collections的内容：\" + jedis.lrange(\"collections\", 0, -1));\n        System.out.println(\"===============================\");\n        System.out.println(\"collections的长度：\" + jedis.llen(\"collections\"));\n        System.out.println(\"获取collections下标为 2 的元素：\" + jedis.lindex(\"collections\", 2));\n        System.out.println(\"===============================\");\n        jedis.lpush(\"sortedList\", \"3\", \"6\", \"2\", \"0\", \"7\", \"4\");\n        System.out.println(\"sortedList排序前：\" + jedis.lrange(\"sortedList\", 0, -1));\n        System.out.println(jedis.sort(\"sortedList\"));\n        System.out.println(\"sortedList排序后：\" + jedis.lrange(\"sortedList\", 0, -1));\n    }\n}\n```\n\n### 对Set的操作命令\n\n```java\npublic class TestSet {\n    public static void main(String[] args) {\n        Jedis jedis = new Jedis(\"127.0.0.1\", 6379);\n        jedis.flushDB();\n        System.out.println(\"============向集合中添加元素（不重复）============\");\n        System.out.println(jedis.sadd(\"eleSet\", \"e1\", \"e2\", \"e4\", \"e3\", \"e0\", \"e8\", \"e7\", \"e5\"));\n        System.out.println(jedis.sadd(\"eleSet\", \"e6\"));\n        System.out.println(jedis.sadd(\"eleSet\", \"e6\"));\n        System.out.println(\"eleSet的所有元素为：\" + jedis.smembers(\"eleSet\"));\n        System.out.println(\"删除一个元素e0：\" + jedis.srem(\"eleSet\", \"e0\"));\n\n        System.out.println(\"eleSet的所有元素为：\" + jedis.smembers(\"eleSet\"));\n        System.out.println(\"删除两个元素e7和e6：\" + jedis.srem(\"eleSet\", \"e7\", \"e6\"));\n        System.out.println(\"eleSet的所有元素为：\" + jedis.smembers(\"eleSet\"));\n        System.out.println(\"随机的移除集合中的一个元素：\" + jedis.spop(\"eleSet\"));\n        System.out.println(\"随机的移除集合中的一个元素：\" + jedis.spop(\"eleSet\"));\n        System.out.println(\"eleSet的所有元素为：\" + jedis.smembers(\"eleSet\"));\n        System.out.println(\"eleSet中包含元素的个数：\" + jedis.scard(\"eleSet\"));\n        System.out.println(\"e3是否在eleSet中：\" + jedis.sismember(\"eleSet\", \"e3\"));\n        System.out.println(\"e1是否在eleSet中：\" + jedis.sismember(\"eleSet\", \"e1\"));\n        System.out.println(\"e1是否在eleSet中：\" + jedis.sismember(\"eleSet\", \"e5\"));\n        System.out.println(\"=================================\");\n        System.out.println(jedis.sadd(\"eleSet1\", \"e1\", \"e2\", \"e4\", \"e3\", \"e0\", \"e8\", \"e7\", \"e5\"));\n        System.out.println(jedis.sadd(\"eleSet2\", \"e1\", \"e2\", \"e4\", \"e3\", \"e0\", \"e8\"));\n        System.out.println(\"将eleSet1中删除e1并存入eleSet3中：\" + jedis.smove(\"eleSet1\", \"eleSet3\", \"e1\"));//移到集合元素\n        System.out.println(\"将eleSet1中删除e2并存入eleSet3中：\" + jedis.smove(\"eleSet1\", \"eleSet3\", \"e2\"));\n        System.out.println(\"eleSet1中的元素：\" + jedis.smembers(\"eleSet1\"));\n        System.out.println(\"eleSet3中的元素：\" + jedis.smembers(\"eleSet3\"));\n        System.out.println(\"============集合运算=================\");\n        System.out.println(\"eleSet1中的元素：\" + jedis.smembers(\"eleSet1\"));\n        System.out.println(\"eleSet2中的元素：\" + jedis.smembers(\"eleSet2\"));\n        System.out.println(\"eleSet1和eleSet2的交集:\" + jedis.sinter(\"eleSet1\", \"eleSet2\"));\n        System.out.println(\"eleSet1和eleSet2的并集:\" + jedis.sunion(\"eleSet1\", \"eleSet2\"));\n        System.out.println(\"eleSet1和eleSet2的差集:\" + jedis.sdiff(\"eleSet1\", \"eleSet2\"));//eleSet1中有，eleSet2中没有\n        jedis.sinterstore(\"eleSet4\", \"eleSet1\", \"eleSet2\");//求交集并将交集保存到dstkey的集合\n        System.out.println(\"eleSet4中的元素：\" + jedis.smembers(\"eleSet4\"));\n    }\n}\n```\n\n### 对Hash的操作命令\n\n```java\npublic class TestHash {\n    public static void main(String[] args) {\n        Jedis jedis = new Jedis(\"127.0.0.1\", 6379);\n        jedis.flushDB();\n        Map<String, String> map = new HashMap<>();\n        map.put(\"key1\", \"value1\");\n        map.put(\"key2\", \"value2\");\n        map.put(\"key3\", \"value3\");\n        map.put(\"key4\", \"value4\");\n        //添加名称为hash（key）的hash元素\n        jedis.hmset(\"hash\", map);\n        //向名称为hash的hash中添加key为key5，value为value5元素\n        jedis.hset(\"hash\", \"key5\", \"value5\");\n        System.out.println(\"散列hash的所有键值对为：\" + jedis.hgetAll(\"hash\"));//return Map<String,String>\n\n        System.out.println(\"散列hash的所有键为：\" + jedis.hkeys(\"hash\"));//return\n        Set<String>\n        System.out.println(\"散列hash的所有值为：\" + jedis.hvals(\"hash\"));//return\n        List<String>\n        System.out.println(\"将key6保存的值加上一个整数，如果key6不存在则添加key6：\" + jedis.hincrBy(\"hash\", \"key6\", 6));\n        System.out.println(\"散列hash的所有键值对为：\" + jedis.hgetAll(\"hash\"));\n        System.out.println(\"将key6保存的值加上一个整数，如果key6不存在则添加key6：\" + jedis.hincrBy(\"hash\", \"key6\", 3));\n        System.out.println(\"散列hash的所有键值对为：\" + jedis.hgetAll(\"hash\"));\n        System.out.println(\"删除一个或者多个键值对：\" + jedis.hdel(\"hash\", \"key2\"));\n        System.out.println(\"散列hash的所有键值对为：\" + jedis.hgetAll(\"hash\"));\n        System.out.println(\"散列hash中键值对的个数：\" + jedis.hlen(\"hash\"));\n        System.out.println(\"判断hash中是否存在key2：\" + jedis.hexists(\"hash\", \"key2\"));\n        System.out.println(\"判断hash中是否存在key3：\" + jedis.hexists(\"hash\", \"key3\"));\n        System.out.println(\"获取hash中的值：\" + jedis.hmget(\"hash\", \"key3\"));\n        System.out.println(\"获取hash中的值：\" + jedis.hmget(\"hash\", \"key3\", \"key4\"));\n    }\n}\n```\n\n## 事务\n\n### 基本操作\n\n```java\npackage com.kuang.multi;\n\nimport com.alibaba.fastjson.JSONObject;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.Transaction;\n\npublic class TestMulti {\n    public static void main(String[] args) {\n        //创建客户端连接服务端，redis服务端需要被开启\n        Jedis jedis = new Jedis(\"127.0.0.1\", 6379);\n        jedis.flushDB();\n\n        JSONObject jsonObject = new JSONObject();\n        jsonObject.put(\"hello\", \"world\");\n        jsonObject.put(\"name\", \"java\");\n        //开启事务\n        Transaction multi = jedis.multi();\n        String result = jsonObject.toJSONString();\n        try {\n            //向redis存入一条数据\n            multi.set(\"json\", result);\n            //再存入一条数据\n            multi.set(\"json2\", result);\n            //这里引发了异常，用 0 作为被除数\n            int i = 100 / 0;\n            //如果没有引发异常，执行进入队列的命令\n            multi.exec();\n        } catch (Exception e) {\n            e.printStackTrace();\n            //如果出现异常，回滚\n            multi.discard();\n        } finally {\n            System.out.println(jedis.get(\"json\"));\n            System.out.println(jedis.get(\"json2\"));\n            //最终关闭客户端\n            jedis.close();\n        }\n    }\n}\n```\n\n# SpringBoot整合\n\n## 基础使用\n\n### 概述\n\n> 在SpringBoot中一般使用RedisTemplate提供的方法来操作Redis。那么使用SpringBoot整合Redis需要那些步骤呢。\n\n* 1 、 JedisPoolConfig (这个是配置连接池)\n* 2 、 RedisConnectionFactory 这个是配置连接信息，这里的RedisConnectionFactory是一个接口，我们需要使用它的实现类，在SpringD Data Redis方案中提供了以下四种工厂模型：\n    * JredisConnectionFactory\n    * JedisConnectionFactory\n    * LettuceConnectionFactory\n    * SrpConnectionFactory\n* 3 、 RedisTemplate 基本操作\n\n### 导入依赖\n\n```xml\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n```\n\n### yaml配置\n\n```yml\nspring:\n  redis:\n    host: 127.0.0.1\n    port: 6379\n    password: 123456\n    jedis:\n      pool:\n        max-active: 8\n        max-wait: -1ms\n        max-idle: 500\n        min-idle: 0\n    lettuce:\n    shutdown-timeout: 0ms\n```\n\n### 测试\n\n```java\n\n@SpringBootTest\nclass SpringbootRedisApplicationTests {\n\n    @Autowired\n    private RedisTemplate<String, String> redisTemplate;\n\n    @Test\n    void contextLoads() {\n        redisTemplate.opsForValue().set(\"myKey\", \"myValue\");\n        System.out.println(redisTemplate.opsForValue().get(\"myKey\"));\n    }\n}\n```\n\n## 封装工具类\n\n* 1 、新建一个SpringBoot项目\n* 2 、导入redis的启动器\n\n```xml\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n```\n\n* 3 、配置redis，可以查看 RedisProperties 分析\n\n```yml\n# Redis服务器地址\nspring.redis.host=127.0.0.1\n  # Redis服务器连接端口\nspring.redis.port= 6379\n```\n\n* 4 、分析 RedisAutoConfiguration 自动配置类\n\n```java\n\n@Configuration(proxyBeanMethods = false)\n@ConditionalOnClass(RedisOperations.class)\n@EnableConfigurationProperties(RedisProperties.class)\n@Import({LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class})\npublic class RedisAutoConfiguration {\n\n\n    @Bean\n    @ConditionalOnMissingBean(name = \"redisTemplate\")\n    public RedisTemplate<Object, Object>\n    redisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException {\n        RedisTemplate<Object, Object> template = new RedisTemplate<>();\n        template.setConnectionFactory(redisConnectionFactory);\n        return template;\n    }\n\n    @Bean\n    @ConditionalOnMissingBean\n    public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException {\n        StringRedisTemplate template = new StringRedisTemplate();\n        template.setConnectionFactory(redisConnectionFactory);\n        return template;\n    }\n}\n```\n\n> 通过源码可以看出，SpringBoot自动帮我们在容器中生成了一个RedisTemplate和一个StringRedisTemplate。\n\n> 但是，这个RedisTemplate的泛型是<Object,Object>，写代码不方便，需要写好多类型转换的代码；我们需要一个泛型为<String,Object>形式的RedisTemplate。\n\n> 并且，这个RedisTemplate没有设置数据存在Redis时，key及value的序列化方式。\n\n> 看到这个@ConditionalOnMissingBean注解后，就知道如果Spring容器中有了RedisTemplate对象了，这个自动配置的RedisTemplate不会实例化。因此我们可以直接自己写个配置类，配置RedisTemplate。\n\n* 5 、既然自动配置不好用，就重新配置一个RedisTemplate\n\n```java\npackage com.kuang.config;\n\nimport com.fasterxml.jackson.annotation.JsonAutoDetect;\nimport com.fasterxml.jackson.annotation.PropertyAccessor;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\n\n@Configuration\npublic class RedisConfig {\n\n    @Bean\n    @SuppressWarnings(\"all\")\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {\n        RedisTemplate<String, Object> template = new RedisTemplate<String, Object>();\n        template.setConnectionFactory(factory);\n        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new\n                Jackson2JsonRedisSerializer(Object.class);\n        ObjectMapper om = new ObjectMapper();\n        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n        jackson2JsonRedisSerializer.setObjectMapper(om);\n        StringRedisSerializer stringRedisSerializer = new\n                StringRedisSerializer();\n\n        // key采用String的序列化方式\n        template.setKeySerializer(stringRedisSerializer);\n        // hash的key也采用String的序列化方式\n        template.setHashKeySerializer(stringRedisSerializer);\n        // value序列化方式采用jackson\n        template.setValueSerializer(jackson2JsonRedisSerializer);\n        // hash的value序列化方式采用jackson\n        template.setHashValueSerializer(jackson2JsonRedisSerializer);\n        template.afterPropertiesSet();\n        return template;\n    }\n}\n```\n\n* 6 、写一个Redis工具类（直接用RedisTemplate操作Redis，需要很多行代码，因此直接封装好一个RedisUtils，这样写代码更方便点。这个RedisUtils交给Spring容器实例化，使用时直接注解注入。）\n\n```java\npackage com.kuang.utils;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.stereotype.Component;\nimport org.springframework.util.CollectionUtils;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.TimeUnit;\n\n@Component\npublic final class RedisUtil {\n\n    @Autowired\n    private RedisTemplate<String, Object> redisTemplate;\n// =============================common============================\n\n    /**\n     * 指定缓存失效时间\n     * @param key 键\n     * @param time 时间(秒)\n     */\n    public boolean expire(String key, long time) {\n        try {\n            if (time > 0) {\n                redisTemplate.expire(key, time, TimeUnit.SECONDS);\n            }\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    /**\n     * 根据key 获取过期时间\n     * @param key 键 不能为null\n     * @return 时间(秒) 返回 0 代表为永久有效\n     */\n    public long getExpire(String key) {\n        return redisTemplate.getExpire(key, TimeUnit.SECONDS);\n    }\n\n    /**\n     * 判断key是否存在\n     * @param key 键\n     * @return true 存在 false不存在\n     */\n    public boolean hasKey(String key) {\n        try {\n            return redisTemplate.hasKey(key);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    /**\n     * 删除缓存\n     * @param key 可以传一个值 或多个\n     */\n    @SuppressWarnings(\"unchecked\")\n    public void del(String... key) {\n        if (key != null && key.length > 0) {\n            if (key.length == 1) {\n                redisTemplate.delete(key[0]);\n            } else {\n                redisTemplate.delete(CollectionUtils.arrayToList(key));\n            }\n        }\n    }\n// ============================String=============================\n\n    /**\n     * 普通缓存获取\n     * @param key 键\n     * @return 值\n     */\n    public Object get(String key) {\n        return key == null ? null : redisTemplate.opsForValue().get(key);\n    }\n\n    /**\n     * 普通缓存放入\n     * @param key 键\n     * @param value 值\n     * @return true成功 false失败\n     */\n    public boolean set(String key, Object value) {\n        try {\n            redisTemplate.opsForValue().set(key, value);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    /**\n     普通缓存放入并设置时间\n     * @param key 键\n     * @param value 值\n     * @param time 时间(秒) time要大于 0 如果time小于等于 0 将设置无限期\n     * @return true成功 false 失败\n     */\n    public boolean set(String key, Object value, long time) {\n        try {\n            if (time > 0) {\n                redisTemplate.opsForValue().set(key, value, time,\n                        TimeUnit.SECONDS);\n            } else {\n                set(key, value);\n            }\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    /**\n     递增\n     * @param key 键\n     * @param delta 要增加几(大于0)\n     */\n    public long incr(String key, long delta) {\n        if (delta < 0) {\n            throw new RuntimeException(\"递增因子必须大于0\");\n        }\n        return redisTemplate.opsForValue().increment(key, delta);\n    }\n\n    /**\n     * 递减\n     * @param key 键\n     * @param delta 要减少几(小于0)\n     */\n    public long decr(String key, long delta) {\n        if (delta < 0) {\n            throw new RuntimeException(\"递减因子必须大于0\");\n        }\n        return redisTemplate.opsForValue().increment(key, -delta);\n    }\n\n// ================================Map=================================\n\n    /**\n     * HashGet\n     * @param key 键 不能为null\n     * @param item 项 不能为null\n     */\n    public Object hget(String key, String item) {\n        return redisTemplate.opsForHash().get(key, item);\n    }\n\n    /**\n     * 获取hashKey对应的所有键值\n     * @param key 键\n     * @return 对应的多个键值\n     */\n    public Map<Object, Object> hmget(String key) {\n        return redisTemplate.opsForHash().entries(key);\n    }\n\n    /**\n     * HashSet\n     * @param key 键\n     * @param map 对应多个键值\n     */\n    public boolean hmset(String key, Map<String, Object> map) {\n        try {\n            redisTemplate.opsForHash().putAll(key, map);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    /**\n     * HashSet 并设置时间\n     * @param key 键\n     * @param map 对应多个键值\n     * @param time 时间(秒)\n     * @return true成功 false失败\n     */\n    public boolean hmset(String key, Map<String, Object> map, long time) {\n        try {\n            redisTemplate.opsForHash().putAll(key, map);\n            if (time > 0) {\n                expire(key, time);\n            }\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    /**\n     * 向一张hash表中放入数据,如果不存在将创建\n     *\n     * @param key 键\n     * @param item 项\n     * @param value 值\n     * @return true 成功 false失败\n     */\n    public boolean hset(String key, String item, Object value) {\n        try {\n            redisTemplate.opsForHash().put(key, item, value);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    /**\n     * 向一张hash表中放入数据,如果不存在将创建\n     *\n     * @param key 键\n     * @param item 项\n     * @param value 值\n     * @param time 时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间\n     * @return true 成功 false失败\n     */\n    public boolean hset(String key, String item, Object value, long time) {\n        try {\n            redisTemplate.opsForHash().put(key, item, value);\n            if (time > 0) {\n                expire(key, time);\n            }\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    /**\n     * 删除hash表中的值\n     *\n     * @param key 键 不能为null\n     * @param item 项 可以使多个 不能为null\n     */\n    public void hdel(String key, Object... item) {\n        redisTemplate.opsForHash().delete(key, item);\n    }\n\n    /**\n     * 判断hash表中是否有该项的值\n     *\n     * @param key 键 不能为null\n     * @param item 项 不能为null\n     * @return true 存在 false不存在\n     */\n    public boolean hHasKey(String key, String item) {\n        return redisTemplate.opsForHash().hasKey(key, item);\n    }\n\n    /**\n     * hash递增 如果不存在,就会创建一个 并把新增后的值返回\n     *\n     * @param key 键\n     * @param item 项\n     * @param by 要增加几(大于0)\n     */\n    public double hincr(String key, String item, double by) {\n        return redisTemplate.opsForHash().increment(key, item, by);\n    }\n\n    /**\n     * hash递减\n     *\n     * @param key 键\n     * @param item 项\n     * @param by 要减少记(小于0)\n     */\n    public double hdecr(String key, String item, double by) {\n        return redisTemplate.opsForHash().increment(key, item, -by);\n    }\n// ============================set=============================\n\n    /**\n     * 根据key获取Set中的所有值\n     * @param key 键\n     */\n    public Set<Object> sGet(String key) {\n        try {\n            return redisTemplate.opsForSet().members(key);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    /**\n     * 根据value从一个set中查询,是否存在\n     *\n     * @param key 键\n     * @param value 值\n     * @return true 存在 false不存在\n     */\n    public boolean sHasKey(String key, Object value) {\n        try {\n            return redisTemplate.opsForSet().isMember(key, value);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    /**\n     * 将数据放入set缓存\n     *\n     * @param key 键\n     * @param values 值 可以是多个\n     * @return 成功个数\n     */\n    public long sSet(String key, Object... values) {\n        try {\n            return redisTemplate.opsForSet().add(key, values);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return 0;\n        }\n    }\n\n    /**\n     * 将set数据放入缓存\n     *\n     * @param key 键\n     * @param time 时间(秒)\n     * @param values 值 可以是多个\n     * @return 成功个数\n     */\n    public long sSetAndTime(String key, long time, Object... values) {\n        try {\n            Long count = redisTemplate.opsForSet().add(key, values);\n            if (time > 0)\n                expire(key, time);\n            return count;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return 0;\n        }\n    }\n\n    /**\n     * 获取set缓存的长度\n     * @param key 键\n     */\n    public long sGetSetSize(String key) {\n        try {\n            return redisTemplate.opsForSet().size(key);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return 0;\n        }\n    }\n\n    /**\n     * 移除值为value的\n     *\n     * @param key 键\n     * @param values 值 可以是多个\n     * @return 移除的个数\n     */\n\n    public long setRemove(String key, Object... values) {\n        try {\n            Long count = redisTemplate.opsForSet().remove(key, values);\n            return count;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return 0;\n        }\n    }\n// ===============================list=================================\n\n    /**\n     * 获取list缓存的内容\n     *\n     * @param key 键\n     * @param start 开始\n     * @param end 结束 0 到 -1代表所有值\n     */\n    public List<Object> lGet(String key, long start, long end) {\n        try {\n            return redisTemplate.opsForList().range(key, start, end);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    /**\n     * 获取list缓存的长度\n     *\n     * @param key 键\n     */\n    public long lGetListSize(String key) {\n        try {\n            return redisTemplate.opsForList().size(key);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return 0;\n        }\n    }\n\n    /**\n     * 通过索引 获取list中的值\n     *\n     * @param key 键\n     * @param index 索引 index>=0时， 0 表头， 1 第二个元素，依次类推；index<0\n    时，-1，表尾，-2倒数第二个元素，依次类推\n     */\n    public Object lGetIndex(String key, long index) {\n        try {\n            return redisTemplate.opsForList().index(key, index);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    /**\n     * 将list放入缓存\n     *\n     * @param key 键\n     * @param value 值\n     */\n    public boolean lSet(String key, Object value) {\n        try {\n            redisTemplate.opsForList().rightPush(key, value);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    /**\n     * 将list放入缓存\n     * @param key 键\n     * @param value 值\n     * @param time 时间(秒)\n     */\n    public boolean lSet(String key, Object value, long time) {\n        try {\n            redisTemplate.opsForList().rightPush(key, value);\n            if (time > 0)\n                expire(key, time);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    /**\n     * 将list放入缓存\n     *\n     * @param key 键\n     * @param value 值\n     * @return\n     */\n    public boolean lSet(String key, List<Object> value) {\n        try {\n            redisTemplate.opsForList().rightPushAll(key, value);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    /**\n     * 将list放入缓存\n     *\n     * @param key 键\n     * @param value 值\n     * @param time 时间(秒)\n     * @return\n     */\n    public boolean lSet(String key, List<Object> value, long time) {\n        try {\n            redisTemplate.opsForList().rightPushAll(key, value);\n            if (time > 0)\n                expire(key, time);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    /**\n     * 根据索引修改list中的某条数据\n     *\n     * @param key 键\n     * @param index 索引\n     * @param value 值\n     * @return\n     */\n    public boolean lUpdateIndex(String key, long index, Object value) {\n        try {\n            redisTemplate.opsForList().set(key, index, value);\n            ren true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    /**\n     * 移除N个值为value\n     *\n     * @param key 键\n     * @param count 移除多少个\n     * @param value 值\n     * @return 移除的个数\n     */\n    public long lRemove(String key, long count, Object value) {\n        try {\n            Long remove = redisTemplate.opsForList().remove(key, count, value);\n            return remove;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return 0;\n        }\n    }\n}\n```\n\n# Redis.conf\n\n## 熟悉基本配置\n\n> 位置\n\nRedis 的配置文件位于 Redis 安装目录下，文件名为 redis.conf\n\n```shell\nconfig get *  # 获取全部的配置\n```\n\n配置文件的地址：\n![输入图片说明](redis/QQ截图20210927102035.png \"QQ截图20201229183512.png\")\n\n我们一般情况下，会单独拷贝出来一份进行操作。来保证初始文件的安全。\n\n### Units 单位\n\n![输入图片说明](redis/QQ截图20210927102059.png \"QQ截图20201229183512.png\")\n\n* 1 、配置大小单位，开头定义了一些基本的度量单位，只支持bytes，不支持bit\n* 2 、对 大小写 不敏感\n\n### INCLUDES 包含\n\n和Spring配置文件类似，可以通过includes包含，redis.conf 可以作为总文件，可以包含其他文件！\n\n### NETWORK 网络配置\n\n```\nbind 127.0.0.1  # 绑定的ip\nprotected-mode yes # 保护模式\nport 6379 # 默认端口\n```\n\n### GENERAL 通用\n\n```\ndaemonize yes # 默认情况下，Redis不作为守护进程运行。需要开启的话，改为 yes\n\nsupervised no  # 可通过upstart和systemd管理Redis守护进程\n\npidfile /var/run/redis_6379.pid  # 以后台进程方式运行redis，则需要指定pid 文件\n\nloglevel notice # 日志级别。可选项有：\n# debug（记录大量日志信息，适用于开发、测试阶段）；\n# verbose（较多日志信息）；\n# notice（适量日志信息，使用于生产环境）；\n# warning（仅有部分重要、关键信息才会被记录）。\n\nlogfile \"\" # 日志文件的位置，当指定为空字符串时，为标准输出\ndatabases 16 # 设置数据库的数目。默认的数据库是DB 0\nalways-show-logo yes # 是否总是显示logo\n```\n\n### SNAPSHOPTING 快照\n\n```\n# 900秒（ 15 分钟）内至少 1 个key值改变（则进行数据库保存--持久化）\nsave 900 1\n# 300秒（ 5 分钟）内至少 10 个key值改变（则进行数据库保存--持久化）\nsave 300 10\n# 60秒（ 1 分钟）内至少 10000 个key值改变（则进行数据库保存--持久化）\nsave 60 10000\n\nstop-writes-on-bgsave-error yes # 持久化出现错误后，是否依然进行继续进行工作\n\nrdbcompression yes # 使用压缩rdb文件 yes：压缩，但是需要一些cpu的消耗。no：不压\n缩，需要更多的磁盘空间\n\nrdbchecksum yes # 是否校验rdb文件，更有利于文件的容错性，但是在保存rdb文件的时\n候，会有大概10%的性能损耗\n\ndbfilename dump.rdb  # dbfilenamerdb文件名称\n\ndir./  # dir 数据目录，数据库的写入会在这个目录。rdb、aof文件也会写在这个目录\n```\n\n### REPLICATION 复制 我们后面讲主从复制再给大家讲解！这里先跳过！\n\n### SECURITY安全\n\n访问密码的查看，设置和取消\n\n```\n# 启动redis\n# 连接客户端\n\n# 获得和设置密码\nconfig get requirepass\nconfig set requirepass \"123456\"\n\n#测试ping，发现需要验证\n127.0.0.1:6379> ping\nNOAUTH Authentication required.\n# 验证\n127.0.0.1:6379> auth 123456\nOK\n127.0.0.1:6379> ping\nPONG\n```\n\n### 限制\n\n```\nmaxclients 10000 # 设置能连上redis的最大客户端连接数量\nmaxmemory <bytes> # redis配置的最大内存容量\nmaxmemory-policy noeviction # maxmemory-policy 内存达到上限的处理策略\n#volatile-lru：利用LRU算法移除设置过过期时间的key。\n#volatile-random：随机移除设置过过期时间的key。\n#volatile-ttl：移除即将过期的key，根据最近过期时间来删除（辅以TTL）\n#allkeys-lru：利用LRU算法移除任何key。\n#allkeys-random：随机移除任何key。\n#noeviction：不移除任何key，只是返回一个写错误。\n```\n\n### append only模式\n\n```\nappendonly no # 是否以append only模式作为持久化方式，默认使用的是rdb方式持久化，这种\n方式在许多应用中已经足够用了\nappendfilename \"appendonly.aof\" # appendfilename AOF 文件名称\nappendfsync everysec  # appendfsync aof持久化策略的配置\n# no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快。\n# always表示每次写入都执行fsync，以保证数据同步到磁盘。\n# everysec表示每秒执行一次fsync，可能会导致丢失这1s数据。\n```\n\n具体的我们会在后面讲解Redis的持久化配置的时候进行讲解！先了解下，听个耳音！\n\n## 常见配置介绍\n\n1 、Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程\n\n> daemonize no\n\n2 、当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定\n\n> pidfile /var/run/redis.pid\n\n3 、指定Redis监听端口，默认端口为 6379 ，作者在自己的一篇博文中解释了为什么选用 6379 作为默认端口，因为 6379 在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字\n\n> port 6379\n\n4 、绑定的主机地址\n\n> bind 127.0.0.1\n\n5 、当 客户端闲置多长时间后关闭连接，如果指定为 0 ，表示关闭该功能\n\n> timeout 300\n\n6 、指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose\n\n> loglevel verbose\n\n7 、日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null\n> logfile stdout\n\n8 、设置数据库的数量，默认数据库为 0 ，可以使用SELECT 命令在连接上指定数据库id\n\n> databases 16\n\n9 、指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合\n\n> save Redis默认配置文件中提供了三个条件： save 900 1 save 300 10 save 60 10000 分别表示 900 秒（ 15 分钟）内有 1 个更改， 300 秒（ 5 分钟）内有 10 个更改以及 60 秒内有 10000 个更改。\n\n10 、指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大\n\n> rdbcompression yes\n\n11 、指定本地数据库文件名，默认值为dump.rdb\n\n> dbfilename dump.rdb\n\n12 、指定本地数据库存放目录\n\n> dir./\n\n13 、设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步\n\n> slaveof\n\n14 、当master服务设置了密码保护时，slav服务连接master的密码\n\n> masterauth\n\n15 、设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH 命令提供密码，默认关闭\n\n> requirepass foobared\n\n16 、设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients\n0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息\n\n> maxclients 128\n\n17 、指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理\n后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区\n\n> maxmemory\n\n18 、指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为\nredis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no\n\n> appendonly no\n\n19 、指定更新日志文件名，默认为appendonly.aof\n\n> appendfilename appendonly.aof\n\n20 、指定更新日志条件，共有 3 个可选值：\n\n> no：表示等操作系统进行数据缓存同步到磁盘（快）<br>\nalways：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）<br>\neverysec：表示每秒同步一次（折衷，默认值）<br>\nappendfsync everysec<br>\n\n21 、指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制）\n\n> vm-enabled no\n\n22 、虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享\n\n> vm-swap-file /tmp/redis.swap\n\n23 、将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为 0\n的时候,其实是所有value都存在于磁盘。默认值为 0\n\n> vm-max-memory 0\n\n24 、Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为 32\n或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值\n\n> vm-page-size 32\n\n25 、设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每 8 个pages将消耗1byte的内存。\n\n> vm-pages 134217728\n\n26 、设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为 4\n\n> vm-max-threads 4\n\n27 、设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启\n\n> glueoutputbuf yes\n\n28 、指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法\n\n> hash-max-zipmap-entries 64<br>\nhash-max-zipmap-value 512\n\n29 、指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍）\n\n> activerehashing yes\n\n> 30 、指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件\n\n> include /path/to/local.conf\n\n# Redis的持久化\n\n> Redis 是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以 Redis 提供了持久化功能！\n\n## RDB（Redis DataBase）\n\n### 什么是RDB\n\n> 在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。\n\n\n> Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。\n\n### Fork\n\n> Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量，环境变量，程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。\n\n**Rdb 保存的是 dump.rdb 文件**\n\n![输入图片说明](redis/QQ截图20210927110129.png \"QQ截图20201229183512.png\")\n\n### 配置位置及SNAPSHOTTING解析\n\n![输入图片说明](redis/QQ截图20210927110152.png \"QQ截图20201229183512.png\")\n\n### 这里的触发条件机制，我们可以修改测试一下：\n\n```\nsave 120 10 # 120秒内修改 10 次则触发RDB\n```\n\nRDB 是整合内存的压缩过的Snapshot，RDB 的数据结构，可以配置复合的快照触发条件。 默认：\n\n* 1 分钟内改了 1 万次\n* 5 分钟内改了 10 次\n* 15 分钟内改了 1 次\n\n如果想禁用RDB持久化的策略，只要不设置任何save指令，或者给save传入一个空字符串参数也可以。若要修改完毕需要立马生效，可以手动使用 save 命令！立马生效!\n\n### 其余命令解析\n\nStop-writes-on-bgsave-error：如果配置为no，表示你不在乎数据不一致或者有其他的手段发现和控制，默认为yes。\n\nrbdcompression：对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩，如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能。\n\nrdbchecksum：在存储快照后，还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。默认为yes。\n\n### 如何触发RDB快照\n\n* 1 、配置文件中默认的快照配置，建议多用一台机子作为备份，复制一份 dump.rdb\n* 2 、命令save或者是bgsave\n    * save 时只管保存，其他不管，全部阻塞\n    * bgsave，Redis 会在后台异步进行快照操作，快照同时还可以响应客户端请求。可以通过lastsave命令获取最后一次成功执行快照的时间。\n\n* 3 、执行flushall命令，也会产生 dump.rdb 文件，但里面是空的，无意义!\n* 4 、退出的时候也会产生 dump.rdb 文件！\n\n### 如何恢复\n\n* 1 、将备份文件（dump.rdb）移动到redis安装目录并启动服务即可\n* 2 、CONFIG GET dir 获取目录\n\n```\n127.0.0.1:6379> config get dir\ndir\n/usr/local/bin\n```\n\n### 优点和缺点\n\n### 优点：\n\n* 1 、适合大规模的数据恢复\n* 2 、对数据完整性和一致性要求不高\n\n### 缺点：\n\n* 1 、在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改\n* 2 、Fork的时候，内存中的数据被克隆了一份，大致 2 倍的膨胀性需要考虑。\n\n### 小结\n\n![输入图片说明](redis/QQ截图20210927111622.png \"QQ截图20201229183512.png\")\n\n## AOF（Append Only File）\n\n> 是什么\n\n> 以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作\n\n`Aof保存的是 appendonly.aof 文件`\n\n### 配置\n\n![输入图片说明](redis/QQ截图20210927111724.png \"QQ截图20201229183512.png\")\n\n```shell\nappendonly no # 是否以append only模式作为持久化方式，默认使用的是rdb方式持久化，这\n种方式在许多应用中已经足够用了\n\nappendfilename \"appendonly.aof\" # appendfilename AOF 文件名称\n\nappendfsync everysec  # appendfsync aof持久化策略的配置\n# no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快。\n# always表示每次写入都执行fsync，以保证数据同步到磁盘。\n# everysec表示每秒执行一次fsync，可能会导致丢失这1s数据。\n\nNo-appendfsync-on-rewrite #重写时是否可以运用Appendfsync，用默认no即可，保证数据安\n全性\n\nAuto-aof-rewrite-min-size # 设置重写的基准值\n\nAuto-aof-rewrite-percentage #设置重写的基准值\n```\n\n### AOF 启动/修复/恢复\n\n正常恢复：\n\n* 启动：设置Yes，修改默认的appendonly no，改为yes\n* 将有数据的aof文件复制一份保存到对应目录（config get dir）\n* 恢复：重启redis然后重新加载\n\n异常恢复：\n\n* 启动：设置Yes\n* 故意破坏 appendonly.aof 文件！\n* 修复： redis-check-aof --fix appendonly.aof 进行修复\n* 恢复：重启 redis 然后重新加载\n\n### Rewrite\n\n是什么：\n\n\n> AOF 采用文件追加方式，文件会越来越大，为避免出现此种情况，新增了重写机制，当AOF文件的大小超过所设定的阈值时，Redis 就会启动AOF 文件的内容压缩，只保留可以恢复数据的最小指令集，可以使用命令 bgrewriteaof ！\n\n### 重写原理：\n\n> AOF 文件持续增长而过大时，会fork出一条新进程来将文件重写（也是先写临时文件最后再rename），遍历新进程的内存中数据，每条记录有一条的Set语句。重写aof文件的操作，并没有读取旧的aof文件，这点和快照有点类似！\n\n### 触发机制：\n\n> Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的已被且文件大于64M的触发。\n\n`行家一出手，就只有没有，内行看门道，外行看热闹`\n\n### 优点和缺点\n\n### 优点：\n\n* 1 、每修改同步：appendfsync always 同步持久化，每次发生数据变更会被立即记录到磁盘，性能较差但数据完整性比较好\n* 2 、每秒同步： appendfsync everysec 异步操作，每秒记录 ，如果一秒内宕机，有数据丢失\n* 3 、不同步： appendfsync no 从不同步\n\n### 缺点：\n\n* 1 、相同数据集的数据而言，aof 文件要远大于 rdb文件，恢复速度慢于 rdb。\n* 2 、Aof 运行效率要慢于 rdb，每秒同步策略效率较好，不同步效率和rdb相同。\n\n### 小总结\n\n![输入图片说明](redis/QQ截图20210927112007.png \"QQ截图20201229183512.png\")\n\n## 总结\n\n* 1 、RDB 持久化方式能够在指定的时间间隔内对你的数据进行快照存储\n* 2 、AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以Redis 协议追加保存每次写的操作到文件末尾，Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大。\n* 3 、只做缓存，如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化\n* 4 、同时开启两种持久化方式\n    * 在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。\n    * RDB\n      的数据不实时，同时使用两者时服务器重启也只会找AOF文件，那要不要只使用AOF呢？作者建议不要，因为RDB更适合用于备份数据库（AOF在不断变化不好备份），快速重启，而且不会有AOF可能潜在的Bug，留着作为一个万一的手段。\n* 5 、性能建议\n\n    * 因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要 15 分钟备份一次就够了，只保留 save 900 1 这条规则。\n    * 如果Enable AOF ，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了，代价一是带来了持续的IO，二是AOF rewrite 的最后将 rewrite\n      过程中产生的新数据写到新文件 造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重写可以改到适当的数值。\n    * 如果不Enable AOF ，仅靠 Master-Slave Repllcation 实现高可用性也可以，能省掉一大笔IO，也减少了rewrite时带来的系统波动。代价是如果Master/Slave\n      同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个 Master/Slave 中的 RDB文件，载入较新的那个，微博就是这种架构。\n\n\n# Redis 发布订阅\n\n是什么\n\n* Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。\n* Redis 客户端可以订阅任意数量的频道。\n\n订阅/发布消息图：\n\n![输入图片说明](redis/QQ截图20210927113113.png \"QQ截图20201229183512.png\")\n\n下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的\n\n![输入图片说明](redis/QQ截图20210927113126.png \"QQ截图20201229183512.png\")\n\n当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：\n\n![输入图片说明](redis/QQ截图20210927113242.png \"QQ截图20201229183512.png\")\n\n### 命令\n\n这些命令被广泛用于构建即时通信应用，比如网络聊天室(chatroom)和实时广播、实时提醒等。\n\n![输入图片说明](redis/QQ截图20210927113307.png \"QQ截图20201229183512.png\")\n\n### 测试\n\n以下实例演示了发布订阅是如何工作的。在我们实例中我们创建了订阅频道名为 redisChat :\n\n```shell\nredis 127.0.0.1:6379> SUBSCRIBE redisChat\n\nReading messages... (press Ctrl-C to quit)\n1 ) \"subscribe\"\n2 ) \"redisChat\"\n3 ) (integer) 1\n```\n\n现在，我们先重新开启个 redis 客户端，然后在同一个频道 redisChat 发布两次消息，订阅者就能接收到消息。\n\n```shell\nredis 127.0.0.1:6379> PUBLISH redisChat \"Hello,Redis\"\n(integer) 1\nredis 127.0.0.1:6379> PUBLISH redisChat \"Hello，Kuangshen\"\n(integer) 1\n\n# 订阅者的客户端会显示如下消息\n1 ) \"message\"\n2 ) \"redisChat\"\n3 ) \"Hello,Redis\"\n1 ) \"message\"\n2 ) \"redisChat\"\n3 ) \"Hello，Kuangshen\"\n```\n\n### 原理\n\n> Redis是使用C实现的，通过分析 Redis 源码里的 pubsub.c 文件，了解发布和订阅机制的底层实现，籍此加深对 Redis 的理解。\n\n> Redis 通过 PUBLISH 、SUBSCRIBE 和 PSUBSCRIBE 等命令实现发布和订阅功能。通过 SUBSCRIBE 命令订阅某频道后，redis-server 里维护了一个字典，字典的键就是一个个 channel，而字典的值则是一个链表，链表中保存了所有订阅这个 channel 的客户端。SUBSCRIBE 命令的关键，就是将客户端添加到给定 channel 的订阅链表中。\n\n> 通过 PUBLISH 命令向订阅者发送消息，redis-server 会使用给定的频道作为键，在它所维护的 channel字典中查找记录了订阅这个频道的所有客户端的链表，遍历这个链表，将消息发布给所有订阅者。\n\n> Pub/Sub 从字面上理解就是发布（Publish）与订阅（Subscribe），在Redis中，你可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。\n\n### 使用场景\n\n> Pub/Sub构建实时消息系统\n\n> Redis的Pub/Sub系统可以构建实时的消息系统\n\n> 比如很多用Pub/Sub构建的实时聊天系统的例子。\n\n# Redis主从复制\n\n## 概念\n\n> 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master/leader)，后者称为从节点(slave/follower)；数据的复制是单向的，只能由主节点到从节点。Master以写为主，Slave 以读为主。\n\n> 默认情况下，每台Redis服务器都是主节点；且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。\n\n主从复制的作用主要包括：\n\n* 1 、数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。\n* 2 、故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。\n* 3\n  、负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。\n* 4 、高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。\n\n一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的，原因如下：\n\n* 1 、从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大；\n* 2 、从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存容量为256G，也不能将所有内存用作Redis存储内存，一般来说，单台Redis最大使用内存不应该超过20G。\n  电商网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是\"多读少写\"。 对于这种场景，我们可以使如下这种架构：\n\n![输入图片说明](redis/QQ截图20210927113849.png \"QQ截图20201229183512.png\")\n\n## 环境配置\n\n基本配置\n\n配从库不配主库，从库配置：\n\n```\nslaveof 主库ip 主库端口 # 配置主从\ninfo replication # 查看信息\n```\n\n每次与 master 断开之后，都需要重新连接，除非你配置进 redis.conf 文件！\n\n### 修改配置文件！\n\n准备工作：我们配置主从复制，至少需要三个，一主二从！配置三个客户端！\n\n![输入图片说明](redis/QQ截图20210927113948.png \"QQ截图20201229183512.png\")\n\n* 1 、拷贝多个redis.conf 文件\n\n  ![输入图片说明](redis/QQ截图20210927114022.png \"QQ截图20201229183512.png\")\n\n* 2 、指定端口 6379 ，依次类推\n* 3 、开启daemonize yes\n* 4 、Pid文件名字 pidfile /var/run/redis_6379.pid , 依次类推\n* 5 、Log文件名字 logfile \"6379.log\" , 依次类推\n* 6 、Dump.rdb 名字 dbfilename dump6379.rdb , 依次类推\n\n  ![输入图片说明](redis/QQ截图20210927114130.png \"QQ截图20201229183512.png\")\n\n### 上面都配置完毕后， 3 个服务通过 3 个不同的配置文件开启，我们的准备环境就OK 了！\n\n![输入图片说明](redis/QQ截图20210927114141.png \"QQ截图20201229183512.png\")\n\n## 一主二从\n\n一主二仆\n\n* 1 、环境初始化\n\n  ![输入图片说明](redis/QQ截图20210928085838.png \"QQ截图20201229183512.png\")\n\n默认三个都是Master 主节点\n\n![输入图片说明](redis/QQ截图20210928085902.png \"QQ截图20201229183512.png\")\n\n* 2 、配置为一个Master 两个Slave\n\n  ![输入图片说明](redis/QQ截图20210928085902.png \"QQ截图20201229183512.png\")\n\n* 3 、在主机设置值，在从机都可以取到！从机不能写值！\n\n  ![输入图片说明](redis/QQ截图20210928085936.png \"QQ截图20201229183512.png\")\n\n测试一：主机挂了，查看从机信息，主机恢复，再次查看信息\n\n测试二：从机挂了，查看主机信息，从机恢复，查看从机信息\n\n### 层层链路\n\n> 上一个Slave 可以是下一个slave 和 Master，Slave 同样可以接收其他 slaves 的连接和同步请求，那么该 slave 作为了链条中下一个的master，可以有效减轻 master 的写压力！\n\n![输入图片说明](redis/QQ截图20210928090032.png \"QQ截图20201229183512.png\")\n\n### 测试： 6379 设置值以后 6380 和 6381 都可以获取到！OK！\n\n### 谋朝篡位\n\n> 一主二从的情况下，如果主机断了，从机可以使用命令 SLAVEOF NO ONE 将自己改为主机！这个时候其余的从机链接到这个节点。对一个从属服务器执行命令 SLAVEOF NO ONE 将使得这个从属服务器关闭复制功能，并从从属服务器转变回主服务器，原来同步所得的数据集不会被丢弃。\n\n![输入图片说明](redis/QQ截图20210928090112.png \"QQ截图20201229183512.png\")\n\n主机再回来，也只是一个光杆司令了，从机为了正常使用跑到了新的主机上！\n\n### 复制原理\n\n> Slave 启动成功连接到 master 后会发送一个sync命令Master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。增量复制：Master 继续将新的所有收集到的修改命令依次传给slave，完成同步但是只要是重新连接master，一次完全同步（全量复制）将被自动执行\n\n## 哨兵模式\n\n概述\n\n> 主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。Redis从2.8开始正式提供了Sentinel（哨兵） 架构来解决这个问题。谋朝篡位的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是 **哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。**\n\n![输入图片说明](redis/QQ截图20210928090249.png \"QQ截图20201229183512.png\")\n\n这里的哨兵有两个作用\n\n* 通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。\n* 当哨兵监测到master宕机，会自动将slave切换成master，然后通过 发布订阅模式 通知其他的从服务器，修改配置文件，让它们切换主机。\n\n> 然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。\n\n![输入图片说明](redis/QQ截图20210928090331.png \"QQ截图20201229183512.png\")\n\n> 假设主服务器宕机，哨兵 1 先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵 1 主观的认为主服务器不可用，这个现象成为 主观下线 。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover[故障转移]操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为客观下线 。\n\n### 配置测试\n\n* 1 、调整结构， 6379 带着 80 、 81\n* 2 、自定义的 /myredis 目录下新建 sentinel.conf 文件，名字千万不要错\n* 3 、配置哨兵，填写内容\n    * sentinel monitor 被监控主机名字 127.0.0.1 6379 1\n    * 上面最后一个数字 1 ，表示主机挂掉后slave投票看让谁接替成为主机，得票数多少后成为主机\n* 4 、启动哨兵\n    * Redis-sentinel /myredis/sentinel.conf\n    * 上述目录依照各自的实际情况配置，可能目录不同\n* 5 、正常主从演示\n* 6 、原有的Master 挂了\n* 7 、投票新选\n* 8 、重新主从继续开工，info replication 查查看\n* 9 、问题：如果之前的master 重启回来，会不会双master 冲突？ 之前的回来只能做小弟了\n\n### 哨兵模式的优缺点\n\n### 优点\n\n*\n    1. 哨兵集群模式是基于主从模式的，所有主从的优点，哨兵模式同样具有。\n*\n    2. 主从可以切换，故障可以转移，系统可用性更好。\n*\n    3. 哨兵模式是主从模式的升级，系统更健壮，可用性更高。\n\n### 缺点\n\n*\n    1. Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。\n*\n    2. 实现哨兵模式的配置也不简单，甚至可以说有些繁琐\n\n### 哨兵配置说明\n\n```shell\n# Example sentinel.conf\n\n# 哨兵sentinel实例运行的端口 默认 26379\nport 26379\n\n# 哨兵sentinel的工作目录\ndir /tmp\n\n# 哨兵sentinel监控的redis主节点的 ip port\n# master-name 可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符\".-_\"组成。\n# quorum 配置多少个sentinel哨兵统一认为master主节点失联 那么这时客观上认为主节点失联了\n# sentinel monitor <master-name> <ip> <redis-port> <quorum>\nsentinel monitor mymaster 127.0.0.1 6379 2\n\n# 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都\n要提供密码\n# 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码\n# sentinel auth-pass <master-name> <password>\nsentinel auth-pass mymaster MySUPER--secret-0123passw0rd\n\n# 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认 30 秒\n# sentinel down-after-milliseconds <master-name> <milliseconds>\nsentinel down-after-milliseconds mymaster 30000\n\n# 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，这个数字越小，完成failover所需的时间就越长，但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。\n# sentinel parallel-syncs <master-name> <numslaves>\nsentinel parallel-syncs mymaster 1\n\n# 故障转移的超时时间 failover-timeout 可以用在以下这些方面：\n#1. 同一个sentinel对同一个master两次failover之间的间隔时间。\n#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。\n#3.当想要取消一个正在进行的failover所需要的时间。\n#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了\n# 默认三分钟\n# sentinel failover-timeout <master-name> <milliseconds>\nsentinel failover-timeout mymaster 180000\n\n# SCRIPTS EXECUTION\n\n#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。\n#对于脚本的运行结果有以下规则：\n#若脚本执行后返回 1 ，那么该脚本稍后将会被再次执行，重复次数目前默认为 10\n#若脚本执行后返回 2 ，或者比 2 更高的一个返回值，脚本将不会重复执行。\n#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为 1 时的行为相同。\n#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。\n\n#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。\n#通知脚本\n# sentinel notification-script <master-name> <script-path>\nsentinel notification-script mymaster /var/redis/notify.sh\n\n# 客户端重新配置主节点参数脚本\n# 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。\n# 以下参数将会在调用脚本时传给脚本:\n# <master-name> <role> <state> <from-ip> <from-port> <to-ip> <to-port>\n# 目前<state>总是“failover”,\n# <role>是“leader”或者“observer”中的一个。\n# 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的\n# sentinel client-reconfig-script <master-name> <script-path>\nsentinel client-reconfig-script mymaster /var/redis/reconfig.sh\n```\n\n# 缓存穿透和雪崩\n\n> Redis缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询方面。但同时，它也带来了一些问题。其中，最要害的问题，就是数据的一致性问题，从严格意义上讲，这个问题无解。如果对数据的一致性要求很高，那么就不能使用缓存。\n\n> 另外的一些典型问题就是，缓存穿透、缓存雪崩和缓存击穿。目前，业界也都有比较流行的解决方案。\n\n## 缓存穿透\n\n### 概念\n\n> 缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中，于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。\n\n### 解决方案\n\n### 布隆过滤器\n\n> 布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力；\n\n![输入图片说明](redis/QQ截图20210928090903.png \"QQ截图20201229183512.png\")\n\n### 缓存空对象\n\n> 当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源；\n\n![输入图片说明](redis/QQ截图20210928090930.png \"QQ截图20201229183512.png\")\n\n### 但是这种方法会存在两个问题：\n\n* 1 、如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键；\n* 2 、即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。\n\n## 缓存击穿\n\n### 概述\n\n> 这里需要注意和缓存击穿的区别，缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。\n\n> 当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大。\n\n### 解决方案\n\n### 设置热点数据永不过期\n\n从缓存层面来看，没有设置过期时间，所以不会出现热点 key 过期后产生的问题。\n\n### 加互斥锁\n\n分布式锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。\n\n## 缓存雪崩\n\n### 概念\n\n缓存雪崩，是指在某一个时间段，缓存集中过期失效。\n\n> 产生雪崩的原因之一，比如在写本文的时候，马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。\n\n![输入图片说明](redis/QQ截图20210928091310.png \"QQ截图20201229183512.png\")\n\n> 其实集中过期，倒不是非常致命，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网。因为自然形成的缓存雪崩，一定是在某个时间段集中创建缓存，这个时候，数据库也是可以顶住压力的。无非就是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间就把数据库压垮。\n\n### 解决方案\n\n### redis高可用\n\n> 这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。\n\n### 限流降级\n\n> 这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。\n\n### 数据预热\n\n> 数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。\n","source":"_posts/redis.md","raw":"---\ntitle: Redis指南\ndate: 2022-07-19 12:21:18\ntags: \n - Redis\n - NoSQL\ncategories: NoSQL\n---\n\n# NoSQL概述\n\n## 为什么用NoSQL\n\n> 1 、单机MySQL的美好年代\n\n在 90 年代，一个网站的访问量一般不大，用单个数据库完全可以轻松 在那个时候，更多的都是静态网页，动态交互类型的网站不多。\n\n上述架构下，我们来看看数据存储的瓶颈是什么？\n\n*\n    1. 数据量的总大小，一个机器放*\n    *\n        2. 数据的索引（B+ Tree）一个机器的内存放*\n        *\n            3. 访问量（读写混合）一个实例不能承受\n\n如果满足了上述 1 or 3个，进化. DAL：数据库访问层\n\n![输入图片说明](redis/QQ截图20210922100205.png \"QQ截图20201229183512.png\")\n> 2 、Memcached（缓存）+ MySQL + 垂直拆分\n\n> 后来，随着访问量的上升，几乎大部分使用MySQL架构的网站在数据库上都开始出现了性能问题，web 程序不再仅仅专注在功能上，同时也在追求性能。程序猿们开始大量使用缓存技术来缓解数据库的压 力，优化数据库的结构和索引，开始比较流行的是通过文件缓存来缓解数据库压力，但是当访问量继续 增大的时候，多台web机器通过文件缓存不能共享，大量的小文件缓存也带了比较高的IO压力，在这个 时候，Memcached就自然的成为一个非常时尚的技术产品。\n\n![输入图片说明](redis/QQ截图20210922100407.png \"QQ截图20201229183512.png\")\n> 3 、MySQL主从读写分离\n\n> 由于数据库的写入压力增加，Memcached只能缓解数据库的读取压力，读写集中在一个数据库上让数 据库不堪重负，大部分网站开始使用主从复制技术来达到读写分离，以提高读写性能和读库的可扩展 性，MySQL的master-slave模式成为这个时候的网站标配了。\n\n![输入图片说明](redis/QQ截图20210924134715.png \"QQ截图20201229183512.png\")\n\n> 4 、分表分库 + 水平拆分 + Mysql 集群\n\n> 在Memcached的高速缓存，MySQL的主从复制，读写分离的基础之上，这时MySQL主库的写压力开始 出现瓶颈，而数据量的持续猛增，由于MyISAM使用表锁，在高并发下会出现严重的锁问题，大量的高 并发MySQL应用开始使用InnoDB引擎代替MyISAM。 同时，开始流行使用分表分库来缓解写压力和数据增长的扩展问题，这个时候，分表分库成了一个热门 技术，是面试的热门问题，也是业界讨论的热门技术问题。也就是在这个时候，MySQL推出了还不太稳 定的表分区，这也给技术实力一般的公司带来了希望。虽然MySQL推出了MySQL Cluster集群，但性能 也不能很好满足互联网的需求，只是在高可靠性上提供了非常大的保证。\n\n![输入图片说明](redis/QQ截图20210924134937.png \"QQ截图20201229183512.png\")\n\n> 5 、MySQL 的扩展性瓶颈\n\n> MySQL数据库也经常存储一些大文本的字段，导致数据库表非常的大，在做数据库恢复的时候就导致非 常的慢，不容易快速恢复数据库，比如 1000 万4KB大小的文本就接近40GB的大小，如果能把这些数据 从MySQL省去，MySQL将变的非常的小，关系数据库很强大，但是它并不能很好的应付所有的应用场 景，MySQL的扩展性差（需要复杂的技术来实现），大数据下IO压力大，表结构更改困难，正是当前使 用MySQL的开发人员面临的问题。\n\n> 6 、今天是什么样子？？\n\n![输入图片说明](redis/QQ截图20210924135030.png \"QQ截图20201229183512.png\")\n\n> 7 、为什么用NoSQL？\n\n> 今天我们可以通过第三方平台（如：Google，FaceBook等）可以很容易的访问和抓取数据。用户的个 人信息，社交网络，地理位置，用户生成的数据和用户操作日志已经成倍的增加、我们如果要对这些用 户数据进行挖掘，那SQL数据库已经不适合这些应用了，而NoSQL数据库的发展却能很好的处理这些大 的数据！\n\n## 什么是NoSQL\n\n> NoSQL\n\n> NoSQL = Not Only SQL，意思：不仅仅是SQL；\n\n> 泛指非关系型的数据库，随着互联网Web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别 是超大规模和高并发的社交网络服务类型的Web2.0纯动态网站已经显得力不从心，暴露了很多难以克服 的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展，NoSQL数据库的产生就是为 了解决大规模数据集合多种数据种类带来的挑战，尤其是大数据应用难题，包括超大规模数据的存储。 （例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模 式，无需多余操作就可以横向扩展。\n\n> NoSQL的特点\n\n### 1 、易扩展\n\n> NoSQL 数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。 数据之间无关系，这样就非常容易扩展，也无形之间，在架构的层面上带来了可扩展的能力。\n\n### 2 、大数据量高性能\n\n> NoSQL数据库都具有非常高的读写性能，尤其是在大数据量下，同样表现优秀。这得益于它的非关系 性，数据库的结构简单。\n\n> 一般MySQL使用Query Cache，每次表的更新Cache就失效，是一种大力度的Cache，在针对Web2.0的 交互频繁应用，Cache性能不高，而NoSQL的Cache是记录级的，是一种细粒度的Cache，所以NoSQL 在这个层面上来说就要性能高很多了。\n\n> 官方记录：Redis 一秒可以写 8 万次，读 11 万次！\n\n### 3 、多样灵活的数据模型\n\n> NoSQL无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式，而在关系数据库里，增删 字段是一件非常麻烦的事情。如果是非常大数据量的表，增加字段简直就是噩梦。\n\n### 4 、传统的RDBMS VS NoSQL\n\n![输入图片说明](redis/QQ截图20210924135616.png \"QQ截图20201229183512.png\")\n\n> 拓展：3V+3高\n\n### 大数据时代的3V ： 主要是对问题的描述\n\n* 海量 Volume\n* 多样 Variety\n* 实时 Velocity\n\n### 互联网需求的 3 高 ： 主要是对程序的要求\n\n* 高并发\n* 高可用\n* 高性能\n\n`当下的应用是 SQL 和 NoSQL 一起使用，技术没有高低之分，就看你怎么用，对吧！`\n\n## 经典应用分析\n\n### 聊聊阿里巴巴中文网站的商品信息如何存放，以女装、包包为例：\n\n![输入图片说明](redis/QQ截图20210924135616.png \"QQ截图20201229183512.png\")\n\n### 聊聊架构发展历程：推荐书籍《淘宝技术这十年》\n\n### 1 、演变过程：以下图片资料来源：阿里巴巴中文站架构设计实践\n\n![输入图片说明](redis/QQ截图20210924135855.png \"QQ截图20201229183512.png\")\n\n### 2 、第五代\n\n![输入图片说明](redis/QQ截图20210924135915.png \"QQ截图20201229183512.png\")\n\n### 3 、第 5 代架构使命\n\n![输入图片说明](redis/QQ截图20210924135957.png \"QQ截图20201229183512.png\")\n\n### 和我们相关的，多数据源多数据类型的存储问题\n\n![输入图片说明](redis/QQ截图20210924140055.png \"QQ截图20201229183512.png\")\n\n### 1 、商品的基本信息\n\n```\n名称、价格、出厂日期、生产厂商等\n关系型数据库：mysql、oracle目前淘宝在去O化（也即，拿掉Oracle）\n注意，淘宝内部用的MySQL是里面的大牛自己改造过的。\n\n为什么去IOE：\n2008 年,王坚博士加入阿里巴巴，成为首席架构师。把云计算植入阿里IT基因。\n2013 年 5 月 17 日，阿里集团最后一台IBM小机在支付宝下线。这是自 2009 年“去IOE”战略透露以来，“去\nIOE”非常重要的一个节点。“去 IOE”指的是摆脱掉IT部署中原有的IBM小型机、Oracle数据库以及EMC\n存储的过度依赖。告别最后一台小机，意味着整个阿里集团尽管还有一些Oracle数据库和EMC存储，但是\nIBM小型机已全部被替换。 2013 年 7 月 10 日，淘宝重中之重的广告系统使用的Oracle数据库下线，也是整\n个淘宝最后一个 Oracle数据库。这两件事合在一起是阿里巴巴技术发展过程中的一个重要里程碑。\n```\n\n### 2、商品描述、详情、评价信息（多文字类）\n\n```\n多文字信息描述类，IO读写性能变差 \n存在文档数据库MongDB中\n```\n\n3、商品的图片\n\n```\n商品图片展现类 \n分布式文件系统中 \n  - 淘宝自己的 TFS \n  - Google的 GFS \n  - Hadoop的 HDFS\n```\n\n4、商品的关键字\n\n```\n搜索引擎，淘宝内用 \nISearch：多隆一高兴一个人开发的 \n\n所有牛逼的人在牛逼之前,肯定有一段苦逼的岁月,但只要像傻逼一样的坚持,一定终将牛逼\n```\n\n5、商品的波段性的热点高频信息\n\n```\n内存数据库 \nTair、Redis、Memcache等\n```\n\n6、商品的交易，价格计算，积分累计！\n\n```\n外部系统，外部第三方支付接口 \n支付宝\n```\n\n> 大型互联网应用（大数据，高并发，多样数据类型）的难点和解决方案\n**难点：**\n\n* 数据类型的多样性\n* 数据源多样性和变化重构\n* 数据源改造而数据服务平台不需要大面积重构\n\n**解决办法：**\n![输入图片说明](redis/QQ截图20210924140800.png \"QQ截图20201229183512.png\")\n\n![输入图片说明](redis/QQ截图20210924140819.png \"QQ截图20201229183512.png\")\n\n![输入图片说明](redis/QQ截图20210924140833.png \"QQ截图20201229183512.png\")\n\n![输入图片说明](redis/QQ截图20210924140847.png \"QQ截图20201229183512.png\")\n\n![输入图片说明](redis/QQ截图20210924140901.png \"QQ截图20201229183512.png\")\n\n## NoSQL数据模型简介\n\n### 案例设计\n\n`以一个电商客户，订单，订购，地址模型来对比下关系型数据库和非关系型数据库`\n\n**传统的关系型数据库你如何设计？**\n\n### ER图（1:1/1:N/N:N,主外键等常见）\n\n* 用户对应多个订单多个地址\n* 每个订单对应每个商品、价格、地址\n* 每个商品对应产品\n\n  ![输入图片说明](redis/QQ截图20210924141013.png \"QQ截图20201229183512.png\")\n\n> 闲聊：用户画像分析，女人心是琢磨不透的，看了男装，剃须刀，根据她的信息找到她男朋友的生日就 在最近，后台画像已经分析完毕，准备推送广告了，结果她买了一个零食就走了~\n90 后的程序员真的在一点点的改变生活中的点点滴滴，假设你有幸进入了大厂，你会发现周围的小伙伴 都在努力，真的就是那种可以在海底捞吃着吃着饭，突然就掏出笔记本写代码的那种，别人都以为他们 是疯子，只有他们自己内心才懂。这才是对技术的痴迷。\n\n### NoSQL你如何设计\n\n可以尝试使用 BSON 。\n\nBSON是一种类json的一种二进制形式的存储格式，简称Binary JSON，它和JSON一样，支持内嵌的文档\n\n对象和数组对象\n\n用BSon画出构建的数据模型\n\n```json\n{\n  \"customer\": {\n    \"id\": 1000,\n    \"name\": \"Z3\",\n    \"billingAddress\": [\n      {\n        \"city\": \"beijing\"\n      }\n    ],\n    \"orders\": [\n      {\n        \"id\": 17,\n        \"customerId\": 1000,\n        \"orderItems\": [\n          {\n            \"productId\": 27,\n            \"price\": 77.5,\n            \"productName\": \"thinking injava\"\n          }\n        ],\n        \"shippingAddress\": [\n          {\n            \"city\": \"beijing\"\n          }\n        ]\n        \"orderPayment\": [\n          {\n            \"ccinfo\": \"111-222-333\",\n            \"txnid\": \"asdfadcd334\",\n            \"billingAddress\": {\n              \"city\": \"beijing\"\n            }\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n\n> 想想关系模型数据库你如何查？如果按照我们新设计的BSon，是不是查询起来很简单。\n\n* 高并发的操作是不太建议有关联查询的，互联网公司用冗余数据来避免关联查询\n* 分布式事务是支持不了太多的并发的\n\n## NoSQL四大分类\n\n**KV键值 ：**\n\n* 新浪：BerkeleyDB+redis\n* 美团：redis+tair\n* 阿里、百度：memcache+redis\n\n**文档型数据库(bson格式比较多) ：**\n\n* CouchDB\n* MongoDB\n    * MongoDB 是一个 基于分布式文件存储的数据库 。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。\n    * MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。\n\n### 列存储数据库：\n\n* Cassandra, HBase\n* 分布式文件系统\n\n### 图关系数据库\n\n* 它不是放图形的，放的是关系比如:朋友圈社交网络、广告推荐系统\n* 社交网络，推荐系统等。专注于构建关系图谱\n* Neo4J, InfoGrid\n\n### 四者对比\n\n![输入图片说明](redis/QQ截图20210924141532.png \"QQ截图20201229183512.png\")\n\n## CAP + BASE\n\n> 传统的ACID分别是什么？\n\n### 关系型数据库遵循ACID规则，事务在英文中是transaction，和现实世界中的交易很类似，它有如下四个特性：\n\n* A (Atomicity) 原子性\n\n```\n原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务 \n里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。 \n比如银行转账，从A账户转100元至B账户，分为两个步骤： \n1）从A账户取100元； \n2）存入100元至B账户。 \n这两步要么一起完成，要么一起不完成，如果只完成第一步，第二步失败，钱会莫名其妙少了100 元。\n```\n\n* C (Consistency) 一致性\n\n```\n事务前后数据的完整性必须保持一致。\n```\n\n* I (Isolation) 隔离性\n\n```\n所谓的独立性是指并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修 改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。比如现有有个交易是从A 账户转100元至B账户，在这个交易还未完成的情况下，如果此时B查询自己的账户，是看不到新增加 的100元的\n```\n\n* D (Durability) 持久性\n\n```\n持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。\n```\n\n### CAP（三进二）\n\n* C : Consistency（强一致性）\n* A : Availability（可用性）\n* P : Partition tolerance（分区容错性）\n\n**CAP理论就是说在分布式存储系统中，最多只能实现上面的两点 。**\n\n> 而由于当前的网络硬件肯定会出现延迟丢包等问题，所以 分区容错性是我们必须需要实现 的。 所以我们只能在一致性和可用性之间进行权衡，没有NoSQL系统能同时保证这三点。 注意：分布式架构的时候必须做出取舍。 一致性和可用性之间取一个平衡。多余大多数web应用，其实并不需要强一致性。 因此牺牲C换取P，这是目前分布式数据库产品的方向\n\n**一致性与可用性的决择**\n> 对于web2.0网站来说，关系数据库的很多主要特性却往往无用武之地\n\n**数据库事务一致性需求**\n\n> 很多web实时系统并不要求严格的数据库事务，对读一致性的要求很低， 有些场合对写一致性要求并不 高。允许实现最终一致性。\n\n**数据库的写实时性和读实时性需求**\n\n> 对关系数据库来说，插入一条数据之后立刻查询，是肯定可以读出来这条数据的，但是对于很多web应 用来说，并不要求这么高的实时性，比方说发一条消息之 后，过几秒乃至十几秒之后，我的订阅者才看 到这条动态是完全可以接受的。\n\n**对复杂的SQL查询，特别是多表关联查询的需求**\n\n> 任何大数据量的web系统，都非常忌讳多个大表的关联查询，以及复杂的数据分析类型的报表查询，特 别是SNS类型的网站，从需求以及产品设计角度，就避免了这种情况的产生。往往更多的只是单表的主 键查询，以及单表的简单条件分页查询，SQL的功能被极大的弱化了。\n\n**CAP理论的核心** 是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求， 最多只能同时较好的满足两个。因此，根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足 AP 原则三\n大类：\n\n* CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。\n* CP - 满足一致性，分区容忍必的系统，通常性能不是特别高。\n* AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。\n\n  ![输入图片说明](redis/QQ截图20210924144835.png \"QQ截图20201229183512.png\")\n\n### BASE 理论\n\n> BASE理论是由eBay架构师提出的。BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互 联网分布式系统实践的总结，是基于CAP定律逐步演化而来。其核心思想是即使无法做到强一致性，但 每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。\n\n**BASE就是为了解决关系数据库强一致性引起的问题而引起的可用性降低而提出的解决方案。**\n\n### BASE其实是下面三个术语的缩写：\n\n* 基本可用(Basically Available)：\n  基本可用是指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。电商大促时，为了应对访问量激增，部分用户可能会被引导到降级页面，服务层也可能只提供降级服务。这就是损失部分可用性的体现。\n\n* 软状态(Soft State)： 软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现。MySQL Replication\n  的异步复制也是一种体现。\n\n* 最终一致性(Eventual Consistency)： 最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。\n\n> 它的思想是通过让系统放松对某一时刻数据一致性的要求来换取系统整体伸缩性和性能上改观。为什么 这么说呢，缘由就在于大型系统往往由于地域分布和极高性能的要求，不可能采用分布式事务来完成这 些指标，要想获得这些指标，我们必须采用另外一种方式来完成，这里BASE就是解决这个问题的办法！\n**解释：**\n\n* 1 、分布式：不同的多台服务器上面部署不同的服务模块（工程），他们之间通过Rpc通信和调用，对外提供服务和组内协作。\n* 2 、集群：不同的多台服务器上面部署相同的服务模块，通过分布式调度软件进行统一的调度，对外提供服务和访问。\n\n# Redis入门\n\n## 概述\n\n### Redis是什么\n\n> Redis：REmote DIctionary Server（远程字典服务器） 是完全开源免费的，用C语言编写的，遵守BSD协议，是一个高性能的（Key/Value）分布式内存数据 库，基于内存运行，并支持持久化的NoSQL数据库，是当前最热门的NoSQL数据库之一，也被人们称为 数据结构服务器\n\n### Redis与其他key-value缓存产品有以下三个特点\n\n* Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。\n\n* Redis不仅仅支持简单的 key-value 类型的数据，同时还提供list、set、zset、hash等数据结构的存储。\n\n* Redis支持数据的备份，即master-slave模式的数据备份。\n\n### Redis能干嘛\n\n> 内存存储和持久化：redis支持异步将内存中的数据写到硬盘上，同时不影响继续服务取最新N个数据的操作，如：可以将最新的 10 条评论的ID放在Redis的List集合里面 发布、订阅消息系统 地图信息分析 定时器、计数器......\n\n### 特性\n\n数据类型、基本操作和配置\n\n持久化和复制，RDB、AOF\n\n事务的控制\n\n.....\n\n### 常用网站\n\n### https://redis.io/ 官网\n\n### http://www.redis.cn 中文网\n\n## Windows安装\n\n### 下载地址：https://github.com/dmajkic/redis/downloads ( 素材提供 )\n\n解压到自己电脑的环境目录即可\n\n![输入图片说明](redis/QQ截图20210927092007.png \"QQ截图20201229183512.png\")\n\n### 双击 redis-server.exe 启动即可\n\n![输入图片说明](redis/QQ截图20210927092027.png \"QQ截图20201229183512.png\")\n\n**通过客户端去访问 redis-cli**\n\n```shell\n# 基本的set设值\n127.0.0.1:6379> set key kuangshen\nOK\n# 取出存储的值\n127.0.0.1:6379> get key\n\"kuangshen\"\n```\n\n`重要提示`\n\n> 由于企业里面做Redis开发，99%都是Linux版的运用和安装，几乎不会涉及到Windows版，上一步的讲 解只是为了知识的完整性，Windows版不作为重点，大家可以自己玩，企业实战就认一个版：Linux版\n\n**http://www.redis.cn/topics/introduction**\n\n![输入图片说明](redis/QQ截图20210927092145.png \"QQ截图20201229183512.png\")\n\n## Linux安装\n\n### 下载地址 http://download.redis.io/releases/redis-5.0.7.tar.gz\n\n![输入图片说明](redis/QQ截图20210927092233.png \"QQ截图20201229183512.png\")\n\n### 安装步骤\n\n* 1 、下载获得 redis-5.0.7.tar.gz 后将它放到我们Linux的目录下 /opt\n* 2 、/opt 目录下，解压命令 ： tar -zxvf redis-5.0.7.tar.gz\n* 3 、解压完成后出现文件夹：redis-5.0.\n* 4 、进入目录： cd redis-5.0.\n* 5 、在 redis-5.0.7 目录下执行 make 命令\n\n```\n运行make命令时故意出现的错误解析：\n1. 安装gcc (gcc是linux下的一个编译程序，是c程序的编译工具)\n能上网: yum install gcc-c++\n版本测试: gcc-v\n2. 二次make\n3. Jemalloc/jemalloc.h: 没有那个文件或目录\n运行 make distclean 之后再make\n4. Redis Test（可以不用执行）\n```\n\n* 6 、如果make完成后继续执行 make install\n* 7 、查看默认安装目录：usr/local/bin 1 /usr 这是一个非常重要的目录，类似于windows下的Program Files,存放用户的程序\n* 8 、拷贝配置文件（备用）\n\n```shell\ncd /usr/local/bin\nls -l\n# 在redis的解压目录下备份redis.conf\nmkdir myredis\ncp redis.conf myredis  # 拷一个备份，养成良好的习惯，我们就修改这个文件\n# 修改配置保证可以后台应用\nvim redis.conf\n```\n\n![输入图片说明](redis/QQ截图20210927092451.png \"QQ截图20201229183512.png\")\n\n* A、redis.conf配置文件中daemonize守护线程，默认是NO。\n* B、daemonize是用来指定redis是否要用守护线程的方式启动。\n\n**daemonize 设置yes或者no区别**\n\n* daemonize:yes\n\n    *\n    redis采用的是单进程多线程的模式。当redis.conf中选项daemonize设置成yes时，代表开启守护进程模式。在该模式下，redis会在后台运行，并将进程pid号写入至redis.conf选项pidfile设置的文件中，此时redis将一直运行，除非手动kill该进程。\n\n* daemonize:no\n    * 当daemonize选项设置成no时，当前界面将进入redis的命令行界面，exit强制退出或者关闭连接工具(putty,xshell等)都会导致redis进程退出。\n\n### 9 、启动测试一下！\n\n```shell\n# 【shell】启动redis服务\n[root@192 bin]# cd /usr/local/bin\n[root@192 bin]# redis-server /opt/redis-5.0.7/redis.conf\n\n# redis客户端连接===> 观察地址的变化，如果连接ok,是直接连上的，redis默认端口号 6379\n[root@192 bin]# redis-cli -p 6379\n127.0.0.1:6379> ping\nPONG\n127.0.0.1:6379> set k1 helloworld\nOK\n127.0.0.1:6379> get k\n\"helloworld\"\n\n# 【shell】ps显示系统当前进程信息\n[root@192 myredis]# ps -ef|grep redis\nroot 16005  1  0 04 :45? 00 :00:00 redis-server\n127.0.0.1:\nroot 16031  15692  0 04 :47 pts/0 00 :00:00 redis-cli -p 6379\nroot 16107  16076  0 04 :51 pts/2 00 :00:00 grep --color=auto redis\n\n# 【redis】关闭连接\n127.0.0.1:6379> shutdown\nnot connected> exit\n\n# 【shell】ps显示系统当前进程信息\n[root@192 myredis]# ps -ef|grep redis\nroot 16140  16076  0 04 :53 pts/2 00 :00:00 grep --color=auto redis\n```\n\n## 基础知识说明\n\n准备工作：开启redis服务，客户端连接\n\n> redis压力测试工具-----Redis-benchmark\n\nRedis-benchmark是官方自带的Redis性能测试工具，可以有效的测试Redis服务的性能。\n\n![输入图片说明](redis/QQ截图20210927092755.png \"QQ截图20201229183512.png\")\n\n### redis 性能测试工具可选参数如下所示：\n\n|  序号   | 选项  |  描述   | 默认值  |\n|  ----  | ----  |  ----  | ----  |\n| 1  | -h | 指定服务器主机名  | 127.0.0.1 |\n| 2  | -p | 指定服务器端口  |  6379 |\n|3| -s| 指定服务器| socket|\n|4| -c| 指定并发连接数| 50|\n|5| -n| 指定请求数 |10000|\n|6| -d| 以字节的形式指定 SET/GET 值的数据大小 |2|\n|7| -k| 1=keep alive 0=reconnect |1|\n|8| -r| SET/GET/INCR 使用随机 key, SADD 使用随机值|\n|9| -P| 通过管道传输 请求 |1\n|10| -q| 强制退出 redis。仅显示 query/sec 值|\n|11| --csv| 以 CSV 格式输出|\n|12| -l| 生成循环，永久执行测试|\n|13| -t| 仅运行以逗号分隔的测试命令列表。|\n|14| -I| Idle 模式。仅打开 N 个 idle 连接并等待。|\n\n```shell\n# 测试一： 100 个并发连接， 100000 个请求，检测host为localhost 端口为 6379 的redis服务器性能\nredis-benchmark -h localhost -p 6379 -c 100 -n 100000\n# 测试出来的所有命令只举例一个！\n====== SET ======\n 100000 requests completed in 1.88 seconds # 对集合写入测试\n 100 parallel clients # 每次请求有 100 个并发客户端\n 3 bytes payload # 每次写入 3 个字节的数据，有效载荷\nkeep alive: 1 # 保持一个连接，一台服务器来处理这些请求\n\n17.05% <= 1 milliseconds\n97.35% <= 2 milliseconds\n99.97% <= 3 milliseconds\n100.00% <= 3 milliseconds # 所有请求在 3 毫秒内完成\n53248.14 requests per second # 每秒处理 53248.14 次请求\n```\n\n### 基本数据库常识\n\n### 默认 16 个数据库，类似数组下标从零开始，初始默认使用零号库\n\n```\n查看 redis.conf ，里面有默认的配置\ndatabases 16\n\n# Set the number of databases. The default database is DB 0, you can select\n# a different one on a per-connection basis using SELECT <dbid> where\n# dbid is a number between 0 and 'databases'-1\ndatabases 16\n```\n\n### Select命令切换数据库\n\n```shell\n127.0.0.1:6379> select 7\nOK\n127.0.0.1:6379[7]>\n# 不同的库可以存不同的数据\n### Dbsize查看当前数据库的key的数量\n127.0.0.1:6379> select 7\nOK\n127.0.0.1:6379[7]> DBSIZE\n(integer) 0\n127.0.0.1:6379[7]> select 0\nOK\n127.0.0.1:6379> DBSIZE\n(integer) 5\n127.0.0.1:6379> keys * # 查看具体的key\n1 ) \"counter:__rand_int__\"\n2 ) \"mylist\"\n3 ) \"k1\"\n4 ) \"myset:__rand_int__\"\n5 ) \"key:__rand_int__\"\n```\n\n### Flushdb：清空当前库\n\n### Flushall：清空全部的库\n\n```shell\n127.0.0.1:6379> DBSIZE\n(integer) 5\n127.0.0.1:6379> FLUSHDB\nOK\n127.0.0.1:6379> DBSIZE\n(integer) 0\n```\n\n### 为什么默认端口是 6379 ？粉丝效应！\n\n> 为什么redis是单线程\n\n> 我们首先要明白，Redis很快！官方表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了！\n\n\n> Redis采用的是基于内存的采用的是单进程单线程模型的 KV 数据库，由C语言编写，官方提供的数据是可以达到100000+的QPS（每秒内查询次数）。这个数据不比采用单进程多线程的同样基于内存的 KV数据库 Memcached 差！\n\n### Redis为什么这么快？\n\n* 1 ）以前一直有个误区，以为：高性能服务器 一定是多线程来实现的 原因很简单因为误区二导致的：多线程 一定比 单线程 效率高，其实不然！ 在说这个事前希望大家都能对 CPU 、 内存 、 硬盘的速度都有了解了！\n\n* 2 ）redis 核心就是 如果我的数据全都在内存里，我单线程的去操作 就是效率最高的，为什么呢，因为 多线程的本质就是 CPU 模拟出来多个线程的情况，这种模拟出来的情况就有一个代价，就是上下文的切\n  换，对于一个内存的系统来说，它没有上下文的切换就是效率最高的。redis 用 单个CPU 绑定一块内存 的数据，然后针对这块内存的数据进行多次读写的时候，都是在一个CPU上完成的，所以它是单线程处\n  理这个事。在内存的情况下，这个方案就是最佳方案。 因为一次CPU上下文的切换大概在 1500ns 左右。从内存中读取 1MB 的连续数据，耗时大约为 250us， 假设1MB的数据由多个线程读取了 1000 次，那么就有 1000\n  次时间上下文的切换，那么就有1500ns *\n  1000 = 1500us ，我单线程的读完1MB数据才250us ,你光时间上下文的切换就用了1500us了，我还不 算你每次读一点数据 的时间。\n\n# 五大数据类型\n\n> 官方文档\n![输入图片说明](redis/QQ截图20210927094518.png \"QQ截图20201229183512.png\")\n\n命令文档 http://doc.redisfans.com/\n\n### 全段翻译：\n\n> Redis是一个开放源代码（BSD许可）的内存中数据结构存储，用作数据库，缓存和消息代理。它支持数 据结构，例如字符串，哈希，列表，集合，带范围查询的排序集合，位图，超日志，带有半径查询和流 的地理空间索引。Redis具有内置的复制，Lua脚本，LRU驱逐，事务和不同级别的磁盘持久性，并通过 Redis Sentinel和Redis Cluster自动分区提供了高可用性。\n\n### String （字符串类型）\n\n> String是redis最基本的类型，你可以理解成Memcached一模一样的类型，一个key对应一个value。<br>\nString类型是二进制安全的，意思是redis的string可以包含任何数据，比如jpg图片或者序列化的对象。<br>\nString类型是redis最基本的数据类型，一个redis中字符串value最多可以是512M。<br>\n\n### Hash（哈希，类似 Java里的Map）\n\n> Redis hash 是一个键值对集合。<br>\nRedis hash 是一个String类型的field和value的映射表，hash特别适合用于存储对象。<br>\n类似Java里面的Map<String,Object><br>\n\n### List（列表）\n\n> Redis列表是简单的字符串列表，按照插入顺序排序，你可以添加一个元素到列表的头部（左边）或者尾部（右边）。<br>\n它的底层实际是个链表!\n\n### Set（集合）\n\n> Redis的Set是String类型的无序集合，它是通过HashTable实现的!\n\n### Zset（sorted set：有序集合）\n\n> Redis zset 和 set 一样，也是String类型元素的集合，且不允许重复的成员。<br>\n不同的是每个元素都会关联一个double类型的分数。<br><br>\nRedis正是通过分数来为集合中的成员进行从小到大的排序，zset的成员是唯一的，但是分数（Score）<br>\n却可以重复。<br>\n\n## Redis键（key）\n\n```shell\n# keys * 查看所有的key\n127.0.0.1:6379> keys *\n(empty list or set)\n127.0.0.1:6379> set name qinjiang\nOK\n127.0.0.1:6379> keys *\n1 ) \"name\"\n\n# exists key 的名字，判断某个key是否存在\n127.0.0.1:6379> EXISTS name\n(integer) 1\n127.0.0.1:6379> EXISTS name1\n(integer) 0\n\n# move key db ---> 当前库就没有了，被移除了\n127.0.0.1:6379> move name 1\n(integer) 1\n127.0.0.1:6379> keys *\n(empty list or set)\n\n# expire key 秒钟：为给定 key 设置生存时间，当 key 过期时(生存时间为 0 )，它会被自动删\n除。\n# ttl key 查看还有多少秒过期，-1 表示永不过期，-2 表示已过期\n127.0.0.1:6379> set name qinjiang\nOK\n\n127.0.0.1:6379> EXPIRE name 10\n(integer) 1\n127.0.0.1:6379> ttl name\n(integer) 4\n127.0.0.1:6379> ttl name\n(integer) 3\n127.0.0.1:6379> ttl name\n(integer) 2\n127.0.0.1:6379> ttl name\n(integer) 1\n127.0.0.1:6379> ttl name\n(integer) -2\n127.0.0.1:6379> keys *\n(empty list or set)\n\n# type key 查看你的key是什么类型\n127.0.0.1:6379> set name qinjiang\nOK\n127.0.0.1:6379> get name\n\"qinjiang\"\n127.0.0.1:6379> type name\nstring\n```\n\n## 字符串String\n\n`单值单Value`\n\n**常用命令说明：**\n\n```shell\n#### # ===================================================\n# set、get、del、append、strlen\n# ===================================================\n127.0.0.1:6379> set key1 value1 # 设置值\nOK\n127.0.0.1:6379> get key1  # 获得key\n\"value1\"\n127.0.0.1:6379> del key1  # 删除key\n(integer) 1\n127.0.0.1:6379> keys *  # 查看全部的key\n(empty list or set)\n127.0.0.1:6379> exists key1 # 确保 key1 不存在\n(integer) 0\n127.0.0.1:6379> append key1 \"hello\" # 对不存在的 key 进行 APPEND ，等同于 SET\nkey1 \"hello\"\n(integer) 5 # 字符长度\n127.0.0.1:6379> APPEND key1 \"-2333\" # 对已存在的字符串进行 APPEND\n(integer) 10 # 长度从 5 个字符增加到 10 个字符\n127.0.0.1:6379> get key1\n\"hello-2333\"\n127.0.0.1:6379> STRLEN key1 # # 获取字符串的长度\n(integer) 10\n\n# ===================================================\n# incr、decr 一定要是数字才能进行加减，+1 和 -1。\n# incrby、decrby 命令将 key 中储存的数字加上指定的增量值。\n# ===================================================\n\n127.0.0.1:6379> set views 0 # 设置浏览量为 0\nOK\n127.0.0.1:6379> incr views  # 浏览 + 1\n(integer) 1\n127.0.0.1:6379> incr views  # 浏览 + 1\n(integer) 2\n127.0.0.1:6379> decr views  # 浏览 - 1\n(integer) 1\n127.0.0.1:6379> incrby views 10 # +10\n(integer) 11\n127.0.0.1:6379> decrby views 10 # -10\n(integer) 1\n\n# ===================================================\n# range [范围]\n# getrange 获取指定区间范围内的值，类似between...and的关系，从零到负一表示全部\n# ===================================================\n127.0.0.1:6379> set key2 abcd123456  # 设置key2的值\nOK\n127.0.0.1:6379> getrange key2 0 -1 # 获得全部的值\n\"abcd123456\"\n127.0.0.1:6379> getrange key2 0 2 # 截取部分字符串\n\"abc\"\n\n# ===================================================\n# setrange 设置指定区间范围内的值，格式是setrange key值 具体值\n# ===================================================\n127.0.0.1:6379> get key2\n\"abcd123456\"\n127.0.0.1:6379> SETRANGE key2 1 xx # 替换值\n(integer) 10\n127.0.0.1:6379> get key2\n\"axxd123456\"\n\n# ===================================================\n# setex（set with expire）键秒值\n# setnx（set if not exist）\n# ===================================================\n127.0.0.1:6379> setex key3 60 expire  # 设置过期时间\nOK\n\n127.0.0.1:6379> ttl key3  # 查看剩余的时间\n(integer) 55\n127.0.0.1:6379> setnx mykey \"redis\" # 如果不存在就设置，成功返回 1\n(integer) 1\n127.0.0.1:6379> setnx mykey \"mongodb\" # 如果存在就设置，失败返回 0\n(integer) 0\n127.0.0.1:6379> get mykey\n\"redis\"\n\n# ===================================================\n# mset Mset 命令用于同时设置一个或多个 key-value 对。\n# mget Mget 命令返回所有(一个或多个)给定 key 的值。\n# 如果给定的 key 里面，有某个 key 不存在，那么这个 key 返回特殊值 nil 。\n# msetnx 当所有 key 都成功设置，返回 1 。\n# 如果所有给定 key 都设置失败(至少有一个 key 已经存在)，那么返回 0 。原子操\n作\n# ===================================================\n127.0.0.1:6379> mset k10 v10 k11 v11 k12 v12\nOK\n127.0.0.1:6379> keys *\n1 ) \"k12\"\n2 ) \"k11\"\n3 ) \"k10\"\n127.0.0.1:6379> mget k10 k11 k12 k13\n1 ) \"v10\"\n2 ) \"v11\"\n3 ) \"v12\"\n4 ) (nil)\n127.0.0.1:6379> msetnx k10 v10 k15 v15 # 原子性操作！\n(integer) 0\n127.0.0.1:6379> get key15\n(nil)\n\n# 传统对象缓存\nset user:1 value(json数据)\n\n# 可以用来缓存对象\nmset user:1:name zhangsan user:1:age 2\nmget user:1:name user:1:age\n\n# ===================================================\n# getset（先get再set）\n# ===================================================\n127.0.0.1:6379> getset db mongodb # 没有旧值，返回 nil\n(nil)\n127.0.0.1:6379> get db\n\"mongodb\"\n127.0.0.1:6379> getset db redis # 返回旧值 mongodb\n\"mongodb\"\n127.0.0.1:6379> get db\n\"redis\"\n```\n\nString数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。\n\n常规key-value缓存应用：\n\n常规计数：微博数，粉丝数等。\n\n## 列表List\n\n`单值多Value`\n\n```shell\n#### # ===================================================\n# Lpush：将一个或多个值插入到列表头部。（左）\n# rpush：将一个或多个值插入到列表尾部。（右）\n# lrange：返回列表中指定区间内的元素，区间以偏移量 START 和 END 指定。\n# 其中 0 表示列表的第一个元素， 1 表示列表的第二个元素，以此类推。\n# 你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此\n类推。\n# ===================================================\n127.0.0.1:6379> LPUSH list \"one\"\n(integer) 1\n127.0.0.1:6379> LPUSH list \"two\"\n(integer) 2\n\n127.0.0.1:6379> RPUSH list \"right\"\n(integer) 3\n127.0.0.1:6379> Lrange list 0 -1\n1 ) \"two\"\n2 ) \"one\"\n3 ) \"right\"\n127.0.0.1:6379> Lrange list 0 1\n1 ) \"two\"\n2 ) \"one\"\n\n# ===================================================\n# lpop 命令用于移除并返回列表的第一个元素。当列表 key 不存在时，返回 nil 。\n# rpop 移除列表的最后一个元素，返回值为移除的元素。\n# ===================================================\n127.0.0.1:6379> Lpop list\n\"two\"\n127.0.0.1:6379> Rpop list\n\"right\"\n127.0.0.1:6379> Lrange list 0 -1\n1 ) \"one\"\n\n# ===================================================\n# Lindex，按照索引下标获得元素（-1代表最后一个， 0 代表是第一个）\n# ===================================================\n127.0.0.1:6379> Lindex list 1\n(nil)\n127.0.0.1:6379> Lindex list 0\n\"one\"\n127.0.0.1:6379> Lindex list -1\n\"one\"\n\n# ===================================================\n# llen 用于返回列表的长度。\n# ===================================================\n127.0.0.1:6379> flushdb\nOK\n127.0.0.1:6379> Lpush list \"one\"\n(integer) 1\n127.0.0.1:6379> Lpush list \"two\"\n(integer) 2\n127.0.0.1:6379> Lpush list \"three\"\n(integer) 3\n127.0.0.1:6379> Llen list # 返回列表的长度\n(integer) 3\n\n# ===================================================\n# lrem key 根据参数 COUNT 的值，移除列表中与参数 VALUE 相等的元素。\n# ===================================================\n127.0.0.1:6379> lrem list 1 \"two\"\n(integer) 1\n127.0.0.1:6379> Lrange list 0 -1\n1 ) \"three\"\n2 ) \"one\"\n\n# ===================================================\n# Ltrim key 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区\n间之内的元素都将被删除。\n# ===================================================\n\n127.0.0.1:6379> RPUSH mylist \"hello\"\n(integer) 1\n127.0.0.1:6379> RPUSH mylist \"hello\"\n(integer) 2\n127.0.0.1:6379> RPUSH mylist \"hello2\"\n(integer) 3\n127.0.0.1:6379> RPUSH mylist \"hello3\"\n(integer) 4\n127.0.0.1:6379> ltrim mylist 1 2\nOK\n127.0.0.1:6379> lrange mylist 0 -1\n1 ) \"hello\"\n2 ) \"hello2\"\n\n# ===================================================\n# rpoplpush 移除列表的最后一个元素，并将该元素添加到另一个列表并返回。\n# ===================================================\n127.0.0.1:6379> rpush mylist \"hello\"\n(integer) 1\n127.0.0.1:6379> rpush mylist \"foo\"\n(integer) 2\n127.0.0.1:6379> rpush mylist \"bar\"\n(integer) 3\n127.0.0.1:6379> rpoplpush mylist myotherlist\n\"bar\"\n127.0.0.1:6379> lrange mylist 0 -1\n1 ) \"hello\"\n2 ) \"foo\"\n127.0.0.1:6379> lrange myotherlist 0 -1\n1 ) \"bar\"\n\n# ===================================================\n# lset key index value 将列表 key 下标为 index 的元素的值设置为 value 。\n# ===================================================\n127.0.0.1:6379> exists list  # 对空列表(key 不存在)进行 LSET\n(integer) 0\n127.0.0.1:6379> lset list 0 item # 报错\n(error) ERR no such key\n\n127.0.0.1:6379> lpush list \"value1\" # 对非空列表进行 LSET\n(integer) 1\n127.0.0.1:6379> lrange list 0 0\n1 ) \"value1\"\n127.0.0.1:6379> lset list 0 \"new\" # 更新值\nOK\n127.0.0.1:6379> lrange list 0 0\n1 ) \"new\"\n127.0.0.1:6379> lset list 1 \"new\" # index 超出范围报错\n(error) ERR index out of range\n\n# ===================================================\n# linsert key before/after pivot value 用于在列表的元素前或者后插入元素。\n# 将值 value 插入到列表 key 当中，位于值 pivot 之前或之后。\n# ===================================================\nredis> RPUSH mylist \"Hello\"\n(integer) 1\nredis> RPUSH mylist \"World\"\n(integer) 2\n\nredis> LINSERT mylist BEFORE \"World\" \"There\"\n(integer) 3\nredis> LRANGE mylist 0 -1\n1 ) \"Hello\"\n2 ) \"There\"\n3 ) \"World\"\n```\n\n### 性能总结\n\n* 它是一个字符串链表，left，right 都可以插入添加\n* 如果键不存在，创建新的链表\n* 如果键已存在，新增内容\n* 如果值全移除，对应的键也就消失了\n* 链表的操作无论是头和尾效率都极高，但假如是对中间元素进行操作，效率就很惨淡了。\n\n> list就是链表，略有数据结构知识的人都应该能理解其结构。使用Lists结构，我们可以轻松地实现最新消 息排行等功能。List的另一个应用就是消息队列，可以利用List的PUSH操作，将任务存在List中，然后工 作线程再用POP操作将任务取出进行执行。Redis还提供了操作List中某一段的api，你可以直接查询，删 除List中某一段的元素。\n\n> Redis的list是每个子元素都是String类型的双向链表，可以通过push和pop操作从列表的头部或者尾部添加或者删除元素，这样List即可以作为栈，也可以作为队列。\n\n## 集合Set\n\n`单值多value`\n\n```shell\n#### # ===================================================\n# sadd 将一个或多个成员元素加入到集合中，不能重复\n# smembers 返回集合中的所有的成员。\n# sismember 命令判断成员元素是否是集合的成员。\n# ===================================================\n127.0.0.1:6379> sadd myset \"hello\"\n(integer) 1\n127.0.0.1:6379> sadd myset \"kuangshen\"\n(integer) 1\n127.0.0.1:6379> sadd myset \"kuangshen\"\n(integer) 0\n127.0.0.1:6379> SMEMBERS myset\n1 ) \"kuangshen\"\n2 ) \"hello\"\n127.0.0.1:6379> SISMEMBER myset \"hello\"\n(integer) 1\n127.0.0.1:6379> SISMEMBER myset \"world\"\n(integer) 0\n\n# ===================================================\n# scard，获取集合里面的元素个数\n# ===================================================\n127.0.0.1:6379> scard myset\n(integer) 2\n\n# ===================================================\n# srem key value 用于移除集合中的一个或多个成员元素\n# ===================================================\n127.0.0.1:6379> srem myset \"kuangshen\"\n(integer) 1\n\n127.0.0.1:6379> SMEMBERS myset\n1 ) \"hello\"\n\n# ===================================================\n# srandmember key 命令用于返回集合中的一个随机元素。\n# ===================================================\n127.0.0.1:6379> SMEMBERS myset\n1 ) \"kuangshen\"\n2 ) \"world\"\n3 ) \"hello\"\n127.0.0.1:6379> SRANDMEMBER myset\n\"hello\"\n127.0.0.1:6379> SRANDMEMBER myset 2\n1 ) \"world\"\n2 ) \"kuangshen\"\n127.0.0.1:6379> SRANDMEMBER myset 2\n1 ) \"kuangshen\"\n2 ) \"hello\"\n\n# ===================================================\n# spop key 用于移除集合中的指定 key 的一个或多个随机元素\n# ===================================================\n127.0.0.1:6379> SMEMBERS myset\n1 ) \"kuangshen\"\n2 ) \"world\"\n3 ) \"hello\"\n127.0.0.1:6379> spop myset\n\"world\"\n127.0.0.1:6379> spop myset\n\"kuangshen\"\n127.0.0.1:6379> spop myset\n\"hello\"\n\n# ===================================================\n# smove SOURCE DESTINATION MEMBER\n# 将指定成员 member 元素从 source 集合移动到 destination 集合。\n# ===================================================\n127.0.0.1:6379> sadd myset \"hello\"\n(integer) 1\n127.0.0.1:6379> sadd myset \"world\"\n(integer) 1\n127.0.0.1:6379> sadd myset \"kuangshen\"\n(integer) 1\n127.0.0.1:6379> sadd myset2 \"set2\"\n(integer) 1\n127.0.0.1:6379> smove myset myset2 \"kuangshen\"\n(integer) 1\n127.0.0.1:6379> SMEMBERS myset\n1 ) \"world\"\n2 ) \"hello\"\n127.0.0.1:6379> SMEMBERS myset2\n1 ) \"kuangshen\"\n2 ) \"set2\"\n\n# ===================================================\n- 数字集合类\n  - 差集： sdiff\n  - 交集： sinter\n  - 并集： sunion\n# ===================================================\n127.0.0.1:6379> sadd key1 \"a\"\n(integer) 1\n127.0.0.1:6379> sadd key1 \"b\"\n(integer) 1\n127.0.0.1:6379> sadd key1 \"c\"\n(integer) 1\n127.0.0.1:6379> sadd key2 \"c\"\n(integer) 1\n127.0.0.1:6379> sadd key2 \"d\"\n(integer) 1\n127.0.0.1:6379> sadd key2 \"e\"\n(integer) 1\n127.0.0.1:6379> SDIFF key1 key2 # 差集\n1 ) \"a\"\n2 ) \"b\"\n127.0.0.1:6379> SINTER key1 key2 # 交集\n1 ) \"c\"\n127.0.0.1:6379> SUNION key1 key2 # 并集\n1 ) \"a\"\n2 ) \"b\"\n3 ) \"c\"\n4 ) \"e\"\n5 ) \"d\"\n```\n\n> 在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis还为集合提供了求交集、并集、差集等操作，可以非常方便的实现如共同关注、共同喜好、二度好友等功能，对上面的所有集合操作，你还可以使用不同的命令选择将结果返回给客户端还是存集到一个新的集合中。\n\n## 哈希Hash\n\n`kv模式不变，但V是一个键值对`\n\n```shell\n#### # ===================================================\n\n# hset、hget 命令用于为哈希表中的字段赋值 。\n# hmset、hmget 同时将多个field-value对设置到哈希表中。会覆盖哈希表中已存在的字段。\n# hgetall 用于返回哈希表中，所有的字段和值。\n# hdel 用于删除哈希表 key 中的一个或多个指定字段\n# ===================================================\n127.0.0.1:6379> hset myhash field1 \"kuangshen\"\n(integer) 1\n127.0.0.1:6379> hget myhash field1\n\"kuangshen\"\n127.0.0.1:6379> HMSET myhash field1 \"Hello\" field2 \"World\"\nOK\n127.0.0.1:6379> HGET myhash field1\n\"Hello\"\n127.0.0.1:6379> HGET myhash field2\n\"World\"\n127.0.0.1:6379> hgetall myhash\n1 ) \"field1\"\n2 ) \"Hello\"\n3 ) \"field2\"\n4 ) \"World\"\n127.0.0.1:6379> HDEL myhash field1\n(integer) 1\n127.0.0.1:6379> hgetall myhash\n1 ) \"field2\"\n2 ) \"World\"\n\n# ===================================================\n# hlen 获取哈希表中字段的数量。\n# ===================================================\n127.0.0.1:6379> hlen myhash\n(integer) 1\n127.0.0.1:6379> HMSET myhash field1 \"Hello\" field2 \"World\"\nOK\n127.0.0.1:6379> hlen myhash\n(integer) 2\n\n# ===================================================\n# hexists 查看哈希表的指定字段是否存在。\n# ===================================================\n127.0.0.1:6379> hexists myhash field1\n(integer) 1\n127.0.0.1:6379> hexists myhash field3\n(integer) 0\n\n# ===================================================\n# hkeys 获取哈希表中的所有域（field）。\n# hvals 返回哈希表所有域(field)的值。\n# ===================================================\n127.0.0.1:6379> HKEYS myhash\n1 ) \"field2\"\n2 ) \"field1\"\n127.0.0.1:6379> HVALS myhash\n1 ) \"World\"\n2 ) \"Hello\"\n\n# ===================================================\n# hincrby 为哈希表中的字段值加上指定增量值。\n# ===================================================\n127.0.0.1:6379> hset myhash field 5\n(integer) 1\n127.0.0.1:6379> HINCRBY myhash field 1\n(integer) 6\n127.0.0.1:6379> HINCRBY myhash field -1\n(integer) 5\n127.0.0.1:6379> HINCRBY myhash field -10\n(integer) -5\n\n# ===================================================\n# hsetnx 为哈希表中不存在的的字段赋值 。\n# ===================================================\n127.0.0.1:6379> HSETNX myhash field1 \"hello\"\n(integer) 1 # 设置成功，返回 1 。\n127.0.0.1:6379> HSETNX myhash field1 \"world\"\n(integer) 0 # 如果给定字段已经存在，返回 0 。\n127.0.0.1:6379> HGET myhash field1\n\"hello\"\n```\n\n> Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。存储部分变更的数据，如用户信息等。\n\n## 有序集合Zset\n\n`在set基础上，加一个score值。之前set是k1 v1 v2 v3，现在zset是 k1 score1 v1 score2 v2`\n\n```shell\n#### # ===================================================\n# zadd 将一个或多个成员元素及其分数值加入到有序集当中。\n# zrange 返回有序集中，指定区间内的成员\n# ===================================================\n127.0.0.1:6379> zadd myset 1 \"one\"\n(integer) 1\n127.0.0.1:6379> zadd myset 2 \"two\" 3 \"three\"\n(integer) 2\n127.0.0.1:6379> ZRANGE myset 0 -1\n1 ) \"one\"\n2 ) \"two\"\n3 ) \"three\"\n\n# ===================================================\n# zrangebyscore 返回有序集合中指定分数区间的成员列表。有序集成员按分数值递增(从小到大)\n次序排列。\n# ===================================================\n127.0.0.1:6379> zadd salary 2500 xiaoming\n(integer) 1\n127.0.0.1:6379> zadd salary 5000 xiaohong\n(integer) 1\n127.0.0.1:6379> zadd salary 500 kuangshen\n(integer) 1\n# Inf无穷大量+∞,同样地,-∞可以表示为-Inf。\n127.0.0.1:6379> ZRANGEBYSCORE salary -inf +inf # 显示整个有序集\n1 ) \"kuangshen\"\n2 ) \"xiaoming\"\n3 ) \"xiaohong\"\n127.0.0.1:6379> ZRANGEBYSCORE salary -inf +inf withscores # 递增排列\n1 ) \"kuangshen\"\n2 ) \"500\"\n3 ) \"xiaoming\"\n4 ) \"2500\"\n5 ) \"xiaohong\"\n6 ) \"5000\"\n127.0.0.1:6379> ZREVRANGE salary 0 -1 WITHSCORES  # 递减排列\n1 ) \"xiaohong\"\n2 ) \"5000\"\n3 ) \"xiaoming\"\n4 ) \"2500\"\n5 ) \"kuangshen\"\n6 ) \"500\"\n127.0.0.1:6379> ZRANGEBYSCORE salary -inf 2500 WITHSCORES # 显示工资 <=2500\n的所有成员\n1 ) \"kuangshen\"\n2 ) \"500\"\n3 ) \"xiaoming\"\n4 ) \"2500\"\n\n#### # ===================================================\n# zrem 移除有序集中的一个或多个成员\n# ===================================================\n127.0.0.1:6379> ZRANGE salary 0 -1\n1 ) \"kuangshen\"\n2 ) \"xiaoming\"\n3 ) \"xiaohong\"\n127.0.0.1:6379> zrem salary kuangshen\n(integer) 1\n127.0.0.1:6379> ZRANGE salary 0 -1\n1 ) \"xiaoming\"\n2 ) \"xiaohong\"\n\n# ===================================================\n# zcard 命令用于计算集合中元素的数量。\n# ===================================================\n127.0.0.1:6379> zcard salary\n(integer) 2\nOK\n\n# ===================================================\n# zcount 计算有序集合中指定分数区间的成员数量。\n# ===================================================\n127.0.0.1:6379> zadd myset 1 \"hello\"\n(integer) 1\n127.0.0.1:6379> zadd myset 2 \"world\" 3 \"kuangshen\"\n(integer) 2\n127.0.0.1:6379> ZCOUNT myset 1 3\n(integer) 3\n127.0.0.1:6379> ZCOUNT myset 1 2\n(integer) 2\n\n# ===================================================\n# zrank 返回有序集中指定成员的排名。其中有序集成员按分数值递增(从小到大)顺序排列。\n# ===================================================\n127.0.0.1:6379> zadd salary 2500 xiaoming\n(integer) 1\n127.0.0.1:6379> zadd salary 5000 xiaohong\n(integer) 1\n127.0.0.1:6379> zadd salary 500 kuangshen\n(integer) 1\n127.0.0.1:6379> ZRANGE salary 0 -1 WITHSCORES  # 显示所有成员及其 score 值\n1 ) \"kuangshen\"\n2 ) \"500\"\n3 ) \"xiaoming\"\n4 ) \"2500\"\n5 ) \"xiaohong\"\n6 ) \"5000\"\n127.0.0.1:6379> zrank salary kuangshen  # 显示 kuangshen 的薪水排名，最少\n(integer) 0\n127.0.0.1:6379> zrank salary xiaohong # 显示 xiaohong 的薪水排名，第三\n(integer) 2\n\n# ===================================================\n# zrevrank 返回有序集中成员的排名。其中有序集成员按分数值递减(从大到小)排序。\n# ===================================================\n127.0.0.1:6379> ZREVRANK salary bright\n```\n\n> 和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列，比如一个存储全班同学成绩的sorted set，其集合value可以是同学的学号，而score就可以是其考试得分，这样在数据插入集合的时候，就已经进行了天然的排序。可以用sorted set来做带权重的队列，比如普通消息的score为 1 ，重要消息的score为 2 ，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。\n\n> 排行榜应用，取TOP N操作 ！\n\n# 三种特殊数据类型\n\n## GEO地理位置\n\n> 简介\n\n> Redis 的 GEO 特性在 Redis 3.2 版本中推出， 这个功能可以将用户给定的地理位置信息储存起来， 并对这些信息进行操作。来实现诸如附近位置、摇一摇这类依赖于地理位置信息的功能。geo的数据类型为zset。\n\n> GEO 的数据结构总共有六个常用命令：geoadd、geopos、geodist、georadius、georadiusbymember、gethash\n\n### 官方文档：https://www.redis.net.cn/order/3685.html\n\n### geoadd\n\n**解析：**\n\n```shell\n#### # 语法\ngeoadd key longitude latitude member...\n\n# 将给定的空间元素(纬度、经度、名字)添加到指定的键里面。\n# 这些数据会以有序集he的形式被储存在键里面，从而使得georadius和georadiusbymember这样的命令可以在之后通过位置查询取得这些元素。\n# geoadd命令以标准的x,y格式接受参数,所以用户必须先输入经度,然后再输入纬度。\n# geoadd能够记录的坐标是有限的:非常接近两极的区域无法被索引。\n# 有效的经度介于-180-180度之间，有效的纬度介于-85.05112878 度至 85.05112878 度之间。，当用户尝试输入一个超出范围的经度或者纬度时,geoadd命令将返回一个错误。\n```\n\n### 测试：百度搜索经纬度查询，模拟真实数据\n\n```shell\n127.0.0.1:6379> geoadd china:city 116.23 40.22 北京\n(integer) 1\n127.0.0.1:6379> geoadd china:city 121.48 31.40 上海 113.88 22.55 深圳 120.21\n30.20 杭州\n(integer) 3\n127.0.0.1:6379> geoadd china:city 106.54 29.40 重庆 108.93 34.23 西安 114.02\n30.58 武汉\n(integer) 3\n```\n\n### geopos\n\n**解析：**\n\n```shell\ngeopos key member [member...]\n\n#从key里返回所有给定位置元素的位置（经度和纬度）\n```\n\n### 测试：\n\n```shell\n127.0.0.1:6379> geopos china:city 北京\n1 ) 1 ) \"116.23000055551528931\"\n2 ) \"40.2200010338739844\"\n127.0.0.1:6379> geopos china:city 上海 重庆\n1 ) 1 ) \"121.48000091314315796\"\n2 ) \"31.40000025319353938\"\n2 ) 1 ) \"106.54000014066696167\"\n2 ) \"29.39999880018641676\"\n127.0.0.1:6379> geopos china:city 新疆\n1 ) (nil)\n```\n\n### geodist\n\n**解析：**\n\n```shell\ngeodist key member1 member2 [unit]\n\n# 返回两个给定位置之间的距离，如果两个位置之间的其中一个不存在,那么命令返回空值。\n# 指定单位的参数unit必须是以下单位的其中一个：\n# m表示单位为米\n# km表示单位为千米\n# mi表示单位为英里\n# ft表示单位为英尺\n# 如果用户没有显式地指定单位参数,那么geodist默认使用米作为单位。\n#geodist命令在计算距离时会假设地球为完美的球形,在极限情况下,这一假设最大会造成0.5%的误差。\n```\n\n### 测试：\n\n```shell\n127.0.0.1:6379> geodist china:city 北京 上海\n\"1088785.4302\"\n127.0.0.1:6379> geodist china:city 北京 上海 km\n\"1088.7854\"\n127.0.0.1:6379> geodist china:city 重庆 北京 km\n\"1491.6716\"\n```\n\n### georadius\n\n### 解析：\n\n```shell\n#### # 语法\ngeoradius key longitude latitude radius m|km|ft|mi [withcoord][withdist]\n[withhash][asc|desc][count count]\n# 以给定的经纬度为中心， 找出某一半径内的元素\n```\n\n### 测试：重新连接 redis-cli，增加参数 --raw ，可以强制输出中文，不然会乱码\n\n```shell\n[root@kuangshen bin]# redis-cli --raw -p 6379\n# 在 china:city 中寻找坐标 100 30 半径为 1000km 的城市\n127.0.0.1:6379> georadius china:city 100 30 1000 km\n重庆\n西安\n\n# withdist 返回位置名称和中心距离\n127.0.0.1:6379> georadius china:city 100 30 1000 km withdist\n重庆\n635.2850\n西安\n963.3171\n\n# withcoord 返回位置名称和经纬度\n127.0.0.1:6379> georadius china:city 100 30 1000 km withcoord\n重庆\n106.54000014066696167\n29.39999880018641676\n西安\n108.92999857664108276\n34.23000121926852302\n\n# withdist withcoord 返回位置名称 距离 和经纬度 count 限定寻找个数\n127.0.0.1:6379> georadius china:city 100 30 1000 km withcoord withdist count\n1\n重庆\n635.2850\n106.54000014066696167\n29.39999880018641676\n127.0.0.1:6379> georadius china:city 100 30 1000 km withcoord withdist count\n2\n重庆\n635.2850\n106.54000014066696167\n29.39999880018641676\n西安\n963.3171\n108.92999857664108276\n34.23000121926852302\n```\n\n### georadiusbymember\n\n### 解析：\n\n```shell\n#### # 语法\ngeoradiusbymember key member radius m|km|ft|mi [withcoord][withdist]\n[withhash][asc|desc][count count]\n# 找出位于指定范围内的元素，中心点是由给定的位置元素决定\n```\n\n### 测试：\n\n```\n127.0.0.1:6379> GEORADIUSBYMEMBER china:city 北京 1000 km\n北京\n西安\n127.0.0.1:6379> GEORADIUSBYMEMBER china:city 上海 400 km\n杭州\n上海\n```\n\n### geohash\n\n### 解析：\n\n```\n#### # 语法\ngeohash key member [member...]\n# Redis使用geohash将二维经纬度转换为一维字符串，字符串越长表示位置更精确,两个字符串越相似\n表示距离越近。\n```\n\n### 测试：\n\n```\n127.0.0.1:6379> geohash china:city 北京 重庆\nwx4sucu47r0\nwm5z22h53v0\n127.0.0.1:6379> geohash china:city 北京 上海\nwx4sucu47r0\nwtw6sk5n300\n```\n\n### zrem\n\n> GEO没有提供删除成员的命令，但是因为GEO的底层实现是zset，所以可以借用zrem命令实现对地理位置信息的删除.\n\n```shell\n127.0.0.1:6379> geoadd china:city 116.23 40.22 beijin\n1\n127.0.0.1:6379> zrange china:city 0 -1 # 查看全部的元素\n重庆\n西安\n深圳\n武汉\n杭州\n上海\nbeijin\n北京\n127.0.0.1:6379> zrem china:city beijin  # 移除元素\n1\n127.0.0.1:6379> zrem china:city 北京 # 移除元素\n1\n127.0.0.1:6379> zrange china:city 0 -1\n重庆\n西安\n深圳\n武汉\n杭州\n上海\n```\n\n## HyperLogLog\n\n### 简介\n\nRedis 在 2.8.9 版本添加了 HyperLogLog 结构。\n\nRedis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积 非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。\n\n在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。\n\n> HyperLogLog则是一种算法，它提供了不精确的去重计数方案。举个栗子：假如我要统计网页的UV（浏览用户数量，一天内同一个用户多次访问只能算一次），传统的解决方案是使用Set来保存用户id，然后统计Set中的元素数量来获取页面UV。但这种方案只能承载少量用户，一旦用户数量大起来就需要消耗大量的空间来存储用户id。我的目的是统计用户数量而不是保存用户，这简直是个吃力不讨好的方案！而使用Redis的HyperLogLog最多需要12k就可以统计大量的用户数，尽管它大概有0.81%的错误率，但对于统计UV这种不需要很精确的数据是可以忽略不计的。\n\n### 什么是基数？\n\n> 比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为 5 。基数估计就是在误差可接受的范围内，快速计算基数。\n\n### 基本命令\n\n|  命令   | 描述  |\n|  ----  | ----  |\n| [PFADD key element [element...]  | 添加指定元素到 HyperLogLog 中。 |\n| [PFCOUNT key [key...]  | 返回给定 HyperLogLog 的基数估算值。 |\n|[PFMERGE destkey sourcekey[sourcekey...]  | 将多个 HyperLogLog 合并为一个 HyperLogLog，并集计算 |\n\n### 测试\n\n```\n127.0.0.1: 6379 > PFADD mykey a b c d e f g h i j\n1\n127.0.0.1: 6379 > PFCOUNT mykey\n10\n127.0.0.1: 6379 > PFADD mykey2 i j z x c v b n m\n1\n127.0.0.1: 6379 > PFMERGE mykey3 mykey mykey2\nOK\n127.0.0.1: 6379 > PFCOUNT mykey3\n15\n```\n\n## BitMap\n\n> 简介\n\n> 在开发中，可能会遇到这种情况：需要统计用户的某些信息，如活跃或不活跃，登录或者不登录；又如需要记录用户一年的打卡情况，打卡了是 1 ， 没有打卡是 0 ，如果使用普通的 key/value存储，则要记录365 条记录，如果用户量很大，需要的空间也会很大，所以 Redis 提供了 Bitmap 位图这中数据结构，Bitmap 就是通过操作二进制位来进行记录，即为 0 和 1 ；如果要记录 365 天的打卡情况，使用 Bitmap表示的形式大概如下：0101000111000111...........................，这样有什么好处呢？当然就是节约内存了， 365 天相当于 365 bit，又 1 字节 = 8 bit , 所以相当于使用 46 个字节即可。\n\n> BitMap 就是通过一个 bit 位来表示某个元素对应的值或者状态, 其中的 key 就是对应元素本身，实际上底层也是通过对字符串的操作来实现。Redis 从 2.2 版本之后新增了setbit, getbit, bitcount 等几个bitmap 相关命令。\n\n### setbit 设置操作\n\nSETBIT key offset value : 设置 key 的第 offset 位为value (1或0)\n\n```shell\n# 使用 bitmap 来记录上述事例中一周的打卡记录如下所示：\n# 周一： 1 ，周二： 0 ，周三： 0 ，周四： 1 ，周五： 1 ，周六： 0 ，周天： 0 （ 1 为打卡， 0 为不打卡）\n127.0.0.1:6379> setbit sign 0 1\n0\n127.0.0.1:6379> setbit sign 1 0\n0\n127.0.0.1:6379> setbit sign 2 0\n0\n127.0.0.1:6379> setbit sign 3 1\n0\n127.0.0.1:6379> setbit sign 4 1\n0\n127.0.0.1:6379> setbit sign 5 0\n0\n127.0.0.1:6379> setbit sign 6 0\n0\n```\n\n### getbit 获取操作\n\nGETBIT key offset 获取offset设置的值，未设置过默认返回 0\n\n```shell\n127.0.0.1:6379> getbit sign 3 # 查看周四是否打卡\n1\n127.0.0.1:6379> getbit sign 6 # 查看周七是否打卡\n0\n```\n\n### bitcount 统计操作\n\nbitcount key [start, end] 统计 key 上位为 1 的个数\n\n```\n127.0.0.1:6379> bitcount sign\n3\n```\n\n# Redis事务\n\n## 理论\n\n### Redis事务的概念：\n\n> Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。\n\n总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。\n**Redis事务没有隔离级别的概念：**\n\n批量操作在发送 EXEC 命令前被放入队列缓存，并不会被实际执行！\n\n**Redis不保证原子性：**\n\nRedis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。\n\n**Redis事务的三个阶段：**\n\n* 开始事务\n* 命令入队\n* 执行事务\n\n### Redis事务相关命令：\n\n```\nwatch key1 key2...  #监视一或多个key,如果在事务执行之前，被监视的key被其他命令改动，则\n事务被打断 （ 类似乐观锁 ）\nmulti # 标记一个事务块的开始（ queued ）\nexec # 执行所有事务块的命令 （ 一旦执行exec后，之前加的监控锁都会被取消掉 ）\ndiscard # 取消事务，放弃事务块中的所有命令\nunwatch # 取消watch对所有key的监控\n```\n\n## 实践\n\n### 正常执行\n\n![输入图片说明](redis/QQ截图20210927112345.png \"QQ截图20201229183512.png\")\n\n### 放弃事务\n\n![输入图片说明](redis/QQ截图20210927112358.png \"QQ截图20201229183512.png\")\n\n若在事务队列中存在命令性错误（类似于java编译性错误），则执行EXEC命令时，所有命令都不会执行\n![输入图片说明](redis/QQ截图20210927112441.png \"QQ截图20201229183512.png\")\n\n若在事务队列中存在语法性错误（类似于java的1/0的运行时异常），则执行EXEC命令时，其他正确命令会被执行，错误命令抛出异常。\n\n![输入图片说明](redis/QQ截图20210927112511.png \"QQ截图20201229183512.png\")\n\n## Watch 监控\n\n### 悲观锁：\n\n> 悲观锁(Pessimistic Lock),顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿到这个数据就会block直到它拿到锁。传统的关系型数据库里面就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在操作之前先上锁。\n\n### 乐观锁：\n\n> 乐观锁(Optimistic Lock),顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁。但是在更新的时候会判断一下再此期间别人有没有去更新这个数据，可以使用版本号等机制，乐观锁适用于多读的应用类型，这样可以提高吞吐量，乐观锁策略：提交版本必须大于记录当前版本才能执行更新。\n\n### 测试：\n\n* 1 、初始化信用卡可用余额和欠额\n\n```\n127.0.0.1:6379> set balance 100\nOK\n127.0.0.1:6379> set debt 0\nOK\n```\n\n* 2 、使用watch检测balance，事务期间balance数据未变动，事务执行成功\n\n```\n127.0.0.1:6379> watch balance\nOK\n127.0.0.1:6379> MULTI\nOK\n127.0.0.1:6379> decrby balance 20\nQUEUED\n127.0.0.1:6379> incrby debt 20\nQUEUED\n127.0.0.1:6379> exec\n1 ) (integer) 80\n2 ) (integer) 20\n```\n\n* 3 、使用watch检测balance，事务期间balance数据变动，事务执行失败！\n\n```shell\n#### # 窗口一\n127.0.0.1:6379> watch balance\nOK\n127.0.0.1:6379> MULTI  # 执行完毕后，执行窗口二代码测试\nOK\n127.0.0.1:6379> decrby balance 20\nQUEUED\n127.0.0.1:6379> incrby debt 20\nQUEUED\n127.0.0.1:6379> exec  # 修改失败！\n(nil)\n\n# 窗口二\n127.0.0.1:6379> get balance\n\"80\"\n127.0.0.1:6379> set balance 200\nOK\n\n# 窗口一：出现问题后放弃监视，然后重来！\n127.0.0.1:6379> UNWATCH  # 放弃监视\nOK\n127.0.0.1:6379> watch balance\nOK\n127.0.0.1:6379> MULTI\nOK\n127.0.0.1:6379> decrby balance 20\nQUEUED\n127.0.0.1:6379> incrby debt 20\n```\n\n### 说明：\n\n一但执行 EXEC 开启事务的执行后，无论事务使用执行成功， WARCH 对变量的监控都将被取消。故当事务执行失败后，需重新执行WATCH命令对变量进行监控，并开启新的事务进行操作。\n\n## 小结\n\nwatch指令类似于乐观锁，在事务提交时，如果watch监控的多个KEY中任何KEY的值已经被其他客户端更改，则使用EXEC执行事务时，事务队列将不会被执行，同时返回Nullmulti-bulk应答以通知调用者事务执行失败。\n\n# Jedis\n\n> Jedis是Redis官方推荐的Java连接开发工具。要在Java开发中使用好Redis中间件，必须对Jedis熟悉才能写成漂亮的代码\n\n## 测试联通\n\n* 1 、新建一个普通的Maven项目\n* 2 、导入redis的依赖！\n\n```xml\n<!-- https://mvnrepository.com/artifact/redis.clients/jedis -->\n<dependency>\n    <groupId>redis.clients</groupId>\n    <artifactId>jedis</artifactId>\n    <version>3.2.0</version>\n</dependency>\n<dependency>\n<groupId>com.alibaba</groupId>\n<artifactId>fastjson</artifactId>\n<version>1.2.58</version>\n</dependency>\n```\n\n* 3 、编写测试代码\n\n```java\npackage com.kuang.ping;\n\nimport redis.clients.jedis.Jedis;\n\npublic class Ping {\n    public static void main(String[] args) {\n        Jedis jedis = new Jedis(\"127.0.0.1\", 6379);\n        System.out.println(\"连接成功\");\n        //查看服务是否运行\n        System.out.println(\"服务正在运行: \" + jedis.ping());\n    }\n}\n*4 、启动redis服务\n        *5 、启动测试，结果\n        ```shell\n        连接成功\n        服务正在运行:PONG\n```\n\n## 常用API\n\n### 基本操作\n\n```java\npublic class TestPassword {\n    public static void main(String[] args) {\n        Jedis jedis = new Jedis(\"127.0.0.1\", 6379);\n\n        //验证密码，如果没有设置密码这段代码省略\n        // jedis.auth(\"password\");\n\n        jedis.connect(); //连接\n        jedis.disconnect(); //断开连接\n\n        jedis.flushAll(); //清空所有的key\n    }\n}\n```\n\n### 对key操作的命令\n\n```java\npublic class TestKey {\n    public static void main(String[] args) {\n        Jedis jedis = new Jedis(\"127.0.0.1\", 6379);\n\n        System.out.println(\"清空数据：\" + jedis.flushDB());\n        System.out.println(\"判断某个键是否存在：\" + jedis.exists(\"username\"));\n        System.out.println(\"新增<'username','kuangshen'>的键值对：\" + jedis.set(\"username\", \"kuangshen\"));\n        System.out.println(\"新增<'password','password'>的键值对：\" + jedis.set(\"password\", \"password\"));\n        System.out.print(\"系统中所有的键如下：\");\n        Set<String> keys = jedis.keys(\"*\");\n        System.out.println(keys);\n        System.out.println(\"删除键password:\" + jedis.del(\"password\"));\n        System.out.println(\"判断键password是否存在：\" + jedis.exists(\"password\"));\n        System.out.println(\"查看键username所存储的值的类型：\" + jedis.type(\"username\"));\n        System.out.println(\"随机返回key空间的一个：\" + jedis.randomKey());\n        System.out.println(\"重命名key：\" + jedis.rename(\"username\", \"name\"));\n        System.out.println(\"取出改后的name：\" + jedis.get(\"name\"));\n        System.out.println(\"按索引查询：\" + jedis.select(0));\n        System.out.println(\"删除当前选择数据库中的所有key：\" + jedis.flushDB());\n        System.out.println(\"返回当前数据库中key的数目：\" + jedis.dbSize());\n        System.out.println(\"删除所有数据库中的所有key：\" + jedis.flushAll());\n    }\n}\n```\n\n### 对String操作的命令\n\n```java\npublic class TestString {\n    public static void main(String[] args) {\n        Jedis jedis = new Jedis(\"127.0.0.1\", 6379);\n\n        jedis.flushDB();\n        System.out.println(\"===========增加数据===========\");\n        System.out.println(jedis.set(\"key1\", \"value1\"));\n        System.out.println(jedis.set(\"key2\", \"value2\"));\n        System.out.println(jedis.set(\"key3\", \"value3\"));\n\n        System.out.println(\"删除键key2:\" + jedis.del(\"key2\"));\n        System.out.println(\"获取键key2:\" + jedis.get(\"key2\"));\n        System.out.println(\"修改key1:\" + jedis.set(\"key1\", \"value1Changed\"));\n        System.out.println(\"获取key1的值：\" + jedis.get(\"key1\"));\n        System.out.println(\"在key3后面加入值：\" + jedis.append(\"key3\", \"End\"));\n        System.out.println(\"key3的值：\" + jedis.get(\"key3\"));\n        System.out.println(\"增加多个键值对：\" + jedis.mset(\"key01\", \"value01\", \"key02\", \"value02\", \"key03\", \"value03\"));\n        System.out.println(\"获取多个键值对：\" + jedis.mget(\"key01\", \"key02\", \"key03\"));\n        System.out.println(\"获取多个键值对：\" + jedis.mget(\"key01\", \"key02\", \"key03\", \"key04\"));\n        System.out.println(\"删除多个键值对：\" + jedis.del(\"key01\", \"key02\"));\n        System.out.println(\"获取多个键值对：\" + jedis.mget(\"key01\", \"key02\", \"key03\"));\n\n        jedis.flushDB();\n        System.out.println(\"===========新增键值对防止覆盖原先值==============\");\n        System.out.println(jedis.setnx(\"key1\", \"value1\"));\n        System.out.println(jedis.setnx(\"key2\", \"value2\"));\n        System.out.println(jedis.setnx(\"key2\", \"value2-new\"));\n        System.out.println(jedis.get(\"key1\"));\n        System.out.println(jedis.get(\"key2\"));\n\n        System.out.println(\"===========新增键值对并设置有效时间=============\");\n        System.out.println(jedis.setex(\"key3\", 2, \"value3\"));\n        System.out.println(jedis.get(\"key3\"));\n        try {\n            TimeUnit.SECONDS.sleep(3);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(jedis.get(\"key3\"));\n\n        System.out.println(\"===========获取原值，更新为新值==========\");\n        System.out.println(jedis.getSet(\"key2\", \"key2GetSet\"));\n        System.out.println(jedis.get(\"key2\"));\n\n        System.out.println(\"获得key2的值的字串：\" + jedis.getrange(\"key2\", 2, 4));\n    }\n}\n```\n\n### 对List操作命令\n\n```java\npublic class TestList {\n    public static void main(String[] args) {\n        Jedis jedis = new Jedis(\"127.0.0.1\", 6379);\n        jedis.flushDB();\n        System.out.println(\"===========添加一个list===========\");\n        jedis.lpush(\"collections\", \"ArrayList\", \"Vector\", \"Stack\", \"HashMap\", \"WeakHashMap\", \"LinkedHashMap\");\n        jedis.lpush(\"collections\", \"HashSet\");\n        jedis.lpush(\"collections\", \"TreeSet\");\n        jedis.lpush(\"collections\", \"TreeMap\");\n        System.out.println(\"collections的内容：\" + jedis.lrange(\"collections\", 0, -1));//-1代表倒数第一个元素，-2代表倒数第二个元素,end为-1表示查询全部\n\n        System.out.println(\"collections区间0-3的元素：\" + jedis.lrange(\"collections\", 0, 3));\n        System.out.println(\"===============================\");\n        // 删除列表指定的值 ，第二个参数为删除的个数（有重复时），后add进去的值先被删，类似于出栈\n        System.out.println(\"删除指定元素个数：\" + jedis.lrem(\"collections\", 2, \"HashMap\"));\n        System.out.println(\"collections的内容：\" + jedis.lrange(\"collections\", 0, -1));\n        System.out.println(\"删除下表0-3区间之外的元素：\" + jedis.ltrim(\"collections\", 0, 3));\n        System.out.println(\"collections的内容：\" + jedis.lrange(\"collections\", 0, -1));\n        System.out.println(\"collections列表出栈（左端）：\" + jedis.lpop(\"collections\"));\n        System.out.println(\"collections的内容：\" + jedis.lrange(\"collections\", 0, -1));\n        System.out.println(\"collections添加元素，从列表右端，与lpush相对应：\" + jedis.rpush(\"collections\", \"EnumMap\"));\n        System.out.println(\"collections的内容：\" + jedis.lrange(\"collections\", 0, -1));\n        System.out.println(\"collections列表出栈（右端）：\" + jedis.rpop(\"collections\"));\n        System.out.println(\"collections的内容：\" + jedis.lrange(\"collections\", 0, -1));\n        System.out.println(\"修改collections指定下标 1 的内容：\" + jedis.lset(\"collections\", 1, \"LinkedArrayList\"));\n        System.out.println(\"collections的内容：\" + jedis.lrange(\"collections\", 0, -1));\n        System.out.println(\"===============================\");\n        System.out.println(\"collections的长度：\" + jedis.llen(\"collections\"));\n        System.out.println(\"获取collections下标为 2 的元素：\" + jedis.lindex(\"collections\", 2));\n        System.out.println(\"===============================\");\n        jedis.lpush(\"sortedList\", \"3\", \"6\", \"2\", \"0\", \"7\", \"4\");\n        System.out.println(\"sortedList排序前：\" + jedis.lrange(\"sortedList\", 0, -1));\n        System.out.println(jedis.sort(\"sortedList\"));\n        System.out.println(\"sortedList排序后：\" + jedis.lrange(\"sortedList\", 0, -1));\n    }\n}\n```\n\n### 对Set的操作命令\n\n```java\npublic class TestSet {\n    public static void main(String[] args) {\n        Jedis jedis = new Jedis(\"127.0.0.1\", 6379);\n        jedis.flushDB();\n        System.out.println(\"============向集合中添加元素（不重复）============\");\n        System.out.println(jedis.sadd(\"eleSet\", \"e1\", \"e2\", \"e4\", \"e3\", \"e0\", \"e8\", \"e7\", \"e5\"));\n        System.out.println(jedis.sadd(\"eleSet\", \"e6\"));\n        System.out.println(jedis.sadd(\"eleSet\", \"e6\"));\n        System.out.println(\"eleSet的所有元素为：\" + jedis.smembers(\"eleSet\"));\n        System.out.println(\"删除一个元素e0：\" + jedis.srem(\"eleSet\", \"e0\"));\n\n        System.out.println(\"eleSet的所有元素为：\" + jedis.smembers(\"eleSet\"));\n        System.out.println(\"删除两个元素e7和e6：\" + jedis.srem(\"eleSet\", \"e7\", \"e6\"));\n        System.out.println(\"eleSet的所有元素为：\" + jedis.smembers(\"eleSet\"));\n        System.out.println(\"随机的移除集合中的一个元素：\" + jedis.spop(\"eleSet\"));\n        System.out.println(\"随机的移除集合中的一个元素：\" + jedis.spop(\"eleSet\"));\n        System.out.println(\"eleSet的所有元素为：\" + jedis.smembers(\"eleSet\"));\n        System.out.println(\"eleSet中包含元素的个数：\" + jedis.scard(\"eleSet\"));\n        System.out.println(\"e3是否在eleSet中：\" + jedis.sismember(\"eleSet\", \"e3\"));\n        System.out.println(\"e1是否在eleSet中：\" + jedis.sismember(\"eleSet\", \"e1\"));\n        System.out.println(\"e1是否在eleSet中：\" + jedis.sismember(\"eleSet\", \"e5\"));\n        System.out.println(\"=================================\");\n        System.out.println(jedis.sadd(\"eleSet1\", \"e1\", \"e2\", \"e4\", \"e3\", \"e0\", \"e8\", \"e7\", \"e5\"));\n        System.out.println(jedis.sadd(\"eleSet2\", \"e1\", \"e2\", \"e4\", \"e3\", \"e0\", \"e8\"));\n        System.out.println(\"将eleSet1中删除e1并存入eleSet3中：\" + jedis.smove(\"eleSet1\", \"eleSet3\", \"e1\"));//移到集合元素\n        System.out.println(\"将eleSet1中删除e2并存入eleSet3中：\" + jedis.smove(\"eleSet1\", \"eleSet3\", \"e2\"));\n        System.out.println(\"eleSet1中的元素：\" + jedis.smembers(\"eleSet1\"));\n        System.out.println(\"eleSet3中的元素：\" + jedis.smembers(\"eleSet3\"));\n        System.out.println(\"============集合运算=================\");\n        System.out.println(\"eleSet1中的元素：\" + jedis.smembers(\"eleSet1\"));\n        System.out.println(\"eleSet2中的元素：\" + jedis.smembers(\"eleSet2\"));\n        System.out.println(\"eleSet1和eleSet2的交集:\" + jedis.sinter(\"eleSet1\", \"eleSet2\"));\n        System.out.println(\"eleSet1和eleSet2的并集:\" + jedis.sunion(\"eleSet1\", \"eleSet2\"));\n        System.out.println(\"eleSet1和eleSet2的差集:\" + jedis.sdiff(\"eleSet1\", \"eleSet2\"));//eleSet1中有，eleSet2中没有\n        jedis.sinterstore(\"eleSet4\", \"eleSet1\", \"eleSet2\");//求交集并将交集保存到dstkey的集合\n        System.out.println(\"eleSet4中的元素：\" + jedis.smembers(\"eleSet4\"));\n    }\n}\n```\n\n### 对Hash的操作命令\n\n```java\npublic class TestHash {\n    public static void main(String[] args) {\n        Jedis jedis = new Jedis(\"127.0.0.1\", 6379);\n        jedis.flushDB();\n        Map<String, String> map = new HashMap<>();\n        map.put(\"key1\", \"value1\");\n        map.put(\"key2\", \"value2\");\n        map.put(\"key3\", \"value3\");\n        map.put(\"key4\", \"value4\");\n        //添加名称为hash（key）的hash元素\n        jedis.hmset(\"hash\", map);\n        //向名称为hash的hash中添加key为key5，value为value5元素\n        jedis.hset(\"hash\", \"key5\", \"value5\");\n        System.out.println(\"散列hash的所有键值对为：\" + jedis.hgetAll(\"hash\"));//return Map<String,String>\n\n        System.out.println(\"散列hash的所有键为：\" + jedis.hkeys(\"hash\"));//return\n        Set<String>\n        System.out.println(\"散列hash的所有值为：\" + jedis.hvals(\"hash\"));//return\n        List<String>\n        System.out.println(\"将key6保存的值加上一个整数，如果key6不存在则添加key6：\" + jedis.hincrBy(\"hash\", \"key6\", 6));\n        System.out.println(\"散列hash的所有键值对为：\" + jedis.hgetAll(\"hash\"));\n        System.out.println(\"将key6保存的值加上一个整数，如果key6不存在则添加key6：\" + jedis.hincrBy(\"hash\", \"key6\", 3));\n        System.out.println(\"散列hash的所有键值对为：\" + jedis.hgetAll(\"hash\"));\n        System.out.println(\"删除一个或者多个键值对：\" + jedis.hdel(\"hash\", \"key2\"));\n        System.out.println(\"散列hash的所有键值对为：\" + jedis.hgetAll(\"hash\"));\n        System.out.println(\"散列hash中键值对的个数：\" + jedis.hlen(\"hash\"));\n        System.out.println(\"判断hash中是否存在key2：\" + jedis.hexists(\"hash\", \"key2\"));\n        System.out.println(\"判断hash中是否存在key3：\" + jedis.hexists(\"hash\", \"key3\"));\n        System.out.println(\"获取hash中的值：\" + jedis.hmget(\"hash\", \"key3\"));\n        System.out.println(\"获取hash中的值：\" + jedis.hmget(\"hash\", \"key3\", \"key4\"));\n    }\n}\n```\n\n## 事务\n\n### 基本操作\n\n```java\npackage com.kuang.multi;\n\nimport com.alibaba.fastjson.JSONObject;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.Transaction;\n\npublic class TestMulti {\n    public static void main(String[] args) {\n        //创建客户端连接服务端，redis服务端需要被开启\n        Jedis jedis = new Jedis(\"127.0.0.1\", 6379);\n        jedis.flushDB();\n\n        JSONObject jsonObject = new JSONObject();\n        jsonObject.put(\"hello\", \"world\");\n        jsonObject.put(\"name\", \"java\");\n        //开启事务\n        Transaction multi = jedis.multi();\n        String result = jsonObject.toJSONString();\n        try {\n            //向redis存入一条数据\n            multi.set(\"json\", result);\n            //再存入一条数据\n            multi.set(\"json2\", result);\n            //这里引发了异常，用 0 作为被除数\n            int i = 100 / 0;\n            //如果没有引发异常，执行进入队列的命令\n            multi.exec();\n        } catch (Exception e) {\n            e.printStackTrace();\n            //如果出现异常，回滚\n            multi.discard();\n        } finally {\n            System.out.println(jedis.get(\"json\"));\n            System.out.println(jedis.get(\"json2\"));\n            //最终关闭客户端\n            jedis.close();\n        }\n    }\n}\n```\n\n# SpringBoot整合\n\n## 基础使用\n\n### 概述\n\n> 在SpringBoot中一般使用RedisTemplate提供的方法来操作Redis。那么使用SpringBoot整合Redis需要那些步骤呢。\n\n* 1 、 JedisPoolConfig (这个是配置连接池)\n* 2 、 RedisConnectionFactory 这个是配置连接信息，这里的RedisConnectionFactory是一个接口，我们需要使用它的实现类，在SpringD Data Redis方案中提供了以下四种工厂模型：\n    * JredisConnectionFactory\n    * JedisConnectionFactory\n    * LettuceConnectionFactory\n    * SrpConnectionFactory\n* 3 、 RedisTemplate 基本操作\n\n### 导入依赖\n\n```xml\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n```\n\n### yaml配置\n\n```yml\nspring:\n  redis:\n    host: 127.0.0.1\n    port: 6379\n    password: 123456\n    jedis:\n      pool:\n        max-active: 8\n        max-wait: -1ms\n        max-idle: 500\n        min-idle: 0\n    lettuce:\n    shutdown-timeout: 0ms\n```\n\n### 测试\n\n```java\n\n@SpringBootTest\nclass SpringbootRedisApplicationTests {\n\n    @Autowired\n    private RedisTemplate<String, String> redisTemplate;\n\n    @Test\n    void contextLoads() {\n        redisTemplate.opsForValue().set(\"myKey\", \"myValue\");\n        System.out.println(redisTemplate.opsForValue().get(\"myKey\"));\n    }\n}\n```\n\n## 封装工具类\n\n* 1 、新建一个SpringBoot项目\n* 2 、导入redis的启动器\n\n```xml\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n```\n\n* 3 、配置redis，可以查看 RedisProperties 分析\n\n```yml\n# Redis服务器地址\nspring.redis.host=127.0.0.1\n  # Redis服务器连接端口\nspring.redis.port= 6379\n```\n\n* 4 、分析 RedisAutoConfiguration 自动配置类\n\n```java\n\n@Configuration(proxyBeanMethods = false)\n@ConditionalOnClass(RedisOperations.class)\n@EnableConfigurationProperties(RedisProperties.class)\n@Import({LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class})\npublic class RedisAutoConfiguration {\n\n\n    @Bean\n    @ConditionalOnMissingBean(name = \"redisTemplate\")\n    public RedisTemplate<Object, Object>\n    redisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException {\n        RedisTemplate<Object, Object> template = new RedisTemplate<>();\n        template.setConnectionFactory(redisConnectionFactory);\n        return template;\n    }\n\n    @Bean\n    @ConditionalOnMissingBean\n    public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException {\n        StringRedisTemplate template = new StringRedisTemplate();\n        template.setConnectionFactory(redisConnectionFactory);\n        return template;\n    }\n}\n```\n\n> 通过源码可以看出，SpringBoot自动帮我们在容器中生成了一个RedisTemplate和一个StringRedisTemplate。\n\n> 但是，这个RedisTemplate的泛型是<Object,Object>，写代码不方便，需要写好多类型转换的代码；我们需要一个泛型为<String,Object>形式的RedisTemplate。\n\n> 并且，这个RedisTemplate没有设置数据存在Redis时，key及value的序列化方式。\n\n> 看到这个@ConditionalOnMissingBean注解后，就知道如果Spring容器中有了RedisTemplate对象了，这个自动配置的RedisTemplate不会实例化。因此我们可以直接自己写个配置类，配置RedisTemplate。\n\n* 5 、既然自动配置不好用，就重新配置一个RedisTemplate\n\n```java\npackage com.kuang.config;\n\nimport com.fasterxml.jackson.annotation.JsonAutoDetect;\nimport com.fasterxml.jackson.annotation.PropertyAccessor;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\n\n@Configuration\npublic class RedisConfig {\n\n    @Bean\n    @SuppressWarnings(\"all\")\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {\n        RedisTemplate<String, Object> template = new RedisTemplate<String, Object>();\n        template.setConnectionFactory(factory);\n        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new\n                Jackson2JsonRedisSerializer(Object.class);\n        ObjectMapper om = new ObjectMapper();\n        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n        jackson2JsonRedisSerializer.setObjectMapper(om);\n        StringRedisSerializer stringRedisSerializer = new\n                StringRedisSerializer();\n\n        // key采用String的序列化方式\n        template.setKeySerializer(stringRedisSerializer);\n        // hash的key也采用String的序列化方式\n        template.setHashKeySerializer(stringRedisSerializer);\n        // value序列化方式采用jackson\n        template.setValueSerializer(jackson2JsonRedisSerializer);\n        // hash的value序列化方式采用jackson\n        template.setHashValueSerializer(jackson2JsonRedisSerializer);\n        template.afterPropertiesSet();\n        return template;\n    }\n}\n```\n\n* 6 、写一个Redis工具类（直接用RedisTemplate操作Redis，需要很多行代码，因此直接封装好一个RedisUtils，这样写代码更方便点。这个RedisUtils交给Spring容器实例化，使用时直接注解注入。）\n\n```java\npackage com.kuang.utils;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.stereotype.Component;\nimport org.springframework.util.CollectionUtils;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.TimeUnit;\n\n@Component\npublic final class RedisUtil {\n\n    @Autowired\n    private RedisTemplate<String, Object> redisTemplate;\n// =============================common============================\n\n    /**\n     * 指定缓存失效时间\n     * @param key 键\n     * @param time 时间(秒)\n     */\n    public boolean expire(String key, long time) {\n        try {\n            if (time > 0) {\n                redisTemplate.expire(key, time, TimeUnit.SECONDS);\n            }\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    /**\n     * 根据key 获取过期时间\n     * @param key 键 不能为null\n     * @return 时间(秒) 返回 0 代表为永久有效\n     */\n    public long getExpire(String key) {\n        return redisTemplate.getExpire(key, TimeUnit.SECONDS);\n    }\n\n    /**\n     * 判断key是否存在\n     * @param key 键\n     * @return true 存在 false不存在\n     */\n    public boolean hasKey(String key) {\n        try {\n            return redisTemplate.hasKey(key);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    /**\n     * 删除缓存\n     * @param key 可以传一个值 或多个\n     */\n    @SuppressWarnings(\"unchecked\")\n    public void del(String... key) {\n        if (key != null && key.length > 0) {\n            if (key.length == 1) {\n                redisTemplate.delete(key[0]);\n            } else {\n                redisTemplate.delete(CollectionUtils.arrayToList(key));\n            }\n        }\n    }\n// ============================String=============================\n\n    /**\n     * 普通缓存获取\n     * @param key 键\n     * @return 值\n     */\n    public Object get(String key) {\n        return key == null ? null : redisTemplate.opsForValue().get(key);\n    }\n\n    /**\n     * 普通缓存放入\n     * @param key 键\n     * @param value 值\n     * @return true成功 false失败\n     */\n    public boolean set(String key, Object value) {\n        try {\n            redisTemplate.opsForValue().set(key, value);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    /**\n     普通缓存放入并设置时间\n     * @param key 键\n     * @param value 值\n     * @param time 时间(秒) time要大于 0 如果time小于等于 0 将设置无限期\n     * @return true成功 false 失败\n     */\n    public boolean set(String key, Object value, long time) {\n        try {\n            if (time > 0) {\n                redisTemplate.opsForValue().set(key, value, time,\n                        TimeUnit.SECONDS);\n            } else {\n                set(key, value);\n            }\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    /**\n     递增\n     * @param key 键\n     * @param delta 要增加几(大于0)\n     */\n    public long incr(String key, long delta) {\n        if (delta < 0) {\n            throw new RuntimeException(\"递增因子必须大于0\");\n        }\n        return redisTemplate.opsForValue().increment(key, delta);\n    }\n\n    /**\n     * 递减\n     * @param key 键\n     * @param delta 要减少几(小于0)\n     */\n    public long decr(String key, long delta) {\n        if (delta < 0) {\n            throw new RuntimeException(\"递减因子必须大于0\");\n        }\n        return redisTemplate.opsForValue().increment(key, -delta);\n    }\n\n// ================================Map=================================\n\n    /**\n     * HashGet\n     * @param key 键 不能为null\n     * @param item 项 不能为null\n     */\n    public Object hget(String key, String item) {\n        return redisTemplate.opsForHash().get(key, item);\n    }\n\n    /**\n     * 获取hashKey对应的所有键值\n     * @param key 键\n     * @return 对应的多个键值\n     */\n    public Map<Object, Object> hmget(String key) {\n        return redisTemplate.opsForHash().entries(key);\n    }\n\n    /**\n     * HashSet\n     * @param key 键\n     * @param map 对应多个键值\n     */\n    public boolean hmset(String key, Map<String, Object> map) {\n        try {\n            redisTemplate.opsForHash().putAll(key, map);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    /**\n     * HashSet 并设置时间\n     * @param key 键\n     * @param map 对应多个键值\n     * @param time 时间(秒)\n     * @return true成功 false失败\n     */\n    public boolean hmset(String key, Map<String, Object> map, long time) {\n        try {\n            redisTemplate.opsForHash().putAll(key, map);\n            if (time > 0) {\n                expire(key, time);\n            }\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    /**\n     * 向一张hash表中放入数据,如果不存在将创建\n     *\n     * @param key 键\n     * @param item 项\n     * @param value 值\n     * @return true 成功 false失败\n     */\n    public boolean hset(String key, String item, Object value) {\n        try {\n            redisTemplate.opsForHash().put(key, item, value);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    /**\n     * 向一张hash表中放入数据,如果不存在将创建\n     *\n     * @param key 键\n     * @param item 项\n     * @param value 值\n     * @param time 时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间\n     * @return true 成功 false失败\n     */\n    public boolean hset(String key, String item, Object value, long time) {\n        try {\n            redisTemplate.opsForHash().put(key, item, value);\n            if (time > 0) {\n                expire(key, time);\n            }\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    /**\n     * 删除hash表中的值\n     *\n     * @param key 键 不能为null\n     * @param item 项 可以使多个 不能为null\n     */\n    public void hdel(String key, Object... item) {\n        redisTemplate.opsForHash().delete(key, item);\n    }\n\n    /**\n     * 判断hash表中是否有该项的值\n     *\n     * @param key 键 不能为null\n     * @param item 项 不能为null\n     * @return true 存在 false不存在\n     */\n    public boolean hHasKey(String key, String item) {\n        return redisTemplate.opsForHash().hasKey(key, item);\n    }\n\n    /**\n     * hash递增 如果不存在,就会创建一个 并把新增后的值返回\n     *\n     * @param key 键\n     * @param item 项\n     * @param by 要增加几(大于0)\n     */\n    public double hincr(String key, String item, double by) {\n        return redisTemplate.opsForHash().increment(key, item, by);\n    }\n\n    /**\n     * hash递减\n     *\n     * @param key 键\n     * @param item 项\n     * @param by 要减少记(小于0)\n     */\n    public double hdecr(String key, String item, double by) {\n        return redisTemplate.opsForHash().increment(key, item, -by);\n    }\n// ============================set=============================\n\n    /**\n     * 根据key获取Set中的所有值\n     * @param key 键\n     */\n    public Set<Object> sGet(String key) {\n        try {\n            return redisTemplate.opsForSet().members(key);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    /**\n     * 根据value从一个set中查询,是否存在\n     *\n     * @param key 键\n     * @param value 值\n     * @return true 存在 false不存在\n     */\n    public boolean sHasKey(String key, Object value) {\n        try {\n            return redisTemplate.opsForSet().isMember(key, value);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    /**\n     * 将数据放入set缓存\n     *\n     * @param key 键\n     * @param values 值 可以是多个\n     * @return 成功个数\n     */\n    public long sSet(String key, Object... values) {\n        try {\n            return redisTemplate.opsForSet().add(key, values);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return 0;\n        }\n    }\n\n    /**\n     * 将set数据放入缓存\n     *\n     * @param key 键\n     * @param time 时间(秒)\n     * @param values 值 可以是多个\n     * @return 成功个数\n     */\n    public long sSetAndTime(String key, long time, Object... values) {\n        try {\n            Long count = redisTemplate.opsForSet().add(key, values);\n            if (time > 0)\n                expire(key, time);\n            return count;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return 0;\n        }\n    }\n\n    /**\n     * 获取set缓存的长度\n     * @param key 键\n     */\n    public long sGetSetSize(String key) {\n        try {\n            return redisTemplate.opsForSet().size(key);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return 0;\n        }\n    }\n\n    /**\n     * 移除值为value的\n     *\n     * @param key 键\n     * @param values 值 可以是多个\n     * @return 移除的个数\n     */\n\n    public long setRemove(String key, Object... values) {\n        try {\n            Long count = redisTemplate.opsForSet().remove(key, values);\n            return count;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return 0;\n        }\n    }\n// ===============================list=================================\n\n    /**\n     * 获取list缓存的内容\n     *\n     * @param key 键\n     * @param start 开始\n     * @param end 结束 0 到 -1代表所有值\n     */\n    public List<Object> lGet(String key, long start, long end) {\n        try {\n            return redisTemplate.opsForList().range(key, start, end);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    /**\n     * 获取list缓存的长度\n     *\n     * @param key 键\n     */\n    public long lGetListSize(String key) {\n        try {\n            return redisTemplate.opsForList().size(key);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return 0;\n        }\n    }\n\n    /**\n     * 通过索引 获取list中的值\n     *\n     * @param key 键\n     * @param index 索引 index>=0时， 0 表头， 1 第二个元素，依次类推；index<0\n    时，-1，表尾，-2倒数第二个元素，依次类推\n     */\n    public Object lGetIndex(String key, long index) {\n        try {\n            return redisTemplate.opsForList().index(key, index);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    /**\n     * 将list放入缓存\n     *\n     * @param key 键\n     * @param value 值\n     */\n    public boolean lSet(String key, Object value) {\n        try {\n            redisTemplate.opsForList().rightPush(key, value);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    /**\n     * 将list放入缓存\n     * @param key 键\n     * @param value 值\n     * @param time 时间(秒)\n     */\n    public boolean lSet(String key, Object value, long time) {\n        try {\n            redisTemplate.opsForList().rightPush(key, value);\n            if (time > 0)\n                expire(key, time);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    /**\n     * 将list放入缓存\n     *\n     * @param key 键\n     * @param value 值\n     * @return\n     */\n    public boolean lSet(String key, List<Object> value) {\n        try {\n            redisTemplate.opsForList().rightPushAll(key, value);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    /**\n     * 将list放入缓存\n     *\n     * @param key 键\n     * @param value 值\n     * @param time 时间(秒)\n     * @return\n     */\n    public boolean lSet(String key, List<Object> value, long time) {\n        try {\n            redisTemplate.opsForList().rightPushAll(key, value);\n            if (time > 0)\n                expire(key, time);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    /**\n     * 根据索引修改list中的某条数据\n     *\n     * @param key 键\n     * @param index 索引\n     * @param value 值\n     * @return\n     */\n    public boolean lUpdateIndex(String key, long index, Object value) {\n        try {\n            redisTemplate.opsForList().set(key, index, value);\n            ren true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    /**\n     * 移除N个值为value\n     *\n     * @param key 键\n     * @param count 移除多少个\n     * @param value 值\n     * @return 移除的个数\n     */\n    public long lRemove(String key, long count, Object value) {\n        try {\n            Long remove = redisTemplate.opsForList().remove(key, count, value);\n            return remove;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return 0;\n        }\n    }\n}\n```\n\n# Redis.conf\n\n## 熟悉基本配置\n\n> 位置\n\nRedis 的配置文件位于 Redis 安装目录下，文件名为 redis.conf\n\n```shell\nconfig get *  # 获取全部的配置\n```\n\n配置文件的地址：\n![输入图片说明](redis/QQ截图20210927102035.png \"QQ截图20201229183512.png\")\n\n我们一般情况下，会单独拷贝出来一份进行操作。来保证初始文件的安全。\n\n### Units 单位\n\n![输入图片说明](redis/QQ截图20210927102059.png \"QQ截图20201229183512.png\")\n\n* 1 、配置大小单位，开头定义了一些基本的度量单位，只支持bytes，不支持bit\n* 2 、对 大小写 不敏感\n\n### INCLUDES 包含\n\n和Spring配置文件类似，可以通过includes包含，redis.conf 可以作为总文件，可以包含其他文件！\n\n### NETWORK 网络配置\n\n```\nbind 127.0.0.1  # 绑定的ip\nprotected-mode yes # 保护模式\nport 6379 # 默认端口\n```\n\n### GENERAL 通用\n\n```\ndaemonize yes # 默认情况下，Redis不作为守护进程运行。需要开启的话，改为 yes\n\nsupervised no  # 可通过upstart和systemd管理Redis守护进程\n\npidfile /var/run/redis_6379.pid  # 以后台进程方式运行redis，则需要指定pid 文件\n\nloglevel notice # 日志级别。可选项有：\n# debug（记录大量日志信息，适用于开发、测试阶段）；\n# verbose（较多日志信息）；\n# notice（适量日志信息，使用于生产环境）；\n# warning（仅有部分重要、关键信息才会被记录）。\n\nlogfile \"\" # 日志文件的位置，当指定为空字符串时，为标准输出\ndatabases 16 # 设置数据库的数目。默认的数据库是DB 0\nalways-show-logo yes # 是否总是显示logo\n```\n\n### SNAPSHOPTING 快照\n\n```\n# 900秒（ 15 分钟）内至少 1 个key值改变（则进行数据库保存--持久化）\nsave 900 1\n# 300秒（ 5 分钟）内至少 10 个key值改变（则进行数据库保存--持久化）\nsave 300 10\n# 60秒（ 1 分钟）内至少 10000 个key值改变（则进行数据库保存--持久化）\nsave 60 10000\n\nstop-writes-on-bgsave-error yes # 持久化出现错误后，是否依然进行继续进行工作\n\nrdbcompression yes # 使用压缩rdb文件 yes：压缩，但是需要一些cpu的消耗。no：不压\n缩，需要更多的磁盘空间\n\nrdbchecksum yes # 是否校验rdb文件，更有利于文件的容错性，但是在保存rdb文件的时\n候，会有大概10%的性能损耗\n\ndbfilename dump.rdb  # dbfilenamerdb文件名称\n\ndir./  # dir 数据目录，数据库的写入会在这个目录。rdb、aof文件也会写在这个目录\n```\n\n### REPLICATION 复制 我们后面讲主从复制再给大家讲解！这里先跳过！\n\n### SECURITY安全\n\n访问密码的查看，设置和取消\n\n```\n# 启动redis\n# 连接客户端\n\n# 获得和设置密码\nconfig get requirepass\nconfig set requirepass \"123456\"\n\n#测试ping，发现需要验证\n127.0.0.1:6379> ping\nNOAUTH Authentication required.\n# 验证\n127.0.0.1:6379> auth 123456\nOK\n127.0.0.1:6379> ping\nPONG\n```\n\n### 限制\n\n```\nmaxclients 10000 # 设置能连上redis的最大客户端连接数量\nmaxmemory <bytes> # redis配置的最大内存容量\nmaxmemory-policy noeviction # maxmemory-policy 内存达到上限的处理策略\n#volatile-lru：利用LRU算法移除设置过过期时间的key。\n#volatile-random：随机移除设置过过期时间的key。\n#volatile-ttl：移除即将过期的key，根据最近过期时间来删除（辅以TTL）\n#allkeys-lru：利用LRU算法移除任何key。\n#allkeys-random：随机移除任何key。\n#noeviction：不移除任何key，只是返回一个写错误。\n```\n\n### append only模式\n\n```\nappendonly no # 是否以append only模式作为持久化方式，默认使用的是rdb方式持久化，这种\n方式在许多应用中已经足够用了\nappendfilename \"appendonly.aof\" # appendfilename AOF 文件名称\nappendfsync everysec  # appendfsync aof持久化策略的配置\n# no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快。\n# always表示每次写入都执行fsync，以保证数据同步到磁盘。\n# everysec表示每秒执行一次fsync，可能会导致丢失这1s数据。\n```\n\n具体的我们会在后面讲解Redis的持久化配置的时候进行讲解！先了解下，听个耳音！\n\n## 常见配置介绍\n\n1 、Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程\n\n> daemonize no\n\n2 、当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定\n\n> pidfile /var/run/redis.pid\n\n3 、指定Redis监听端口，默认端口为 6379 ，作者在自己的一篇博文中解释了为什么选用 6379 作为默认端口，因为 6379 在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字\n\n> port 6379\n\n4 、绑定的主机地址\n\n> bind 127.0.0.1\n\n5 、当 客户端闲置多长时间后关闭连接，如果指定为 0 ，表示关闭该功能\n\n> timeout 300\n\n6 、指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose\n\n> loglevel verbose\n\n7 、日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null\n> logfile stdout\n\n8 、设置数据库的数量，默认数据库为 0 ，可以使用SELECT 命令在连接上指定数据库id\n\n> databases 16\n\n9 、指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合\n\n> save Redis默认配置文件中提供了三个条件： save 900 1 save 300 10 save 60 10000 分别表示 900 秒（ 15 分钟）内有 1 个更改， 300 秒（ 5 分钟）内有 10 个更改以及 60 秒内有 10000 个更改。\n\n10 、指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大\n\n> rdbcompression yes\n\n11 、指定本地数据库文件名，默认值为dump.rdb\n\n> dbfilename dump.rdb\n\n12 、指定本地数据库存放目录\n\n> dir./\n\n13 、设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步\n\n> slaveof\n\n14 、当master服务设置了密码保护时，slav服务连接master的密码\n\n> masterauth\n\n15 、设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH 命令提供密码，默认关闭\n\n> requirepass foobared\n\n16 、设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients\n0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息\n\n> maxclients 128\n\n17 、指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理\n后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区\n\n> maxmemory\n\n18 、指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为\nredis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no\n\n> appendonly no\n\n19 、指定更新日志文件名，默认为appendonly.aof\n\n> appendfilename appendonly.aof\n\n20 、指定更新日志条件，共有 3 个可选值：\n\n> no：表示等操作系统进行数据缓存同步到磁盘（快）<br>\nalways：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）<br>\neverysec：表示每秒同步一次（折衷，默认值）<br>\nappendfsync everysec<br>\n\n21 、指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制）\n\n> vm-enabled no\n\n22 、虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享\n\n> vm-swap-file /tmp/redis.swap\n\n23 、将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为 0\n的时候,其实是所有value都存在于磁盘。默认值为 0\n\n> vm-max-memory 0\n\n24 、Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为 32\n或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值\n\n> vm-page-size 32\n\n25 、设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每 8 个pages将消耗1byte的内存。\n\n> vm-pages 134217728\n\n26 、设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为 4\n\n> vm-max-threads 4\n\n27 、设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启\n\n> glueoutputbuf yes\n\n28 、指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法\n\n> hash-max-zipmap-entries 64<br>\nhash-max-zipmap-value 512\n\n29 、指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍）\n\n> activerehashing yes\n\n> 30 、指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件\n\n> include /path/to/local.conf\n\n# Redis的持久化\n\n> Redis 是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以 Redis 提供了持久化功能！\n\n## RDB（Redis DataBase）\n\n### 什么是RDB\n\n> 在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。\n\n\n> Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。\n\n### Fork\n\n> Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量，环境变量，程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。\n\n**Rdb 保存的是 dump.rdb 文件**\n\n![输入图片说明](redis/QQ截图20210927110129.png \"QQ截图20201229183512.png\")\n\n### 配置位置及SNAPSHOTTING解析\n\n![输入图片说明](redis/QQ截图20210927110152.png \"QQ截图20201229183512.png\")\n\n### 这里的触发条件机制，我们可以修改测试一下：\n\n```\nsave 120 10 # 120秒内修改 10 次则触发RDB\n```\n\nRDB 是整合内存的压缩过的Snapshot，RDB 的数据结构，可以配置复合的快照触发条件。 默认：\n\n* 1 分钟内改了 1 万次\n* 5 分钟内改了 10 次\n* 15 分钟内改了 1 次\n\n如果想禁用RDB持久化的策略，只要不设置任何save指令，或者给save传入一个空字符串参数也可以。若要修改完毕需要立马生效，可以手动使用 save 命令！立马生效!\n\n### 其余命令解析\n\nStop-writes-on-bgsave-error：如果配置为no，表示你不在乎数据不一致或者有其他的手段发现和控制，默认为yes。\n\nrbdcompression：对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩，如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能。\n\nrdbchecksum：在存储快照后，还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。默认为yes。\n\n### 如何触发RDB快照\n\n* 1 、配置文件中默认的快照配置，建议多用一台机子作为备份，复制一份 dump.rdb\n* 2 、命令save或者是bgsave\n    * save 时只管保存，其他不管，全部阻塞\n    * bgsave，Redis 会在后台异步进行快照操作，快照同时还可以响应客户端请求。可以通过lastsave命令获取最后一次成功执行快照的时间。\n\n* 3 、执行flushall命令，也会产生 dump.rdb 文件，但里面是空的，无意义!\n* 4 、退出的时候也会产生 dump.rdb 文件！\n\n### 如何恢复\n\n* 1 、将备份文件（dump.rdb）移动到redis安装目录并启动服务即可\n* 2 、CONFIG GET dir 获取目录\n\n```\n127.0.0.1:6379> config get dir\ndir\n/usr/local/bin\n```\n\n### 优点和缺点\n\n### 优点：\n\n* 1 、适合大规模的数据恢复\n* 2 、对数据完整性和一致性要求不高\n\n### 缺点：\n\n* 1 、在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改\n* 2 、Fork的时候，内存中的数据被克隆了一份，大致 2 倍的膨胀性需要考虑。\n\n### 小结\n\n![输入图片说明](redis/QQ截图20210927111622.png \"QQ截图20201229183512.png\")\n\n## AOF（Append Only File）\n\n> 是什么\n\n> 以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作\n\n`Aof保存的是 appendonly.aof 文件`\n\n### 配置\n\n![输入图片说明](redis/QQ截图20210927111724.png \"QQ截图20201229183512.png\")\n\n```shell\nappendonly no # 是否以append only模式作为持久化方式，默认使用的是rdb方式持久化，这\n种方式在许多应用中已经足够用了\n\nappendfilename \"appendonly.aof\" # appendfilename AOF 文件名称\n\nappendfsync everysec  # appendfsync aof持久化策略的配置\n# no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快。\n# always表示每次写入都执行fsync，以保证数据同步到磁盘。\n# everysec表示每秒执行一次fsync，可能会导致丢失这1s数据。\n\nNo-appendfsync-on-rewrite #重写时是否可以运用Appendfsync，用默认no即可，保证数据安\n全性\n\nAuto-aof-rewrite-min-size # 设置重写的基准值\n\nAuto-aof-rewrite-percentage #设置重写的基准值\n```\n\n### AOF 启动/修复/恢复\n\n正常恢复：\n\n* 启动：设置Yes，修改默认的appendonly no，改为yes\n* 将有数据的aof文件复制一份保存到对应目录（config get dir）\n* 恢复：重启redis然后重新加载\n\n异常恢复：\n\n* 启动：设置Yes\n* 故意破坏 appendonly.aof 文件！\n* 修复： redis-check-aof --fix appendonly.aof 进行修复\n* 恢复：重启 redis 然后重新加载\n\n### Rewrite\n\n是什么：\n\n\n> AOF 采用文件追加方式，文件会越来越大，为避免出现此种情况，新增了重写机制，当AOF文件的大小超过所设定的阈值时，Redis 就会启动AOF 文件的内容压缩，只保留可以恢复数据的最小指令集，可以使用命令 bgrewriteaof ！\n\n### 重写原理：\n\n> AOF 文件持续增长而过大时，会fork出一条新进程来将文件重写（也是先写临时文件最后再rename），遍历新进程的内存中数据，每条记录有一条的Set语句。重写aof文件的操作，并没有读取旧的aof文件，这点和快照有点类似！\n\n### 触发机制：\n\n> Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的已被且文件大于64M的触发。\n\n`行家一出手，就只有没有，内行看门道，外行看热闹`\n\n### 优点和缺点\n\n### 优点：\n\n* 1 、每修改同步：appendfsync always 同步持久化，每次发生数据变更会被立即记录到磁盘，性能较差但数据完整性比较好\n* 2 、每秒同步： appendfsync everysec 异步操作，每秒记录 ，如果一秒内宕机，有数据丢失\n* 3 、不同步： appendfsync no 从不同步\n\n### 缺点：\n\n* 1 、相同数据集的数据而言，aof 文件要远大于 rdb文件，恢复速度慢于 rdb。\n* 2 、Aof 运行效率要慢于 rdb，每秒同步策略效率较好，不同步效率和rdb相同。\n\n### 小总结\n\n![输入图片说明](redis/QQ截图20210927112007.png \"QQ截图20201229183512.png\")\n\n## 总结\n\n* 1 、RDB 持久化方式能够在指定的时间间隔内对你的数据进行快照存储\n* 2 、AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以Redis 协议追加保存每次写的操作到文件末尾，Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大。\n* 3 、只做缓存，如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化\n* 4 、同时开启两种持久化方式\n    * 在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。\n    * RDB\n      的数据不实时，同时使用两者时服务器重启也只会找AOF文件，那要不要只使用AOF呢？作者建议不要，因为RDB更适合用于备份数据库（AOF在不断变化不好备份），快速重启，而且不会有AOF可能潜在的Bug，留着作为一个万一的手段。\n* 5 、性能建议\n\n    * 因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要 15 分钟备份一次就够了，只保留 save 900 1 这条规则。\n    * 如果Enable AOF ，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了，代价一是带来了持续的IO，二是AOF rewrite 的最后将 rewrite\n      过程中产生的新数据写到新文件 造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重写可以改到适当的数值。\n    * 如果不Enable AOF ，仅靠 Master-Slave Repllcation 实现高可用性也可以，能省掉一大笔IO，也减少了rewrite时带来的系统波动。代价是如果Master/Slave\n      同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个 Master/Slave 中的 RDB文件，载入较新的那个，微博就是这种架构。\n\n\n# Redis 发布订阅\n\n是什么\n\n* Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。\n* Redis 客户端可以订阅任意数量的频道。\n\n订阅/发布消息图：\n\n![输入图片说明](redis/QQ截图20210927113113.png \"QQ截图20201229183512.png\")\n\n下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的\n\n![输入图片说明](redis/QQ截图20210927113126.png \"QQ截图20201229183512.png\")\n\n当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：\n\n![输入图片说明](redis/QQ截图20210927113242.png \"QQ截图20201229183512.png\")\n\n### 命令\n\n这些命令被广泛用于构建即时通信应用，比如网络聊天室(chatroom)和实时广播、实时提醒等。\n\n![输入图片说明](redis/QQ截图20210927113307.png \"QQ截图20201229183512.png\")\n\n### 测试\n\n以下实例演示了发布订阅是如何工作的。在我们实例中我们创建了订阅频道名为 redisChat :\n\n```shell\nredis 127.0.0.1:6379> SUBSCRIBE redisChat\n\nReading messages... (press Ctrl-C to quit)\n1 ) \"subscribe\"\n2 ) \"redisChat\"\n3 ) (integer) 1\n```\n\n现在，我们先重新开启个 redis 客户端，然后在同一个频道 redisChat 发布两次消息，订阅者就能接收到消息。\n\n```shell\nredis 127.0.0.1:6379> PUBLISH redisChat \"Hello,Redis\"\n(integer) 1\nredis 127.0.0.1:6379> PUBLISH redisChat \"Hello，Kuangshen\"\n(integer) 1\n\n# 订阅者的客户端会显示如下消息\n1 ) \"message\"\n2 ) \"redisChat\"\n3 ) \"Hello,Redis\"\n1 ) \"message\"\n2 ) \"redisChat\"\n3 ) \"Hello，Kuangshen\"\n```\n\n### 原理\n\n> Redis是使用C实现的，通过分析 Redis 源码里的 pubsub.c 文件，了解发布和订阅机制的底层实现，籍此加深对 Redis 的理解。\n\n> Redis 通过 PUBLISH 、SUBSCRIBE 和 PSUBSCRIBE 等命令实现发布和订阅功能。通过 SUBSCRIBE 命令订阅某频道后，redis-server 里维护了一个字典，字典的键就是一个个 channel，而字典的值则是一个链表，链表中保存了所有订阅这个 channel 的客户端。SUBSCRIBE 命令的关键，就是将客户端添加到给定 channel 的订阅链表中。\n\n> 通过 PUBLISH 命令向订阅者发送消息，redis-server 会使用给定的频道作为键，在它所维护的 channel字典中查找记录了订阅这个频道的所有客户端的链表，遍历这个链表，将消息发布给所有订阅者。\n\n> Pub/Sub 从字面上理解就是发布（Publish）与订阅（Subscribe），在Redis中，你可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。\n\n### 使用场景\n\n> Pub/Sub构建实时消息系统\n\n> Redis的Pub/Sub系统可以构建实时的消息系统\n\n> 比如很多用Pub/Sub构建的实时聊天系统的例子。\n\n# Redis主从复制\n\n## 概念\n\n> 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master/leader)，后者称为从节点(slave/follower)；数据的复制是单向的，只能由主节点到从节点。Master以写为主，Slave 以读为主。\n\n> 默认情况下，每台Redis服务器都是主节点；且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。\n\n主从复制的作用主要包括：\n\n* 1 、数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。\n* 2 、故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。\n* 3\n  、负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。\n* 4 、高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。\n\n一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的，原因如下：\n\n* 1 、从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大；\n* 2 、从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存容量为256G，也不能将所有内存用作Redis存储内存，一般来说，单台Redis最大使用内存不应该超过20G。\n  电商网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是\"多读少写\"。 对于这种场景，我们可以使如下这种架构：\n\n![输入图片说明](redis/QQ截图20210927113849.png \"QQ截图20201229183512.png\")\n\n## 环境配置\n\n基本配置\n\n配从库不配主库，从库配置：\n\n```\nslaveof 主库ip 主库端口 # 配置主从\ninfo replication # 查看信息\n```\n\n每次与 master 断开之后，都需要重新连接，除非你配置进 redis.conf 文件！\n\n### 修改配置文件！\n\n准备工作：我们配置主从复制，至少需要三个，一主二从！配置三个客户端！\n\n![输入图片说明](redis/QQ截图20210927113948.png \"QQ截图20201229183512.png\")\n\n* 1 、拷贝多个redis.conf 文件\n\n  ![输入图片说明](redis/QQ截图20210927114022.png \"QQ截图20201229183512.png\")\n\n* 2 、指定端口 6379 ，依次类推\n* 3 、开启daemonize yes\n* 4 、Pid文件名字 pidfile /var/run/redis_6379.pid , 依次类推\n* 5 、Log文件名字 logfile \"6379.log\" , 依次类推\n* 6 、Dump.rdb 名字 dbfilename dump6379.rdb , 依次类推\n\n  ![输入图片说明](redis/QQ截图20210927114130.png \"QQ截图20201229183512.png\")\n\n### 上面都配置完毕后， 3 个服务通过 3 个不同的配置文件开启，我们的准备环境就OK 了！\n\n![输入图片说明](redis/QQ截图20210927114141.png \"QQ截图20201229183512.png\")\n\n## 一主二从\n\n一主二仆\n\n* 1 、环境初始化\n\n  ![输入图片说明](redis/QQ截图20210928085838.png \"QQ截图20201229183512.png\")\n\n默认三个都是Master 主节点\n\n![输入图片说明](redis/QQ截图20210928085902.png \"QQ截图20201229183512.png\")\n\n* 2 、配置为一个Master 两个Slave\n\n  ![输入图片说明](redis/QQ截图20210928085902.png \"QQ截图20201229183512.png\")\n\n* 3 、在主机设置值，在从机都可以取到！从机不能写值！\n\n  ![输入图片说明](redis/QQ截图20210928085936.png \"QQ截图20201229183512.png\")\n\n测试一：主机挂了，查看从机信息，主机恢复，再次查看信息\n\n测试二：从机挂了，查看主机信息，从机恢复，查看从机信息\n\n### 层层链路\n\n> 上一个Slave 可以是下一个slave 和 Master，Slave 同样可以接收其他 slaves 的连接和同步请求，那么该 slave 作为了链条中下一个的master，可以有效减轻 master 的写压力！\n\n![输入图片说明](redis/QQ截图20210928090032.png \"QQ截图20201229183512.png\")\n\n### 测试： 6379 设置值以后 6380 和 6381 都可以获取到！OK！\n\n### 谋朝篡位\n\n> 一主二从的情况下，如果主机断了，从机可以使用命令 SLAVEOF NO ONE 将自己改为主机！这个时候其余的从机链接到这个节点。对一个从属服务器执行命令 SLAVEOF NO ONE 将使得这个从属服务器关闭复制功能，并从从属服务器转变回主服务器，原来同步所得的数据集不会被丢弃。\n\n![输入图片说明](redis/QQ截图20210928090112.png \"QQ截图20201229183512.png\")\n\n主机再回来，也只是一个光杆司令了，从机为了正常使用跑到了新的主机上！\n\n### 复制原理\n\n> Slave 启动成功连接到 master 后会发送一个sync命令Master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。增量复制：Master 继续将新的所有收集到的修改命令依次传给slave，完成同步但是只要是重新连接master，一次完全同步（全量复制）将被自动执行\n\n## 哨兵模式\n\n概述\n\n> 主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。Redis从2.8开始正式提供了Sentinel（哨兵） 架构来解决这个问题。谋朝篡位的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是 **哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。**\n\n![输入图片说明](redis/QQ截图20210928090249.png \"QQ截图20201229183512.png\")\n\n这里的哨兵有两个作用\n\n* 通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。\n* 当哨兵监测到master宕机，会自动将slave切换成master，然后通过 发布订阅模式 通知其他的从服务器，修改配置文件，让它们切换主机。\n\n> 然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。\n\n![输入图片说明](redis/QQ截图20210928090331.png \"QQ截图20201229183512.png\")\n\n> 假设主服务器宕机，哨兵 1 先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵 1 主观的认为主服务器不可用，这个现象成为 主观下线 。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover[故障转移]操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为客观下线 。\n\n### 配置测试\n\n* 1 、调整结构， 6379 带着 80 、 81\n* 2 、自定义的 /myredis 目录下新建 sentinel.conf 文件，名字千万不要错\n* 3 、配置哨兵，填写内容\n    * sentinel monitor 被监控主机名字 127.0.0.1 6379 1\n    * 上面最后一个数字 1 ，表示主机挂掉后slave投票看让谁接替成为主机，得票数多少后成为主机\n* 4 、启动哨兵\n    * Redis-sentinel /myredis/sentinel.conf\n    * 上述目录依照各自的实际情况配置，可能目录不同\n* 5 、正常主从演示\n* 6 、原有的Master 挂了\n* 7 、投票新选\n* 8 、重新主从继续开工，info replication 查查看\n* 9 、问题：如果之前的master 重启回来，会不会双master 冲突？ 之前的回来只能做小弟了\n\n### 哨兵模式的优缺点\n\n### 优点\n\n*\n    1. 哨兵集群模式是基于主从模式的，所有主从的优点，哨兵模式同样具有。\n*\n    2. 主从可以切换，故障可以转移，系统可用性更好。\n*\n    3. 哨兵模式是主从模式的升级，系统更健壮，可用性更高。\n\n### 缺点\n\n*\n    1. Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。\n*\n    2. 实现哨兵模式的配置也不简单，甚至可以说有些繁琐\n\n### 哨兵配置说明\n\n```shell\n# Example sentinel.conf\n\n# 哨兵sentinel实例运行的端口 默认 26379\nport 26379\n\n# 哨兵sentinel的工作目录\ndir /tmp\n\n# 哨兵sentinel监控的redis主节点的 ip port\n# master-name 可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符\".-_\"组成。\n# quorum 配置多少个sentinel哨兵统一认为master主节点失联 那么这时客观上认为主节点失联了\n# sentinel monitor <master-name> <ip> <redis-port> <quorum>\nsentinel monitor mymaster 127.0.0.1 6379 2\n\n# 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都\n要提供密码\n# 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码\n# sentinel auth-pass <master-name> <password>\nsentinel auth-pass mymaster MySUPER--secret-0123passw0rd\n\n# 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认 30 秒\n# sentinel down-after-milliseconds <master-name> <milliseconds>\nsentinel down-after-milliseconds mymaster 30000\n\n# 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，这个数字越小，完成failover所需的时间就越长，但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。\n# sentinel parallel-syncs <master-name> <numslaves>\nsentinel parallel-syncs mymaster 1\n\n# 故障转移的超时时间 failover-timeout 可以用在以下这些方面：\n#1. 同一个sentinel对同一个master两次failover之间的间隔时间。\n#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。\n#3.当想要取消一个正在进行的failover所需要的时间。\n#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了\n# 默认三分钟\n# sentinel failover-timeout <master-name> <milliseconds>\nsentinel failover-timeout mymaster 180000\n\n# SCRIPTS EXECUTION\n\n#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。\n#对于脚本的运行结果有以下规则：\n#若脚本执行后返回 1 ，那么该脚本稍后将会被再次执行，重复次数目前默认为 10\n#若脚本执行后返回 2 ，或者比 2 更高的一个返回值，脚本将不会重复执行。\n#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为 1 时的行为相同。\n#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。\n\n#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。\n#通知脚本\n# sentinel notification-script <master-name> <script-path>\nsentinel notification-script mymaster /var/redis/notify.sh\n\n# 客户端重新配置主节点参数脚本\n# 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。\n# 以下参数将会在调用脚本时传给脚本:\n# <master-name> <role> <state> <from-ip> <from-port> <to-ip> <to-port>\n# 目前<state>总是“failover”,\n# <role>是“leader”或者“observer”中的一个。\n# 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的\n# sentinel client-reconfig-script <master-name> <script-path>\nsentinel client-reconfig-script mymaster /var/redis/reconfig.sh\n```\n\n# 缓存穿透和雪崩\n\n> Redis缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询方面。但同时，它也带来了一些问题。其中，最要害的问题，就是数据的一致性问题，从严格意义上讲，这个问题无解。如果对数据的一致性要求很高，那么就不能使用缓存。\n\n> 另外的一些典型问题就是，缓存穿透、缓存雪崩和缓存击穿。目前，业界也都有比较流行的解决方案。\n\n## 缓存穿透\n\n### 概念\n\n> 缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中，于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。\n\n### 解决方案\n\n### 布隆过滤器\n\n> 布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力；\n\n![输入图片说明](redis/QQ截图20210928090903.png \"QQ截图20201229183512.png\")\n\n### 缓存空对象\n\n> 当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源；\n\n![输入图片说明](redis/QQ截图20210928090930.png \"QQ截图20201229183512.png\")\n\n### 但是这种方法会存在两个问题：\n\n* 1 、如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键；\n* 2 、即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。\n\n## 缓存击穿\n\n### 概述\n\n> 这里需要注意和缓存击穿的区别，缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。\n\n> 当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大。\n\n### 解决方案\n\n### 设置热点数据永不过期\n\n从缓存层面来看，没有设置过期时间，所以不会出现热点 key 过期后产生的问题。\n\n### 加互斥锁\n\n分布式锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。\n\n## 缓存雪崩\n\n### 概念\n\n缓存雪崩，是指在某一个时间段，缓存集中过期失效。\n\n> 产生雪崩的原因之一，比如在写本文的时候，马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。\n\n![输入图片说明](redis/QQ截图20210928091310.png \"QQ截图20201229183512.png\")\n\n> 其实集中过期，倒不是非常致命，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网。因为自然形成的缓存雪崩，一定是在某个时间段集中创建缓存，这个时候，数据库也是可以顶住压力的。无非就是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间就把数据库压垮。\n\n### 解决方案\n\n### redis高可用\n\n> 这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。\n\n### 限流降级\n\n> 这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。\n\n### 数据预热\n\n> 数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。\n","slug":"redis","published":1,"updated":"2022-07-21T01:59:01.371Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5w7e73y000bigvuemp7fr3g","content":"<h1 id=\"NoSQL概述\"><a href=\"#NoSQL概述\" class=\"headerlink\" title=\"NoSQL概述\"></a>NoSQL概述</h1><h2 id=\"为什么用NoSQL\"><a href=\"#为什么用NoSQL\" class=\"headerlink\" title=\"为什么用NoSQL\"></a>为什么用NoSQL</h2><blockquote>\n<p>1 、单机MySQL的美好年代</p>\n</blockquote>\n<p>在 90 年代，一个网站的访问量一般不大，用单个数据库完全可以轻松 在那个时候，更多的都是静态网页，动态交互类型的网站不多。</p>\n<p>上述架构下，我们来看看数据存储的瓶颈是什么？</p>\n<p>*<br>    1. 数据量的总大小，一个机器放*<br>    *<br>        2. 数据的索引（B+ Tree）一个机器的内存放*<br>        *<br>            3. 访问量（读写混合）一个实例不能承受</p>\n<p>如果满足了上述 1 or 3个，进化. DAL：数据库访问层</p>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210922100205.png\" class title=\"输入图片说明\">\n<blockquote>\n<p>2 、Memcached（缓存）+ MySQL + 垂直拆分</p>\n</blockquote>\n<blockquote>\n<p>后来，随着访问量的上升，几乎大部分使用MySQL架构的网站在数据库上都开始出现了性能问题，web 程序不再仅仅专注在功能上，同时也在追求性能。程序猿们开始大量使用缓存技术来缓解数据库的压 力，优化数据库的结构和索引，开始比较流行的是通过文件缓存来缓解数据库压力，但是当访问量继续 增大的时候，多台web机器通过文件缓存不能共享，大量的小文件缓存也带了比较高的IO压力，在这个 时候，Memcached就自然的成为一个非常时尚的技术产品。</p>\n</blockquote>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210922100407.png\" class title=\"输入图片说明\">\n<blockquote>\n<p>3 、MySQL主从读写分离</p>\n</blockquote>\n<blockquote>\n<p>由于数据库的写入压力增加，Memcached只能缓解数据库的读取压力，读写集中在一个数据库上让数 据库不堪重负，大部分网站开始使用主从复制技术来达到读写分离，以提高读写性能和读库的可扩展 性，MySQL的master-slave模式成为这个时候的网站标配了。</p>\n</blockquote>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210924134715.png\" class title=\"输入图片说明\">\n\n<blockquote>\n<p>4 、分表分库 + 水平拆分 + Mysql 集群</p>\n</blockquote>\n<blockquote>\n<p>在Memcached的高速缓存，MySQL的主从复制，读写分离的基础之上，这时MySQL主库的写压力开始 出现瓶颈，而数据量的持续猛增，由于MyISAM使用表锁，在高并发下会出现严重的锁问题，大量的高 并发MySQL应用开始使用InnoDB引擎代替MyISAM。 同时，开始流行使用分表分库来缓解写压力和数据增长的扩展问题，这个时候，分表分库成了一个热门 技术，是面试的热门问题，也是业界讨论的热门技术问题。也就是在这个时候，MySQL推出了还不太稳 定的表分区，这也给技术实力一般的公司带来了希望。虽然MySQL推出了MySQL Cluster集群，但性能 也不能很好满足互联网的需求，只是在高可靠性上提供了非常大的保证。</p>\n</blockquote>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210924134937.png\" class title=\"输入图片说明\">\n\n<blockquote>\n<p>5 、MySQL 的扩展性瓶颈</p>\n</blockquote>\n<blockquote>\n<p>MySQL数据库也经常存储一些大文本的字段，导致数据库表非常的大，在做数据库恢复的时候就导致非 常的慢，不容易快速恢复数据库，比如 1000 万4KB大小的文本就接近40GB的大小，如果能把这些数据 从MySQL省去，MySQL将变的非常的小，关系数据库很强大，但是它并不能很好的应付所有的应用场 景，MySQL的扩展性差（需要复杂的技术来实现），大数据下IO压力大，表结构更改困难，正是当前使 用MySQL的开发人员面临的问题。</p>\n</blockquote>\n<blockquote>\n<p>6 、今天是什么样子？？</p>\n</blockquote>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210924135030.png\" class title=\"输入图片说明\">\n\n<blockquote>\n<p>7 、为什么用NoSQL？</p>\n</blockquote>\n<blockquote>\n<p>今天我们可以通过第三方平台（如：Google，FaceBook等）可以很容易的访问和抓取数据。用户的个 人信息，社交网络，地理位置，用户生成的数据和用户操作日志已经成倍的增加、我们如果要对这些用 户数据进行挖掘，那SQL数据库已经不适合这些应用了，而NoSQL数据库的发展却能很好的处理这些大 的数据！</p>\n</blockquote>\n<h2 id=\"什么是NoSQL\"><a href=\"#什么是NoSQL\" class=\"headerlink\" title=\"什么是NoSQL\"></a>什么是NoSQL</h2><blockquote>\n<p>NoSQL</p>\n</blockquote>\n<blockquote>\n<p>NoSQL = Not Only SQL，意思：不仅仅是SQL；</p>\n</blockquote>\n<blockquote>\n<p>泛指非关系型的数据库，随着互联网Web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别 是超大规模和高并发的社交网络服务类型的Web2.0纯动态网站已经显得力不从心，暴露了很多难以克服 的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展，NoSQL数据库的产生就是为 了解决大规模数据集合多种数据种类带来的挑战，尤其是大数据应用难题，包括超大规模数据的存储。 （例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模 式，无需多余操作就可以横向扩展。</p>\n</blockquote>\n<blockquote>\n<p>NoSQL的特点</p>\n</blockquote>\n<h3 id=\"1-、易扩展\"><a href=\"#1-、易扩展\" class=\"headerlink\" title=\"1 、易扩展\"></a>1 、易扩展</h3><blockquote>\n<p>NoSQL 数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。 数据之间无关系，这样就非常容易扩展，也无形之间，在架构的层面上带来了可扩展的能力。</p>\n</blockquote>\n<h3 id=\"2-、大数据量高性能\"><a href=\"#2-、大数据量高性能\" class=\"headerlink\" title=\"2 、大数据量高性能\"></a>2 、大数据量高性能</h3><blockquote>\n<p>NoSQL数据库都具有非常高的读写性能，尤其是在大数据量下，同样表现优秀。这得益于它的非关系 性，数据库的结构简单。</p>\n</blockquote>\n<blockquote>\n<p>一般MySQL使用Query Cache，每次表的更新Cache就失效，是一种大力度的Cache，在针对Web2.0的 交互频繁应用，Cache性能不高，而NoSQL的Cache是记录级的，是一种细粒度的Cache，所以NoSQL 在这个层面上来说就要性能高很多了。</p>\n</blockquote>\n<blockquote>\n<p>官方记录：Redis 一秒可以写 8 万次，读 11 万次！</p>\n</blockquote>\n<h3 id=\"3-、多样灵活的数据模型\"><a href=\"#3-、多样灵活的数据模型\" class=\"headerlink\" title=\"3 、多样灵活的数据模型\"></a>3 、多样灵活的数据模型</h3><blockquote>\n<p>NoSQL无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式，而在关系数据库里，增删 字段是一件非常麻烦的事情。如果是非常大数据量的表，增加字段简直就是噩梦。</p>\n</blockquote>\n<h3 id=\"4-、传统的RDBMS-VS-NoSQL\"><a href=\"#4-、传统的RDBMS-VS-NoSQL\" class=\"headerlink\" title=\"4 、传统的RDBMS VS NoSQL\"></a>4 、传统的RDBMS VS NoSQL</h3><img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210924135616.png\" class title=\"输入图片说明\">\n\n<blockquote>\n<p>拓展：3V+3高</p>\n</blockquote>\n<h3 id=\"大数据时代的3V-：-主要是对问题的描述\"><a href=\"#大数据时代的3V-：-主要是对问题的描述\" class=\"headerlink\" title=\"大数据时代的3V ： 主要是对问题的描述\"></a>大数据时代的3V ： 主要是对问题的描述</h3><ul>\n<li>海量 Volume</li>\n<li>多样 Variety</li>\n<li>实时 Velocity</li>\n</ul>\n<h3 id=\"互联网需求的-3-高-：-主要是对程序的要求\"><a href=\"#互联网需求的-3-高-：-主要是对程序的要求\" class=\"headerlink\" title=\"互联网需求的 3 高 ： 主要是对程序的要求\"></a>互联网需求的 3 高 ： 主要是对程序的要求</h3><ul>\n<li>高并发</li>\n<li>高可用</li>\n<li>高性能</li>\n</ul>\n<p><code>当下的应用是 SQL 和 NoSQL 一起使用，技术没有高低之分，就看你怎么用，对吧！</code></p>\n<h2 id=\"经典应用分析\"><a href=\"#经典应用分析\" class=\"headerlink\" title=\"经典应用分析\"></a>经典应用分析</h2><h3 id=\"聊聊阿里巴巴中文网站的商品信息如何存放，以女装、包包为例：\"><a href=\"#聊聊阿里巴巴中文网站的商品信息如何存放，以女装、包包为例：\" class=\"headerlink\" title=\"聊聊阿里巴巴中文网站的商品信息如何存放，以女装、包包为例：\"></a>聊聊阿里巴巴中文网站的商品信息如何存放，以女装、包包为例：</h3><img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210924135616.png\" class title=\"输入图片说明\">\n\n<h3 id=\"聊聊架构发展历程：推荐书籍《淘宝技术这十年》\"><a href=\"#聊聊架构发展历程：推荐书籍《淘宝技术这十年》\" class=\"headerlink\" title=\"聊聊架构发展历程：推荐书籍《淘宝技术这十年》\"></a>聊聊架构发展历程：推荐书籍《淘宝技术这十年》</h3><h3 id=\"1-、演变过程：以下图片资料来源：阿里巴巴中文站架构设计实践\"><a href=\"#1-、演变过程：以下图片资料来源：阿里巴巴中文站架构设计实践\" class=\"headerlink\" title=\"1 、演变过程：以下图片资料来源：阿里巴巴中文站架构设计实践\"></a>1 、演变过程：以下图片资料来源：阿里巴巴中文站架构设计实践</h3><img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210924135855.png\" class title=\"输入图片说明\">\n\n<h3 id=\"2-、第五代\"><a href=\"#2-、第五代\" class=\"headerlink\" title=\"2 、第五代\"></a>2 、第五代</h3><img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210924135915.png\" class title=\"输入图片说明\">\n\n<h3 id=\"3-、第-5-代架构使命\"><a href=\"#3-、第-5-代架构使命\" class=\"headerlink\" title=\"3 、第 5 代架构使命\"></a>3 、第 5 代架构使命</h3><img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210924135957.png\" class title=\"输入图片说明\">\n\n<h3 id=\"和我们相关的，多数据源多数据类型的存储问题\"><a href=\"#和我们相关的，多数据源多数据类型的存储问题\" class=\"headerlink\" title=\"和我们相关的，多数据源多数据类型的存储问题\"></a>和我们相关的，多数据源多数据类型的存储问题</h3><img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210924140055.png\" class title=\"输入图片说明\">\n\n<h3 id=\"1-、商品的基本信息\"><a href=\"#1-、商品的基本信息\" class=\"headerlink\" title=\"1 、商品的基本信息\"></a>1 、商品的基本信息</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">名称、价格、出厂日期、生产厂商等</span><br><span class=\"line\">关系型数据库：mysql、oracle目前淘宝在去O化（也即，拿掉Oracle）</span><br><span class=\"line\">注意，淘宝内部用的MySQL是里面的大牛自己改造过的。</span><br><span class=\"line\"></span><br><span class=\"line\">为什么去IOE：</span><br><span class=\"line\">2008 年,王坚博士加入阿里巴巴，成为首席架构师。把云计算植入阿里IT基因。</span><br><span class=\"line\">2013 年 5 月 17 日，阿里集团最后一台IBM小机在支付宝下线。这是自 2009 年“去IOE”战略透露以来，“去</span><br><span class=\"line\">IOE”非常重要的一个节点。“去 IOE”指的是摆脱掉IT部署中原有的IBM小型机、Oracle数据库以及EMC</span><br><span class=\"line\">存储的过度依赖。告别最后一台小机，意味着整个阿里集团尽管还有一些Oracle数据库和EMC存储，但是</span><br><span class=\"line\">IBM小型机已全部被替换。 2013 年 7 月 10 日，淘宝重中之重的广告系统使用的Oracle数据库下线，也是整</span><br><span class=\"line\">个淘宝最后一个 Oracle数据库。这两件事合在一起是阿里巴巴技术发展过程中的一个重要里程碑。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2、商品描述、详情、评价信息（多文字类）\"><a href=\"#2、商品描述、详情、评价信息（多文字类）\" class=\"headerlink\" title=\"2、商品描述、详情、评价信息（多文字类）\"></a>2、商品描述、详情、评价信息（多文字类）</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">多文字信息描述类，IO读写性能变差 </span><br><span class=\"line\">存在文档数据库MongDB中</span><br></pre></td></tr></table></figure>\n\n<p>3、商品的图片</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">商品图片展现类 </span><br><span class=\"line\">分布式文件系统中 </span><br><span class=\"line\">  - 淘宝自己的 TFS </span><br><span class=\"line\">  - Google的 GFS </span><br><span class=\"line\">  - Hadoop的 HDFS</span><br></pre></td></tr></table></figure>\n\n<p>4、商品的关键字</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">搜索引擎，淘宝内用 </span><br><span class=\"line\">ISearch：多隆一高兴一个人开发的 </span><br><span class=\"line\"></span><br><span class=\"line\">所有牛逼的人在牛逼之前,肯定有一段苦逼的岁月,但只要像傻逼一样的坚持,一定终将牛逼</span><br></pre></td></tr></table></figure>\n\n<p>5、商品的波段性的热点高频信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">内存数据库 </span><br><span class=\"line\">Tair、Redis、Memcache等</span><br></pre></td></tr></table></figure>\n\n<p>6、商品的交易，价格计算，积分累计！</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">外部系统，外部第三方支付接口 </span><br><span class=\"line\">支付宝</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>大型互联网应用（大数据，高并发，多样数据类型）的难点和解决方案<br><strong>难点：</strong></p>\n</blockquote>\n<ul>\n<li>数据类型的多样性</li>\n<li>数据源多样性和变化重构</li>\n<li>数据源改造而数据服务平台不需要大面积重构</li>\n</ul>\n<p><strong>解决办法：</strong></p>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210924140800.png\" class title=\"输入图片说明\">\n\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210924140819.png\" class title=\"输入图片说明\">\n\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210924140833.png\" class title=\"输入图片说明\">\n\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210924140847.png\" class title=\"输入图片说明\">\n\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210924140901.png\" class title=\"输入图片说明\">\n\n<h2 id=\"NoSQL数据模型简介\"><a href=\"#NoSQL数据模型简介\" class=\"headerlink\" title=\"NoSQL数据模型简介\"></a>NoSQL数据模型简介</h2><h3 id=\"案例设计\"><a href=\"#案例设计\" class=\"headerlink\" title=\"案例设计\"></a>案例设计</h3><p><code>以一个电商客户，订单，订购，地址模型来对比下关系型数据库和非关系型数据库</code></p>\n<p><strong>传统的关系型数据库你如何设计？</strong></p>\n<h3 id=\"ER图（1-1-1-N-N-N-主外键等常见）\"><a href=\"#ER图（1-1-1-N-N-N-主外键等常见）\" class=\"headerlink\" title=\"ER图（1:1/1:N/N:N,主外键等常见）\"></a>ER图（1:1/1:N/N:N,主外键等常见）</h3><ul>\n<li><p>用户对应多个订单多个地址</p>\n</li>\n<li><p>每个订单对应每个商品、价格、地址</p>\n</li>\n<li><p>每个商品对应产品</p>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210924141013.png\" class title=\"输入图片说明\"></li>\n</ul>\n<blockquote>\n<p>闲聊：用户画像分析，女人心是琢磨不透的，看了男装，剃须刀，根据她的信息找到她男朋友的生日就 在最近，后台画像已经分析完毕，准备推送广告了，结果她买了一个零食就走了~<br>90 后的程序员真的在一点点的改变生活中的点点滴滴，假设你有幸进入了大厂，你会发现周围的小伙伴 都在努力，真的就是那种可以在海底捞吃着吃着饭，突然就掏出笔记本写代码的那种，别人都以为他们 是疯子，只有他们自己内心才懂。这才是对技术的痴迷。</p>\n</blockquote>\n<h3 id=\"NoSQL你如何设计\"><a href=\"#NoSQL你如何设计\" class=\"headerlink\" title=\"NoSQL你如何设计\"></a>NoSQL你如何设计</h3><p>可以尝试使用 BSON 。</p>\n<p>BSON是一种类json的一种二进制形式的存储格式，简称Binary JSON，它和JSON一样，支持内嵌的文档</p>\n<p>对象和数组对象</p>\n<p>用BSon画出构建的数据模型</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;customer&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;id&quot;</span>: <span class=\"number\">1000</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;name&quot;</span>: <span class=\"string\">&quot;Z3&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;billingAddress&quot;</span>: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"attr\">&quot;city&quot;</span>: <span class=\"string\">&quot;beijing&quot;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"attr\">&quot;orders&quot;</span>: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"attr\">&quot;id&quot;</span>: <span class=\"number\">17</span>,</span><br><span class=\"line\">        <span class=\"attr\">&quot;customerId&quot;</span>: <span class=\"number\">1000</span>,</span><br><span class=\"line\">        <span class=\"attr\">&quot;orderItems&quot;</span>: [</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            <span class=\"attr\">&quot;productId&quot;</span>: <span class=\"number\">27</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;price&quot;</span>: <span class=\"number\">77.5</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;productName&quot;</span>: <span class=\"string\">&quot;thinking injava&quot;</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        ],</span><br><span class=\"line\">        <span class=\"attr\">&quot;shippingAddress&quot;</span>: [</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            <span class=\"attr\">&quot;city&quot;</span>: <span class=\"string\">&quot;beijing&quot;</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">        <span class=\"string\">&quot;orderPayment&quot;</span>: [</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            <span class=\"attr\">&quot;ccinfo&quot;</span>: <span class=\"string\">&quot;111-222-333&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;txnid&quot;</span>: <span class=\"string\">&quot;asdfadcd334&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;billingAddress&quot;</span>: &#123;</span><br><span class=\"line\">              <span class=\"attr\">&quot;city&quot;</span>: <span class=\"string\">&quot;beijing&quot;</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>想想关系模型数据库你如何查？如果按照我们新设计的BSon，是不是查询起来很简单。</p>\n</blockquote>\n<ul>\n<li>高并发的操作是不太建议有关联查询的，互联网公司用冗余数据来避免关联查询</li>\n<li>分布式事务是支持不了太多的并发的</li>\n</ul>\n<h2 id=\"NoSQL四大分类\"><a href=\"#NoSQL四大分类\" class=\"headerlink\" title=\"NoSQL四大分类\"></a>NoSQL四大分类</h2><p><strong>KV键值 ：</strong></p>\n<ul>\n<li>新浪：BerkeleyDB+redis</li>\n<li>美团：redis+tair</li>\n<li>阿里、百度：memcache+redis</li>\n</ul>\n<p><strong>文档型数据库(bson格式比较多) ：</strong></p>\n<ul>\n<li>CouchDB</li>\n<li>MongoDB<ul>\n<li>MongoDB 是一个 基于分布式文件存储的数据库 。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。</li>\n<li>MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"列存储数据库：\"><a href=\"#列存储数据库：\" class=\"headerlink\" title=\"列存储数据库：\"></a>列存储数据库：</h3><ul>\n<li>Cassandra, HBase</li>\n<li>分布式文件系统</li>\n</ul>\n<h3 id=\"图关系数据库\"><a href=\"#图关系数据库\" class=\"headerlink\" title=\"图关系数据库\"></a>图关系数据库</h3><ul>\n<li>它不是放图形的，放的是关系比如:朋友圈社交网络、广告推荐系统</li>\n<li>社交网络，推荐系统等。专注于构建关系图谱</li>\n<li>Neo4J, InfoGrid</li>\n</ul>\n<h3 id=\"四者对比\"><a href=\"#四者对比\" class=\"headerlink\" title=\"四者对比\"></a>四者对比</h3><img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210924141532.png\" class title=\"输入图片说明\">\n\n<h2 id=\"CAP-BASE\"><a href=\"#CAP-BASE\" class=\"headerlink\" title=\"CAP + BASE\"></a>CAP + BASE</h2><blockquote>\n<p>传统的ACID分别是什么？</p>\n</blockquote>\n<h3 id=\"关系型数据库遵循ACID规则，事务在英文中是transaction，和现实世界中的交易很类似，它有如下四个特性：\"><a href=\"#关系型数据库遵循ACID规则，事务在英文中是transaction，和现实世界中的交易很类似，它有如下四个特性：\" class=\"headerlink\" title=\"关系型数据库遵循ACID规则，事务在英文中是transaction，和现实世界中的交易很类似，它有如下四个特性：\"></a>关系型数据库遵循ACID规则，事务在英文中是transaction，和现实世界中的交易很类似，它有如下四个特性：</h3><ul>\n<li>A (Atomicity) 原子性</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务 </span><br><span class=\"line\">里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。 </span><br><span class=\"line\">比如银行转账，从A账户转100元至B账户，分为两个步骤： </span><br><span class=\"line\">1）从A账户取100元； </span><br><span class=\"line\">2）存入100元至B账户。 </span><br><span class=\"line\">这两步要么一起完成，要么一起不完成，如果只完成第一步，第二步失败，钱会莫名其妙少了100 元。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>C (Consistency) 一致性</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">事务前后数据的完整性必须保持一致。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>I (Isolation) 隔离性</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">所谓的独立性是指并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修 改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。比如现有有个交易是从A 账户转100元至B账户，在这个交易还未完成的情况下，如果此时B查询自己的账户，是看不到新增加 的100元的</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>D (Durability) 持久性</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"CAP（三进二）\"><a href=\"#CAP（三进二）\" class=\"headerlink\" title=\"CAP（三进二）\"></a>CAP（三进二）</h3><ul>\n<li>C : Consistency（强一致性）</li>\n<li>A : Availability（可用性）</li>\n<li>P : Partition tolerance（分区容错性）</li>\n</ul>\n<p><strong>CAP理论就是说在分布式存储系统中，最多只能实现上面的两点 。</strong></p>\n<blockquote>\n<p>而由于当前的网络硬件肯定会出现延迟丢包等问题，所以 分区容错性是我们必须需要实现 的。 所以我们只能在一致性和可用性之间进行权衡，没有NoSQL系统能同时保证这三点。 注意：分布式架构的时候必须做出取舍。 一致性和可用性之间取一个平衡。多余大多数web应用，其实并不需要强一致性。 因此牺牲C换取P，这是目前分布式数据库产品的方向</p>\n</blockquote>\n<p><strong>一致性与可用性的决择</strong></p>\n<blockquote>\n<p>对于web2.0网站来说，关系数据库的很多主要特性却往往无用武之地</p>\n</blockquote>\n<p><strong>数据库事务一致性需求</strong></p>\n<blockquote>\n<p>很多web实时系统并不要求严格的数据库事务，对读一致性的要求很低， 有些场合对写一致性要求并不 高。允许实现最终一致性。</p>\n</blockquote>\n<p><strong>数据库的写实时性和读实时性需求</strong></p>\n<blockquote>\n<p>对关系数据库来说，插入一条数据之后立刻查询，是肯定可以读出来这条数据的，但是对于很多web应 用来说，并不要求这么高的实时性，比方说发一条消息之 后，过几秒乃至十几秒之后，我的订阅者才看 到这条动态是完全可以接受的。</p>\n</blockquote>\n<p><strong>对复杂的SQL查询，特别是多表关联查询的需求</strong></p>\n<blockquote>\n<p>任何大数据量的web系统，都非常忌讳多个大表的关联查询，以及复杂的数据分析类型的报表查询，特 别是SNS类型的网站，从需求以及产品设计角度，就避免了这种情况的产生。往往更多的只是单表的主 键查询，以及单表的简单条件分页查询，SQL的功能被极大的弱化了。</p>\n</blockquote>\n<p><strong>CAP理论的核心</strong> 是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求， 最多只能同时较好的满足两个。因此，根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足 AP 原则三<br>大类：</p>\n<ul>\n<li><p>CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。</p>\n</li>\n<li><p>CP - 满足一致性，分区容忍必的系统，通常性能不是特别高。</p>\n</li>\n<li><p>AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。</p>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210924144835.png\" class title=\"输入图片说明\"></li>\n</ul>\n<h3 id=\"BASE-理论\"><a href=\"#BASE-理论\" class=\"headerlink\" title=\"BASE 理论\"></a>BASE 理论</h3><blockquote>\n<p>BASE理论是由eBay架构师提出的。BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互 联网分布式系统实践的总结，是基于CAP定律逐步演化而来。其核心思想是即使无法做到强一致性，但 每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p>\n</blockquote>\n<p><strong>BASE就是为了解决关系数据库强一致性引起的问题而引起的可用性降低而提出的解决方案。</strong></p>\n<h3 id=\"BASE其实是下面三个术语的缩写：\"><a href=\"#BASE其实是下面三个术语的缩写：\" class=\"headerlink\" title=\"BASE其实是下面三个术语的缩写：\"></a>BASE其实是下面三个术语的缩写：</h3><ul>\n<li><p>基本可用(Basically Available)：<br>基本可用是指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。电商大促时，为了应对访问量激增，部分用户可能会被引导到降级页面，服务层也可能只提供降级服务。这就是损失部分可用性的体现。</p>\n</li>\n<li><p>软状态(Soft State)： 软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现。MySQL Replication<br>的异步复制也是一种体现。</p>\n</li>\n<li><p>最终一致性(Eventual Consistency)： 最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。</p>\n</li>\n</ul>\n<blockquote>\n<p>它的思想是通过让系统放松对某一时刻数据一致性的要求来换取系统整体伸缩性和性能上改观。为什么 这么说呢，缘由就在于大型系统往往由于地域分布和极高性能的要求，不可能采用分布式事务来完成这 些指标，要想获得这些指标，我们必须采用另外一种方式来完成，这里BASE就是解决这个问题的办法！<br><strong>解释：</strong></p>\n</blockquote>\n<ul>\n<li>1 、分布式：不同的多台服务器上面部署不同的服务模块（工程），他们之间通过Rpc通信和调用，对外提供服务和组内协作。</li>\n<li>2 、集群：不同的多台服务器上面部署相同的服务模块，通过分布式调度软件进行统一的调度，对外提供服务和访问。</li>\n</ul>\n<h1 id=\"Redis入门\"><a href=\"#Redis入门\" class=\"headerlink\" title=\"Redis入门\"></a>Redis入门</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><h3 id=\"Redis是什么\"><a href=\"#Redis是什么\" class=\"headerlink\" title=\"Redis是什么\"></a>Redis是什么</h3><blockquote>\n<p>Redis：REmote DIctionary Server（远程字典服务器） 是完全开源免费的，用C语言编写的，遵守BSD协议，是一个高性能的（Key/Value）分布式内存数据 库，基于内存运行，并支持持久化的NoSQL数据库，是当前最热门的NoSQL数据库之一，也被人们称为 数据结构服务器</p>\n</blockquote>\n<h3 id=\"Redis与其他key-value缓存产品有以下三个特点\"><a href=\"#Redis与其他key-value缓存产品有以下三个特点\" class=\"headerlink\" title=\"Redis与其他key-value缓存产品有以下三个特点\"></a>Redis与其他key-value缓存产品有以下三个特点</h3><ul>\n<li><p>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。</p>\n</li>\n<li><p>Redis不仅仅支持简单的 key-value 类型的数据，同时还提供list、set、zset、hash等数据结构的存储。</p>\n</li>\n<li><p>Redis支持数据的备份，即master-slave模式的数据备份。</p>\n</li>\n</ul>\n<h3 id=\"Redis能干嘛\"><a href=\"#Redis能干嘛\" class=\"headerlink\" title=\"Redis能干嘛\"></a>Redis能干嘛</h3><blockquote>\n<p>内存存储和持久化：redis支持异步将内存中的数据写到硬盘上，同时不影响继续服务取最新N个数据的操作，如：可以将最新的 10 条评论的ID放在Redis的List集合里面 发布、订阅消息系统 地图信息分析 定时器、计数器……</p>\n</blockquote>\n<h3 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h3><p>数据类型、基本操作和配置</p>\n<p>持久化和复制，RDB、AOF</p>\n<p>事务的控制</p>\n<p>…..</p>\n<h3 id=\"常用网站\"><a href=\"#常用网站\" class=\"headerlink\" title=\"常用网站\"></a>常用网站</h3><h3 id=\"https-redis-io-官网\"><a href=\"#https-redis-io-官网\" class=\"headerlink\" title=\"https://redis.io/ 官网\"></a><a href=\"https://redis.io/\">https://redis.io/</a> 官网</h3><h3 id=\"http-www-redis-cn-中文网\"><a href=\"#http-www-redis-cn-中文网\" class=\"headerlink\" title=\"http://www.redis.cn 中文网\"></a><a href=\"http://www.redis.cn/\">http://www.redis.cn</a> 中文网</h3><h2 id=\"Windows安装\"><a href=\"#Windows安装\" class=\"headerlink\" title=\"Windows安装\"></a>Windows安装</h2><h3 id=\"下载地址：https-github-com-dmajkic-redis-downloads-素材提供\"><a href=\"#下载地址：https-github-com-dmajkic-redis-downloads-素材提供\" class=\"headerlink\" title=\"下载地址：https://github.com/dmajkic/redis/downloads ( 素材提供 )\"></a>下载地址：<a href=\"https://github.com/dmajkic/redis/downloads\">https://github.com/dmajkic/redis/downloads</a> ( 素材提供 )</h3><p>解压到自己电脑的环境目录即可</p>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927092007.png\" class title=\"输入图片说明\">\n\n<h3 id=\"双击-redis-server-exe-启动即可\"><a href=\"#双击-redis-server-exe-启动即可\" class=\"headerlink\" title=\"双击 redis-server.exe 启动即可\"></a>双击 redis-server.exe 启动即可</h3><img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927092027.png\" class title=\"输入图片说明\">\n\n<p><strong>通过客户端去访问 redis-cli</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 基本的<span class=\"built_in\">set</span>设值</span></span><br><span class=\"line\">127.0.0.1:6379&gt; set key kuangshen</span><br><span class=\"line\">OK</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 取出存储的值</span></span><br><span class=\"line\">127.0.0.1:6379&gt; get key</span><br><span class=\"line\">&quot;kuangshen&quot;</span><br></pre></td></tr></table></figure>\n\n<p><code>重要提示</code></p>\n<blockquote>\n<p>由于企业里面做Redis开发，99%都是Linux版的运用和安装，几乎不会涉及到Windows版，上一步的讲 解只是为了知识的完整性，Windows版不作为重点，大家可以自己玩，企业实战就认一个版：Linux版</p>\n</blockquote>\n<p><strong><a href=\"http://www.redis.cn/topics/introduction\">http://www.redis.cn/topics/introduction</a></strong></p>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927092145.png\" class title=\"输入图片说明\">\n\n<h2 id=\"Linux安装\"><a href=\"#Linux安装\" class=\"headerlink\" title=\"Linux安装\"></a>Linux安装</h2><h3 id=\"下载地址-http-download-redis-io-releases-redis-5-0-7-tar-gz\"><a href=\"#下载地址-http-download-redis-io-releases-redis-5-0-7-tar-gz\" class=\"headerlink\" title=\"下载地址 http://download.redis.io/releases/redis-5.0.7.tar.gz\"></a>下载地址 <a href=\"http://download.redis.io/releases/redis-5.0.7.tar.gz\">http://download.redis.io/releases/redis-5.0.7.tar.gz</a></h3><img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927092233.png\" class title=\"输入图片说明\">\n\n<h3 id=\"安装步骤\"><a href=\"#安装步骤\" class=\"headerlink\" title=\"安装步骤\"></a>安装步骤</h3><ul>\n<li>1 、下载获得 redis-5.0.7.tar.gz 后将它放到我们Linux的目录下 /opt</li>\n<li>2 、/opt 目录下，解压命令 ： tar -zxvf redis-5.0.7.tar.gz</li>\n<li>3 、解压完成后出现文件夹：redis-5.0.</li>\n<li>4 、进入目录： cd redis-5.0.</li>\n<li>5 、在 redis-5.0.7 目录下执行 make 命令</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">运行make命令时故意出现的错误解析：</span><br><span class=\"line\">1. 安装gcc (gcc是linux下的一个编译程序，是c程序的编译工具)</span><br><span class=\"line\">能上网: yum install gcc-c++</span><br><span class=\"line\">版本测试: gcc-v</span><br><span class=\"line\">2. 二次make</span><br><span class=\"line\">3. Jemalloc/jemalloc.h: 没有那个文件或目录</span><br><span class=\"line\">运行 make distclean 之后再make</span><br><span class=\"line\">4. Redis Test（可以不用执行）</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>6 、如果make完成后继续执行 make install</li>\n<li>7 、查看默认安装目录：usr/local/bin 1 /usr 这是一个非常重要的目录，类似于windows下的Program Files,存放用户的程序</li>\n<li>8 、拷贝配置文件（备用）</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">cd /usr/local/bin</span><br><span class=\"line\">ls -l</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 在redis的解压目录下备份redis.conf</span></span><br><span class=\"line\">mkdir myredis</span><br><span class=\"line\">cp redis.conf myredis  # 拷一个备份，养成良好的习惯，我们就修改这个文件</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 修改配置保证可以后台应用</span></span><br><span class=\"line\">vim redis.conf</span><br></pre></td></tr></table></figure>\n\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927092451.png\" class title=\"输入图片说明\">\n\n<ul>\n<li>A、redis.conf配置文件中daemonize守护线程，默认是NO。</li>\n<li>B、daemonize是用来指定redis是否要用守护线程的方式启动。</li>\n</ul>\n<p><strong>daemonize 设置yes或者no区别</strong></p>\n<ul>\n<li><p>daemonize:yes</p>\n<p>  *<br>  redis采用的是单进程多线程的模式。当redis.conf中选项daemonize设置成yes时，代表开启守护进程模式。在该模式下，redis会在后台运行，并将进程pid号写入至redis.conf选项pidfile设置的文件中，此时redis将一直运行，除非手动kill该进程。</p>\n</li>\n<li><p>daemonize:no</p>\n<ul>\n<li>当daemonize选项设置成no时，当前界面将进入redis的命令行界面，exit强制退出或者关闭连接工具(putty,xshell等)都会导致redis进程退出。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"9-、启动测试一下！\"><a href=\"#9-、启动测试一下！\" class=\"headerlink\" title=\"9 、启动测试一下！\"></a>9 、启动测试一下！</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 【shell】启动redis服务</span></span><br><span class=\"line\">[root@192 bin]# cd /usr/local/bin</span><br><span class=\"line\">[root@192 bin]# redis-server /opt/redis-5.0.7/redis.conf</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> redis客户端连接===&gt; 观察地址的变化，如果连接ok,是直接连上的，redis默认端口号 6379</span></span><br><span class=\"line\">[root@192 bin]# redis-cli -p 6379</span><br><span class=\"line\">127.0.0.1:6379&gt; ping</span><br><span class=\"line\">PONG</span><br><span class=\"line\">127.0.0.1:6379&gt; set k1 helloworld</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; get k</span><br><span class=\"line\">&quot;helloworld&quot;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 【shell】ps显示系统当前进程信息</span></span><br><span class=\"line\">[root@192 myredis]# ps -ef|grep redis</span><br><span class=\"line\">root 16005  1  0 04 :45? 00 :00:00 redis-server</span><br><span class=\"line\">127.0.0.1:</span><br><span class=\"line\">root 16031  15692  0 04 :47 pts/0 00 :00:00 redis-cli -p 6379</span><br><span class=\"line\">root 16107  16076  0 04 :51 pts/2 00 :00:00 grep --color=auto redis</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 【redis】关闭连接</span></span><br><span class=\"line\">127.0.0.1:6379&gt; shutdown</span><br><span class=\"line\">not connected&gt; exit</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 【shell】ps显示系统当前进程信息</span></span><br><span class=\"line\">[root@192 myredis]# ps -ef|grep redis</span><br><span class=\"line\">root 16140  16076  0 04 :53 pts/2 00 :00:00 grep --color=auto redis</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"基础知识说明\"><a href=\"#基础知识说明\" class=\"headerlink\" title=\"基础知识说明\"></a>基础知识说明</h2><p>准备工作：开启redis服务，客户端连接</p>\n<blockquote>\n<p>redis压力测试工具—–Redis-benchmark</p>\n</blockquote>\n<p>Redis-benchmark是官方自带的Redis性能测试工具，可以有效的测试Redis服务的性能。</p>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927092755.png\" class title=\"输入图片说明\">\n\n<h3 id=\"redis-性能测试工具可选参数如下所示：\"><a href=\"#redis-性能测试工具可选参数如下所示：\" class=\"headerlink\" title=\"redis 性能测试工具可选参数如下所示：\"></a>redis 性能测试工具可选参数如下所示：</h3><table>\n<thead>\n<tr>\n<th>序号</th>\n<th>选项</th>\n<th>描述</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>-h</td>\n<td>指定服务器主机名</td>\n<td>127.0.0.1</td>\n</tr>\n<tr>\n<td>2</td>\n<td>-p</td>\n<td>指定服务器端口</td>\n<td>6379</td>\n</tr>\n<tr>\n<td>3</td>\n<td>-s</td>\n<td>指定服务器</td>\n<td>socket</td>\n</tr>\n<tr>\n<td>4</td>\n<td>-c</td>\n<td>指定并发连接数</td>\n<td>50</td>\n</tr>\n<tr>\n<td>5</td>\n<td>-n</td>\n<td>指定请求数</td>\n<td>10000</td>\n</tr>\n<tr>\n<td>6</td>\n<td>-d</td>\n<td>以字节的形式指定 SET/GET 值的数据大小</td>\n<td>2</td>\n</tr>\n<tr>\n<td>7</td>\n<td>-k</td>\n<td>1=keep alive 0=reconnect</td>\n<td>1</td>\n</tr>\n<tr>\n<td>8</td>\n<td>-r</td>\n<td>SET/GET/INCR 使用随机 key, SADD 使用随机值</td>\n<td></td>\n</tr>\n<tr>\n<td>9</td>\n<td>-P</td>\n<td>通过管道传输 请求</td>\n<td>1</td>\n</tr>\n<tr>\n<td>10</td>\n<td>-q</td>\n<td>强制退出 redis。仅显示 query/sec 值</td>\n<td></td>\n</tr>\n<tr>\n<td>11</td>\n<td>–csv</td>\n<td>以 CSV 格式输出</td>\n<td></td>\n</tr>\n<tr>\n<td>12</td>\n<td>-l</td>\n<td>生成循环，永久执行测试</td>\n<td></td>\n</tr>\n<tr>\n<td>13</td>\n<td>-t</td>\n<td>仅运行以逗号分隔的测试命令列表。</td>\n<td></td>\n</tr>\n<tr>\n<td>14</td>\n<td>-I</td>\n<td>Idle 模式。仅打开 N 个 idle 连接并等待。</td>\n<td></td>\n</tr>\n</tbody></table>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 测试一： 100 个并发连接， 100000 个请求，检测host为localhost 端口为 6379 的redis服务器性能</span></span><br><span class=\"line\">redis-benchmark -h localhost -p 6379 -c 100 -n 100000</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 测试出来的所有命令只举例一个！</span></span><br><span class=\"line\">====== SET ======</span><br><span class=\"line\"> 100000 requests completed in 1.88 seconds # 对集合写入测试</span><br><span class=\"line\"> 100 parallel clients # 每次请求有 100 个并发客户端</span><br><span class=\"line\"> 3 bytes payload # 每次写入 3 个字节的数据，有效载荷</span><br><span class=\"line\">keep alive: 1 # 保持一个连接，一台服务器来处理这些请求</span><br><span class=\"line\"></span><br><span class=\"line\">17.05% &lt;= 1 milliseconds</span><br><span class=\"line\">97.35% &lt;= 2 milliseconds</span><br><span class=\"line\">99.97% &lt;= 3 milliseconds</span><br><span class=\"line\">100.00% &lt;= 3 milliseconds # 所有请求在 3 毫秒内完成</span><br><span class=\"line\">53248.14 requests per second # 每秒处理 53248.14 次请求</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"基本数据库常识\"><a href=\"#基本数据库常识\" class=\"headerlink\" title=\"基本数据库常识\"></a>基本数据库常识</h3><h3 id=\"默认-16-个数据库，类似数组下标从零开始，初始默认使用零号库\"><a href=\"#默认-16-个数据库，类似数组下标从零开始，初始默认使用零号库\" class=\"headerlink\" title=\"默认 16 个数据库，类似数组下标从零开始，初始默认使用零号库\"></a>默认 16 个数据库，类似数组下标从零开始，初始默认使用零号库</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">查看 redis.conf ，里面有默认的配置</span><br><span class=\"line\">databases 16</span><br><span class=\"line\"></span><br><span class=\"line\"># Set the number of databases. The default database is DB 0, you can select</span><br><span class=\"line\"># a different one on a per-connection basis using SELECT &lt;dbid&gt; where</span><br><span class=\"line\"># dbid is a number between 0 and &#x27;databases&#x27;-1</span><br><span class=\"line\">databases 16</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Select命令切换数据库\"><a href=\"#Select命令切换数据库\" class=\"headerlink\" title=\"Select命令切换数据库\"></a>Select命令切换数据库</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; select 7</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379[7]&gt;</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 不同的库可以存不同的数据</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\">## Dbsize查看当前数据库的key的数量</span></span></span><br><span class=\"line\">127.0.0.1:6379&gt; select 7</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379[7]&gt; DBSIZE</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">127.0.0.1:6379[7]&gt; select 0</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; DBSIZE</span><br><span class=\"line\">(integer) 5</span><br><span class=\"line\">127.0.0.1:6379&gt; keys * # 查看具体的key</span><br><span class=\"line\">1 ) &quot;counter:__rand_int__&quot;</span><br><span class=\"line\">2 ) &quot;mylist&quot;</span><br><span class=\"line\">3 ) &quot;k1&quot;</span><br><span class=\"line\">4 ) &quot;myset:__rand_int__&quot;</span><br><span class=\"line\">5 ) &quot;key:__rand_int__&quot;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Flushdb：清空当前库\"><a href=\"#Flushdb：清空当前库\" class=\"headerlink\" title=\"Flushdb：清空当前库\"></a>Flushdb：清空当前库</h3><h3 id=\"Flushall：清空全部的库\"><a href=\"#Flushall：清空全部的库\" class=\"headerlink\" title=\"Flushall：清空全部的库\"></a>Flushall：清空全部的库</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; DBSIZE</span><br><span class=\"line\">(integer) 5</span><br><span class=\"line\">127.0.0.1:6379&gt; FLUSHDB</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; DBSIZE</span><br><span class=\"line\">(integer) 0</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"为什么默认端口是-6379-？粉丝效应！\"><a href=\"#为什么默认端口是-6379-？粉丝效应！\" class=\"headerlink\" title=\"为什么默认端口是 6379 ？粉丝效应！\"></a>为什么默认端口是 6379 ？粉丝效应！</h3><blockquote>\n<p>为什么redis是单线程</p>\n</blockquote>\n<blockquote>\n<p>我们首先要明白，Redis很快！官方表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了！</p>\n</blockquote>\n<blockquote>\n<p>Redis采用的是基于内存的采用的是单进程单线程模型的 KV 数据库，由C语言编写，官方提供的数据是可以达到100000+的QPS（每秒内查询次数）。这个数据不比采用单进程多线程的同样基于内存的 KV数据库 Memcached 差！</p>\n</blockquote>\n<h3 id=\"Redis为什么这么快？\"><a href=\"#Redis为什么这么快？\" class=\"headerlink\" title=\"Redis为什么这么快？\"></a>Redis为什么这么快？</h3><ul>\n<li><p>1 ）以前一直有个误区，以为：高性能服务器 一定是多线程来实现的 原因很简单因为误区二导致的：多线程 一定比 单线程 效率高，其实不然！ 在说这个事前希望大家都能对 CPU 、 内存 、 硬盘的速度都有了解了！</p>\n</li>\n<li><p>2 ）redis 核心就是 如果我的数据全都在内存里，我单线程的去操作 就是效率最高的，为什么呢，因为 多线程的本质就是 CPU 模拟出来多个线程的情况，这种模拟出来的情况就有一个代价，就是上下文的切<br>换，对于一个内存的系统来说，它没有上下文的切换就是效率最高的。redis 用 单个CPU 绑定一块内存 的数据，然后针对这块内存的数据进行多次读写的时候，都是在一个CPU上完成的，所以它是单线程处<br>理这个事。在内存的情况下，这个方案就是最佳方案。 因为一次CPU上下文的切换大概在 1500ns 左右。从内存中读取 1MB 的连续数据，耗时大约为 250us， 假设1MB的数据由多个线程读取了 1000 次，那么就有 1000<br>次时间上下文的切换，那么就有1500ns *<br>1000 = 1500us ，我单线程的读完1MB数据才250us ,你光时间上下文的切换就用了1500us了，我还不 算你每次读一点数据 的时间。</p>\n</li>\n</ul>\n<h1 id=\"五大数据类型\"><a href=\"#五大数据类型\" class=\"headerlink\" title=\"五大数据类型\"></a>五大数据类型</h1><blockquote>\n<p>官方文档</p>\n</blockquote>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927094518.png\" class title=\"输入图片说明\">\n\n<p>命令文档 <a href=\"http://doc.redisfans.com/\">http://doc.redisfans.com/</a></p>\n<h3 id=\"全段翻译：\"><a href=\"#全段翻译：\" class=\"headerlink\" title=\"全段翻译：\"></a>全段翻译：</h3><blockquote>\n<p>Redis是一个开放源代码（BSD许可）的内存中数据结构存储，用作数据库，缓存和消息代理。它支持数 据结构，例如字符串，哈希，列表，集合，带范围查询的排序集合，位图，超日志，带有半径查询和流 的地理空间索引。Redis具有内置的复制，Lua脚本，LRU驱逐，事务和不同级别的磁盘持久性，并通过 Redis Sentinel和Redis Cluster自动分区提供了高可用性。</p>\n</blockquote>\n<h3 id=\"String-（字符串类型）\"><a href=\"#String-（字符串类型）\" class=\"headerlink\" title=\"String （字符串类型）\"></a>String （字符串类型）</h3><blockquote>\n<p>String是redis最基本的类型，你可以理解成Memcached一模一样的类型，一个key对应一个value。<br><br>String类型是二进制安全的，意思是redis的string可以包含任何数据，比如jpg图片或者序列化的对象。<br><br>String类型是redis最基本的数据类型，一个redis中字符串value最多可以是512M。<br></p>\n</blockquote>\n<h3 id=\"Hash（哈希，类似-Java里的Map）\"><a href=\"#Hash（哈希，类似-Java里的Map）\" class=\"headerlink\" title=\"Hash（哈希，类似 Java里的Map）\"></a>Hash（哈希，类似 Java里的Map）</h3><blockquote>\n<p>Redis hash 是一个键值对集合。<br><br>Redis hash 是一个String类型的field和value的映射表，hash特别适合用于存储对象。<br><br>类似Java里面的Map&lt;String,Object&gt;<br></p>\n</blockquote>\n<h3 id=\"List（列表）\"><a href=\"#List（列表）\" class=\"headerlink\" title=\"List（列表）\"></a>List（列表）</h3><blockquote>\n<p>Redis列表是简单的字符串列表，按照插入顺序排序，你可以添加一个元素到列表的头部（左边）或者尾部（右边）。<br><br>它的底层实际是个链表!</p>\n</blockquote>\n<h3 id=\"Set（集合）\"><a href=\"#Set（集合）\" class=\"headerlink\" title=\"Set（集合）\"></a>Set（集合）</h3><blockquote>\n<p>Redis的Set是String类型的无序集合，它是通过HashTable实现的!</p>\n</blockquote>\n<h3 id=\"Zset（sorted-set：有序集合）\"><a href=\"#Zset（sorted-set：有序集合）\" class=\"headerlink\" title=\"Zset（sorted set：有序集合）\"></a>Zset（sorted set：有序集合）</h3><blockquote>\n<p>Redis zset 和 set 一样，也是String类型元素的集合，且不允许重复的成员。<br><br>不同的是每个元素都会关联一个double类型的分数。<br><br><br>Redis正是通过分数来为集合中的成员进行从小到大的排序，zset的成员是唯一的，但是分数（Score）<br><br>却可以重复。<br></p>\n</blockquote>\n<h2 id=\"Redis键（key）\"><a href=\"#Redis键（key）\" class=\"headerlink\" title=\"Redis键（key）\"></a>Redis键（key）</h2><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> keys * 查看所有的key</span></span><br><span class=\"line\">127.0.0.1:6379&gt; keys *</span><br><span class=\"line\">(empty list or set)</span><br><span class=\"line\">127.0.0.1:6379&gt; set name qinjiang</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; keys *</span><br><span class=\"line\">1 ) &quot;name&quot;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> exists key 的名字，判断某个key是否存在</span></span><br><span class=\"line\">127.0.0.1:6379&gt; EXISTS name</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; EXISTS name1</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> move key db ---&gt; 当前库就没有了，被移除了</span></span><br><span class=\"line\">127.0.0.1:6379&gt; move name 1</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; keys *</span><br><span class=\"line\">(empty list or set)</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> expire key 秒钟：为给定 key 设置生存时间，当 key 过期时(生存时间为 0 )，它会被自动删</span></span><br><span class=\"line\">除。</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ttl key 查看还有多少秒过期，-1 表示永不过期，-2 表示已过期</span></span><br><span class=\"line\">127.0.0.1:6379&gt; set name qinjiang</span><br><span class=\"line\">OK</span><br><span class=\"line\"></span><br><span class=\"line\">127.0.0.1:6379&gt; EXPIRE name 10</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; ttl name</span><br><span class=\"line\">(integer) 4</span><br><span class=\"line\">127.0.0.1:6379&gt; ttl name</span><br><span class=\"line\">(integer) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; ttl name</span><br><span class=\"line\">(integer) 2</span><br><span class=\"line\">127.0.0.1:6379&gt; ttl name</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; ttl name</span><br><span class=\"line\">(integer) -2</span><br><span class=\"line\">127.0.0.1:6379&gt; keys *</span><br><span class=\"line\">(empty list or set)</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"built_in\">type</span> key 查看你的key是什么类型</span></span><br><span class=\"line\">127.0.0.1:6379&gt; set name qinjiang</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; get name</span><br><span class=\"line\">&quot;qinjiang&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; type name</span><br><span class=\"line\">string</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"字符串String\"><a href=\"#字符串String\" class=\"headerlink\" title=\"字符串String\"></a>字符串String</h2><p><code>单值单Value</code></p>\n<p><strong>常用命令说明：</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\">### # ===================================================</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"built_in\">set</span>、get、del、append、strlen</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; set key1 value1 # 设置值</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; get key1  # 获得key</span><br><span class=\"line\">&quot;value1&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; del key1  # 删除key</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; keys *  # 查看全部的key</span><br><span class=\"line\">(empty list or set)</span><br><span class=\"line\">127.0.0.1:6379&gt; exists key1 # 确保 key1 不存在</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; append key1 &quot;hello&quot; # 对不存在的 key 进行 APPEND ，等同于 SET</span><br><span class=\"line\">key1 &quot;hello&quot;</span><br><span class=\"line\">(integer) 5 # 字符长度</span><br><span class=\"line\">127.0.0.1:6379&gt; APPEND key1 &quot;-2333&quot; # 对已存在的字符串进行 APPEND</span><br><span class=\"line\">(integer) 10 # 长度从 5 个字符增加到 10 个字符</span><br><span class=\"line\">127.0.0.1:6379&gt; get key1</span><br><span class=\"line\">&quot;hello-2333&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; STRLEN key1 # # 获取字符串的长度</span><br><span class=\"line\">(integer) 10</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> incr、decr 一定要是数字才能进行加减，+1 和 -1。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> incrby、decrby 命令将 key 中储存的数字加上指定的增量值。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"></span><br><span class=\"line\">127.0.0.1:6379&gt; set views 0 # 设置浏览量为 0</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; incr views  # 浏览 + 1</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; incr views  # 浏览 + 1</span><br><span class=\"line\">(integer) 2</span><br><span class=\"line\">127.0.0.1:6379&gt; decr views  # 浏览 - 1</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; incrby views 10 # +10</span><br><span class=\"line\">(integer) 11</span><br><span class=\"line\">127.0.0.1:6379&gt; decrby views 10 # -10</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> range [范围]</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> getrange 获取指定区间范围内的值，类似between...and的关系，从零到负一表示全部</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; set key2 abcd123456  # 设置key2的值</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; getrange key2 0 -1 # 获得全部的值</span><br><span class=\"line\">&quot;abcd123456&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; getrange key2 0 2 # 截取部分字符串</span><br><span class=\"line\">&quot;abc&quot;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> setrange 设置指定区间范围内的值，格式是setrange key值 具体值</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; get key2</span><br><span class=\"line\">&quot;abcd123456&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; SETRANGE key2 1 xx # 替换值</span><br><span class=\"line\">(integer) 10</span><br><span class=\"line\">127.0.0.1:6379&gt; get key2</span><br><span class=\"line\">&quot;axxd123456&quot;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> setex（<span class=\"built_in\">set</span> with expire）键秒值</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> setnx（<span class=\"built_in\">set</span> <span class=\"keyword\">if</span> not exist）</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; setex key3 60 expire  # 设置过期时间</span><br><span class=\"line\">OK</span><br><span class=\"line\"></span><br><span class=\"line\">127.0.0.1:6379&gt; ttl key3  # 查看剩余的时间</span><br><span class=\"line\">(integer) 55</span><br><span class=\"line\">127.0.0.1:6379&gt; setnx mykey &quot;redis&quot; # 如果不存在就设置，成功返回 1</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; setnx mykey &quot;mongodb&quot; # 如果存在就设置，失败返回 0</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; get mykey</span><br><span class=\"line\">&quot;redis&quot;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> mset Mset 命令用于同时设置一个或多个 key-value 对。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> mget Mget 命令返回所有(一个或多个)给定 key 的值。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 如果给定的 key 里面，有某个 key 不存在，那么这个 key 返回特殊值 nil 。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> msetnx 当所有 key 都成功设置，返回 1 。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 如果所有给定 key 都设置失败(至少有一个 key 已经存在)，那么返回 0 。原子操</span></span><br><span class=\"line\">作</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; mset k10 v10 k11 v11 k12 v12</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; keys *</span><br><span class=\"line\">1 ) &quot;k12&quot;</span><br><span class=\"line\">2 ) &quot;k11&quot;</span><br><span class=\"line\">3 ) &quot;k10&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; mget k10 k11 k12 k13</span><br><span class=\"line\">1 ) &quot;v10&quot;</span><br><span class=\"line\">2 ) &quot;v11&quot;</span><br><span class=\"line\">3 ) &quot;v12&quot;</span><br><span class=\"line\">4 ) (nil)</span><br><span class=\"line\">127.0.0.1:6379&gt; msetnx k10 v10 k15 v15 # 原子性操作！</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; get key15</span><br><span class=\"line\">(nil)</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 传统对象缓存</span></span><br><span class=\"line\">set user:1 value(json数据)</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 可以用来缓存对象</span></span><br><span class=\"line\">mset user:1:name zhangsan user:1:age 2</span><br><span class=\"line\">mget user:1:name user:1:age</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> getset（先get再<span class=\"built_in\">set</span>）</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; getset db mongodb # 没有旧值，返回 nil</span><br><span class=\"line\">(nil)</span><br><span class=\"line\">127.0.0.1:6379&gt; get db</span><br><span class=\"line\">&quot;mongodb&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; getset db redis # 返回旧值 mongodb</span><br><span class=\"line\">&quot;mongodb&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; get db</span><br><span class=\"line\">&quot;redis&quot;</span><br></pre></td></tr></table></figure>\n\n<p>String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。</p>\n<p>常规key-value缓存应用：</p>\n<p>常规计数：微博数，粉丝数等。</p>\n<h2 id=\"列表List\"><a href=\"#列表List\" class=\"headerlink\" title=\"列表List\"></a>列表List</h2><p><code>单值多Value</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\">### # ===================================================</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Lpush：将一个或多个值插入到列表头部。（左）</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> rpush：将一个或多个值插入到列表尾部。（右）</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> lrange：返回列表中指定区间内的元素，区间以偏移量 START 和 END 指定。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 其中 0 表示列表的第一个元素， 1 表示列表的第二个元素，以此类推。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此</span></span><br><span class=\"line\">类推。</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; LPUSH list &quot;one&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; LPUSH list &quot;two&quot;</span><br><span class=\"line\">(integer) 2</span><br><span class=\"line\"></span><br><span class=\"line\">127.0.0.1:6379&gt; RPUSH list &quot;right&quot;</span><br><span class=\"line\">(integer) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; Lrange list 0 -1</span><br><span class=\"line\">1 ) &quot;two&quot;</span><br><span class=\"line\">2 ) &quot;one&quot;</span><br><span class=\"line\">3 ) &quot;right&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; Lrange list 0 1</span><br><span class=\"line\">1 ) &quot;two&quot;</span><br><span class=\"line\">2 ) &quot;one&quot;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> lpop 命令用于移除并返回列表的第一个元素。当列表 key 不存在时，返回 nil 。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> rpop 移除列表的最后一个元素，返回值为移除的元素。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; Lpop list</span><br><span class=\"line\">&quot;two&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; Rpop list</span><br><span class=\"line\">&quot;right&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; Lrange list 0 -1</span><br><span class=\"line\">1 ) &quot;one&quot;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Lindex，按照索引下标获得元素（-1代表最后一个， 0 代表是第一个）</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; Lindex list 1</span><br><span class=\"line\">(nil)</span><br><span class=\"line\">127.0.0.1:6379&gt; Lindex list 0</span><br><span class=\"line\">&quot;one&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; Lindex list -1</span><br><span class=\"line\">&quot;one&quot;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> llen 用于返回列表的长度。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; flushdb</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; Lpush list &quot;one&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; Lpush list &quot;two&quot;</span><br><span class=\"line\">(integer) 2</span><br><span class=\"line\">127.0.0.1:6379&gt; Lpush list &quot;three&quot;</span><br><span class=\"line\">(integer) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; Llen list # 返回列表的长度</span><br><span class=\"line\">(integer) 3</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> lrem key 根据参数 COUNT 的值，移除列表中与参数 VALUE 相等的元素。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; lrem list 1 &quot;two&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; Lrange list 0 -1</span><br><span class=\"line\">1 ) &quot;three&quot;</span><br><span class=\"line\">2 ) &quot;one&quot;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Ltrim key 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区</span></span><br><span class=\"line\">间之内的元素都将被删除。</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"></span><br><span class=\"line\">127.0.0.1:6379&gt; RPUSH mylist &quot;hello&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; RPUSH mylist &quot;hello&quot;</span><br><span class=\"line\">(integer) 2</span><br><span class=\"line\">127.0.0.1:6379&gt; RPUSH mylist &quot;hello2&quot;</span><br><span class=\"line\">(integer) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; RPUSH mylist &quot;hello3&quot;</span><br><span class=\"line\">(integer) 4</span><br><span class=\"line\">127.0.0.1:6379&gt; ltrim mylist 1 2</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class=\"line\">1 ) &quot;hello&quot;</span><br><span class=\"line\">2 ) &quot;hello2&quot;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> rpoplpush 移除列表的最后一个元素，并将该元素添加到另一个列表并返回。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; rpush mylist &quot;hello&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; rpush mylist &quot;foo&quot;</span><br><span class=\"line\">(integer) 2</span><br><span class=\"line\">127.0.0.1:6379&gt; rpush mylist &quot;bar&quot;</span><br><span class=\"line\">(integer) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; rpoplpush mylist myotherlist</span><br><span class=\"line\">&quot;bar&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class=\"line\">1 ) &quot;hello&quot;</span><br><span class=\"line\">2 ) &quot;foo&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; lrange myotherlist 0 -1</span><br><span class=\"line\">1 ) &quot;bar&quot;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> lset key index value 将列表 key 下标为 index 的元素的值设置为 value 。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; exists list  # 对空列表(key 不存在)进行 LSET</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; lset list 0 item # 报错</span><br><span class=\"line\">(error) ERR no such key</span><br><span class=\"line\"></span><br><span class=\"line\">127.0.0.1:6379&gt; lpush list &quot;value1&quot; # 对非空列表进行 LSET</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; lrange list 0 0</span><br><span class=\"line\">1 ) &quot;value1&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; lset list 0 &quot;new&quot; # 更新值</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; lrange list 0 0</span><br><span class=\"line\">1 ) &quot;new&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; lset list 1 &quot;new&quot; # index 超出范围报错</span><br><span class=\"line\">(error) ERR index out of range</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> linsert key before/after pivot value 用于在列表的元素前或者后插入元素。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 将值 value 插入到列表 key 当中，位于值 pivot 之前或之后。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">redis&gt;</span><span class=\"bash\"> RPUSH mylist <span class=\"string\">&quot;Hello&quot;</span></span></span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\"><span class=\"meta\">redis&gt;</span><span class=\"bash\"> RPUSH mylist <span class=\"string\">&quot;World&quot;</span></span></span><br><span class=\"line\">(integer) 2</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">redis&gt;</span><span class=\"bash\"> LINSERT mylist BEFORE <span class=\"string\">&quot;World&quot;</span> <span class=\"string\">&quot;There&quot;</span></span></span><br><span class=\"line\">(integer) 3</span><br><span class=\"line\"><span class=\"meta\">redis&gt;</span><span class=\"bash\"> LRANGE mylist 0 -1</span></span><br><span class=\"line\">1 ) &quot;Hello&quot;</span><br><span class=\"line\">2 ) &quot;There&quot;</span><br><span class=\"line\">3 ) &quot;World&quot;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"性能总结\"><a href=\"#性能总结\" class=\"headerlink\" title=\"性能总结\"></a>性能总结</h3><ul>\n<li>它是一个字符串链表，left，right 都可以插入添加</li>\n<li>如果键不存在，创建新的链表</li>\n<li>如果键已存在，新增内容</li>\n<li>如果值全移除，对应的键也就消失了</li>\n<li>链表的操作无论是头和尾效率都极高，但假如是对中间元素进行操作，效率就很惨淡了。</li>\n</ul>\n<blockquote>\n<p>list就是链表，略有数据结构知识的人都应该能理解其结构。使用Lists结构，我们可以轻松地实现最新消 息排行等功能。List的另一个应用就是消息队列，可以利用List的PUSH操作，将任务存在List中，然后工 作线程再用POP操作将任务取出进行执行。Redis还提供了操作List中某一段的api，你可以直接查询，删 除List中某一段的元素。</p>\n</blockquote>\n<blockquote>\n<p>Redis的list是每个子元素都是String类型的双向链表，可以通过push和pop操作从列表的头部或者尾部添加或者删除元素，这样List即可以作为栈，也可以作为队列。</p>\n</blockquote>\n<h2 id=\"集合Set\"><a href=\"#集合Set\" class=\"headerlink\" title=\"集合Set\"></a>集合Set</h2><p><code>单值多value</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\">### # ===================================================</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sadd 将一个或多个成员元素加入到集合中，不能重复</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> smembers 返回集合中的所有的成员。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sismember 命令判断成员元素是否是集合的成员。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; sadd myset &quot;hello&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; sadd myset &quot;kuangshen&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; sadd myset &quot;kuangshen&quot;</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class=\"line\">1 ) &quot;kuangshen&quot;</span><br><span class=\"line\">2 ) &quot;hello&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; SISMEMBER myset &quot;hello&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; SISMEMBER myset &quot;world&quot;</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> scard，获取集合里面的元素个数</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; scard myset</span><br><span class=\"line\">(integer) 2</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> srem key value 用于移除集合中的一个或多个成员元素</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; srem myset &quot;kuangshen&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\"></span><br><span class=\"line\">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class=\"line\">1 ) &quot;hello&quot;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> srandmember key 命令用于返回集合中的一个随机元素。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class=\"line\">1 ) &quot;kuangshen&quot;</span><br><span class=\"line\">2 ) &quot;world&quot;</span><br><span class=\"line\">3 ) &quot;hello&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; SRANDMEMBER myset</span><br><span class=\"line\">&quot;hello&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; SRANDMEMBER myset 2</span><br><span class=\"line\">1 ) &quot;world&quot;</span><br><span class=\"line\">2 ) &quot;kuangshen&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; SRANDMEMBER myset 2</span><br><span class=\"line\">1 ) &quot;kuangshen&quot;</span><br><span class=\"line\">2 ) &quot;hello&quot;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> spop key 用于移除集合中的指定 key 的一个或多个随机元素</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class=\"line\">1 ) &quot;kuangshen&quot;</span><br><span class=\"line\">2 ) &quot;world&quot;</span><br><span class=\"line\">3 ) &quot;hello&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; spop myset</span><br><span class=\"line\">&quot;world&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; spop myset</span><br><span class=\"line\">&quot;kuangshen&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; spop myset</span><br><span class=\"line\">&quot;hello&quot;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> smove SOURCE DESTINATION MEMBER</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 将指定成员 member 元素从 <span class=\"built_in\">source</span> 集合移动到 destination 集合。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; sadd myset &quot;hello&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; sadd myset &quot;world&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; sadd myset &quot;kuangshen&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; sadd myset2 &quot;set2&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; smove myset myset2 &quot;kuangshen&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class=\"line\">1 ) &quot;world&quot;</span><br><span class=\"line\">2 ) &quot;hello&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; SMEMBERS myset2</span><br><span class=\"line\">1 ) &quot;kuangshen&quot;</span><br><span class=\"line\">2 ) &quot;set2&quot;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">- 数字集合类</span><br><span class=\"line\">  - 差集： sdiff</span><br><span class=\"line\">  - 交集： sinter</span><br><span class=\"line\">  - 并集： sunion</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; sadd key1 &quot;a&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; sadd key1 &quot;b&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; sadd key1 &quot;c&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; sadd key2 &quot;c&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; sadd key2 &quot;d&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; sadd key2 &quot;e&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; SDIFF key1 key2 # 差集</span><br><span class=\"line\">1 ) &quot;a&quot;</span><br><span class=\"line\">2 ) &quot;b&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; SINTER key1 key2 # 交集</span><br><span class=\"line\">1 ) &quot;c&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; SUNION key1 key2 # 并集</span><br><span class=\"line\">1 ) &quot;a&quot;</span><br><span class=\"line\">2 ) &quot;b&quot;</span><br><span class=\"line\">3 ) &quot;c&quot;</span><br><span class=\"line\">4 ) &quot;e&quot;</span><br><span class=\"line\">5 ) &quot;d&quot;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis还为集合提供了求交集、并集、差集等操作，可以非常方便的实现如共同关注、共同喜好、二度好友等功能，对上面的所有集合操作，你还可以使用不同的命令选择将结果返回给客户端还是存集到一个新的集合中。</p>\n</blockquote>\n<h2 id=\"哈希Hash\"><a href=\"#哈希Hash\" class=\"headerlink\" title=\"哈希Hash\"></a>哈希Hash</h2><p><code>kv模式不变，但V是一个键值对</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\">### # ===================================================</span></span></span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hset、hget 命令用于为哈希表中的字段赋值 。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hmset、hmget 同时将多个field-value对设置到哈希表中。会覆盖哈希表中已存在的字段。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hgetall 用于返回哈希表中，所有的字段和值。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hdel 用于删除哈希表 key 中的一个或多个指定字段</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; hset myhash field1 &quot;kuangshen&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; hget myhash field1</span><br><span class=\"line\">&quot;kuangshen&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; HMSET myhash field1 &quot;Hello&quot; field2 &quot;World&quot;</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; HGET myhash field1</span><br><span class=\"line\">&quot;Hello&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; HGET myhash field2</span><br><span class=\"line\">&quot;World&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; hgetall myhash</span><br><span class=\"line\">1 ) &quot;field1&quot;</span><br><span class=\"line\">2 ) &quot;Hello&quot;</span><br><span class=\"line\">3 ) &quot;field2&quot;</span><br><span class=\"line\">4 ) &quot;World&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; HDEL myhash field1</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; hgetall myhash</span><br><span class=\"line\">1 ) &quot;field2&quot;</span><br><span class=\"line\">2 ) &quot;World&quot;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hlen 获取哈希表中字段的数量。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; hlen myhash</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; HMSET myhash field1 &quot;Hello&quot; field2 &quot;World&quot;</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; hlen myhash</span><br><span class=\"line\">(integer) 2</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hexists 查看哈希表的指定字段是否存在。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; hexists myhash field1</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; hexists myhash field3</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hkeys 获取哈希表中的所有域（field）。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hvals 返回哈希表所有域(field)的值。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; HKEYS myhash</span><br><span class=\"line\">1 ) &quot;field2&quot;</span><br><span class=\"line\">2 ) &quot;field1&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; HVALS myhash</span><br><span class=\"line\">1 ) &quot;World&quot;</span><br><span class=\"line\">2 ) &quot;Hello&quot;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hincrby 为哈希表中的字段值加上指定增量值。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; hset myhash field 5</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; HINCRBY myhash field 1</span><br><span class=\"line\">(integer) 6</span><br><span class=\"line\">127.0.0.1:6379&gt; HINCRBY myhash field -1</span><br><span class=\"line\">(integer) 5</span><br><span class=\"line\">127.0.0.1:6379&gt; HINCRBY myhash field -10</span><br><span class=\"line\">(integer) -5</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hsetnx 为哈希表中不存在的的字段赋值 。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; HSETNX myhash field1 &quot;hello&quot;</span><br><span class=\"line\">(integer) 1 # 设置成功，返回 1 。</span><br><span class=\"line\">127.0.0.1:6379&gt; HSETNX myhash field1 &quot;world&quot;</span><br><span class=\"line\">(integer) 0 # 如果给定字段已经存在，返回 0 。</span><br><span class=\"line\">127.0.0.1:6379&gt; HGET myhash field1</span><br><span class=\"line\">&quot;hello&quot;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。存储部分变更的数据，如用户信息等。</p>\n</blockquote>\n<h2 id=\"有序集合Zset\"><a href=\"#有序集合Zset\" class=\"headerlink\" title=\"有序集合Zset\"></a>有序集合Zset</h2><p><code>在set基础上，加一个score值。之前set是k1 v1 v2 v3，现在zset是 k1 score1 v1 score2 v2</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\">### # ===================================================</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> zadd 将一个或多个成员元素及其分数值加入到有序集当中。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> zrange 返回有序集中，指定区间内的成员</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; zadd myset 1 &quot;one&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; zadd myset 2 &quot;two&quot; 3 &quot;three&quot;</span><br><span class=\"line\">(integer) 2</span><br><span class=\"line\">127.0.0.1:6379&gt; ZRANGE myset 0 -1</span><br><span class=\"line\">1 ) &quot;one&quot;</span><br><span class=\"line\">2 ) &quot;two&quot;</span><br><span class=\"line\">3 ) &quot;three&quot;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> zrangebyscore 返回有序集合中指定分数区间的成员列表。有序集成员按分数值递增(从小到大)</span></span><br><span class=\"line\">次序排列。</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; zadd salary 2500 xiaoming</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; zadd salary 5000 xiaohong</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; zadd salary 500 kuangshen</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Inf无穷大量+∞,同样地,-∞可以表示为-Inf。</span></span><br><span class=\"line\">127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf +inf # 显示整个有序集</span><br><span class=\"line\">1 ) &quot;kuangshen&quot;</span><br><span class=\"line\">2 ) &quot;xiaoming&quot;</span><br><span class=\"line\">3 ) &quot;xiaohong&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf +inf withscores # 递增排列</span><br><span class=\"line\">1 ) &quot;kuangshen&quot;</span><br><span class=\"line\">2 ) &quot;500&quot;</span><br><span class=\"line\">3 ) &quot;xiaoming&quot;</span><br><span class=\"line\">4 ) &quot;2500&quot;</span><br><span class=\"line\">5 ) &quot;xiaohong&quot;</span><br><span class=\"line\">6 ) &quot;5000&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; ZREVRANGE salary 0 -1 WITHSCORES  # 递减排列</span><br><span class=\"line\">1 ) &quot;xiaohong&quot;</span><br><span class=\"line\">2 ) &quot;5000&quot;</span><br><span class=\"line\">3 ) &quot;xiaoming&quot;</span><br><span class=\"line\">4 ) &quot;2500&quot;</span><br><span class=\"line\">5 ) &quot;kuangshen&quot;</span><br><span class=\"line\">6 ) &quot;500&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf 2500 WITHSCORES # 显示工资 &lt;=2500</span><br><span class=\"line\">的所有成员</span><br><span class=\"line\">1 ) &quot;kuangshen&quot;</span><br><span class=\"line\">2 ) &quot;500&quot;</span><br><span class=\"line\">3 ) &quot;xiaoming&quot;</span><br><span class=\"line\">4 ) &quot;2500&quot;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\">### # ===================================================</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> zrem 移除有序集中的一个或多个成员</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; ZRANGE salary 0 -1</span><br><span class=\"line\">1 ) &quot;kuangshen&quot;</span><br><span class=\"line\">2 ) &quot;xiaoming&quot;</span><br><span class=\"line\">3 ) &quot;xiaohong&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; zrem salary kuangshen</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; ZRANGE salary 0 -1</span><br><span class=\"line\">1 ) &quot;xiaoming&quot;</span><br><span class=\"line\">2 ) &quot;xiaohong&quot;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> zcard 命令用于计算集合中元素的数量。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; zcard salary</span><br><span class=\"line\">(integer) 2</span><br><span class=\"line\">OK</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> zcount 计算有序集合中指定分数区间的成员数量。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; zadd myset 1 &quot;hello&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; zadd myset 2 &quot;world&quot; 3 &quot;kuangshen&quot;</span><br><span class=\"line\">(integer) 2</span><br><span class=\"line\">127.0.0.1:6379&gt; ZCOUNT myset 1 3</span><br><span class=\"line\">(integer) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; ZCOUNT myset 1 2</span><br><span class=\"line\">(integer) 2</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> zrank 返回有序集中指定成员的排名。其中有序集成员按分数值递增(从小到大)顺序排列。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; zadd salary 2500 xiaoming</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; zadd salary 5000 xiaohong</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; zadd salary 500 kuangshen</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; ZRANGE salary 0 -1 WITHSCORES  # 显示所有成员及其 score 值</span><br><span class=\"line\">1 ) &quot;kuangshen&quot;</span><br><span class=\"line\">2 ) &quot;500&quot;</span><br><span class=\"line\">3 ) &quot;xiaoming&quot;</span><br><span class=\"line\">4 ) &quot;2500&quot;</span><br><span class=\"line\">5 ) &quot;xiaohong&quot;</span><br><span class=\"line\">6 ) &quot;5000&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; zrank salary kuangshen  # 显示 kuangshen 的薪水排名，最少</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; zrank salary xiaohong # 显示 xiaohong 的薪水排名，第三</span><br><span class=\"line\">(integer) 2</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> zrevrank 返回有序集中成员的排名。其中有序集成员按分数值递减(从大到小)排序。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; ZREVRANK salary bright</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列，比如一个存储全班同学成绩的sorted set，其集合value可以是同学的学号，而score就可以是其考试得分，这样在数据插入集合的时候，就已经进行了天然的排序。可以用sorted set来做带权重的队列，比如普通消息的score为 1 ，重要消息的score为 2 ，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。</p>\n</blockquote>\n<blockquote>\n<p>排行榜应用，取TOP N操作 ！</p>\n</blockquote>\n<h1 id=\"三种特殊数据类型\"><a href=\"#三种特殊数据类型\" class=\"headerlink\" title=\"三种特殊数据类型\"></a>三种特殊数据类型</h1><h2 id=\"GEO地理位置\"><a href=\"#GEO地理位置\" class=\"headerlink\" title=\"GEO地理位置\"></a>GEO地理位置</h2><blockquote>\n<p>简介</p>\n</blockquote>\n<blockquote>\n<p>Redis 的 GEO 特性在 Redis 3.2 版本中推出， 这个功能可以将用户给定的地理位置信息储存起来， 并对这些信息进行操作。来实现诸如附近位置、摇一摇这类依赖于地理位置信息的功能。geo的数据类型为zset。</p>\n</blockquote>\n<blockquote>\n<p>GEO 的数据结构总共有六个常用命令：geoadd、geopos、geodist、georadius、georadiusbymember、gethash</p>\n</blockquote>\n<h3 id=\"官方文档：https-www-redis-net-cn-order-3685-html\"><a href=\"#官方文档：https-www-redis-net-cn-order-3685-html\" class=\"headerlink\" title=\"官方文档：https://www.redis.net.cn/order/3685.html\"></a>官方文档：<a href=\"https://www.redis.net.cn/order/3685.html\">https://www.redis.net.cn/order/3685.html</a></h3><h3 id=\"geoadd\"><a href=\"#geoadd\" class=\"headerlink\" title=\"geoadd\"></a>geoadd</h3><p><strong>解析：</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\">### # 语法</span></span></span><br><span class=\"line\">geoadd key longitude latitude member...</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 将给定的空间元素(纬度、经度、名字)添加到指定的键里面。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 这些数据会以有序集he的形式被储存在键里面，从而使得georadius和georadiusbymember这样的命令可以在之后通过位置查询取得这些元素。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> geoadd命令以标准的x,y格式接受参数,所以用户必须先输入经度,然后再输入纬度。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> geoadd能够记录的坐标是有限的:非常接近两极的区域无法被索引。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 有效的经度介于-180-180度之间，有效的纬度介于-85.05112878 度至 85.05112878 度之间。，当用户尝试输入一个超出范围的经度或者纬度时,geoadd命令将返回一个错误。</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"测试：百度搜索经纬度查询，模拟真实数据\"><a href=\"#测试：百度搜索经纬度查询，模拟真实数据\" class=\"headerlink\" title=\"测试：百度搜索经纬度查询，模拟真实数据\"></a>测试：百度搜索经纬度查询，模拟真实数据</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; geoadd china:city 116.23 40.22 北京</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; geoadd china:city 121.48 31.40 上海 113.88 22.55 深圳 120.21</span><br><span class=\"line\">30.20 杭州</span><br><span class=\"line\">(integer) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; geoadd china:city 106.54 29.40 重庆 108.93 34.23 西安 114.02</span><br><span class=\"line\">30.58 武汉</span><br><span class=\"line\">(integer) 3</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"geopos\"><a href=\"#geopos\" class=\"headerlink\" title=\"geopos\"></a>geopos</h3><p><strong>解析：</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">geopos key member [member...]</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">从key里返回所有给定位置元素的位置（经度和纬度）</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"测试：\"><a href=\"#测试：\" class=\"headerlink\" title=\"测试：\"></a>测试：</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; geopos china:city 北京</span><br><span class=\"line\">1 ) 1 ) &quot;116.23000055551528931&quot;</span><br><span class=\"line\">2 ) &quot;40.2200010338739844&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; geopos china:city 上海 重庆</span><br><span class=\"line\">1 ) 1 ) &quot;121.48000091314315796&quot;</span><br><span class=\"line\">2 ) &quot;31.40000025319353938&quot;</span><br><span class=\"line\">2 ) 1 ) &quot;106.54000014066696167&quot;</span><br><span class=\"line\">2 ) &quot;29.39999880018641676&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; geopos china:city 新疆</span><br><span class=\"line\">1 ) (nil)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"geodist\"><a href=\"#geodist\" class=\"headerlink\" title=\"geodist\"></a>geodist</h3><p><strong>解析：</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">geodist key member1 member2 [unit]</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 返回两个给定位置之间的距离，如果两个位置之间的其中一个不存在,那么命令返回空值。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 指定单位的参数unit必须是以下单位的其中一个：</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> m表示单位为米</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> km表示单位为千米</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> mi表示单位为英里</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ft表示单位为英尺</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 如果用户没有显式地指定单位参数,那么geodist默认使用米作为单位。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">geodist命令在计算距离时会假设地球为完美的球形,在极限情况下,这一假设最大会造成0.5%的误差。</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"测试：-1\"><a href=\"#测试：-1\" class=\"headerlink\" title=\"测试：\"></a>测试：</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; geodist china:city 北京 上海</span><br><span class=\"line\">&quot;1088785.4302&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; geodist china:city 北京 上海 km</span><br><span class=\"line\">&quot;1088.7854&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; geodist china:city 重庆 北京 km</span><br><span class=\"line\">&quot;1491.6716&quot;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"georadius\"><a href=\"#georadius\" class=\"headerlink\" title=\"georadius\"></a>georadius</h3><h3 id=\"解析：\"><a href=\"#解析：\" class=\"headerlink\" title=\"解析：\"></a>解析：</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\">### # 语法</span></span></span><br><span class=\"line\">georadius key longitude latitude radius m|km|ft|mi [withcoord][withdist]</span><br><span class=\"line\">[withhash][asc|desc][count count]</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 以给定的经纬度为中心， 找出某一半径内的元素</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"测试：重新连接-redis-cli，增加参数-–raw-，可以强制输出中文，不然会乱码\"><a href=\"#测试：重新连接-redis-cli，增加参数-–raw-，可以强制输出中文，不然会乱码\" class=\"headerlink\" title=\"测试：重新连接 redis-cli，增加参数 –raw ，可以强制输出中文，不然会乱码\"></a>测试：重新连接 redis-cli，增加参数 –raw ，可以强制输出中文，不然会乱码</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@kuangshen bin]# redis-cli --raw -p 6379</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 在 china:city 中寻找坐标 100 30 半径为 1000km 的城市</span></span><br><span class=\"line\">127.0.0.1:6379&gt; georadius china:city 100 30 1000 km</span><br><span class=\"line\">重庆</span><br><span class=\"line\">西安</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> withdist 返回位置名称和中心距离</span></span><br><span class=\"line\">127.0.0.1:6379&gt; georadius china:city 100 30 1000 km withdist</span><br><span class=\"line\">重庆</span><br><span class=\"line\">635.2850</span><br><span class=\"line\">西安</span><br><span class=\"line\">963.3171</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> withcoord 返回位置名称和经纬度</span></span><br><span class=\"line\">127.0.0.1:6379&gt; georadius china:city 100 30 1000 km withcoord</span><br><span class=\"line\">重庆</span><br><span class=\"line\">106.54000014066696167</span><br><span class=\"line\">29.39999880018641676</span><br><span class=\"line\">西安</span><br><span class=\"line\">108.92999857664108276</span><br><span class=\"line\">34.23000121926852302</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> withdist withcoord 返回位置名称 距离 和经纬度 count 限定寻找个数</span></span><br><span class=\"line\">127.0.0.1:6379&gt; georadius china:city 100 30 1000 km withcoord withdist count</span><br><span class=\"line\">1</span><br><span class=\"line\">重庆</span><br><span class=\"line\">635.2850</span><br><span class=\"line\">106.54000014066696167</span><br><span class=\"line\">29.39999880018641676</span><br><span class=\"line\">127.0.0.1:6379&gt; georadius china:city 100 30 1000 km withcoord withdist count</span><br><span class=\"line\">2</span><br><span class=\"line\">重庆</span><br><span class=\"line\">635.2850</span><br><span class=\"line\">106.54000014066696167</span><br><span class=\"line\">29.39999880018641676</span><br><span class=\"line\">西安</span><br><span class=\"line\">963.3171</span><br><span class=\"line\">108.92999857664108276</span><br><span class=\"line\">34.23000121926852302</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"georadiusbymember\"><a href=\"#georadiusbymember\" class=\"headerlink\" title=\"georadiusbymember\"></a>georadiusbymember</h3><h3 id=\"解析：-1\"><a href=\"#解析：-1\" class=\"headerlink\" title=\"解析：\"></a>解析：</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\">### # 语法</span></span></span><br><span class=\"line\">georadiusbymember key member radius m|km|ft|mi [withcoord][withdist]</span><br><span class=\"line\">[withhash][asc|desc][count count]</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 找出位于指定范围内的元素，中心点是由给定的位置元素决定</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"测试：-2\"><a href=\"#测试：-2\" class=\"headerlink\" title=\"测试：\"></a>测试：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city 北京 1000 km</span><br><span class=\"line\">北京</span><br><span class=\"line\">西安</span><br><span class=\"line\">127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city 上海 400 km</span><br><span class=\"line\">杭州</span><br><span class=\"line\">上海</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"geohash\"><a href=\"#geohash\" class=\"headerlink\" title=\"geohash\"></a>geohash</h3><h3 id=\"解析：-2\"><a href=\"#解析：-2\" class=\"headerlink\" title=\"解析：\"></a>解析：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#### # 语法</span><br><span class=\"line\">geohash key member [member...]</span><br><span class=\"line\"># Redis使用geohash将二维经纬度转换为一维字符串，字符串越长表示位置更精确,两个字符串越相似</span><br><span class=\"line\">表示距离越近。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"测试：-3\"><a href=\"#测试：-3\" class=\"headerlink\" title=\"测试：\"></a>测试：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; geohash china:city 北京 重庆</span><br><span class=\"line\">wx4sucu47r0</span><br><span class=\"line\">wm5z22h53v0</span><br><span class=\"line\">127.0.0.1:6379&gt; geohash china:city 北京 上海</span><br><span class=\"line\">wx4sucu47r0</span><br><span class=\"line\">wtw6sk5n300</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"zrem\"><a href=\"#zrem\" class=\"headerlink\" title=\"zrem\"></a>zrem</h3><blockquote>\n<p>GEO没有提供删除成员的命令，但是因为GEO的底层实现是zset，所以可以借用zrem命令实现对地理位置信息的删除.</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; geoadd china:city 116.23 40.22 beijin</span><br><span class=\"line\">1</span><br><span class=\"line\">127.0.0.1:6379&gt; zrange china:city 0 -1 # 查看全部的元素</span><br><span class=\"line\">重庆</span><br><span class=\"line\">西安</span><br><span class=\"line\">深圳</span><br><span class=\"line\">武汉</span><br><span class=\"line\">杭州</span><br><span class=\"line\">上海</span><br><span class=\"line\">beijin</span><br><span class=\"line\">北京</span><br><span class=\"line\">127.0.0.1:6379&gt; zrem china:city beijin  # 移除元素</span><br><span class=\"line\">1</span><br><span class=\"line\">127.0.0.1:6379&gt; zrem china:city 北京 # 移除元素</span><br><span class=\"line\">1</span><br><span class=\"line\">127.0.0.1:6379&gt; zrange china:city 0 -1</span><br><span class=\"line\">重庆</span><br><span class=\"line\">西安</span><br><span class=\"line\">深圳</span><br><span class=\"line\">武汉</span><br><span class=\"line\">杭州</span><br><span class=\"line\">上海</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"HyperLogLog\"><a href=\"#HyperLogLog\" class=\"headerlink\" title=\"HyperLogLog\"></a>HyperLogLog</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>Redis 在 2.8.9 版本添加了 HyperLogLog 结构。</p>\n<p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积 非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。</p>\n<p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p>\n<blockquote>\n<p>HyperLogLog则是一种算法，它提供了不精确的去重计数方案。举个栗子：假如我要统计网页的UV（浏览用户数量，一天内同一个用户多次访问只能算一次），传统的解决方案是使用Set来保存用户id，然后统计Set中的元素数量来获取页面UV。但这种方案只能承载少量用户，一旦用户数量大起来就需要消耗大量的空间来存储用户id。我的目的是统计用户数量而不是保存用户，这简直是个吃力不讨好的方案！而使用Redis的HyperLogLog最多需要12k就可以统计大量的用户数，尽管它大概有0.81%的错误率，但对于统计UV这种不需要很精确的数据是可以忽略不计的。</p>\n</blockquote>\n<h3 id=\"什么是基数？\"><a href=\"#什么是基数？\" class=\"headerlink\" title=\"什么是基数？\"></a>什么是基数？</h3><blockquote>\n<p>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为 5 。基数估计就是在误差可接受的范围内，快速计算基数。</p>\n</blockquote>\n<h3 id=\"基本命令\"><a href=\"#基本命令\" class=\"headerlink\" title=\"基本命令\"></a>基本命令</h3><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>[PFADD key element [element…]</td>\n<td>添加指定元素到 HyperLogLog 中。</td>\n</tr>\n<tr>\n<td>[PFCOUNT key [key…]</td>\n<td>返回给定 HyperLogLog 的基数估算值。</td>\n</tr>\n<tr>\n<td>[PFMERGE destkey sourcekey[sourcekey…]</td>\n<td>将多个 HyperLogLog 合并为一个 HyperLogLog，并集计算</td>\n</tr>\n</tbody></table>\n<h3 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1: 6379 &gt; PFADD mykey a b c d e f g h i j</span><br><span class=\"line\">1</span><br><span class=\"line\">127.0.0.1: 6379 &gt; PFCOUNT mykey</span><br><span class=\"line\">10</span><br><span class=\"line\">127.0.0.1: 6379 &gt; PFADD mykey2 i j z x c v b n m</span><br><span class=\"line\">1</span><br><span class=\"line\">127.0.0.1: 6379 &gt; PFMERGE mykey3 mykey mykey2</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1: 6379 &gt; PFCOUNT mykey3</span><br><span class=\"line\">15</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"BitMap\"><a href=\"#BitMap\" class=\"headerlink\" title=\"BitMap\"></a>BitMap</h2><blockquote>\n<p>简介</p>\n</blockquote>\n<blockquote>\n<p>在开发中，可能会遇到这种情况：需要统计用户的某些信息，如活跃或不活跃，登录或者不登录；又如需要记录用户一年的打卡情况，打卡了是 1 ， 没有打卡是 0 ，如果使用普通的 key/value存储，则要记录365 条记录，如果用户量很大，需要的空间也会很大，所以 Redis 提供了 Bitmap 位图这中数据结构，Bitmap 就是通过操作二进制位来进行记录，即为 0 和 1 ；如果要记录 365 天的打卡情况，使用 Bitmap表示的形式大概如下：0101000111000111………………………，这样有什么好处呢？当然就是节约内存了， 365 天相当于 365 bit，又 1 字节 = 8 bit , 所以相当于使用 46 个字节即可。</p>\n</blockquote>\n<blockquote>\n<p>BitMap 就是通过一个 bit 位来表示某个元素对应的值或者状态, 其中的 key 就是对应元素本身，实际上底层也是通过对字符串的操作来实现。Redis 从 2.2 版本之后新增了setbit, getbit, bitcount 等几个bitmap 相关命令。</p>\n</blockquote>\n<h3 id=\"setbit-设置操作\"><a href=\"#setbit-设置操作\" class=\"headerlink\" title=\"setbit 设置操作\"></a>setbit 设置操作</h3><p>SETBIT key offset value : 设置 key 的第 offset 位为value (1或0)</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 使用 bitmap 来记录上述事例中一周的打卡记录如下所示：</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 周一： 1 ，周二： 0 ，周三： 0 ，周四： 1 ，周五： 1 ，周六： 0 ，周天： 0 （ 1 为打卡， 0 为不打卡）</span></span><br><span class=\"line\">127.0.0.1:6379&gt; setbit sign 0 1</span><br><span class=\"line\">0</span><br><span class=\"line\">127.0.0.1:6379&gt; setbit sign 1 0</span><br><span class=\"line\">0</span><br><span class=\"line\">127.0.0.1:6379&gt; setbit sign 2 0</span><br><span class=\"line\">0</span><br><span class=\"line\">127.0.0.1:6379&gt; setbit sign 3 1</span><br><span class=\"line\">0</span><br><span class=\"line\">127.0.0.1:6379&gt; setbit sign 4 1</span><br><span class=\"line\">0</span><br><span class=\"line\">127.0.0.1:6379&gt; setbit sign 5 0</span><br><span class=\"line\">0</span><br><span class=\"line\">127.0.0.1:6379&gt; setbit sign 6 0</span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"getbit-获取操作\"><a href=\"#getbit-获取操作\" class=\"headerlink\" title=\"getbit 获取操作\"></a>getbit 获取操作</h3><p>GETBIT key offset 获取offset设置的值，未设置过默认返回 0</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; getbit sign 3 # 查看周四是否打卡</span><br><span class=\"line\">1</span><br><span class=\"line\">127.0.0.1:6379&gt; getbit sign 6 # 查看周七是否打卡</span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"bitcount-统计操作\"><a href=\"#bitcount-统计操作\" class=\"headerlink\" title=\"bitcount 统计操作\"></a>bitcount 统计操作</h3><p>bitcount key [start, end] 统计 key 上位为 1 的个数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; bitcount sign</span><br><span class=\"line\">3</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Redis事务\"><a href=\"#Redis事务\" class=\"headerlink\" title=\"Redis事务\"></a>Redis事务</h1><h2 id=\"理论\"><a href=\"#理论\" class=\"headerlink\" title=\"理论\"></a>理论</h2><h3 id=\"Redis事务的概念：\"><a href=\"#Redis事务的概念：\" class=\"headerlink\" title=\"Redis事务的概念：\"></a>Redis事务的概念：</h3><blockquote>\n<p>Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p>\n</blockquote>\n<p>总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。<br><strong>Redis事务没有隔离级别的概念：</strong></p>\n<p>批量操作在发送 EXEC 命令前被放入队列缓存，并不会被实际执行！</p>\n<p><strong>Redis不保证原子性：</strong></p>\n<p>Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。</p>\n<p><strong>Redis事务的三个阶段：</strong></p>\n<ul>\n<li>开始事务</li>\n<li>命令入队</li>\n<li>执行事务</li>\n</ul>\n<h3 id=\"Redis事务相关命令：\"><a href=\"#Redis事务相关命令：\" class=\"headerlink\" title=\"Redis事务相关命令：\"></a>Redis事务相关命令：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">watch key1 key2...  #监视一或多个key,如果在事务执行之前，被监视的key被其他命令改动，则</span><br><span class=\"line\">事务被打断 （ 类似乐观锁 ）</span><br><span class=\"line\">multi # 标记一个事务块的开始（ queued ）</span><br><span class=\"line\">exec # 执行所有事务块的命令 （ 一旦执行exec后，之前加的监控锁都会被取消掉 ）</span><br><span class=\"line\">discard # 取消事务，放弃事务块中的所有命令</span><br><span class=\"line\">unwatch # 取消watch对所有key的监控</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><h3 id=\"正常执行\"><a href=\"#正常执行\" class=\"headerlink\" title=\"正常执行\"></a>正常执行</h3><img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927112345.png\" class title=\"输入图片说明\">\n\n<h3 id=\"放弃事务\"><a href=\"#放弃事务\" class=\"headerlink\" title=\"放弃事务\"></a>放弃事务</h3><img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927112358.png\" class title=\"输入图片说明\">\n\n<p>若在事务队列中存在命令性错误（类似于java编译性错误），则执行EXEC命令时，所有命令都不会执行</p>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927112441.png\" class title=\"输入图片说明\">\n\n<p>若在事务队列中存在语法性错误（类似于java的1/0的运行时异常），则执行EXEC命令时，其他正确命令会被执行，错误命令抛出异常。</p>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927112511.png\" class title=\"输入图片说明\">\n\n<h2 id=\"Watch-监控\"><a href=\"#Watch-监控\" class=\"headerlink\" title=\"Watch 监控\"></a>Watch 监控</h2><h3 id=\"悲观锁：\"><a href=\"#悲观锁：\" class=\"headerlink\" title=\"悲观锁：\"></a>悲观锁：</h3><blockquote>\n<p>悲观锁(Pessimistic Lock),顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿到这个数据就会block直到它拿到锁。传统的关系型数据库里面就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在操作之前先上锁。</p>\n</blockquote>\n<h3 id=\"乐观锁：\"><a href=\"#乐观锁：\" class=\"headerlink\" title=\"乐观锁：\"></a>乐观锁：</h3><blockquote>\n<p>乐观锁(Optimistic Lock),顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁。但是在更新的时候会判断一下再此期间别人有没有去更新这个数据，可以使用版本号等机制，乐观锁适用于多读的应用类型，这样可以提高吞吐量，乐观锁策略：提交版本必须大于记录当前版本才能执行更新。</p>\n</blockquote>\n<h3 id=\"测试：-4\"><a href=\"#测试：-4\" class=\"headerlink\" title=\"测试：\"></a>测试：</h3><ul>\n<li>1 、初始化信用卡可用余额和欠额</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; set balance 100</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; set debt 0</span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>2 、使用watch检测balance，事务期间balance数据未变动，事务执行成功</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; watch balance</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; MULTI</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; decrby balance 20</span><br><span class=\"line\">QUEUED</span><br><span class=\"line\">127.0.0.1:6379&gt; incrby debt 20</span><br><span class=\"line\">QUEUED</span><br><span class=\"line\">127.0.0.1:6379&gt; exec</span><br><span class=\"line\">1 ) (integer) 80</span><br><span class=\"line\">2 ) (integer) 20</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>3 、使用watch检测balance，事务期间balance数据变动，事务执行失败！</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\">### # 窗口一</span></span></span><br><span class=\"line\">127.0.0.1:6379&gt; watch balance</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; MULTI  # 执行完毕后，执行窗口二代码测试</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; decrby balance 20</span><br><span class=\"line\">QUEUED</span><br><span class=\"line\">127.0.0.1:6379&gt; incrby debt 20</span><br><span class=\"line\">QUEUED</span><br><span class=\"line\">127.0.0.1:6379&gt; exec  # 修改失败！</span><br><span class=\"line\">(nil)</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 窗口二</span></span><br><span class=\"line\">127.0.0.1:6379&gt; get balance</span><br><span class=\"line\">&quot;80&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; set balance 200</span><br><span class=\"line\">OK</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 窗口一：出现问题后放弃监视，然后重来！</span></span><br><span class=\"line\">127.0.0.1:6379&gt; UNWATCH  # 放弃监视</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; watch balance</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; MULTI</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; decrby balance 20</span><br><span class=\"line\">QUEUED</span><br><span class=\"line\">127.0.0.1:6379&gt; incrby debt 20</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"说明：\"><a href=\"#说明：\" class=\"headerlink\" title=\"说明：\"></a>说明：</h3><p>一但执行 EXEC 开启事务的执行后，无论事务使用执行成功， WARCH 对变量的监控都将被取消。故当事务执行失败后，需重新执行WATCH命令对变量进行监控，并开启新的事务进行操作。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>watch指令类似于乐观锁，在事务提交时，如果watch监控的多个KEY中任何KEY的值已经被其他客户端更改，则使用EXEC执行事务时，事务队列将不会被执行，同时返回Nullmulti-bulk应答以通知调用者事务执行失败。</p>\n<h1 id=\"Jedis\"><a href=\"#Jedis\" class=\"headerlink\" title=\"Jedis\"></a>Jedis</h1><blockquote>\n<p>Jedis是Redis官方推荐的Java连接开发工具。要在Java开发中使用好Redis中间件，必须对Jedis熟悉才能写成漂亮的代码</p>\n</blockquote>\n<h2 id=\"测试联通\"><a href=\"#测试联通\" class=\"headerlink\" title=\"测试联通\"></a>测试联通</h2><ul>\n<li>1 、新建一个普通的Maven项目</li>\n<li>2 、导入redis的依赖！</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>redis.clients<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>jedis<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.2.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.alibaba<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>fastjson<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.2.58<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>3 、编写测试代码</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.kuang.ping;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> redis.clients.jedis.Jedis;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Ping</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Jedis jedis = <span class=\"keyword\">new</span> Jedis(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">6379</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;连接成功&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//查看服务是否运行</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;服务正在运行: &quot;</span> + jedis.ping());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">*<span class=\"number\">4</span> 、启动redis服务</span><br><span class=\"line\">        *<span class=\"number\">5</span> 、启动测试，结果</span><br><span class=\"line\">        ```shell</span><br><span class=\"line\">        连接成功</span><br><span class=\"line\">        服务正在运行:PONG</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"常用API\"><a href=\"#常用API\" class=\"headerlink\" title=\"常用API\"></a>常用API</h2><h3 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestPassword</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Jedis jedis = <span class=\"keyword\">new</span> Jedis(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">6379</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//验证密码，如果没有设置密码这段代码省略</span></span><br><span class=\"line\">        <span class=\"comment\">// jedis.auth(&quot;password&quot;);</span></span><br><span class=\"line\"></span><br><span class=\"line\">        jedis.connect(); <span class=\"comment\">//连接</span></span><br><span class=\"line\">        jedis.disconnect(); <span class=\"comment\">//断开连接</span></span><br><span class=\"line\"></span><br><span class=\"line\">        jedis.flushAll(); <span class=\"comment\">//清空所有的key</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"对key操作的命令\"><a href=\"#对key操作的命令\" class=\"headerlink\" title=\"对key操作的命令\"></a>对key操作的命令</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestKey</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Jedis jedis = <span class=\"keyword\">new</span> Jedis(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">6379</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;清空数据：&quot;</span> + jedis.flushDB());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;判断某个键是否存在：&quot;</span> + jedis.exists(<span class=\"string\">&quot;username&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;新增&lt;&#x27;username&#x27;,&#x27;kuangshen&#x27;&gt;的键值对：&quot;</span> + jedis.set(<span class=\"string\">&quot;username&quot;</span>, <span class=\"string\">&quot;kuangshen&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;新增&lt;&#x27;password&#x27;,&#x27;password&#x27;&gt;的键值对：&quot;</span> + jedis.set(<span class=\"string\">&quot;password&quot;</span>, <span class=\"string\">&quot;password&quot;</span>));</span><br><span class=\"line\">        System.out.print(<span class=\"string\">&quot;系统中所有的键如下：&quot;</span>);</span><br><span class=\"line\">        Set&lt;String&gt; keys = jedis.keys(<span class=\"string\">&quot;*&quot;</span>);</span><br><span class=\"line\">        System.out.println(keys);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;删除键password:&quot;</span> + jedis.del(<span class=\"string\">&quot;password&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;判断键password是否存在：&quot;</span> + jedis.exists(<span class=\"string\">&quot;password&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;查看键username所存储的值的类型：&quot;</span> + jedis.type(<span class=\"string\">&quot;username&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;随机返回key空间的一个：&quot;</span> + jedis.randomKey());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;重命名key：&quot;</span> + jedis.rename(<span class=\"string\">&quot;username&quot;</span>, <span class=\"string\">&quot;name&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;取出改后的name：&quot;</span> + jedis.get(<span class=\"string\">&quot;name&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;按索引查询：&quot;</span> + jedis.select(<span class=\"number\">0</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;删除当前选择数据库中的所有key：&quot;</span> + jedis.flushDB());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;返回当前数据库中key的数目：&quot;</span> + jedis.dbSize());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;删除所有数据库中的所有key：&quot;</span> + jedis.flushAll());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"对String操作的命令\"><a href=\"#对String操作的命令\" class=\"headerlink\" title=\"对String操作的命令\"></a>对String操作的命令</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestString</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Jedis jedis = <span class=\"keyword\">new</span> Jedis(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">6379</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        jedis.flushDB();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;===========增加数据===========&quot;</span>);</span><br><span class=\"line\">        System.out.println(jedis.set(<span class=\"string\">&quot;key1&quot;</span>, <span class=\"string\">&quot;value1&quot;</span>));</span><br><span class=\"line\">        System.out.println(jedis.set(<span class=\"string\">&quot;key2&quot;</span>, <span class=\"string\">&quot;value2&quot;</span>));</span><br><span class=\"line\">        System.out.println(jedis.set(<span class=\"string\">&quot;key3&quot;</span>, <span class=\"string\">&quot;value3&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;删除键key2:&quot;</span> + jedis.del(<span class=\"string\">&quot;key2&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;获取键key2:&quot;</span> + jedis.get(<span class=\"string\">&quot;key2&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;修改key1:&quot;</span> + jedis.set(<span class=\"string\">&quot;key1&quot;</span>, <span class=\"string\">&quot;value1Changed&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;获取key1的值：&quot;</span> + jedis.get(<span class=\"string\">&quot;key1&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;在key3后面加入值：&quot;</span> + jedis.append(<span class=\"string\">&quot;key3&quot;</span>, <span class=\"string\">&quot;End&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;key3的值：&quot;</span> + jedis.get(<span class=\"string\">&quot;key3&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;增加多个键值对：&quot;</span> + jedis.mset(<span class=\"string\">&quot;key01&quot;</span>, <span class=\"string\">&quot;value01&quot;</span>, <span class=\"string\">&quot;key02&quot;</span>, <span class=\"string\">&quot;value02&quot;</span>, <span class=\"string\">&quot;key03&quot;</span>, <span class=\"string\">&quot;value03&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;获取多个键值对：&quot;</span> + jedis.mget(<span class=\"string\">&quot;key01&quot;</span>, <span class=\"string\">&quot;key02&quot;</span>, <span class=\"string\">&quot;key03&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;获取多个键值对：&quot;</span> + jedis.mget(<span class=\"string\">&quot;key01&quot;</span>, <span class=\"string\">&quot;key02&quot;</span>, <span class=\"string\">&quot;key03&quot;</span>, <span class=\"string\">&quot;key04&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;删除多个键值对：&quot;</span> + jedis.del(<span class=\"string\">&quot;key01&quot;</span>, <span class=\"string\">&quot;key02&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;获取多个键值对：&quot;</span> + jedis.mget(<span class=\"string\">&quot;key01&quot;</span>, <span class=\"string\">&quot;key02&quot;</span>, <span class=\"string\">&quot;key03&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        jedis.flushDB();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;===========新增键值对防止覆盖原先值==============&quot;</span>);</span><br><span class=\"line\">        System.out.println(jedis.setnx(<span class=\"string\">&quot;key1&quot;</span>, <span class=\"string\">&quot;value1&quot;</span>));</span><br><span class=\"line\">        System.out.println(jedis.setnx(<span class=\"string\">&quot;key2&quot;</span>, <span class=\"string\">&quot;value2&quot;</span>));</span><br><span class=\"line\">        System.out.println(jedis.setnx(<span class=\"string\">&quot;key2&quot;</span>, <span class=\"string\">&quot;value2-new&quot;</span>));</span><br><span class=\"line\">        System.out.println(jedis.get(<span class=\"string\">&quot;key1&quot;</span>));</span><br><span class=\"line\">        System.out.println(jedis.get(<span class=\"string\">&quot;key2&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;===========新增键值对并设置有效时间=============&quot;</span>);</span><br><span class=\"line\">        System.out.println(jedis.setex(<span class=\"string\">&quot;key3&quot;</span>, <span class=\"number\">2</span>, <span class=\"string\">&quot;value3&quot;</span>));</span><br><span class=\"line\">        System.out.println(jedis.get(<span class=\"string\">&quot;key3&quot;</span>));</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            TimeUnit.SECONDS.sleep(<span class=\"number\">3</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(jedis.get(<span class=\"string\">&quot;key3&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;===========获取原值，更新为新值==========&quot;</span>);</span><br><span class=\"line\">        System.out.println(jedis.getSet(<span class=\"string\">&quot;key2&quot;</span>, <span class=\"string\">&quot;key2GetSet&quot;</span>));</span><br><span class=\"line\">        System.out.println(jedis.get(<span class=\"string\">&quot;key2&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;获得key2的值的字串：&quot;</span> + jedis.getrange(<span class=\"string\">&quot;key2&quot;</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"对List操作命令\"><a href=\"#对List操作命令\" class=\"headerlink\" title=\"对List操作命令\"></a>对List操作命令</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestList</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Jedis jedis = <span class=\"keyword\">new</span> Jedis(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">6379</span>);</span><br><span class=\"line\">        jedis.flushDB();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;===========添加一个list===========&quot;</span>);</span><br><span class=\"line\">        jedis.lpush(<span class=\"string\">&quot;collections&quot;</span>, <span class=\"string\">&quot;ArrayList&quot;</span>, <span class=\"string\">&quot;Vector&quot;</span>, <span class=\"string\">&quot;Stack&quot;</span>, <span class=\"string\">&quot;HashMap&quot;</span>, <span class=\"string\">&quot;WeakHashMap&quot;</span>, <span class=\"string\">&quot;LinkedHashMap&quot;</span>);</span><br><span class=\"line\">        jedis.lpush(<span class=\"string\">&quot;collections&quot;</span>, <span class=\"string\">&quot;HashSet&quot;</span>);</span><br><span class=\"line\">        jedis.lpush(<span class=\"string\">&quot;collections&quot;</span>, <span class=\"string\">&quot;TreeSet&quot;</span>);</span><br><span class=\"line\">        jedis.lpush(<span class=\"string\">&quot;collections&quot;</span>, <span class=\"string\">&quot;TreeMap&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;collections的内容：&quot;</span> + jedis.lrange(<span class=\"string\">&quot;collections&quot;</span>, <span class=\"number\">0</span>, -<span class=\"number\">1</span>));<span class=\"comment\">//-1代表倒数第一个元素，-2代表倒数第二个元素,end为-1表示查询全部</span></span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;collections区间0-3的元素：&quot;</span> + jedis.lrange(<span class=\"string\">&quot;collections&quot;</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;===============================&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 删除列表指定的值 ，第二个参数为删除的个数（有重复时），后add进去的值先被删，类似于出栈</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;删除指定元素个数：&quot;</span> + jedis.lrem(<span class=\"string\">&quot;collections&quot;</span>, <span class=\"number\">2</span>, <span class=\"string\">&quot;HashMap&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;collections的内容：&quot;</span> + jedis.lrange(<span class=\"string\">&quot;collections&quot;</span>, <span class=\"number\">0</span>, -<span class=\"number\">1</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;删除下表0-3区间之外的元素：&quot;</span> + jedis.ltrim(<span class=\"string\">&quot;collections&quot;</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;collections的内容：&quot;</span> + jedis.lrange(<span class=\"string\">&quot;collections&quot;</span>, <span class=\"number\">0</span>, -<span class=\"number\">1</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;collections列表出栈（左端）：&quot;</span> + jedis.lpop(<span class=\"string\">&quot;collections&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;collections的内容：&quot;</span> + jedis.lrange(<span class=\"string\">&quot;collections&quot;</span>, <span class=\"number\">0</span>, -<span class=\"number\">1</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;collections添加元素，从列表右端，与lpush相对应：&quot;</span> + jedis.rpush(<span class=\"string\">&quot;collections&quot;</span>, <span class=\"string\">&quot;EnumMap&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;collections的内容：&quot;</span> + jedis.lrange(<span class=\"string\">&quot;collections&quot;</span>, <span class=\"number\">0</span>, -<span class=\"number\">1</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;collections列表出栈（右端）：&quot;</span> + jedis.rpop(<span class=\"string\">&quot;collections&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;collections的内容：&quot;</span> + jedis.lrange(<span class=\"string\">&quot;collections&quot;</span>, <span class=\"number\">0</span>, -<span class=\"number\">1</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;修改collections指定下标 1 的内容：&quot;</span> + jedis.lset(<span class=\"string\">&quot;collections&quot;</span>, <span class=\"number\">1</span>, <span class=\"string\">&quot;LinkedArrayList&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;collections的内容：&quot;</span> + jedis.lrange(<span class=\"string\">&quot;collections&quot;</span>, <span class=\"number\">0</span>, -<span class=\"number\">1</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;===============================&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;collections的长度：&quot;</span> + jedis.llen(<span class=\"string\">&quot;collections&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;获取collections下标为 2 的元素：&quot;</span> + jedis.lindex(<span class=\"string\">&quot;collections&quot;</span>, <span class=\"number\">2</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;===============================&quot;</span>);</span><br><span class=\"line\">        jedis.lpush(<span class=\"string\">&quot;sortedList&quot;</span>, <span class=\"string\">&quot;3&quot;</span>, <span class=\"string\">&quot;6&quot;</span>, <span class=\"string\">&quot;2&quot;</span>, <span class=\"string\">&quot;0&quot;</span>, <span class=\"string\">&quot;7&quot;</span>, <span class=\"string\">&quot;4&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;sortedList排序前：&quot;</span> + jedis.lrange(<span class=\"string\">&quot;sortedList&quot;</span>, <span class=\"number\">0</span>, -<span class=\"number\">1</span>));</span><br><span class=\"line\">        System.out.println(jedis.sort(<span class=\"string\">&quot;sortedList&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;sortedList排序后：&quot;</span> + jedis.lrange(<span class=\"string\">&quot;sortedList&quot;</span>, <span class=\"number\">0</span>, -<span class=\"number\">1</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"对Set的操作命令\"><a href=\"#对Set的操作命令\" class=\"headerlink\" title=\"对Set的操作命令\"></a>对Set的操作命令</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestSet</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Jedis jedis = <span class=\"keyword\">new</span> Jedis(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">6379</span>);</span><br><span class=\"line\">        jedis.flushDB();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;============向集合中添加元素（不重复）============&quot;</span>);</span><br><span class=\"line\">        System.out.println(jedis.sadd(<span class=\"string\">&quot;eleSet&quot;</span>, <span class=\"string\">&quot;e1&quot;</span>, <span class=\"string\">&quot;e2&quot;</span>, <span class=\"string\">&quot;e4&quot;</span>, <span class=\"string\">&quot;e3&quot;</span>, <span class=\"string\">&quot;e0&quot;</span>, <span class=\"string\">&quot;e8&quot;</span>, <span class=\"string\">&quot;e7&quot;</span>, <span class=\"string\">&quot;e5&quot;</span>));</span><br><span class=\"line\">        System.out.println(jedis.sadd(<span class=\"string\">&quot;eleSet&quot;</span>, <span class=\"string\">&quot;e6&quot;</span>));</span><br><span class=\"line\">        System.out.println(jedis.sadd(<span class=\"string\">&quot;eleSet&quot;</span>, <span class=\"string\">&quot;e6&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;eleSet的所有元素为：&quot;</span> + jedis.smembers(<span class=\"string\">&quot;eleSet&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;删除一个元素e0：&quot;</span> + jedis.srem(<span class=\"string\">&quot;eleSet&quot;</span>, <span class=\"string\">&quot;e0&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;eleSet的所有元素为：&quot;</span> + jedis.smembers(<span class=\"string\">&quot;eleSet&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;删除两个元素e7和e6：&quot;</span> + jedis.srem(<span class=\"string\">&quot;eleSet&quot;</span>, <span class=\"string\">&quot;e7&quot;</span>, <span class=\"string\">&quot;e6&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;eleSet的所有元素为：&quot;</span> + jedis.smembers(<span class=\"string\">&quot;eleSet&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;随机的移除集合中的一个元素：&quot;</span> + jedis.spop(<span class=\"string\">&quot;eleSet&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;随机的移除集合中的一个元素：&quot;</span> + jedis.spop(<span class=\"string\">&quot;eleSet&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;eleSet的所有元素为：&quot;</span> + jedis.smembers(<span class=\"string\">&quot;eleSet&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;eleSet中包含元素的个数：&quot;</span> + jedis.scard(<span class=\"string\">&quot;eleSet&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;e3是否在eleSet中：&quot;</span> + jedis.sismember(<span class=\"string\">&quot;eleSet&quot;</span>, <span class=\"string\">&quot;e3&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;e1是否在eleSet中：&quot;</span> + jedis.sismember(<span class=\"string\">&quot;eleSet&quot;</span>, <span class=\"string\">&quot;e1&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;e1是否在eleSet中：&quot;</span> + jedis.sismember(<span class=\"string\">&quot;eleSet&quot;</span>, <span class=\"string\">&quot;e5&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;=================================&quot;</span>);</span><br><span class=\"line\">        System.out.println(jedis.sadd(<span class=\"string\">&quot;eleSet1&quot;</span>, <span class=\"string\">&quot;e1&quot;</span>, <span class=\"string\">&quot;e2&quot;</span>, <span class=\"string\">&quot;e4&quot;</span>, <span class=\"string\">&quot;e3&quot;</span>, <span class=\"string\">&quot;e0&quot;</span>, <span class=\"string\">&quot;e8&quot;</span>, <span class=\"string\">&quot;e7&quot;</span>, <span class=\"string\">&quot;e5&quot;</span>));</span><br><span class=\"line\">        System.out.println(jedis.sadd(<span class=\"string\">&quot;eleSet2&quot;</span>, <span class=\"string\">&quot;e1&quot;</span>, <span class=\"string\">&quot;e2&quot;</span>, <span class=\"string\">&quot;e4&quot;</span>, <span class=\"string\">&quot;e3&quot;</span>, <span class=\"string\">&quot;e0&quot;</span>, <span class=\"string\">&quot;e8&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;将eleSet1中删除e1并存入eleSet3中：&quot;</span> + jedis.smove(<span class=\"string\">&quot;eleSet1&quot;</span>, <span class=\"string\">&quot;eleSet3&quot;</span>, <span class=\"string\">&quot;e1&quot;</span>));<span class=\"comment\">//移到集合元素</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;将eleSet1中删除e2并存入eleSet3中：&quot;</span> + jedis.smove(<span class=\"string\">&quot;eleSet1&quot;</span>, <span class=\"string\">&quot;eleSet3&quot;</span>, <span class=\"string\">&quot;e2&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;eleSet1中的元素：&quot;</span> + jedis.smembers(<span class=\"string\">&quot;eleSet1&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;eleSet3中的元素：&quot;</span> + jedis.smembers(<span class=\"string\">&quot;eleSet3&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;============集合运算=================&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;eleSet1中的元素：&quot;</span> + jedis.smembers(<span class=\"string\">&quot;eleSet1&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;eleSet2中的元素：&quot;</span> + jedis.smembers(<span class=\"string\">&quot;eleSet2&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;eleSet1和eleSet2的交集:&quot;</span> + jedis.sinter(<span class=\"string\">&quot;eleSet1&quot;</span>, <span class=\"string\">&quot;eleSet2&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;eleSet1和eleSet2的并集:&quot;</span> + jedis.sunion(<span class=\"string\">&quot;eleSet1&quot;</span>, <span class=\"string\">&quot;eleSet2&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;eleSet1和eleSet2的差集:&quot;</span> + jedis.sdiff(<span class=\"string\">&quot;eleSet1&quot;</span>, <span class=\"string\">&quot;eleSet2&quot;</span>));<span class=\"comment\">//eleSet1中有，eleSet2中没有</span></span><br><span class=\"line\">        jedis.sinterstore(<span class=\"string\">&quot;eleSet4&quot;</span>, <span class=\"string\">&quot;eleSet1&quot;</span>, <span class=\"string\">&quot;eleSet2&quot;</span>);<span class=\"comment\">//求交集并将交集保存到dstkey的集合</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;eleSet4中的元素：&quot;</span> + jedis.smembers(<span class=\"string\">&quot;eleSet4&quot;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"对Hash的操作命令\"><a href=\"#对Hash的操作命令\" class=\"headerlink\" title=\"对Hash的操作命令\"></a>对Hash的操作命令</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestHash</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Jedis jedis = <span class=\"keyword\">new</span> Jedis(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">6379</span>);</span><br><span class=\"line\">        jedis.flushDB();</span><br><span class=\"line\">        Map&lt;String, String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;key1&quot;</span>, <span class=\"string\">&quot;value1&quot;</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;key2&quot;</span>, <span class=\"string\">&quot;value2&quot;</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;key3&quot;</span>, <span class=\"string\">&quot;value3&quot;</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;key4&quot;</span>, <span class=\"string\">&quot;value4&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//添加名称为hash（key）的hash元素</span></span><br><span class=\"line\">        jedis.hmset(<span class=\"string\">&quot;hash&quot;</span>, map);</span><br><span class=\"line\">        <span class=\"comment\">//向名称为hash的hash中添加key为key5，value为value5元素</span></span><br><span class=\"line\">        jedis.hset(<span class=\"string\">&quot;hash&quot;</span>, <span class=\"string\">&quot;key5&quot;</span>, <span class=\"string\">&quot;value5&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;散列hash的所有键值对为：&quot;</span> + jedis.hgetAll(<span class=\"string\">&quot;hash&quot;</span>));<span class=\"comment\">//return Map&lt;String,String&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;散列hash的所有键为：&quot;</span> + jedis.hkeys(<span class=\"string\">&quot;hash&quot;</span>));<span class=\"comment\">//return</span></span><br><span class=\"line\">        Set&lt;String&gt;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;散列hash的所有值为：&quot;</span> + jedis.hvals(<span class=\"string\">&quot;hash&quot;</span>));<span class=\"comment\">//return</span></span><br><span class=\"line\">        List&lt;String&gt;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;将key6保存的值加上一个整数，如果key6不存在则添加key6：&quot;</span> + jedis.hincrBy(<span class=\"string\">&quot;hash&quot;</span>, <span class=\"string\">&quot;key6&quot;</span>, <span class=\"number\">6</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;散列hash的所有键值对为：&quot;</span> + jedis.hgetAll(<span class=\"string\">&quot;hash&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;将key6保存的值加上一个整数，如果key6不存在则添加key6：&quot;</span> + jedis.hincrBy(<span class=\"string\">&quot;hash&quot;</span>, <span class=\"string\">&quot;key6&quot;</span>, <span class=\"number\">3</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;散列hash的所有键值对为：&quot;</span> + jedis.hgetAll(<span class=\"string\">&quot;hash&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;删除一个或者多个键值对：&quot;</span> + jedis.hdel(<span class=\"string\">&quot;hash&quot;</span>, <span class=\"string\">&quot;key2&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;散列hash的所有键值对为：&quot;</span> + jedis.hgetAll(<span class=\"string\">&quot;hash&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;散列hash中键值对的个数：&quot;</span> + jedis.hlen(<span class=\"string\">&quot;hash&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;判断hash中是否存在key2：&quot;</span> + jedis.hexists(<span class=\"string\">&quot;hash&quot;</span>, <span class=\"string\">&quot;key2&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;判断hash中是否存在key3：&quot;</span> + jedis.hexists(<span class=\"string\">&quot;hash&quot;</span>, <span class=\"string\">&quot;key3&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;获取hash中的值：&quot;</span> + jedis.hmget(<span class=\"string\">&quot;hash&quot;</span>, <span class=\"string\">&quot;key3&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;获取hash中的值：&quot;</span> + jedis.hmget(<span class=\"string\">&quot;hash&quot;</span>, <span class=\"string\">&quot;key3&quot;</span>, <span class=\"string\">&quot;key4&quot;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h2><h3 id=\"基本操作-1\"><a href=\"#基本操作-1\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.kuang.multi;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class=\"line\"><span class=\"keyword\">import</span> redis.clients.jedis.Jedis;</span><br><span class=\"line\"><span class=\"keyword\">import</span> redis.clients.jedis.Transaction;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestMulti</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//创建客户端连接服务端，redis服务端需要被开启</span></span><br><span class=\"line\">        Jedis jedis = <span class=\"keyword\">new</span> Jedis(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">6379</span>);</span><br><span class=\"line\">        jedis.flushDB();</span><br><span class=\"line\"></span><br><span class=\"line\">        JSONObject jsonObject = <span class=\"keyword\">new</span> JSONObject();</span><br><span class=\"line\">        jsonObject.put(<span class=\"string\">&quot;hello&quot;</span>, <span class=\"string\">&quot;world&quot;</span>);</span><br><span class=\"line\">        jsonObject.put(<span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;java&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//开启事务</span></span><br><span class=\"line\">        Transaction multi = jedis.multi();</span><br><span class=\"line\">        String result = jsonObject.toJSONString();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//向redis存入一条数据</span></span><br><span class=\"line\">            multi.set(<span class=\"string\">&quot;json&quot;</span>, result);</span><br><span class=\"line\">            <span class=\"comment\">//再存入一条数据</span></span><br><span class=\"line\">            multi.set(<span class=\"string\">&quot;json2&quot;</span>, result);</span><br><span class=\"line\">            <span class=\"comment\">//这里引发了异常，用 0 作为被除数</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = <span class=\"number\">100</span> / <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"comment\">//如果没有引发异常，执行进入队列的命令</span></span><br><span class=\"line\">            multi.exec();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"comment\">//如果出现异常，回滚</span></span><br><span class=\"line\">            multi.discard();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            System.out.println(jedis.get(<span class=\"string\">&quot;json&quot;</span>));</span><br><span class=\"line\">            System.out.println(jedis.get(<span class=\"string\">&quot;json2&quot;</span>));</span><br><span class=\"line\">            <span class=\"comment\">//最终关闭客户端</span></span><br><span class=\"line\">            jedis.close();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"SpringBoot整合\"><a href=\"#SpringBoot整合\" class=\"headerlink\" title=\"SpringBoot整合\"></a>SpringBoot整合</h1><h2 id=\"基础使用\"><a href=\"#基础使用\" class=\"headerlink\" title=\"基础使用\"></a>基础使用</h2><h3 id=\"概述-1\"><a href=\"#概述-1\" class=\"headerlink\" title=\"概述\"></a>概述</h3><blockquote>\n<p>在SpringBoot中一般使用RedisTemplate提供的方法来操作Redis。那么使用SpringBoot整合Redis需要那些步骤呢。</p>\n</blockquote>\n<ul>\n<li>1 、 JedisPoolConfig (这个是配置连接池)</li>\n<li>2 、 RedisConnectionFactory 这个是配置连接信息，这里的RedisConnectionFactory是一个接口，我们需要使用它的实现类，在SpringD Data Redis方案中提供了以下四种工厂模型：<ul>\n<li>JredisConnectionFactory</li>\n<li>JedisConnectionFactory</li>\n<li>LettuceConnectionFactory</li>\n<li>SrpConnectionFactory</li>\n</ul>\n</li>\n<li>3 、 RedisTemplate 基本操作</li>\n</ul>\n<h3 id=\"导入依赖\"><a href=\"#导入依赖\" class=\"headerlink\" title=\"导入依赖\"></a>导入依赖</h3><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"yaml配置\"><a href=\"#yaml配置\" class=\"headerlink\" title=\"yaml配置\"></a>yaml配置</h3><figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"attr\">redis:</span></span><br><span class=\"line\">    <span class=\"attr\">host:</span> <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span></span><br><span class=\"line\">    <span class=\"attr\">port:</span> <span class=\"number\">6379</span></span><br><span class=\"line\">    <span class=\"attr\">password:</span> <span class=\"number\">123456</span></span><br><span class=\"line\">    <span class=\"attr\">jedis:</span></span><br><span class=\"line\">      <span class=\"attr\">pool:</span></span><br><span class=\"line\">        <span class=\"attr\">max-active:</span> <span class=\"number\">8</span></span><br><span class=\"line\">        <span class=\"attr\">max-wait:</span> <span class=\"string\">-1ms</span></span><br><span class=\"line\">        <span class=\"attr\">max-idle:</span> <span class=\"number\">500</span></span><br><span class=\"line\">        <span class=\"attr\">min-idle:</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"attr\">lettuce:</span></span><br><span class=\"line\">    <span class=\"attr\">shutdown-timeout:</span> <span class=\"string\">0ms</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"测试-1\"><a href=\"#测试-1\" class=\"headerlink\" title=\"测试\"></a>测试</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@SpringBootTest</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SpringbootRedisApplicationTests</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">contextLoads</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        redisTemplate.opsForValue().set(<span class=\"string\">&quot;myKey&quot;</span>, <span class=\"string\">&quot;myValue&quot;</span>);</span><br><span class=\"line\">        System.out.println(redisTemplate.opsForValue().get(<span class=\"string\">&quot;myKey&quot;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"封装工具类\"><a href=\"#封装工具类\" class=\"headerlink\" title=\"封装工具类\"></a>封装工具类</h2><ul>\n<li>1 、新建一个SpringBoot项目</li>\n<li>2 、导入redis的启动器</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>3 、配置redis，可以查看 RedisProperties 分析</li>\n</ul>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Redis服务器地址</span></span><br><span class=\"line\"><span class=\"string\">spring.redis.host=127.0.0.1</span></span><br><span class=\"line\">  <span class=\"comment\"># Redis服务器连接端口</span></span><br><span class=\"line\"><span class=\"string\">spring.redis.port=</span> <span class=\"number\">6379</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>4 、分析 RedisAutoConfiguration 自动配置类</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration(proxyBeanMethods = false)</span></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnClass(RedisOperations.class)</span></span><br><span class=\"line\"><span class=\"meta\">@EnableConfigurationProperties(RedisProperties.class)</span></span><br><span class=\"line\"><span class=\"meta\">@Import(&#123;LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class&#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedisAutoConfiguration</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"meta\">@ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> RedisTemplate&lt;Object, Object&gt;</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">redisTemplate</span><span class=\"params\">(RedisConnectionFactory redisConnectionFactory)</span> <span class=\"keyword\">throws</span> UnknownHostException </span>&#123;</span><br><span class=\"line\">        RedisTemplate&lt;Object, Object&gt; template = <span class=\"keyword\">new</span> RedisTemplate&lt;&gt;();</span><br><span class=\"line\">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> template;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"meta\">@ConditionalOnMissingBean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> StringRedisTemplate <span class=\"title\">stringRedisTemplate</span><span class=\"params\">(RedisConnectionFactory redisConnectionFactory)</span> <span class=\"keyword\">throws</span> UnknownHostException </span>&#123;</span><br><span class=\"line\">        StringRedisTemplate template = <span class=\"keyword\">new</span> StringRedisTemplate();</span><br><span class=\"line\">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> template;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>通过源码可以看出，SpringBoot自动帮我们在容器中生成了一个RedisTemplate和一个StringRedisTemplate。</p>\n</blockquote>\n<blockquote>\n<p>但是，这个RedisTemplate的泛型是&lt;Object,Object&gt;，写代码不方便，需要写好多类型转换的代码；我们需要一个泛型为&lt;String,Object&gt;形式的RedisTemplate。</p>\n</blockquote>\n<blockquote>\n<p>并且，这个RedisTemplate没有设置数据存在Redis时，key及value的序列化方式。</p>\n</blockquote>\n<blockquote>\n<p>看到这个@ConditionalOnMissingBean注解后，就知道如果Spring容器中有了RedisTemplate对象了，这个自动配置的RedisTemplate不会实例化。因此我们可以直接自己写个配置类，配置RedisTemplate。</p>\n</blockquote>\n<ul>\n<li>5 、既然自动配置不好用，就重新配置一个RedisTemplate</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.kuang.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.annotation.JsonAutoDetect;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.annotation.PropertyAccessor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedisConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> RedisTemplate&lt;String, Object&gt; <span class=\"title\">redisTemplate</span><span class=\"params\">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class=\"line\">        RedisTemplate&lt;String, Object&gt; template = <span class=\"keyword\">new</span> RedisTemplate&lt;String, Object&gt;();</span><br><span class=\"line\">        template.setConnectionFactory(factory);</span><br><span class=\"line\">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class=\"keyword\">new</span></span><br><span class=\"line\">                Jackson2JsonRedisSerializer(Object.class);</span><br><span class=\"line\">        ObjectMapper om = <span class=\"keyword\">new</span> ObjectMapper();</span><br><span class=\"line\">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class=\"line\">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class=\"line\">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class=\"line\">        StringRedisSerializer stringRedisSerializer = <span class=\"keyword\">new</span></span><br><span class=\"line\">                StringRedisSerializer();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// key采用String的序列化方式</span></span><br><span class=\"line\">        template.setKeySerializer(stringRedisSerializer);</span><br><span class=\"line\">        <span class=\"comment\">// hash的key也采用String的序列化方式</span></span><br><span class=\"line\">        template.setHashKeySerializer(stringRedisSerializer);</span><br><span class=\"line\">        <span class=\"comment\">// value序列化方式采用jackson</span></span><br><span class=\"line\">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class=\"line\">        <span class=\"comment\">// hash的value序列化方式采用jackson</span></span><br><span class=\"line\">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class=\"line\">        template.afterPropertiesSet();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> template;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>6 、写一个Redis工具类（直接用RedisTemplate操作Redis，需要很多行代码，因此直接封装好一个RedisUtils，这样写代码更方便点。这个RedisUtils交给Spring容器实例化，使用时直接注解注入。）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.kuang.utils;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.util.CollectionUtils;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Set;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.TimeUnit;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedisUtil</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class=\"line\"><span class=\"comment\">// =============================common============================</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 指定缓存失效时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> time 时间(秒)</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">expire</span><span class=\"params\">(String key, <span class=\"keyword\">long</span> time)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (time &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                redisTemplate.expire(key, time, TimeUnit.SECONDS);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 根据key 获取过期时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键 不能为null</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 时间(秒) 返回 0 代表为永久有效</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">getExpire</span><span class=\"params\">(String key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.getExpire(key, TimeUnit.SECONDS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 判断key是否存在</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true 存在 false不存在</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasKey</span><span class=\"params\">(String key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> redisTemplate.hasKey(key);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 删除缓存</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 可以传一个值 或多个</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">del</span><span class=\"params\">(String... key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key != <span class=\"keyword\">null</span> &amp;&amp; key.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key.length == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                redisTemplate.delete(key[<span class=\"number\">0</span>]);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                redisTemplate.delete(CollectionUtils.arrayToList(key));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">// ============================String=============================</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 普通缓存获取</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 值</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">get</span><span class=\"params\">(String key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> key == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : redisTemplate.opsForValue().get(key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 普通缓存放入</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true成功 false失败</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">set</span><span class=\"params\">(String key, Object value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            redisTemplate.opsForValue().set(key, value);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     普通缓存放入并设置时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> time 时间(秒) time要大于 0 如果time小于等于 0 将设置无限期</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true成功 false 失败</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">set</span><span class=\"params\">(String key, Object value, <span class=\"keyword\">long</span> time)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (time &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                redisTemplate.opsForValue().set(key, value, time,</span><br><span class=\"line\">                        TimeUnit.SECONDS);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                set(key, value);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     递增</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> delta 要增加几(大于0)</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">incr</span><span class=\"params\">(String key, <span class=\"keyword\">long</span> delta)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (delta &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;递增因子必须大于0&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.opsForValue().increment(key, delta);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 递减</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> delta 要减少几(小于0)</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">decr</span><span class=\"params\">(String key, <span class=\"keyword\">long</span> delta)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (delta &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;递减因子必须大于0&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.opsForValue().increment(key, -delta);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ================================Map=================================</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * HashGet</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键 不能为null</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> item 项 不能为null</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">hget</span><span class=\"params\">(String key, String item)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.opsForHash().get(key, item);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取hashKey对应的所有键值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 对应的多个键值</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Map&lt;Object, Object&gt; <span class=\"title\">hmget</span><span class=\"params\">(String key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.opsForHash().entries(key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * HashSet</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> map 对应多个键值</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hmset</span><span class=\"params\">(String key, Map&lt;String, Object&gt; map)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            redisTemplate.opsForHash().putAll(key, map);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * HashSet 并设置时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> map 对应多个键值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> time 时间(秒)</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true成功 false失败</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hmset</span><span class=\"params\">(String key, Map&lt;String, Object&gt; map, <span class=\"keyword\">long</span> time)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            redisTemplate.opsForHash().putAll(key, map);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (time &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                expire(key, time);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> item 项</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true 成功 false失败</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hset</span><span class=\"params\">(String key, String item, Object value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            redisTemplate.opsForHash().put(key, item, value);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> item 项</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> time 时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true 成功 false失败</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hset</span><span class=\"params\">(String key, String item, Object value, <span class=\"keyword\">long</span> time)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            redisTemplate.opsForHash().put(key, item, value);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (time &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                expire(key, time);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 删除hash表中的值</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键 不能为null</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> item 项 可以使多个 不能为null</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hdel</span><span class=\"params\">(String key, Object... item)</span> </span>&#123;</span><br><span class=\"line\">        redisTemplate.opsForHash().delete(key, item);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 判断hash表中是否有该项的值</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键 不能为null</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> item 项 不能为null</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true 存在 false不存在</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hHasKey</span><span class=\"params\">(String key, String item)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.opsForHash().hasKey(key, item);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * hash递增 如果不存在,就会创建一个 并把新增后的值返回</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> item 项</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> by 要增加几(大于0)</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">hincr</span><span class=\"params\">(String key, String item, <span class=\"keyword\">double</span> by)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.opsForHash().increment(key, item, by);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * hash递减</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> item 项</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> by 要减少记(小于0)</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">hdecr</span><span class=\"params\">(String key, String item, <span class=\"keyword\">double</span> by)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.opsForHash().increment(key, item, -by);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">// ============================set=============================</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 根据key获取Set中的所有值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Set&lt;Object&gt; <span class=\"title\">sGet</span><span class=\"params\">(String key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> redisTemplate.opsForSet().members(key);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 根据value从一个set中查询,是否存在</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true 存在 false不存在</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sHasKey</span><span class=\"params\">(String key, Object value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> redisTemplate.opsForSet().isMember(key, value);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将数据放入set缓存</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> values 值 可以是多个</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 成功个数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">sSet</span><span class=\"params\">(String key, Object... values)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> redisTemplate.opsForSet().add(key, values);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将set数据放入缓存</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> time 时间(秒)</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> values 值 可以是多个</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 成功个数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">sSetAndTime</span><span class=\"params\">(String key, <span class=\"keyword\">long</span> time, Object... values)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Long count = redisTemplate.opsForSet().add(key, values);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (time &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                expire(key, time);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取set缓存的长度</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">sGetSetSize</span><span class=\"params\">(String key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> redisTemplate.opsForSet().size(key);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 移除值为value的</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> values 值 可以是多个</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 移除的个数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">setRemove</span><span class=\"params\">(String key, Object... values)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Long count = redisTemplate.opsForSet().remove(key, values);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">// ===============================list=================================</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取list缓存的内容</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> start 开始</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> end 结束 0 到 -1代表所有值</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Object&gt; <span class=\"title\">lGet</span><span class=\"params\">(String key, <span class=\"keyword\">long</span> start, <span class=\"keyword\">long</span> end)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> redisTemplate.opsForList().range(key, start, end);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取list缓存的长度</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">lGetListSize</span><span class=\"params\">(String key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> redisTemplate.opsForList().size(key);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 通过索引 获取list中的值</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> index 索引 index&gt;=0时， 0 表头， 1 第二个元素，依次类推；index&lt;0</span></span><br><span class=\"line\"><span class=\"comment\">    时，-1，表尾，-2倒数第二个元素，依次类推</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">lGetIndex</span><span class=\"params\">(String key, <span class=\"keyword\">long</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> redisTemplate.opsForList().index(key, index);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将list放入缓存</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 值</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">lSet</span><span class=\"params\">(String key, Object value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            redisTemplate.opsForList().rightPush(key, value);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将list放入缓存</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> time 时间(秒)</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">lSet</span><span class=\"params\">(String key, Object value, <span class=\"keyword\">long</span> time)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            redisTemplate.opsForList().rightPush(key, value);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (time &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                expire(key, time);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将list放入缓存</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">lSet</span><span class=\"params\">(String key, List&lt;Object&gt; value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将list放入缓存</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> time 时间(秒)</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">lSet</span><span class=\"params\">(String key, List&lt;Object&gt; value, <span class=\"keyword\">long</span> time)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (time &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                expire(key, time);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 根据索引修改list中的某条数据</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> index 索引</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">lUpdateIndex</span><span class=\"params\">(String key, <span class=\"keyword\">long</span> index, Object value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            redisTemplate.opsForList().set(key, index, value);</span><br><span class=\"line\">            ren <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 移除N个值为value</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> count 移除多少个</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 移除的个数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">lRemove</span><span class=\"params\">(String key, <span class=\"keyword\">long</span> count, Object value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Long remove = redisTemplate.opsForList().remove(key, count, value);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> remove;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Redis-conf\"><a href=\"#Redis-conf\" class=\"headerlink\" title=\"Redis.conf\"></a>Redis.conf</h1><h2 id=\"熟悉基本配置\"><a href=\"#熟悉基本配置\" class=\"headerlink\" title=\"熟悉基本配置\"></a>熟悉基本配置</h2><blockquote>\n<p>位置</p>\n</blockquote>\n<p>Redis 的配置文件位于 Redis 安装目录下，文件名为 redis.conf</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">config get *  # 获取全部的配置</span><br></pre></td></tr></table></figure>\n\n<p>配置文件的地址：</p>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927102035.png\" class title=\"输入图片说明\">\n\n<p>我们一般情况下，会单独拷贝出来一份进行操作。来保证初始文件的安全。</p>\n<h3 id=\"Units-单位\"><a href=\"#Units-单位\" class=\"headerlink\" title=\"Units 单位\"></a>Units 单位</h3><img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927102059.png\" class title=\"输入图片说明\">\n\n<ul>\n<li>1 、配置大小单位，开头定义了一些基本的度量单位，只支持bytes，不支持bit</li>\n<li>2 、对 大小写 不敏感</li>\n</ul>\n<h3 id=\"INCLUDES-包含\"><a href=\"#INCLUDES-包含\" class=\"headerlink\" title=\"INCLUDES 包含\"></a>INCLUDES 包含</h3><p>和Spring配置文件类似，可以通过includes包含，redis.conf 可以作为总文件，可以包含其他文件！</p>\n<h3 id=\"NETWORK-网络配置\"><a href=\"#NETWORK-网络配置\" class=\"headerlink\" title=\"NETWORK 网络配置\"></a>NETWORK 网络配置</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">bind 127.0.0.1  # 绑定的ip</span><br><span class=\"line\">protected-mode yes # 保护模式</span><br><span class=\"line\">port 6379 # 默认端口</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"GENERAL-通用\"><a href=\"#GENERAL-通用\" class=\"headerlink\" title=\"GENERAL 通用\"></a>GENERAL 通用</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">daemonize yes # 默认情况下，Redis不作为守护进程运行。需要开启的话，改为 yes</span><br><span class=\"line\"></span><br><span class=\"line\">supervised no  # 可通过upstart和systemd管理Redis守护进程</span><br><span class=\"line\"></span><br><span class=\"line\">pidfile /var/run/redis_6379.pid  # 以后台进程方式运行redis，则需要指定pid 文件</span><br><span class=\"line\"></span><br><span class=\"line\">loglevel notice # 日志级别。可选项有：</span><br><span class=\"line\"># debug（记录大量日志信息，适用于开发、测试阶段）；</span><br><span class=\"line\"># verbose（较多日志信息）；</span><br><span class=\"line\"># notice（适量日志信息，使用于生产环境）；</span><br><span class=\"line\"># warning（仅有部分重要、关键信息才会被记录）。</span><br><span class=\"line\"></span><br><span class=\"line\">logfile &quot;&quot; # 日志文件的位置，当指定为空字符串时，为标准输出</span><br><span class=\"line\">databases 16 # 设置数据库的数目。默认的数据库是DB 0</span><br><span class=\"line\">always-show-logo yes # 是否总是显示logo</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"SNAPSHOPTING-快照\"><a href=\"#SNAPSHOPTING-快照\" class=\"headerlink\" title=\"SNAPSHOPTING 快照\"></a>SNAPSHOPTING 快照</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 900秒（ 15 分钟）内至少 1 个key值改变（则进行数据库保存--持久化）</span><br><span class=\"line\">save 900 1</span><br><span class=\"line\"># 300秒（ 5 分钟）内至少 10 个key值改变（则进行数据库保存--持久化）</span><br><span class=\"line\">save 300 10</span><br><span class=\"line\"># 60秒（ 1 分钟）内至少 10000 个key值改变（则进行数据库保存--持久化）</span><br><span class=\"line\">save 60 10000</span><br><span class=\"line\"></span><br><span class=\"line\">stop-writes-on-bgsave-error yes # 持久化出现错误后，是否依然进行继续进行工作</span><br><span class=\"line\"></span><br><span class=\"line\">rdbcompression yes # 使用压缩rdb文件 yes：压缩，但是需要一些cpu的消耗。no：不压</span><br><span class=\"line\">缩，需要更多的磁盘空间</span><br><span class=\"line\"></span><br><span class=\"line\">rdbchecksum yes # 是否校验rdb文件，更有利于文件的容错性，但是在保存rdb文件的时</span><br><span class=\"line\">候，会有大概10%的性能损耗</span><br><span class=\"line\"></span><br><span class=\"line\">dbfilename dump.rdb  # dbfilenamerdb文件名称</span><br><span class=\"line\"></span><br><span class=\"line\">dir./  # dir 数据目录，数据库的写入会在这个目录。rdb、aof文件也会写在这个目录</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"REPLICATION-复制-我们后面讲主从复制再给大家讲解！这里先跳过！\"><a href=\"#REPLICATION-复制-我们后面讲主从复制再给大家讲解！这里先跳过！\" class=\"headerlink\" title=\"REPLICATION 复制 我们后面讲主从复制再给大家讲解！这里先跳过！\"></a>REPLICATION 复制 我们后面讲主从复制再给大家讲解！这里先跳过！</h3><h3 id=\"SECURITY安全\"><a href=\"#SECURITY安全\" class=\"headerlink\" title=\"SECURITY安全\"></a>SECURITY安全</h3><p>访问密码的查看，设置和取消</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 启动redis</span><br><span class=\"line\"># 连接客户端</span><br><span class=\"line\"></span><br><span class=\"line\"># 获得和设置密码</span><br><span class=\"line\">config get requirepass</span><br><span class=\"line\">config set requirepass &quot;123456&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">#测试ping，发现需要验证</span><br><span class=\"line\">127.0.0.1:6379&gt; ping</span><br><span class=\"line\">NOAUTH Authentication required.</span><br><span class=\"line\"># 验证</span><br><span class=\"line\">127.0.0.1:6379&gt; auth 123456</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; ping</span><br><span class=\"line\">PONG</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"限制\"><a href=\"#限制\" class=\"headerlink\" title=\"限制\"></a>限制</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">maxclients 10000 # 设置能连上redis的最大客户端连接数量</span><br><span class=\"line\">maxmemory &lt;bytes&gt; # redis配置的最大内存容量</span><br><span class=\"line\">maxmemory-policy noeviction # maxmemory-policy 内存达到上限的处理策略</span><br><span class=\"line\">#volatile-lru：利用LRU算法移除设置过过期时间的key。</span><br><span class=\"line\">#volatile-random：随机移除设置过过期时间的key。</span><br><span class=\"line\">#volatile-ttl：移除即将过期的key，根据最近过期时间来删除（辅以TTL）</span><br><span class=\"line\">#allkeys-lru：利用LRU算法移除任何key。</span><br><span class=\"line\">#allkeys-random：随机移除任何key。</span><br><span class=\"line\">#noeviction：不移除任何key，只是返回一个写错误。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"append-only模式\"><a href=\"#append-only模式\" class=\"headerlink\" title=\"append only模式\"></a>append only模式</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">appendonly no # 是否以append only模式作为持久化方式，默认使用的是rdb方式持久化，这种</span><br><span class=\"line\">方式在许多应用中已经足够用了</span><br><span class=\"line\">appendfilename &quot;appendonly.aof&quot; # appendfilename AOF 文件名称</span><br><span class=\"line\">appendfsync everysec  # appendfsync aof持久化策略的配置</span><br><span class=\"line\"># no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快。</span><br><span class=\"line\"># always表示每次写入都执行fsync，以保证数据同步到磁盘。</span><br><span class=\"line\"># everysec表示每秒执行一次fsync，可能会导致丢失这1s数据。</span><br></pre></td></tr></table></figure>\n\n<p>具体的我们会在后面讲解Redis的持久化配置的时候进行讲解！先了解下，听个耳音！</p>\n<h2 id=\"常见配置介绍\"><a href=\"#常见配置介绍\" class=\"headerlink\" title=\"常见配置介绍\"></a>常见配置介绍</h2><p>1 、Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程</p>\n<blockquote>\n<p>daemonize no</p>\n</blockquote>\n<p>2 、当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定</p>\n<blockquote>\n<p>pidfile /var/run/redis.pid</p>\n</blockquote>\n<p>3 、指定Redis监听端口，默认端口为 6379 ，作者在自己的一篇博文中解释了为什么选用 6379 作为默认端口，因为 6379 在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字</p>\n<blockquote>\n<p>port 6379</p>\n</blockquote>\n<p>4 、绑定的主机地址</p>\n<blockquote>\n<p>bind 127.0.0.1</p>\n</blockquote>\n<p>5 、当 客户端闲置多长时间后关闭连接，如果指定为 0 ，表示关闭该功能</p>\n<blockquote>\n<p>timeout 300</p>\n</blockquote>\n<p>6 、指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose</p>\n<blockquote>\n<p>loglevel verbose</p>\n</blockquote>\n<p>7 、日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null</p>\n<blockquote>\n<p>logfile stdout</p>\n</blockquote>\n<p>8 、设置数据库的数量，默认数据库为 0 ，可以使用SELECT 命令在连接上指定数据库id</p>\n<blockquote>\n<p>databases 16</p>\n</blockquote>\n<p>9 、指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</p>\n<blockquote>\n<p>save Redis默认配置文件中提供了三个条件： save 900 1 save 300 10 save 60 10000 分别表示 900 秒（ 15 分钟）内有 1 个更改， 300 秒（ 5 分钟）内有 10 个更改以及 60 秒内有 10000 个更改。</p>\n</blockquote>\n<p>10 、指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大</p>\n<blockquote>\n<p>rdbcompression yes</p>\n</blockquote>\n<p>11 、指定本地数据库文件名，默认值为dump.rdb</p>\n<blockquote>\n<p>dbfilename dump.rdb</p>\n</blockquote>\n<p>12 、指定本地数据库存放目录</p>\n<blockquote>\n<p>dir./</p>\n</blockquote>\n<p>13 、设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步</p>\n<blockquote>\n<p>slaveof</p>\n</blockquote>\n<p>14 、当master服务设置了密码保护时，slav服务连接master的密码</p>\n<blockquote>\n<p>masterauth</p>\n</blockquote>\n<p>15 、设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH 命令提供密码，默认关闭</p>\n<blockquote>\n<p>requirepass foobared</p>\n</blockquote>\n<p>16 、设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients<br>0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息</p>\n<blockquote>\n<p>maxclients 128</p>\n</blockquote>\n<p>17 、指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理<br>后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区</p>\n<blockquote>\n<p>maxmemory</p>\n</blockquote>\n<p>18 、指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为<br>redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no</p>\n<blockquote>\n<p>appendonly no</p>\n</blockquote>\n<p>19 、指定更新日志文件名，默认为appendonly.aof</p>\n<blockquote>\n<p>appendfilename appendonly.aof</p>\n</blockquote>\n<p>20 、指定更新日志条件，共有 3 个可选值：</p>\n<blockquote>\n<p>no：表示等操作系统进行数据缓存同步到磁盘（快）<br><br>always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）<br><br>everysec：表示每秒同步一次（折衷，默认值）<br><br>appendfsync everysec<br></p>\n</blockquote>\n<p>21 、指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制）</p>\n<blockquote>\n<p>vm-enabled no</p>\n</blockquote>\n<p>22 、虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享</p>\n<blockquote>\n<p>vm-swap-file /tmp/redis.swap</p>\n</blockquote>\n<p>23 、将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为 0<br>的时候,其实是所有value都存在于磁盘。默认值为 0</p>\n<blockquote>\n<p>vm-max-memory 0</p>\n</blockquote>\n<p>24 、Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为 32<br>或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值</p>\n<blockquote>\n<p>vm-page-size 32</p>\n</blockquote>\n<p>25 、设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每 8 个pages将消耗1byte的内存。</p>\n<blockquote>\n<p>vm-pages 134217728</p>\n</blockquote>\n<p>26 、设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为 4</p>\n<blockquote>\n<p>vm-max-threads 4</p>\n</blockquote>\n<p>27 、设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启</p>\n<blockquote>\n<p>glueoutputbuf yes</p>\n</blockquote>\n<p>28 、指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</p>\n<blockquote>\n<p>hash-max-zipmap-entries 64<br><br>hash-max-zipmap-value 512</p>\n</blockquote>\n<p>29 、指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍）</p>\n<blockquote>\n<p>activerehashing yes</p>\n</blockquote>\n<blockquote>\n<p>30 、指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件</p>\n</blockquote>\n<blockquote>\n<p>include /path/to/local.conf</p>\n</blockquote>\n<h1 id=\"Redis的持久化\"><a href=\"#Redis的持久化\" class=\"headerlink\" title=\"Redis的持久化\"></a>Redis的持久化</h1><blockquote>\n<p>Redis 是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以 Redis 提供了持久化功能！</p>\n</blockquote>\n<h2 id=\"RDB（Redis-DataBase）\"><a href=\"#RDB（Redis-DataBase）\" class=\"headerlink\" title=\"RDB（Redis DataBase）\"></a>RDB（Redis DataBase）</h2><h3 id=\"什么是RDB\"><a href=\"#什么是RDB\" class=\"headerlink\" title=\"什么是RDB\"></a>什么是RDB</h3><blockquote>\n<p>在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。</p>\n</blockquote>\n<blockquote>\n<p>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。</p>\n</blockquote>\n<h3 id=\"Fork\"><a href=\"#Fork\" class=\"headerlink\" title=\"Fork\"></a>Fork</h3><blockquote>\n<p>Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量，环境变量，程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。</p>\n</blockquote>\n<p><strong>Rdb 保存的是 dump.rdb 文件</strong></p>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927110129.png\" class title=\"输入图片说明\">\n\n<h3 id=\"配置位置及SNAPSHOTTING解析\"><a href=\"#配置位置及SNAPSHOTTING解析\" class=\"headerlink\" title=\"配置位置及SNAPSHOTTING解析\"></a>配置位置及SNAPSHOTTING解析</h3><img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927110152.png\" class title=\"输入图片说明\">\n\n<h3 id=\"这里的触发条件机制，我们可以修改测试一下：\"><a href=\"#这里的触发条件机制，我们可以修改测试一下：\" class=\"headerlink\" title=\"这里的触发条件机制，我们可以修改测试一下：\"></a>这里的触发条件机制，我们可以修改测试一下：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">save 120 10 # 120秒内修改 10 次则触发RDB</span><br></pre></td></tr></table></figure>\n\n<p>RDB 是整合内存的压缩过的Snapshot，RDB 的数据结构，可以配置复合的快照触发条件。 默认：</p>\n<ul>\n<li>1 分钟内改了 1 万次</li>\n<li>5 分钟内改了 10 次</li>\n<li>15 分钟内改了 1 次</li>\n</ul>\n<p>如果想禁用RDB持久化的策略，只要不设置任何save指令，或者给save传入一个空字符串参数也可以。若要修改完毕需要立马生效，可以手动使用 save 命令！立马生效!</p>\n<h3 id=\"其余命令解析\"><a href=\"#其余命令解析\" class=\"headerlink\" title=\"其余命令解析\"></a>其余命令解析</h3><p>Stop-writes-on-bgsave-error：如果配置为no，表示你不在乎数据不一致或者有其他的手段发现和控制，默认为yes。</p>\n<p>rbdcompression：对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩，如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能。</p>\n<p>rdbchecksum：在存储快照后，还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。默认为yes。</p>\n<h3 id=\"如何触发RDB快照\"><a href=\"#如何触发RDB快照\" class=\"headerlink\" title=\"如何触发RDB快照\"></a>如何触发RDB快照</h3><ul>\n<li><p>1 、配置文件中默认的快照配置，建议多用一台机子作为备份，复制一份 dump.rdb</p>\n</li>\n<li><p>2 、命令save或者是bgsave</p>\n<ul>\n<li>save 时只管保存，其他不管，全部阻塞</li>\n<li>bgsave，Redis 会在后台异步进行快照操作，快照同时还可以响应客户端请求。可以通过lastsave命令获取最后一次成功执行快照的时间。</li>\n</ul>\n</li>\n<li><p>3 、执行flushall命令，也会产生 dump.rdb 文件，但里面是空的，无意义!</p>\n</li>\n<li><p>4 、退出的时候也会产生 dump.rdb 文件！</p>\n</li>\n</ul>\n<h3 id=\"如何恢复\"><a href=\"#如何恢复\" class=\"headerlink\" title=\"如何恢复\"></a>如何恢复</h3><ul>\n<li>1 、将备份文件（dump.rdb）移动到redis安装目录并启动服务即可</li>\n<li>2 、CONFIG GET dir 获取目录</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; config get dir</span><br><span class=\"line\">dir</span><br><span class=\"line\">/usr/local/bin</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"优点和缺点\"><a href=\"#优点和缺点\" class=\"headerlink\" title=\"优点和缺点\"></a>优点和缺点</h3><h3 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><ul>\n<li>1 、适合大规模的数据恢复</li>\n<li>2 、对数据完整性和一致性要求不高</li>\n</ul>\n<h3 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h3><ul>\n<li>1 、在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改</li>\n<li>2 、Fork的时候，内存中的数据被克隆了一份，大致 2 倍的膨胀性需要考虑。</li>\n</ul>\n<h3 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h3><img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927111622.png\" class title=\"输入图片说明\">\n\n<h2 id=\"AOF（Append-Only-File）\"><a href=\"#AOF（Append-Only-File）\" class=\"headerlink\" title=\"AOF（Append Only File）\"></a>AOF（Append Only File）</h2><blockquote>\n<p>是什么</p>\n</blockquote>\n<blockquote>\n<p>以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p>\n</blockquote>\n<p><code>Aof保存的是 appendonly.aof 文件</code></p>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927111724.png\" class title=\"输入图片说明\">\n\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">appendonly no # 是否以append only模式作为持久化方式，默认使用的是rdb方式持久化，这</span><br><span class=\"line\">种方式在许多应用中已经足够用了</span><br><span class=\"line\"></span><br><span class=\"line\">appendfilename &quot;appendonly.aof&quot; # appendfilename AOF 文件名称</span><br><span class=\"line\"></span><br><span class=\"line\">appendfsync everysec  # appendfsync aof持久化策略的配置</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> always表示每次写入都执行fsync，以保证数据同步到磁盘。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> everysec表示每秒执行一次fsync，可能会导致丢失这1s数据。</span></span><br><span class=\"line\"></span><br><span class=\"line\">No-appendfsync-on-rewrite #重写时是否可以运用Appendfsync，用默认no即可，保证数据安</span><br><span class=\"line\">全性</span><br><span class=\"line\"></span><br><span class=\"line\">Auto-aof-rewrite-min-size # 设置重写的基准值</span><br><span class=\"line\"></span><br><span class=\"line\">Auto-aof-rewrite-percentage #设置重写的基准值</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"AOF-启动-修复-恢复\"><a href=\"#AOF-启动-修复-恢复\" class=\"headerlink\" title=\"AOF 启动/修复/恢复\"></a>AOF 启动/修复/恢复</h3><p>正常恢复：</p>\n<ul>\n<li>启动：设置Yes，修改默认的appendonly no，改为yes</li>\n<li>将有数据的aof文件复制一份保存到对应目录（config get dir）</li>\n<li>恢复：重启redis然后重新加载</li>\n</ul>\n<p>异常恢复：</p>\n<ul>\n<li>启动：设置Yes</li>\n<li>故意破坏 appendonly.aof 文件！</li>\n<li>修复： redis-check-aof –fix appendonly.aof 进行修复</li>\n<li>恢复：重启 redis 然后重新加载</li>\n</ul>\n<h3 id=\"Rewrite\"><a href=\"#Rewrite\" class=\"headerlink\" title=\"Rewrite\"></a>Rewrite</h3><p>是什么：</p>\n<blockquote>\n<p>AOF 采用文件追加方式，文件会越来越大，为避免出现此种情况，新增了重写机制，当AOF文件的大小超过所设定的阈值时，Redis 就会启动AOF 文件的内容压缩，只保留可以恢复数据的最小指令集，可以使用命令 bgrewriteaof ！</p>\n</blockquote>\n<h3 id=\"重写原理：\"><a href=\"#重写原理：\" class=\"headerlink\" title=\"重写原理：\"></a>重写原理：</h3><blockquote>\n<p>AOF 文件持续增长而过大时，会fork出一条新进程来将文件重写（也是先写临时文件最后再rename），遍历新进程的内存中数据，每条记录有一条的Set语句。重写aof文件的操作，并没有读取旧的aof文件，这点和快照有点类似！</p>\n</blockquote>\n<h3 id=\"触发机制：\"><a href=\"#触发机制：\" class=\"headerlink\" title=\"触发机制：\"></a>触发机制：</h3><blockquote>\n<p>Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的已被且文件大于64M的触发。</p>\n</blockquote>\n<p><code>行家一出手，就只有没有，内行看门道，外行看热闹</code></p>\n<h3 id=\"优点和缺点-1\"><a href=\"#优点和缺点-1\" class=\"headerlink\" title=\"优点和缺点\"></a>优点和缺点</h3><h3 id=\"优点：-1\"><a href=\"#优点：-1\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><ul>\n<li>1 、每修改同步：appendfsync always 同步持久化，每次发生数据变更会被立即记录到磁盘，性能较差但数据完整性比较好</li>\n<li>2 、每秒同步： appendfsync everysec 异步操作，每秒记录 ，如果一秒内宕机，有数据丢失</li>\n<li>3 、不同步： appendfsync no 从不同步</li>\n</ul>\n<h3 id=\"缺点：-1\"><a href=\"#缺点：-1\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h3><ul>\n<li>1 、相同数据集的数据而言，aof 文件要远大于 rdb文件，恢复速度慢于 rdb。</li>\n<li>2 、Aof 运行效率要慢于 rdb，每秒同步策略效率较好，不同步效率和rdb相同。</li>\n</ul>\n<h3 id=\"小总结\"><a href=\"#小总结\" class=\"headerlink\" title=\"小总结\"></a>小总结</h3><img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927112007.png\" class title=\"输入图片说明\">\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li><p>1 、RDB 持久化方式能够在指定的时间间隔内对你的数据进行快照存储</p>\n</li>\n<li><p>2 、AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以Redis 协议追加保存每次写的操作到文件末尾，Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大。</p>\n</li>\n<li><p>3 、只做缓存，如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化</p>\n</li>\n<li><p>4 、同时开启两种持久化方式</p>\n<ul>\n<li>在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。</li>\n<li>RDB<br>的数据不实时，同时使用两者时服务器重启也只会找AOF文件，那要不要只使用AOF呢？作者建议不要，因为RDB更适合用于备份数据库（AOF在不断变化不好备份），快速重启，而且不会有AOF可能潜在的Bug，留着作为一个万一的手段。</li>\n</ul>\n</li>\n<li><p>5 、性能建议</p>\n<ul>\n<li>因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要 15 分钟备份一次就够了，只保留 save 900 1 这条规则。</li>\n<li>如果Enable AOF ，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了，代价一是带来了持续的IO，二是AOF rewrite 的最后将 rewrite<br>过程中产生的新数据写到新文件 造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重写可以改到适当的数值。</li>\n<li>如果不Enable AOF ，仅靠 Master-Slave Repllcation 实现高可用性也可以，能省掉一大笔IO，也减少了rewrite时带来的系统波动。代价是如果Master/Slave<br>同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个 Master/Slave 中的 RDB文件，载入较新的那个，微博就是这种架构。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Redis-发布订阅\"><a href=\"#Redis-发布订阅\" class=\"headerlink\" title=\"Redis 发布订阅\"></a>Redis 发布订阅</h1><p>是什么</p>\n<ul>\n<li>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</li>\n<li>Redis 客户端可以订阅任意数量的频道。</li>\n</ul>\n<p>订阅/发布消息图：</p>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927113113.png\" class title=\"输入图片说明\">\n\n<p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的</p>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927113126.png\" class title=\"输入图片说明\">\n\n<p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：</p>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927113242.png\" class title=\"输入图片说明\">\n\n<h3 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h3><p>这些命令被广泛用于构建即时通信应用，比如网络聊天室(chatroom)和实时广播、实时提醒等。</p>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927113307.png\" class title=\"输入图片说明\">\n\n<h3 id=\"测试-2\"><a href=\"#测试-2\" class=\"headerlink\" title=\"测试\"></a>测试</h3><p>以下实例演示了发布订阅是如何工作的。在我们实例中我们创建了订阅频道名为 redisChat :</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">redis 127.0.0.1:6379&gt; SUBSCRIBE redisChat</span><br><span class=\"line\"></span><br><span class=\"line\">Reading messages... (press Ctrl-C to quit)</span><br><span class=\"line\">1 ) &quot;subscribe&quot;</span><br><span class=\"line\">2 ) &quot;redisChat&quot;</span><br><span class=\"line\">3 ) (integer) 1</span><br></pre></td></tr></table></figure>\n\n<p>现在，我们先重新开启个 redis 客户端，然后在同一个频道 redisChat 发布两次消息，订阅者就能接收到消息。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">redis 127.0.0.1:6379&gt; PUBLISH redisChat &quot;Hello,Redis&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">redis 127.0.0.1:6379&gt; PUBLISH redisChat &quot;Hello，Kuangshen&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 订阅者的客户端会显示如下消息</span></span><br><span class=\"line\">1 ) &quot;message&quot;</span><br><span class=\"line\">2 ) &quot;redisChat&quot;</span><br><span class=\"line\">3 ) &quot;Hello,Redis&quot;</span><br><span class=\"line\">1 ) &quot;message&quot;</span><br><span class=\"line\">2 ) &quot;redisChat&quot;</span><br><span class=\"line\">3 ) &quot;Hello，Kuangshen&quot;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><blockquote>\n<p>Redis是使用C实现的，通过分析 Redis 源码里的 pubsub.c 文件，了解发布和订阅机制的底层实现，籍此加深对 Redis 的理解。</p>\n</blockquote>\n<blockquote>\n<p>Redis 通过 PUBLISH 、SUBSCRIBE 和 PSUBSCRIBE 等命令实现发布和订阅功能。通过 SUBSCRIBE 命令订阅某频道后，redis-server 里维护了一个字典，字典的键就是一个个 channel，而字典的值则是一个链表，链表中保存了所有订阅这个 channel 的客户端。SUBSCRIBE 命令的关键，就是将客户端添加到给定 channel 的订阅链表中。</p>\n</blockquote>\n<blockquote>\n<p>通过 PUBLISH 命令向订阅者发送消息，redis-server 会使用给定的频道作为键，在它所维护的 channel字典中查找记录了订阅这个频道的所有客户端的链表，遍历这个链表，将消息发布给所有订阅者。</p>\n</blockquote>\n<blockquote>\n<p>Pub/Sub 从字面上理解就是发布（Publish）与订阅（Subscribe），在Redis中，你可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。</p>\n</blockquote>\n<h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><blockquote>\n<p>Pub/Sub构建实时消息系统</p>\n</blockquote>\n<blockquote>\n<p>Redis的Pub/Sub系统可以构建实时的消息系统</p>\n</blockquote>\n<blockquote>\n<p>比如很多用Pub/Sub构建的实时聊天系统的例子。</p>\n</blockquote>\n<h1 id=\"Redis主从复制\"><a href=\"#Redis主从复制\" class=\"headerlink\" title=\"Redis主从复制\"></a>Redis主从复制</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><blockquote>\n<p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master/leader)，后者称为从节点(slave/follower)；数据的复制是单向的，只能由主节点到从节点。Master以写为主，Slave 以读为主。</p>\n</blockquote>\n<blockquote>\n<p>默认情况下，每台Redis服务器都是主节点；且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。</p>\n</blockquote>\n<p>主从复制的作用主要包括：</p>\n<ul>\n<li>1 、数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li>\n<li>2 、故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</li>\n<li>3<br>、负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li>\n<li>4 、高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</li>\n</ul>\n<p>一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的，原因如下：</p>\n<ul>\n<li>1 、从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大；</li>\n<li>2 、从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存容量为256G，也不能将所有内存用作Redis存储内存，一般来说，单台Redis最大使用内存不应该超过20G。<br>电商网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是”多读少写”。 对于这种场景，我们可以使如下这种架构：</li>\n</ul>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927113849.png\" class title=\"输入图片说明\">\n\n<h2 id=\"环境配置\"><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h2><p>基本配置</p>\n<p>配从库不配主库，从库配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">slaveof 主库ip 主库端口 # 配置主从</span><br><span class=\"line\">info replication # 查看信息</span><br></pre></td></tr></table></figure>\n\n<p>每次与 master 断开之后，都需要重新连接，除非你配置进 redis.conf 文件！</p>\n<h3 id=\"修改配置文件！\"><a href=\"#修改配置文件！\" class=\"headerlink\" title=\"修改配置文件！\"></a>修改配置文件！</h3><p>准备工作：我们配置主从复制，至少需要三个，一主二从！配置三个客户端！</p>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927113948.png\" class title=\"输入图片说明\">\n\n<ul>\n<li><p>1 、拷贝多个redis.conf 文件</p>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927114022.png\" class title=\"输入图片说明\"></li>\n<li><p>2 、指定端口 6379 ，依次类推</p>\n</li>\n<li><p>3 、开启daemonize yes</p>\n</li>\n<li><p>4 、Pid文件名字 pidfile /var/run/redis_6379.pid , 依次类推</p>\n</li>\n<li><p>5 、Log文件名字 logfile “6379.log” , 依次类推</p>\n</li>\n<li><p>6 、Dump.rdb 名字 dbfilename dump6379.rdb , 依次类推</p>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927114130.png\" class title=\"输入图片说明\"></li>\n</ul>\n<h3 id=\"上面都配置完毕后，-3-个服务通过-3-个不同的配置文件开启，我们的准备环境就OK-了！\"><a href=\"#上面都配置完毕后，-3-个服务通过-3-个不同的配置文件开启，我们的准备环境就OK-了！\" class=\"headerlink\" title=\"上面都配置完毕后， 3 个服务通过 3 个不同的配置文件开启，我们的准备环境就OK 了！\"></a>上面都配置完毕后， 3 个服务通过 3 个不同的配置文件开启，我们的准备环境就OK 了！</h3><img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927114141.png\" class title=\"输入图片说明\">\n\n<h2 id=\"一主二从\"><a href=\"#一主二从\" class=\"headerlink\" title=\"一主二从\"></a>一主二从</h2><p>一主二仆</p>\n<ul>\n<li><p>1 、环境初始化</p>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210928085838.png\" class title=\"输入图片说明\"></li>\n</ul>\n<p>默认三个都是Master 主节点</p>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210928085902.png\" class title=\"输入图片说明\">\n\n<ul>\n<li><p>2 、配置为一个Master 两个Slave</p>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210928085902.png\" class title=\"输入图片说明\"></li>\n<li><p>3 、在主机设置值，在从机都可以取到！从机不能写值！</p>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210928085936.png\" class title=\"输入图片说明\"></li>\n</ul>\n<p>测试一：主机挂了，查看从机信息，主机恢复，再次查看信息</p>\n<p>测试二：从机挂了，查看主机信息，从机恢复，查看从机信息</p>\n<h3 id=\"层层链路\"><a href=\"#层层链路\" class=\"headerlink\" title=\"层层链路\"></a>层层链路</h3><blockquote>\n<p>上一个Slave 可以是下一个slave 和 Master，Slave 同样可以接收其他 slaves 的连接和同步请求，那么该 slave 作为了链条中下一个的master，可以有效减轻 master 的写压力！</p>\n</blockquote>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210928090032.png\" class title=\"输入图片说明\">\n\n<h3 id=\"测试：-6379-设置值以后-6380-和-6381-都可以获取到！OK！\"><a href=\"#测试：-6379-设置值以后-6380-和-6381-都可以获取到！OK！\" class=\"headerlink\" title=\"测试： 6379 设置值以后 6380 和 6381 都可以获取到！OK！\"></a>测试： 6379 设置值以后 6380 和 6381 都可以获取到！OK！</h3><h3 id=\"谋朝篡位\"><a href=\"#谋朝篡位\" class=\"headerlink\" title=\"谋朝篡位\"></a>谋朝篡位</h3><blockquote>\n<p>一主二从的情况下，如果主机断了，从机可以使用命令 SLAVEOF NO ONE 将自己改为主机！这个时候其余的从机链接到这个节点。对一个从属服务器执行命令 SLAVEOF NO ONE 将使得这个从属服务器关闭复制功能，并从从属服务器转变回主服务器，原来同步所得的数据集不会被丢弃。</p>\n</blockquote>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210928090112.png\" class title=\"输入图片说明\">\n\n<p>主机再回来，也只是一个光杆司令了，从机为了正常使用跑到了新的主机上！</p>\n<h3 id=\"复制原理\"><a href=\"#复制原理\" class=\"headerlink\" title=\"复制原理\"></a>复制原理</h3><blockquote>\n<p>Slave 启动成功连接到 master 后会发送一个sync命令Master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。增量复制：Master 继续将新的所有收集到的修改命令依次传给slave，完成同步但是只要是重新连接master，一次完全同步（全量复制）将被自动执行</p>\n</blockquote>\n<h2 id=\"哨兵模式\"><a href=\"#哨兵模式\" class=\"headerlink\" title=\"哨兵模式\"></a>哨兵模式</h2><p>概述</p>\n<blockquote>\n<p>主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。Redis从2.8开始正式提供了Sentinel（哨兵） 架构来解决这个问题。谋朝篡位的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是 <strong>哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。</strong></p>\n</blockquote>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210928090249.png\" class title=\"输入图片说明\">\n\n<p>这里的哨兵有两个作用</p>\n<ul>\n<li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。</li>\n<li>当哨兵监测到master宕机，会自动将slave切换成master，然后通过 发布订阅模式 通知其他的从服务器，修改配置文件，让它们切换主机。</li>\n</ul>\n<blockquote>\n<p>然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。</p>\n</blockquote>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210928090331.png\" class title=\"输入图片说明\">\n\n<blockquote>\n<p>假设主服务器宕机，哨兵 1 先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵 1 主观的认为主服务器不可用，这个现象成为 主观下线 。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover[故障转移]操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为客观下线 。</p>\n</blockquote>\n<h3 id=\"配置测试\"><a href=\"#配置测试\" class=\"headerlink\" title=\"配置测试\"></a>配置测试</h3><ul>\n<li>1 、调整结构， 6379 带着 80 、 81</li>\n<li>2 、自定义的 /myredis 目录下新建 sentinel.conf 文件，名字千万不要错</li>\n<li>3 、配置哨兵，填写内容<ul>\n<li>sentinel monitor 被监控主机名字 127.0.0.1 6379 1</li>\n<li>上面最后一个数字 1 ，表示主机挂掉后slave投票看让谁接替成为主机，得票数多少后成为主机</li>\n</ul>\n</li>\n<li>4 、启动哨兵<ul>\n<li>Redis-sentinel /myredis/sentinel.conf</li>\n<li>上述目录依照各自的实际情况配置，可能目录不同</li>\n</ul>\n</li>\n<li>5 、正常主从演示</li>\n<li>6 、原有的Master 挂了</li>\n<li>7 、投票新选</li>\n<li>8 、重新主从继续开工，info replication 查查看</li>\n<li>9 、问题：如果之前的master 重启回来，会不会双master 冲突？ 之前的回来只能做小弟了</li>\n</ul>\n<h3 id=\"哨兵模式的优缺点\"><a href=\"#哨兵模式的优缺点\" class=\"headerlink\" title=\"哨兵模式的优缺点\"></a>哨兵模式的优缺点</h3><h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><p>*<br>    1. 哨兵集群模式是基于主从模式的，所有主从的优点，哨兵模式同样具有。<br>*<br>    2. 主从可以切换，故障可以转移，系统可用性更好。<br>*<br>    3. 哨兵模式是主从模式的升级，系统更健壮，可用性更高。</p>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>*<br>    1. Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。<br>*<br>    2. 实现哨兵模式的配置也不简单，甚至可以说有些繁琐</p>\n<h3 id=\"哨兵配置说明\"><a href=\"#哨兵配置说明\" class=\"headerlink\" title=\"哨兵配置说明\"></a>哨兵配置说明</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Example sentinel.conf</span></span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 哨兵sentinel实例运行的端口 默认 26379</span></span><br><span class=\"line\">port 26379</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 哨兵sentinel的工作目录</span></span><br><span class=\"line\">dir /tmp</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 哨兵sentinel监控的redis主节点的 ip port</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> master-name 可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符<span class=\"string\">&quot;.-_&quot;</span>组成。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> quorum 配置多少个sentinel哨兵统一认为master主节点失联 那么这时客观上认为主节点失联了</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span></span><br><span class=\"line\">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都</span></span><br><span class=\"line\">要提供密码</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span></span><br><span class=\"line\">sentinel auth-pass mymaster MySUPER--secret-0123passw0rd</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认 30 秒</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class=\"line\">sentinel down-after-milliseconds mymaster 30000</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，这个数字越小，完成failover所需的时间就越长，但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span></span><br><span class=\"line\">sentinel parallel-syncs mymaster 1</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 故障转移的超时时间 failover-timeout 可以用在以下这些方面：</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">1. 同一个sentinel对同一个master两次failover之间的间隔时间。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">3.当想要取消一个正在进行的failover所需要的时间。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 默认三分钟</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class=\"line\">sentinel failover-timeout mymaster 180000</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> SCRIPTS EXECUTION</span></span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">对于脚本的运行结果有以下规则：</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">若脚本执行后返回 1 ，那么该脚本稍后将会被再次执行，重复次数目前默认为 10</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">若脚本执行后返回 2 ，或者比 2 更高的一个返回值，脚本将不会重复执行。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为 1 时的行为相同。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span></span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">通知脚本</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class=\"line\">sentinel notification-script mymaster /var/redis/notify.sh</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 客户端重新配置主节点参数脚本</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 以下参数将会在调用脚本时传给脚本:</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 目前&lt;state&gt;总是“failover”,</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> &lt;role&gt;是“leader”或者“observer”中的一个。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class=\"line\">sentinel client-reconfig-script mymaster /var/redis/reconfig.sh</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"缓存穿透和雪崩\"><a href=\"#缓存穿透和雪崩\" class=\"headerlink\" title=\"缓存穿透和雪崩\"></a>缓存穿透和雪崩</h1><blockquote>\n<p>Redis缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询方面。但同时，它也带来了一些问题。其中，最要害的问题，就是数据的一致性问题，从严格意义上讲，这个问题无解。如果对数据的一致性要求很高，那么就不能使用缓存。</p>\n</blockquote>\n<blockquote>\n<p>另外的一些典型问题就是，缓存穿透、缓存雪崩和缓存击穿。目前，业界也都有比较流行的解决方案。</p>\n</blockquote>\n<h2 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h2><h3 id=\"概念-1\"><a href=\"#概念-1\" class=\"headerlink\" title=\"概念\"></a>概念</h3><blockquote>\n<p>缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中，于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。</p>\n</blockquote>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><h3 id=\"布隆过滤器\"><a href=\"#布隆过滤器\" class=\"headerlink\" title=\"布隆过滤器\"></a>布隆过滤器</h3><blockquote>\n<p>布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力；</p>\n</blockquote>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210928090903.png\" class title=\"输入图片说明\">\n\n<h3 id=\"缓存空对象\"><a href=\"#缓存空对象\" class=\"headerlink\" title=\"缓存空对象\"></a>缓存空对象</h3><blockquote>\n<p>当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源；</p>\n</blockquote>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210928090930.png\" class title=\"输入图片说明\">\n\n<h3 id=\"但是这种方法会存在两个问题：\"><a href=\"#但是这种方法会存在两个问题：\" class=\"headerlink\" title=\"但是这种方法会存在两个问题：\"></a>但是这种方法会存在两个问题：</h3><ul>\n<li>1 、如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键；</li>\n<li>2 、即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。</li>\n</ul>\n<h2 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h2><h3 id=\"概述-2\"><a href=\"#概述-2\" class=\"headerlink\" title=\"概述\"></a>概述</h3><blockquote>\n<p>这里需要注意和缓存击穿的区别，缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</p>\n</blockquote>\n<blockquote>\n<p>当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大。</p>\n</blockquote>\n<h3 id=\"解决方案-1\"><a href=\"#解决方案-1\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><h3 id=\"设置热点数据永不过期\"><a href=\"#设置热点数据永不过期\" class=\"headerlink\" title=\"设置热点数据永不过期\"></a>设置热点数据永不过期</h3><p>从缓存层面来看，没有设置过期时间，所以不会出现热点 key 过期后产生的问题。</p>\n<h3 id=\"加互斥锁\"><a href=\"#加互斥锁\" class=\"headerlink\" title=\"加互斥锁\"></a>加互斥锁</h3><p>分布式锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。</p>\n<h2 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h2><h3 id=\"概念-2\"><a href=\"#概念-2\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>缓存雪崩，是指在某一个时间段，缓存集中过期失效。</p>\n<blockquote>\n<p>产生雪崩的原因之一，比如在写本文的时候，马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。</p>\n</blockquote>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210928091310.png\" class title=\"输入图片说明\">\n\n<blockquote>\n<p>其实集中过期，倒不是非常致命，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网。因为自然形成的缓存雪崩，一定是在某个时间段集中创建缓存，这个时候，数据库也是可以顶住压力的。无非就是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间就把数据库压垮。</p>\n</blockquote>\n<h3 id=\"解决方案-2\"><a href=\"#解决方案-2\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><h3 id=\"redis高可用\"><a href=\"#redis高可用\" class=\"headerlink\" title=\"redis高可用\"></a>redis高可用</h3><blockquote>\n<p>这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。</p>\n</blockquote>\n<h3 id=\"限流降级\"><a href=\"#限流降级\" class=\"headerlink\" title=\"限流降级\"></a>限流降级</h3><blockquote>\n<p>这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p>\n</blockquote>\n<h3 id=\"数据预热\"><a href=\"#数据预热\" class=\"headerlink\" title=\"数据预热\"></a>数据预热</h3><blockquote>\n<p>数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>\n</blockquote>\n","site":{"data":{"bangumis":{"wantWatch":[],"watching":[{"title":"凡人修仙传","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/70d11dfab23a3ee81ccf64f18efa139416a633ff.jpg@220w_280h.webp","totalCount":"未完结","id":28223043,"follow":"615.7 万","view":"8.9 亿","danmaku":"490.9 万","coin":"1186.9 万","score":9.7,"des":"看机智的凡人小子韩立如何稳健发展、步步为营，战魔道、夺至宝、驰骋星海、快意恩仇，成为纵横三界的强者。他日仙界重相逢，一声道友尽沧桑。..."},{"title":"恋爱游戏世界对路人角色很不友好","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/c9723d8c77d881a8debba2852d580e97826b43d0.png@220w_280h.webp","totalCount":"全12话","id":28237300,"follow":"151.2 万","view":"5120.4 万","danmaku":"40.6 万","coin":"24.5 万","score":9.1,"des":"从现代日本转生到“恋爱游戏”世界的里昂，发现这里女尊男卑，对男性很不友好。身为路人角色的他，为了摆脱自己因地位低下而被肆意决定的人生，决定活用从游戏中得到的知识，保持路人角色的身份，取得“失落物品”来..."},{"title":"魔法纪录 魔法少女小圆外传 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/9eef1df9ab157be52d2c4d70d3500442f00cafc3.png@220w_280h.webp","totalCount":"全12话","id":28234642,"follow":"237.1 万","view":"907.6 万","danmaku":"5.0 万","coin":"4.9 万","score":7.7,"des":"愿望的代价，究竟是希望还是绝望——。"},{"title":"小林家的龙女仆 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/847e9dbb6876fb37a30199a5c88910704976d45b.png@220w_280h.webp","totalCount":"全13话","id":28234613,"follow":"855.7 万","view":"1.1 亿","danmaku":"49.0 万","coin":"69.0 万","score":9.6,"des":"那位不可思议的龙女仆再度登场！\n因为各种奇妙的原因而作为小林家的女仆而工作中的龙·托尔。\n偶尔（胡说，是经常）给亲爱的小林添麻烦，总算是融入了人类社会，成为了一个完美的（骗人，也就还行）女仆。\n同样是..."},{"title":"国王排名","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/376d7e69a667bcb1c0b934a4e35e07e7fa23110b.png@220w_280h.webp","totalCount":"全23话","id":28235154,"follow":"927.7 万","view":"4.8 亿","danmaku":"250.1 万","coin":"260.9 万","score":7,"des":"国家的丰饶、麾下勇者的数量、\n以及国王本人如何像勇者一般强大，\n这些要素的综合排名，便是所谓的“国王排名”。\n主人公波吉是国王排名第七名的伯斯王治下王国的第一王子。\n但是波吉却生来又聋又哑，贫弱到挥不..."},{"title":"阿松 第三季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0212baa8898d0c819c7fb84015e95b8fca621435.png@220w_280h.webp","totalCount":"全25话","id":28229892,"follow":"67.6 万","view":"938.0 万","danmaku":"13.0 万","coin":"5.4 万","score":9.6,"des":"日本最有名的六胞胎的传说，第三次开幕！！这次会有怎样意想不到的新展开！？..."},{"title":"命运-冠位指定 冠位时间神殿所罗门","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0e094b798388da19a4feffa6a6dabc1dc1dc90cd.jpg@220w_280h.webp","totalCount":"全1话","id":28236225,"follow":"525.5 万","view":"1220.0 万","danmaku":"8.9 万","coin":"15.1 万","score":8.5,"des":"在经过七个特异点的大战后，\n人理存续保障机关迦勒底，终于到达了圣杯探索的最终地点——终局特异点 冠位时间神殿所罗门。\n他们要击败身为罪魁祸首的魔术王所罗门，夺回未来。\n在开战的前一刻，一行人各自度过了..."},{"title":"JOJO的奇妙冒险 星尘远征军","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/47c0108259355d6d2c517ed97f6b90fb777f844f.png@220w_280h.webp","totalCount":"全24话","id":28223481,"follow":"444.2 万","view":"1.5 亿","danmaku":"463.4 万","coin":"45.7 万","score":9.8,"des":"时为1987年，乔瑟夫·乔斯达与“柱之男”们之间的死战后过了50年……乔瑟夫为了为了帮助“被恶灵附身了”的外孙子·空条承太郎而来到了日本。原来那并不是恶灵而是幽波纹（替身）。替身突然出现的原因在于，从..."},{"title":"JOJO的奇妙冒险 星尘远征军 埃及篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f6709b76e88f50aa132d1e09e2d8de9663a09b3e.png@220w_280h.webp","totalCount":"全24话","id":28223483,"follow":"421.9 万","view":"1.3 亿","danmaku":"468.7 万","coin":"44.3 万","score":9.9,"des":"在乔斯达家的宿敌·迪奥（DIO）复活的影响下，一位年轻人——空条承太郎，得到了名为“幽波纹（替身）”的能力。为了拯救因迪奥的诅咒而倒下的母亲荷莉，空条承太郎与外祖父·乔瑟夫以及伙伴们，一起为了打倒迪奥..."},{"title":"JOJO的奇妙冒险 不灭钻石","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/6a04c87e990ab74cd8d555ef45a863de0993b161.png@220w_280h.webp","totalCount":"全39话","id":140552,"follow":"302.3 万","view":"2.1 亿","danmaku":"813.8 万","coin":"55.9 万","score":9.8,"des":"在埃及与宿敌DIO的死斗之后过了11年。1999年，空条承太郎为了与祖父乔瑟夫·乔斯达的私生子东方仗助见面，而来到了日本M县S市杜王町。但，仗助却持有与承太郎相同的特殊能力“替身”。之后，以承太郎的来..."},{"title":"命运-冠位嘉年华","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/c660976f4502a544d990a882ae62194b57753a71.png@220w_280h.webp","totalCount":"全2话","id":28234639,"follow":"479.8 万","view":"862.4 万","danmaku":"4.1 万","coin":"9.1 万","score":9.8,"des":"一起庆祝吧！为了这奇迹般的嘉年华！"},{"title":"伍六七","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/b69e26d9e50514f3fa99eac9ab5aabf2a6e28c88.jpg@220w_280h.webp","totalCount":"全13话","id":6360,"follow":"585.8 万","view":"3.3 亿","danmaku":"227.1 万","coin":"191.8 万","score":9.8,"des":"在某个小岛上，有一个可以伪装成任何东西的廉价刺客，名叫伍六七。平时看上去是个理发师，其实背地里却做着刺客生意。热爱理发事业，喜欢给人剪头发，善用剪刀——剪刀也是他的刺杀武器。由于初入刺客行当，行情十分..."},{"title":"命运-冠位指定 -月光／失落之室-","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3fa5fd2b7afae827b0bf150d7f0cbfc54eda1ff2.png@220w_280h.webp","totalCount":"全1话","id":28234950,"follow":"483.3 万","view":"551.2 万","danmaku":9696,"coin":"2.9 万","score":9.5,"des":"失落之室——。\n这是一个可以看到被夺去亦或是遗失之物的地方。\n这是位于迦勒底被遗忘的角落，不属于任何人的地方。..."},{"title":"致不灭的你","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/1ae94fbb35d8e23bb84926b694509f8b057f96e6.png@220w_280h.webp","totalCount":"全20话","id":28233896,"follow":"476.3 万","view":"1.3 亿","danmaku":"140.1 万","coin":"95.0 万","score":9.6,"des":"本剧讲述了一个情节跌宕、场面宏大的奇幻故事，通过拥有不灭之身的主人公“不死”来探索人生哲理。\n不死起初是一个被投放到人世间的“球”。\n\n它具有“幻化为刺激源形态的能力”和“死后重生的能力”。\n\n先后从..."},{"title":"来自新世界","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/aaa60f9cb17fb4a38df464f1064ca9623e0769cc.jpg@220w_280h.webp","totalCount":"全25话","id":1598,"follow":"115.9 万","view":"1540.9 万","danmaku":"76.3 万","coin":"5.7 万","score":9.5,"des":"1000年后的日本，孩子们不断地消失，只存在想象中的恐怖动物与人类展开殊死战争。反乌托邦式的未来超级社会“新世界”，是口吐真言凭藉“咒力”就能移动物体的人类，与有着等同于普通人智力的生物“妖鼠”共存的..."},{"title":"转生成蜘蛛又怎样！","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f0796e37abac25ba2aa9f23120646aaa9a3d5ea7.png@220w_280h.webp","totalCount":"全24话","id":28231809,"follow":"600.0 万","view":"3.7 亿","danmaku":"190.3 万","coin":"164.6 万","score":7.8,"des":"曾经是一名女高中生的“我”，突然转生变成了幻想世界中的蜘蛛魔物。\n而且，出生地点还是各种凶恶魔物所盘踞的大迷宫。\n“我”以人类的智慧和非同寻常的积极心态为武器，使用蜘蛛的丝网以及陷阱打倒比自己等级高得..."},{"title":"装甲重拳/MEGALOBOX 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/e14dc4a935397fc074c7a12d9520225615209025.png@220w_280h.webp","totalCount":"全13话","id":28233916,"follow":"244.9 万","view":"3435.4 万","danmaku":"19.7 万","coin":"53.1 万","score":9.9,"des":"再一次，为梦想而活——\n\n将肉体与“装甲技术”融合的究极格斗技“装甲拳击”。\n在决出其顶点之人的大会“重拳之巅”上，身穿装甲用自己肉身挑战一切的拳击手“JOE”。\n\n从最下层的比赛开始仅仅花了三个月就..."},{"title":"机动战士高达SEED HD","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/855c88677267d707ebfe4040403692ff2c0938f0.png@220w_280h.webp","totalCount":"全48话","id":497,"follow":"54.8 万","view":"4044.4 万","danmaku":"114.4 万","coin":"6.0 万","score":9.6,"des":"《机动战士高达SEED》是高达系列在2002年至2003年度放映的动画。续作为《机动战士高达SEED Destiny》在2004年播放。因各具魅力的角色，明星云集的声优阵容和高度商业化的宣传而受到较低..."},{"title":"夏目友人帐 唤石者与怪异的访客","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6cf43708b779cde84ad285ff4e3a080de98df0af.png@220w_280h.webp","totalCount":"全1话","id":28234316,"follow":"567.1 万","view":"1374.8 万","danmaku":"18.1 万","coin":"17.9 万","score":9.9,"des":"本作由【唤石者】与【怪异的访客】两个人气短篇集锦而成。讲述生来便能看见各种妖怪的夏目，与自称保镖的猫咪老师一同邂逅的一系列温暖故事。\n【唤石者】一天夏目在森林中遇到一只小妖怪——密实。密实称自己肩负「..."},{"title":"Fate/Grand Order ‐First Order‐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/b75c55d209d156c8631f5ceb21e5c52c834dbb60.jpg@220w_280h.webp","totalCount":"全1话","id":5747,"follow":"250.9 万","view":"3329.7 万","danmaku":"76.7 万","coin":"10.7 万","score":8.3,"des":"【2016年12月31日bilibili独播】2015年。示巴所观测到的未来领域毫无前兆地消失。根据计算，发现——不，是证明了人类将于2017年灭绝。人理延续保障机构·迦勒底将“无法观测的领域”假定为..."},{"title":"伍六七之玄武国篇","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/00843865ea13702eccc4efd64c313fd4c8029c6b.jpg@220w_280h.webp","totalCount":"全10话","id":28232253,"follow":"999.4 万","view":"4.0 亿","danmaku":"177.7 万","coin":"385.3 万","score":9.8,"des":"为了保护小鸡岛居民和这里平静的生活，伍六七和他的伙伴大保和小飞开启了去往玄武国的冒险旅程，去寻找身世的真相和解救小岛的办法，等待他们的又将是更多的未知与奇遇。..."},{"title":"堀与宫村","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/039c4e0b14e27c7a9e5cce2f20a6efd3c8909401.png@220w_280h.webp","totalCount":"全13话","id":28231840,"follow":"695.2 万","view":"2.2 亿","danmaku":"242.1 万","coin":"361.4 万","score":9.8,"des":"不论是谁，都会有不想被人知道的一面。\n\n在学校中漂亮大方、成绩优秀的人气女生堀，私下却打扮土气、忙于家务和照顾弟弟。\n在学校中是阴暗宅男形象的宫村，生活中却是打扮时尚、带耳钉的帅气男生。\n因为一次特别..."},{"title":"奇蛋物语 / WONDER EGG PRIORITY","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/10e0bbc1047b2c45f0f881de334a6f3bfb42a3b6.png@220w_280h.webp","totalCount":"全12话","id":28231851,"follow":"254.9 万","view":"4686.8 万","danmaku":"47.6 万","coin":"65.5 万","score":9.7,"des":"14岁少女·大户爱在深夜散步的途中，\n随着神秘声音的指引，获得了一枚「蛋」。\n\n「如果想要改变世界的话」\n「那么就在现在做出选择」\n「请相信自己——」\n「打破这枚蛋——」\n\n而在打破「蛋」之后，等待着..."},{"title":"Re：从零开始的异世界生活 第二季 后半","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/4f3edbede7fc0bdb52842075cf8faaa1c5953eaa.png@220w_280h.webp","totalCount":"全12话","id":28232073,"follow":"849.9 万","view":"9308.1 万","danmaku":"108.1 万","coin":"230.1 万","score":9.9,"des":"我一定会拯救你。\n在打倒了魔女教大罪司教「怠惰」担当——培提其乌斯·罗曼尼康帝之后，菜月昴和爱蜜莉雅又得以重新开始。\n克服了艰难的诀别，两人终于和解，然而这只是新一轮风波的序幕。\n超乎想象的绝境危机，..."},{"title":"灰与幻想的格林姆迦尔","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/7fb4945f864e9e988212b7d20f206df2677053f8.jpg@220w_280h.webp","totalCount":"全12话","id":106512,"follow":"172.0 万","view":"2343.4 万","danmaku":"63.8 万","coin":"18.3 万","score":9.8,"des":"电视动画《灰与幻想的格林姆迦尔》改编自日本轻小说家十文字青原作白井锐利插画的同名轻小说。\n我们为什么要这么做…？\n哈尔希洛回过神来，才发现自己身处在黑暗当中，他完全不知道自己人在何处，也不明白这个地方..."},{"title":"龙与虎","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/144910805f172d16c5f544f43939a05d8ca20576.jpg@220w_280h.webp","totalCount":"全26话","id":1672,"follow":"336.9 万","view":"6671.9 万","danmaku":"511.9 万","coin":"61.5 万","score":9.7,"des":"樱花飞舞的四月，全新的高中二年级，新的班级……\n眼神凶恶的普通男孩——高须龙儿，遇上了众人害怕、凶暴残忍的“掌中老虎”逢坂大河，还知道了她不欲为人知的秘密。这就是龙虎相争爱与战斗的序幕。\n再加上总是笑..."},{"title":"机动战士高达 铁血的奥尔芬斯 第一季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/f84a80d731d0431c00903d8951fd66623d8237f7.png@220w_280h.webp","totalCount":"全25话","id":4310042,"follow":"62.4 万","view":"2318.6 万","danmaku":"52.2 万","coin":"5.4 万","score":9.5,"des":"主人公三日月·奥古斯，从所属的民间警备公司克律塞安保公司（下称CGS）那里，接受了对少女库德莉亚·蓝那·伯恩斯坦的护卫任务。但CGS受到了摘取反叛之芽的武力组织加拉尔霍恩的袭击，于是在把三日月当做诱饵..."},{"title":"机动战士高达00 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1d7a969e8f1045739c596de89a963e30475aff0e.jpg@220w_280h.webp","totalCount":"全25话","id":1193,"follow":"37.2 万","view":"2458.1 万","danmaku":"61.4 万","coin":"4.1 万","score":9.8,"des":"天人与联合国军的最终决战后过了四年。建立地球联邦政府的人类，为了追求更进一步的国家间之统合，以及人类意识的统一，在联合正规军之外，设立了独立治安维持部队“A-Laws”，目的为对所有危害联合的势力与主..."},{"title":"机动战士高达00","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/35b11bf59eb3fd12f0387951510a5d722d7435e5.jpg@220w_280h.webp","totalCount":"全25话","id":1192,"follow":"62.1 万","view":"2465.5 万","danmaku":"53.6 万","coin":"4.6 万","score":9.7,"des":"在西历2307年，虽然化石燃料枯竭了，但是人类得到了截然不同的新型能源。三台巨大的轨道升降机以及伴随它们的大规模的太阳光发电系统。但是能得到这个系统恩惠的，只有一部分大国和其同盟国而已。\n拥有三台轨道..."},{"title":"Re：从零开始的异世界生活 第二季 前半","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f2425cbdb07cc93bd0d3ba1c0099bfe78f5dc58a.png@220w_280h.webp","totalCount":"全13话","id":28229233,"follow":"774.2 万","view":"1.3 亿","danmaku":"201.4 万","coin":"126.7 万","score":9.7,"des":"我一定会拯救你。\n在打倒了魔女教大罪司教「怠惰」担当——培提其乌斯·罗曼尼康帝之后，菜月昴和爱蜜莉雅又得以重新开始。\n克服了艰难的诀别，两人终于和解，然而这只是新一轮风波的序幕。\n超乎想象的绝境危机，..."},{"title":"超级小白","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3d3e8257d22596f5d3e4395ca759bd1e0fe9b873.jpg@220w_280h.webp","totalCount":"全48话","id":28222671,"follow":"27.4 万","view":"978.0 万","danmaku":"3.6 万","coin":"3.6 万","score":9.6,"des":"为了阻止企图霸占世界的黑暗势力，野原家的普通小狗——小白接肩负重大使命，变身成为了守护世界的“超级小白”。小白将要面对的不仅是发明狗，还有其他意想不到的对手。当然，面对邪恶势力，小白也有着令人惊讶的超..."},{"title":"Re：从零开始的异世界生活 新编集版","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3c125e1aad08643e3eff2fb7d45e740c1a052725.png@220w_280h.webp","totalCount":"全13话","id":28224394,"follow":"631.1 万","view":"7674.2 万","danmaku":"166.2 万","coin":"51.1 万","score":9.6,"des":"在从便利商店回家的路上，突然被异世界召唤的少年菜月昴。在无法依靠任何东西的异世界，无力的少年手唯一的力量……那是“死去然后重新开始”的力量。为了守护最重要的人们，为了取回确实存在着又无可替代的时间，少..."},{"title":"因为太怕痛就全点防御力了","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/8021d3f6b0df6dbba6d32f76eb9cfe2531e166c4.png@220w_280h.webp","totalCount":"全12话","id":28224137,"follow":"620.6 万","view":"2.3 亿","danmaku":"326.8 万","coin":"103.8 万","score":9,"des":"主角本条枫在好友白峰理沙推荐下开始游玩游戏“NewWorld Online”，创建了名为“梅普露”的角色。然而作为游戏初学者，梅普露选择了不受欢迎的大盾当武器，同时因为怕痛而把所有状态点加到防御力的极..."},{"title":"冰海战记","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/c30401817895e67399094b4e669785a104270cdf.jpg@220w_280h.webp","totalCount":"全24话","id":28220475,"follow":"174.4 万","view":"4893.8 万","danmaku":"48.7 万","coin":"36.7 万","score":9.8,"des":"公元10世纪末期，出现了在世界各地出没的最强民族。被讴歌为最强战士的托尔兹，其子托尔芬幼时便生活在战场上，并向往着梦幻大陆“文兰”。这是一个发生在激荡时代的，真正的英雄物语。..."},{"title":"齐木楠雄的灾难 始动篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ba59822eded39b5254fb01448a7f1502101d5624.png@220w_280h.webp","totalCount":"全6话","id":28223748,"follow":"372.4 万","view":"3054.5 万","danmaku":"20.0 万","coin":"17.8 万","score":9.8,"des":"在电视剧中堪称帅气的超能力，对于高中生齐木楠雄来说只是招致灾难的元凶。作为新动画系列展开的楠雄的日常又会如何！？..."},{"title":"OVERLORD Ⅱ","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/851f979c8ebcc7583a43abd4b786c4e2e66b746b.jpg@220w_280h.webp","totalCount":"全13话","id":8792,"follow":"539.3 万","view":"3.8 亿","danmaku":"413.9 万","coin":"114.1 万","score":9.6,"des":"时为2138年。曾卷起一大风潮的虚拟现实体感型网络游戏《YGGDRASIL》即将迎来停服。玩家飞鼠在曾经以同伴和荣华自傲的根据地纳萨力克地下大坟墓，独自一人安静等待着那一刻。但是，不料发生了结束时间已..."},{"title":"夏目友人帐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/99c549494d9425f6455bd45a151f4d26397d6151.png@220w_280h.webp","totalCount":"全13话","id":1660,"follow":"324.0 万","view":"4975.2 万","danmaku":"278.7 万","coin":"15.5 万","score":9.8,"des":"夏目贵志生来拥有强大的灵力，能感知平常人所无法接触的妖怪神明的存在。因父母双亡，他多年间辗转于互相推卸责任的亲戚之间，又受到同龄人的欺负，未曾与任何人深交，造成性格一定程度上的孤僻。夏目本性和善，对于..."}],"watched":[{"title":"装甲重拳/MEGALOBOX","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0c44785cb5d25cc9f648800d251f21a2e236bb8a.png@220w_280h.webp","totalCount":"全13话","id":79472,"follow":"221.9 万","view":"6162.0 万","danmaku":"48.6 万","coin":"32.9 万","score":9.8,"des":"将肉体与“装甲技术”融合的究极格斗技——“MEGALOBOX”，将自己的全部赌在上面的男人们的热血战斗开始！\n今天也立于未认可地区的赌博比赛赛场上的MEGALO拳击手“JNK DOG”。虽然具备实力，..."},{"title":"超能力女儿","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/152c536f8ecaad8f3d7d568d33da81c963a4a722.png@220w_280h.webp","totalCount":"全12话","id":78352,"follow":"293.8 万","view":"9252.2 万","danmaku":"98.5 万","coin":"35.4 万","score":9.6,"des":"支持着芦川组的年轻智力型黑道新田义史，过着被喜欢的壶所包围的悠然自得单身生活。但某一天，随着装在神秘物体里的少女雏来到他家，他的生活为之一变。他被能使用念动力的雏所胁迫，迫不得已开始和她同居！\n容易暴..."},{"title":"OVERLORD Ⅲ","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/dd7a9d0a0bee32b1f43c2656398d8463d12b3069.jpg@220w_280h.webp","totalCount":"全13话","id":102252,"follow":"551.6 万","view":"4.0 亿","danmaku":"399.7 万","coin":"129.2 万","score":9.4,"des":"时间为2138年。曾卷起一大风潮的虚拟现实体感型网络游戏《YGGDRASIL》即将迎来停服。玩家飞鼠在曾经以同伴和荣华自傲的根据地纳萨力克地下大坟墓，独自一人安静等待着那一刻。\n但是，不料发生了“过了..."},{"title":"路人超能100 第一次灵能咨询所员工旅游～舒缓心灵的疗愈之旅~（OVA2）","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/1271324d51634b68980704731987724a1afc60aa.jpg@220w_280h.webp","totalCount":"全1话","id":28222715,"follow":"318.8 万","view":"520.7 万","danmaku":"3.6 万","coin":"4.6 万","score":9.8,"des":"由原作ONE老师担任原案的完全新作OVA！「灵能咨询所」一行人，龙套与灵幻、小酒窝以及新同伴芹泽的目的地，正是缟马县深山中鲜为人知的温泉·疣神温泉。因为灵幻接受了旅馆老板娘的委托，「弄清温泉的恐怖传闻..."},{"title":"少女终末旅行","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1431ca5bb2f7143062e3df8f21b8448cf8cccc13.jpg@220w_280h.webp","totalCount":"全12话","id":6463,"follow":"239.8 万","view":"3714.7 万","danmaku":"100.7 万","coin":"37.2 万","score":9.8,"des":"本作舞台在人类繁华的文明迎来终结的很久以后，人类基本灭绝，甚至生物都不再存在的末日世界。复杂够高的都市成为迷宫般的废墟，得不到维护的机械渐渐停止运转。连何时终结了，何时开始终结的思考都不复存在的这个世..."},{"title":"齐木楠雄的灾难（日播&精选版）","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/eb4f17335f48951945fb9da47e6ee0bc65fa2fbb.jpg@220w_280h.webp","totalCount":"全120话","id":5070,"follow":"187.0 万","view":"2.3 亿","danmaku":"130.7 万","coin":"32.7 万","score":9.6,"des":"高中生·齐木楠雄是超能力者。心灵感应、念动力、透视、预知、瞬间移动、千里眼等，不论任何事情都自由自在。但这任谁都羡慕不已的最强能力，实际上对于本人而言是引来灾难的不幸元凶。因此，他在别人面前封印了超能..."},{"title":"比宇宙更远的地方","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/c9eca3cbc386c63b27461074b8b218898cb7440e.jpg@220w_280h.webp","totalCount":"全13话","id":13032,"follow":"156.0 万","view":"2298.0 万","danmaku":"45.9 万","coin":"23.9 万","score":9.8,"des":"无论何时，我们的第一步总是从好奇心开始。\n不曾看过的风景，不曾听过的声音，不曾闻过的味道，不曾摸过的质感，不曾尝过的食物，以及不曾感受过的澎湃。\n为了重拾不知何时忘却的记忆碎片和不知何时舍弃的感动的旅..."},{"title":"OVERLORD","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/b8e72ea69e57e0b7ac85d8b4d366554fd866df1a.jpg@220w_280h.webp","totalCount":"全13话","id":2576,"follow":"626.2 万","view":"4.1 亿","danmaku":"385.2 万","coin":"84.4 万","score":9.6,"des":"作品主要讲述了某天，一款曾经掀起过大热潮的VRMMORPG「YGGDRASIL」停止了运营。游戏原本会停止一切服务，但过了结束时间后，玩家们却发现不能退出，NPC也产生了各自的思想。现实世界中喜爱电玩..."},{"title":"路人超能100 II(灵能百分百 第二季)","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/216e1bdaf88244215a13b1154116805ee9adbe07.png@220w_280h.webp","totalCount":"全13话","id":4762734,"follow":"284.9 万","view":"1.0 亿","danmaku":"97.8 万","coin":"56.1 万","score":9.9,"des":"当有什么东西达到“100”的时候，就会爆发的少年·路人（龙套）。外表极其普通——不如说是不起眼。不擅长迎合气氛的他，实际上拥有着强力的超能力。盯上了这样的他的能力，而接连现身的伪灵能力者以及宗教团体、..."},{"title":"多罗罗","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3fc16a667502cbff226e585eb660a96a20c7458c.png@220w_280h.webp","totalCount":"全24话","id":4312482,"follow":"452.1 万","view":"1.8 亿","danmaku":"143.9 万","coin":"73.9 万","score":9.4,"des":"他们向着命运抗争，在那尽头等待他们的是人心，还是业障。\n时值乱世。\n名为景光的醍醐将军，向某个寺庙殿堂中的12尊魔神像祈求早日结束战乱。\n作为代价，他的嫡子在出生时就失去了身体的某些部位，被丢弃在河流..."},{"title":"魔法少女小圆","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/7fcaa0e98b561611538ae4deba7949cec4ca39a8.png@220w_280h.webp","totalCount":"全12话","id":2539,"follow":"218.7 万","view":"4199.0 万","danmaku":"201.5 万","coin":"20.0 万","score":9.8,"des":"就读初中二年级的鹿目圆，过着平凡幸福的生活。神秘转学生晓美焰的出现，开始让小圆的命运有了巨大转变。某日一只名为丘比的神秘生物，希望小圆能够与它签订魔法契约，成为“魔法少女”以对抗邪恶的魔女保护世界。正..."}]},"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"http://rebp38war.bkt.clouddn.com/img/v2-b006882f4ae03db43db5dd9a4bda19e5_r.jpg","excerpt":"","more":"<h1 id=\"NoSQL概述\"><a href=\"#NoSQL概述\" class=\"headerlink\" title=\"NoSQL概述\"></a>NoSQL概述</h1><h2 id=\"为什么用NoSQL\"><a href=\"#为什么用NoSQL\" class=\"headerlink\" title=\"为什么用NoSQL\"></a>为什么用NoSQL</h2><blockquote>\n<p>1 、单机MySQL的美好年代</p>\n</blockquote>\n<p>在 90 年代，一个网站的访问量一般不大，用单个数据库完全可以轻松 在那个时候，更多的都是静态网页，动态交互类型的网站不多。</p>\n<p>上述架构下，我们来看看数据存储的瓶颈是什么？</p>\n<p>*<br>    1. 数据量的总大小，一个机器放*<br>    *<br>        2. 数据的索引（B+ Tree）一个机器的内存放*<br>        *<br>            3. 访问量（读写混合）一个实例不能承受</p>\n<p>如果满足了上述 1 or 3个，进化. DAL：数据库访问层</p>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210922100205.png\" class title=\"输入图片说明\">\n<blockquote>\n<p>2 、Memcached（缓存）+ MySQL + 垂直拆分</p>\n</blockquote>\n<blockquote>\n<p>后来，随着访问量的上升，几乎大部分使用MySQL架构的网站在数据库上都开始出现了性能问题，web 程序不再仅仅专注在功能上，同时也在追求性能。程序猿们开始大量使用缓存技术来缓解数据库的压 力，优化数据库的结构和索引，开始比较流行的是通过文件缓存来缓解数据库压力，但是当访问量继续 增大的时候，多台web机器通过文件缓存不能共享，大量的小文件缓存也带了比较高的IO压力，在这个 时候，Memcached就自然的成为一个非常时尚的技术产品。</p>\n</blockquote>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210922100407.png\" class title=\"输入图片说明\">\n<blockquote>\n<p>3 、MySQL主从读写分离</p>\n</blockquote>\n<blockquote>\n<p>由于数据库的写入压力增加，Memcached只能缓解数据库的读取压力，读写集中在一个数据库上让数 据库不堪重负，大部分网站开始使用主从复制技术来达到读写分离，以提高读写性能和读库的可扩展 性，MySQL的master-slave模式成为这个时候的网站标配了。</p>\n</blockquote>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210924134715.png\" class title=\"输入图片说明\">\n\n<blockquote>\n<p>4 、分表分库 + 水平拆分 + Mysql 集群</p>\n</blockquote>\n<blockquote>\n<p>在Memcached的高速缓存，MySQL的主从复制，读写分离的基础之上，这时MySQL主库的写压力开始 出现瓶颈，而数据量的持续猛增，由于MyISAM使用表锁，在高并发下会出现严重的锁问题，大量的高 并发MySQL应用开始使用InnoDB引擎代替MyISAM。 同时，开始流行使用分表分库来缓解写压力和数据增长的扩展问题，这个时候，分表分库成了一个热门 技术，是面试的热门问题，也是业界讨论的热门技术问题。也就是在这个时候，MySQL推出了还不太稳 定的表分区，这也给技术实力一般的公司带来了希望。虽然MySQL推出了MySQL Cluster集群，但性能 也不能很好满足互联网的需求，只是在高可靠性上提供了非常大的保证。</p>\n</blockquote>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210924134937.png\" class title=\"输入图片说明\">\n\n<blockquote>\n<p>5 、MySQL 的扩展性瓶颈</p>\n</blockquote>\n<blockquote>\n<p>MySQL数据库也经常存储一些大文本的字段，导致数据库表非常的大，在做数据库恢复的时候就导致非 常的慢，不容易快速恢复数据库，比如 1000 万4KB大小的文本就接近40GB的大小，如果能把这些数据 从MySQL省去，MySQL将变的非常的小，关系数据库很强大，但是它并不能很好的应付所有的应用场 景，MySQL的扩展性差（需要复杂的技术来实现），大数据下IO压力大，表结构更改困难，正是当前使 用MySQL的开发人员面临的问题。</p>\n</blockquote>\n<blockquote>\n<p>6 、今天是什么样子？？</p>\n</blockquote>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210924135030.png\" class title=\"输入图片说明\">\n\n<blockquote>\n<p>7 、为什么用NoSQL？</p>\n</blockquote>\n<blockquote>\n<p>今天我们可以通过第三方平台（如：Google，FaceBook等）可以很容易的访问和抓取数据。用户的个 人信息，社交网络，地理位置，用户生成的数据和用户操作日志已经成倍的增加、我们如果要对这些用 户数据进行挖掘，那SQL数据库已经不适合这些应用了，而NoSQL数据库的发展却能很好的处理这些大 的数据！</p>\n</blockquote>\n<h2 id=\"什么是NoSQL\"><a href=\"#什么是NoSQL\" class=\"headerlink\" title=\"什么是NoSQL\"></a>什么是NoSQL</h2><blockquote>\n<p>NoSQL</p>\n</blockquote>\n<blockquote>\n<p>NoSQL = Not Only SQL，意思：不仅仅是SQL；</p>\n</blockquote>\n<blockquote>\n<p>泛指非关系型的数据库，随着互联网Web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别 是超大规模和高并发的社交网络服务类型的Web2.0纯动态网站已经显得力不从心，暴露了很多难以克服 的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展，NoSQL数据库的产生就是为 了解决大规模数据集合多种数据种类带来的挑战，尤其是大数据应用难题，包括超大规模数据的存储。 （例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模 式，无需多余操作就可以横向扩展。</p>\n</blockquote>\n<blockquote>\n<p>NoSQL的特点</p>\n</blockquote>\n<h3 id=\"1-、易扩展\"><a href=\"#1-、易扩展\" class=\"headerlink\" title=\"1 、易扩展\"></a>1 、易扩展</h3><blockquote>\n<p>NoSQL 数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。 数据之间无关系，这样就非常容易扩展，也无形之间，在架构的层面上带来了可扩展的能力。</p>\n</blockquote>\n<h3 id=\"2-、大数据量高性能\"><a href=\"#2-、大数据量高性能\" class=\"headerlink\" title=\"2 、大数据量高性能\"></a>2 、大数据量高性能</h3><blockquote>\n<p>NoSQL数据库都具有非常高的读写性能，尤其是在大数据量下，同样表现优秀。这得益于它的非关系 性，数据库的结构简单。</p>\n</blockquote>\n<blockquote>\n<p>一般MySQL使用Query Cache，每次表的更新Cache就失效，是一种大力度的Cache，在针对Web2.0的 交互频繁应用，Cache性能不高，而NoSQL的Cache是记录级的，是一种细粒度的Cache，所以NoSQL 在这个层面上来说就要性能高很多了。</p>\n</blockquote>\n<blockquote>\n<p>官方记录：Redis 一秒可以写 8 万次，读 11 万次！</p>\n</blockquote>\n<h3 id=\"3-、多样灵活的数据模型\"><a href=\"#3-、多样灵活的数据模型\" class=\"headerlink\" title=\"3 、多样灵活的数据模型\"></a>3 、多样灵活的数据模型</h3><blockquote>\n<p>NoSQL无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式，而在关系数据库里，增删 字段是一件非常麻烦的事情。如果是非常大数据量的表，增加字段简直就是噩梦。</p>\n</blockquote>\n<h3 id=\"4-、传统的RDBMS-VS-NoSQL\"><a href=\"#4-、传统的RDBMS-VS-NoSQL\" class=\"headerlink\" title=\"4 、传统的RDBMS VS NoSQL\"></a>4 、传统的RDBMS VS NoSQL</h3><img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210924135616.png\" class title=\"输入图片说明\">\n\n<blockquote>\n<p>拓展：3V+3高</p>\n</blockquote>\n<h3 id=\"大数据时代的3V-：-主要是对问题的描述\"><a href=\"#大数据时代的3V-：-主要是对问题的描述\" class=\"headerlink\" title=\"大数据时代的3V ： 主要是对问题的描述\"></a>大数据时代的3V ： 主要是对问题的描述</h3><ul>\n<li>海量 Volume</li>\n<li>多样 Variety</li>\n<li>实时 Velocity</li>\n</ul>\n<h3 id=\"互联网需求的-3-高-：-主要是对程序的要求\"><a href=\"#互联网需求的-3-高-：-主要是对程序的要求\" class=\"headerlink\" title=\"互联网需求的 3 高 ： 主要是对程序的要求\"></a>互联网需求的 3 高 ： 主要是对程序的要求</h3><ul>\n<li>高并发</li>\n<li>高可用</li>\n<li>高性能</li>\n</ul>\n<p><code>当下的应用是 SQL 和 NoSQL 一起使用，技术没有高低之分，就看你怎么用，对吧！</code></p>\n<h2 id=\"经典应用分析\"><a href=\"#经典应用分析\" class=\"headerlink\" title=\"经典应用分析\"></a>经典应用分析</h2><h3 id=\"聊聊阿里巴巴中文网站的商品信息如何存放，以女装、包包为例：\"><a href=\"#聊聊阿里巴巴中文网站的商品信息如何存放，以女装、包包为例：\" class=\"headerlink\" title=\"聊聊阿里巴巴中文网站的商品信息如何存放，以女装、包包为例：\"></a>聊聊阿里巴巴中文网站的商品信息如何存放，以女装、包包为例：</h3><img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210924135616.png\" class title=\"输入图片说明\">\n\n<h3 id=\"聊聊架构发展历程：推荐书籍《淘宝技术这十年》\"><a href=\"#聊聊架构发展历程：推荐书籍《淘宝技术这十年》\" class=\"headerlink\" title=\"聊聊架构发展历程：推荐书籍《淘宝技术这十年》\"></a>聊聊架构发展历程：推荐书籍《淘宝技术这十年》</h3><h3 id=\"1-、演变过程：以下图片资料来源：阿里巴巴中文站架构设计实践\"><a href=\"#1-、演变过程：以下图片资料来源：阿里巴巴中文站架构设计实践\" class=\"headerlink\" title=\"1 、演变过程：以下图片资料来源：阿里巴巴中文站架构设计实践\"></a>1 、演变过程：以下图片资料来源：阿里巴巴中文站架构设计实践</h3><img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210924135855.png\" class title=\"输入图片说明\">\n\n<h3 id=\"2-、第五代\"><a href=\"#2-、第五代\" class=\"headerlink\" title=\"2 、第五代\"></a>2 、第五代</h3><img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210924135915.png\" class title=\"输入图片说明\">\n\n<h3 id=\"3-、第-5-代架构使命\"><a href=\"#3-、第-5-代架构使命\" class=\"headerlink\" title=\"3 、第 5 代架构使命\"></a>3 、第 5 代架构使命</h3><img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210924135957.png\" class title=\"输入图片说明\">\n\n<h3 id=\"和我们相关的，多数据源多数据类型的存储问题\"><a href=\"#和我们相关的，多数据源多数据类型的存储问题\" class=\"headerlink\" title=\"和我们相关的，多数据源多数据类型的存储问题\"></a>和我们相关的，多数据源多数据类型的存储问题</h3><img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210924140055.png\" class title=\"输入图片说明\">\n\n<h3 id=\"1-、商品的基本信息\"><a href=\"#1-、商品的基本信息\" class=\"headerlink\" title=\"1 、商品的基本信息\"></a>1 、商品的基本信息</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">名称、价格、出厂日期、生产厂商等</span><br><span class=\"line\">关系型数据库：mysql、oracle目前淘宝在去O化（也即，拿掉Oracle）</span><br><span class=\"line\">注意，淘宝内部用的MySQL是里面的大牛自己改造过的。</span><br><span class=\"line\"></span><br><span class=\"line\">为什么去IOE：</span><br><span class=\"line\">2008 年,王坚博士加入阿里巴巴，成为首席架构师。把云计算植入阿里IT基因。</span><br><span class=\"line\">2013 年 5 月 17 日，阿里集团最后一台IBM小机在支付宝下线。这是自 2009 年“去IOE”战略透露以来，“去</span><br><span class=\"line\">IOE”非常重要的一个节点。“去 IOE”指的是摆脱掉IT部署中原有的IBM小型机、Oracle数据库以及EMC</span><br><span class=\"line\">存储的过度依赖。告别最后一台小机，意味着整个阿里集团尽管还有一些Oracle数据库和EMC存储，但是</span><br><span class=\"line\">IBM小型机已全部被替换。 2013 年 7 月 10 日，淘宝重中之重的广告系统使用的Oracle数据库下线，也是整</span><br><span class=\"line\">个淘宝最后一个 Oracle数据库。这两件事合在一起是阿里巴巴技术发展过程中的一个重要里程碑。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2、商品描述、详情、评价信息（多文字类）\"><a href=\"#2、商品描述、详情、评价信息（多文字类）\" class=\"headerlink\" title=\"2、商品描述、详情、评价信息（多文字类）\"></a>2、商品描述、详情、评价信息（多文字类）</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">多文字信息描述类，IO读写性能变差 </span><br><span class=\"line\">存在文档数据库MongDB中</span><br></pre></td></tr></table></figure>\n\n<p>3、商品的图片</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">商品图片展现类 </span><br><span class=\"line\">分布式文件系统中 </span><br><span class=\"line\">  - 淘宝自己的 TFS </span><br><span class=\"line\">  - Google的 GFS </span><br><span class=\"line\">  - Hadoop的 HDFS</span><br></pre></td></tr></table></figure>\n\n<p>4、商品的关键字</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">搜索引擎，淘宝内用 </span><br><span class=\"line\">ISearch：多隆一高兴一个人开发的 </span><br><span class=\"line\"></span><br><span class=\"line\">所有牛逼的人在牛逼之前,肯定有一段苦逼的岁月,但只要像傻逼一样的坚持,一定终将牛逼</span><br></pre></td></tr></table></figure>\n\n<p>5、商品的波段性的热点高频信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">内存数据库 </span><br><span class=\"line\">Tair、Redis、Memcache等</span><br></pre></td></tr></table></figure>\n\n<p>6、商品的交易，价格计算，积分累计！</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">外部系统，外部第三方支付接口 </span><br><span class=\"line\">支付宝</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>大型互联网应用（大数据，高并发，多样数据类型）的难点和解决方案<br><strong>难点：</strong></p>\n</blockquote>\n<ul>\n<li>数据类型的多样性</li>\n<li>数据源多样性和变化重构</li>\n<li>数据源改造而数据服务平台不需要大面积重构</li>\n</ul>\n<p><strong>解决办法：</strong></p>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210924140800.png\" class title=\"输入图片说明\">\n\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210924140819.png\" class title=\"输入图片说明\">\n\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210924140833.png\" class title=\"输入图片说明\">\n\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210924140847.png\" class title=\"输入图片说明\">\n\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210924140901.png\" class title=\"输入图片说明\">\n\n<h2 id=\"NoSQL数据模型简介\"><a href=\"#NoSQL数据模型简介\" class=\"headerlink\" title=\"NoSQL数据模型简介\"></a>NoSQL数据模型简介</h2><h3 id=\"案例设计\"><a href=\"#案例设计\" class=\"headerlink\" title=\"案例设计\"></a>案例设计</h3><p><code>以一个电商客户，订单，订购，地址模型来对比下关系型数据库和非关系型数据库</code></p>\n<p><strong>传统的关系型数据库你如何设计？</strong></p>\n<h3 id=\"ER图（1-1-1-N-N-N-主外键等常见）\"><a href=\"#ER图（1-1-1-N-N-N-主外键等常见）\" class=\"headerlink\" title=\"ER图（1:1/1:N/N:N,主外键等常见）\"></a>ER图（1:1/1:N/N:N,主外键等常见）</h3><ul>\n<li><p>用户对应多个订单多个地址</p>\n</li>\n<li><p>每个订单对应每个商品、价格、地址</p>\n</li>\n<li><p>每个商品对应产品</p>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210924141013.png\" class title=\"输入图片说明\"></li>\n</ul>\n<blockquote>\n<p>闲聊：用户画像分析，女人心是琢磨不透的，看了男装，剃须刀，根据她的信息找到她男朋友的生日就 在最近，后台画像已经分析完毕，准备推送广告了，结果她买了一个零食就走了~<br>90 后的程序员真的在一点点的改变生活中的点点滴滴，假设你有幸进入了大厂，你会发现周围的小伙伴 都在努力，真的就是那种可以在海底捞吃着吃着饭，突然就掏出笔记本写代码的那种，别人都以为他们 是疯子，只有他们自己内心才懂。这才是对技术的痴迷。</p>\n</blockquote>\n<h3 id=\"NoSQL你如何设计\"><a href=\"#NoSQL你如何设计\" class=\"headerlink\" title=\"NoSQL你如何设计\"></a>NoSQL你如何设计</h3><p>可以尝试使用 BSON 。</p>\n<p>BSON是一种类json的一种二进制形式的存储格式，简称Binary JSON，它和JSON一样，支持内嵌的文档</p>\n<p>对象和数组对象</p>\n<p>用BSon画出构建的数据模型</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;customer&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;id&quot;</span>: <span class=\"number\">1000</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;name&quot;</span>: <span class=\"string\">&quot;Z3&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;billingAddress&quot;</span>: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"attr\">&quot;city&quot;</span>: <span class=\"string\">&quot;beijing&quot;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"attr\">&quot;orders&quot;</span>: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"attr\">&quot;id&quot;</span>: <span class=\"number\">17</span>,</span><br><span class=\"line\">        <span class=\"attr\">&quot;customerId&quot;</span>: <span class=\"number\">1000</span>,</span><br><span class=\"line\">        <span class=\"attr\">&quot;orderItems&quot;</span>: [</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            <span class=\"attr\">&quot;productId&quot;</span>: <span class=\"number\">27</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;price&quot;</span>: <span class=\"number\">77.5</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;productName&quot;</span>: <span class=\"string\">&quot;thinking injava&quot;</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        ],</span><br><span class=\"line\">        <span class=\"attr\">&quot;shippingAddress&quot;</span>: [</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            <span class=\"attr\">&quot;city&quot;</span>: <span class=\"string\">&quot;beijing&quot;</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">        <span class=\"string\">&quot;orderPayment&quot;</span>: [</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            <span class=\"attr\">&quot;ccinfo&quot;</span>: <span class=\"string\">&quot;111-222-333&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;txnid&quot;</span>: <span class=\"string\">&quot;asdfadcd334&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;billingAddress&quot;</span>: &#123;</span><br><span class=\"line\">              <span class=\"attr\">&quot;city&quot;</span>: <span class=\"string\">&quot;beijing&quot;</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>想想关系模型数据库你如何查？如果按照我们新设计的BSon，是不是查询起来很简单。</p>\n</blockquote>\n<ul>\n<li>高并发的操作是不太建议有关联查询的，互联网公司用冗余数据来避免关联查询</li>\n<li>分布式事务是支持不了太多的并发的</li>\n</ul>\n<h2 id=\"NoSQL四大分类\"><a href=\"#NoSQL四大分类\" class=\"headerlink\" title=\"NoSQL四大分类\"></a>NoSQL四大分类</h2><p><strong>KV键值 ：</strong></p>\n<ul>\n<li>新浪：BerkeleyDB+redis</li>\n<li>美团：redis+tair</li>\n<li>阿里、百度：memcache+redis</li>\n</ul>\n<p><strong>文档型数据库(bson格式比较多) ：</strong></p>\n<ul>\n<li>CouchDB</li>\n<li>MongoDB<ul>\n<li>MongoDB 是一个 基于分布式文件存储的数据库 。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。</li>\n<li>MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"列存储数据库：\"><a href=\"#列存储数据库：\" class=\"headerlink\" title=\"列存储数据库：\"></a>列存储数据库：</h3><ul>\n<li>Cassandra, HBase</li>\n<li>分布式文件系统</li>\n</ul>\n<h3 id=\"图关系数据库\"><a href=\"#图关系数据库\" class=\"headerlink\" title=\"图关系数据库\"></a>图关系数据库</h3><ul>\n<li>它不是放图形的，放的是关系比如:朋友圈社交网络、广告推荐系统</li>\n<li>社交网络，推荐系统等。专注于构建关系图谱</li>\n<li>Neo4J, InfoGrid</li>\n</ul>\n<h3 id=\"四者对比\"><a href=\"#四者对比\" class=\"headerlink\" title=\"四者对比\"></a>四者对比</h3><img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210924141532.png\" class title=\"输入图片说明\">\n\n<h2 id=\"CAP-BASE\"><a href=\"#CAP-BASE\" class=\"headerlink\" title=\"CAP + BASE\"></a>CAP + BASE</h2><blockquote>\n<p>传统的ACID分别是什么？</p>\n</blockquote>\n<h3 id=\"关系型数据库遵循ACID规则，事务在英文中是transaction，和现实世界中的交易很类似，它有如下四个特性：\"><a href=\"#关系型数据库遵循ACID规则，事务在英文中是transaction，和现实世界中的交易很类似，它有如下四个特性：\" class=\"headerlink\" title=\"关系型数据库遵循ACID规则，事务在英文中是transaction，和现实世界中的交易很类似，它有如下四个特性：\"></a>关系型数据库遵循ACID规则，事务在英文中是transaction，和现实世界中的交易很类似，它有如下四个特性：</h3><ul>\n<li>A (Atomicity) 原子性</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务 </span><br><span class=\"line\">里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。 </span><br><span class=\"line\">比如银行转账，从A账户转100元至B账户，分为两个步骤： </span><br><span class=\"line\">1）从A账户取100元； </span><br><span class=\"line\">2）存入100元至B账户。 </span><br><span class=\"line\">这两步要么一起完成，要么一起不完成，如果只完成第一步，第二步失败，钱会莫名其妙少了100 元。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>C (Consistency) 一致性</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">事务前后数据的完整性必须保持一致。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>I (Isolation) 隔离性</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">所谓的独立性是指并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修 改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。比如现有有个交易是从A 账户转100元至B账户，在这个交易还未完成的情况下，如果此时B查询自己的账户，是看不到新增加 的100元的</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>D (Durability) 持久性</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"CAP（三进二）\"><a href=\"#CAP（三进二）\" class=\"headerlink\" title=\"CAP（三进二）\"></a>CAP（三进二）</h3><ul>\n<li>C : Consistency（强一致性）</li>\n<li>A : Availability（可用性）</li>\n<li>P : Partition tolerance（分区容错性）</li>\n</ul>\n<p><strong>CAP理论就是说在分布式存储系统中，最多只能实现上面的两点 。</strong></p>\n<blockquote>\n<p>而由于当前的网络硬件肯定会出现延迟丢包等问题，所以 分区容错性是我们必须需要实现 的。 所以我们只能在一致性和可用性之间进行权衡，没有NoSQL系统能同时保证这三点。 注意：分布式架构的时候必须做出取舍。 一致性和可用性之间取一个平衡。多余大多数web应用，其实并不需要强一致性。 因此牺牲C换取P，这是目前分布式数据库产品的方向</p>\n</blockquote>\n<p><strong>一致性与可用性的决择</strong></p>\n<blockquote>\n<p>对于web2.0网站来说，关系数据库的很多主要特性却往往无用武之地</p>\n</blockquote>\n<p><strong>数据库事务一致性需求</strong></p>\n<blockquote>\n<p>很多web实时系统并不要求严格的数据库事务，对读一致性的要求很低， 有些场合对写一致性要求并不 高。允许实现最终一致性。</p>\n</blockquote>\n<p><strong>数据库的写实时性和读实时性需求</strong></p>\n<blockquote>\n<p>对关系数据库来说，插入一条数据之后立刻查询，是肯定可以读出来这条数据的，但是对于很多web应 用来说，并不要求这么高的实时性，比方说发一条消息之 后，过几秒乃至十几秒之后，我的订阅者才看 到这条动态是完全可以接受的。</p>\n</blockquote>\n<p><strong>对复杂的SQL查询，特别是多表关联查询的需求</strong></p>\n<blockquote>\n<p>任何大数据量的web系统，都非常忌讳多个大表的关联查询，以及复杂的数据分析类型的报表查询，特 别是SNS类型的网站，从需求以及产品设计角度，就避免了这种情况的产生。往往更多的只是单表的主 键查询，以及单表的简单条件分页查询，SQL的功能被极大的弱化了。</p>\n</blockquote>\n<p><strong>CAP理论的核心</strong> 是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求， 最多只能同时较好的满足两个。因此，根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足 AP 原则三<br>大类：</p>\n<ul>\n<li><p>CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。</p>\n</li>\n<li><p>CP - 满足一致性，分区容忍必的系统，通常性能不是特别高。</p>\n</li>\n<li><p>AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。</p>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210924144835.png\" class title=\"输入图片说明\"></li>\n</ul>\n<h3 id=\"BASE-理论\"><a href=\"#BASE-理论\" class=\"headerlink\" title=\"BASE 理论\"></a>BASE 理论</h3><blockquote>\n<p>BASE理论是由eBay架构师提出的。BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互 联网分布式系统实践的总结，是基于CAP定律逐步演化而来。其核心思想是即使无法做到强一致性，但 每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p>\n</blockquote>\n<p><strong>BASE就是为了解决关系数据库强一致性引起的问题而引起的可用性降低而提出的解决方案。</strong></p>\n<h3 id=\"BASE其实是下面三个术语的缩写：\"><a href=\"#BASE其实是下面三个术语的缩写：\" class=\"headerlink\" title=\"BASE其实是下面三个术语的缩写：\"></a>BASE其实是下面三个术语的缩写：</h3><ul>\n<li><p>基本可用(Basically Available)：<br>基本可用是指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。电商大促时，为了应对访问量激增，部分用户可能会被引导到降级页面，服务层也可能只提供降级服务。这就是损失部分可用性的体现。</p>\n</li>\n<li><p>软状态(Soft State)： 软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现。MySQL Replication<br>的异步复制也是一种体现。</p>\n</li>\n<li><p>最终一致性(Eventual Consistency)： 最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。</p>\n</li>\n</ul>\n<blockquote>\n<p>它的思想是通过让系统放松对某一时刻数据一致性的要求来换取系统整体伸缩性和性能上改观。为什么 这么说呢，缘由就在于大型系统往往由于地域分布和极高性能的要求，不可能采用分布式事务来完成这 些指标，要想获得这些指标，我们必须采用另外一种方式来完成，这里BASE就是解决这个问题的办法！<br><strong>解释：</strong></p>\n</blockquote>\n<ul>\n<li>1 、分布式：不同的多台服务器上面部署不同的服务模块（工程），他们之间通过Rpc通信和调用，对外提供服务和组内协作。</li>\n<li>2 、集群：不同的多台服务器上面部署相同的服务模块，通过分布式调度软件进行统一的调度，对外提供服务和访问。</li>\n</ul>\n<h1 id=\"Redis入门\"><a href=\"#Redis入门\" class=\"headerlink\" title=\"Redis入门\"></a>Redis入门</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><h3 id=\"Redis是什么\"><a href=\"#Redis是什么\" class=\"headerlink\" title=\"Redis是什么\"></a>Redis是什么</h3><blockquote>\n<p>Redis：REmote DIctionary Server（远程字典服务器） 是完全开源免费的，用C语言编写的，遵守BSD协议，是一个高性能的（Key/Value）分布式内存数据 库，基于内存运行，并支持持久化的NoSQL数据库，是当前最热门的NoSQL数据库之一，也被人们称为 数据结构服务器</p>\n</blockquote>\n<h3 id=\"Redis与其他key-value缓存产品有以下三个特点\"><a href=\"#Redis与其他key-value缓存产品有以下三个特点\" class=\"headerlink\" title=\"Redis与其他key-value缓存产品有以下三个特点\"></a>Redis与其他key-value缓存产品有以下三个特点</h3><ul>\n<li><p>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。</p>\n</li>\n<li><p>Redis不仅仅支持简单的 key-value 类型的数据，同时还提供list、set、zset、hash等数据结构的存储。</p>\n</li>\n<li><p>Redis支持数据的备份，即master-slave模式的数据备份。</p>\n</li>\n</ul>\n<h3 id=\"Redis能干嘛\"><a href=\"#Redis能干嘛\" class=\"headerlink\" title=\"Redis能干嘛\"></a>Redis能干嘛</h3><blockquote>\n<p>内存存储和持久化：redis支持异步将内存中的数据写到硬盘上，同时不影响继续服务取最新N个数据的操作，如：可以将最新的 10 条评论的ID放在Redis的List集合里面 发布、订阅消息系统 地图信息分析 定时器、计数器……</p>\n</blockquote>\n<h3 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h3><p>数据类型、基本操作和配置</p>\n<p>持久化和复制，RDB、AOF</p>\n<p>事务的控制</p>\n<p>…..</p>\n<h3 id=\"常用网站\"><a href=\"#常用网站\" class=\"headerlink\" title=\"常用网站\"></a>常用网站</h3><h3 id=\"https-redis-io-官网\"><a href=\"#https-redis-io-官网\" class=\"headerlink\" title=\"https://redis.io/ 官网\"></a><a href=\"https://redis.io/\">https://redis.io/</a> 官网</h3><h3 id=\"http-www-redis-cn-中文网\"><a href=\"#http-www-redis-cn-中文网\" class=\"headerlink\" title=\"http://www.redis.cn 中文网\"></a><a href=\"http://www.redis.cn/\">http://www.redis.cn</a> 中文网</h3><h2 id=\"Windows安装\"><a href=\"#Windows安装\" class=\"headerlink\" title=\"Windows安装\"></a>Windows安装</h2><h3 id=\"下载地址：https-github-com-dmajkic-redis-downloads-素材提供\"><a href=\"#下载地址：https-github-com-dmajkic-redis-downloads-素材提供\" class=\"headerlink\" title=\"下载地址：https://github.com/dmajkic/redis/downloads ( 素材提供 )\"></a>下载地址：<a href=\"https://github.com/dmajkic/redis/downloads\">https://github.com/dmajkic/redis/downloads</a> ( 素材提供 )</h3><p>解压到自己电脑的环境目录即可</p>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927092007.png\" class title=\"输入图片说明\">\n\n<h3 id=\"双击-redis-server-exe-启动即可\"><a href=\"#双击-redis-server-exe-启动即可\" class=\"headerlink\" title=\"双击 redis-server.exe 启动即可\"></a>双击 redis-server.exe 启动即可</h3><img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927092027.png\" class title=\"输入图片说明\">\n\n<p><strong>通过客户端去访问 redis-cli</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 基本的<span class=\"built_in\">set</span>设值</span></span><br><span class=\"line\">127.0.0.1:6379&gt; set key kuangshen</span><br><span class=\"line\">OK</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 取出存储的值</span></span><br><span class=\"line\">127.0.0.1:6379&gt; get key</span><br><span class=\"line\">&quot;kuangshen&quot;</span><br></pre></td></tr></table></figure>\n\n<p><code>重要提示</code></p>\n<blockquote>\n<p>由于企业里面做Redis开发，99%都是Linux版的运用和安装，几乎不会涉及到Windows版，上一步的讲 解只是为了知识的完整性，Windows版不作为重点，大家可以自己玩，企业实战就认一个版：Linux版</p>\n</blockquote>\n<p><strong><a href=\"http://www.redis.cn/topics/introduction\">http://www.redis.cn/topics/introduction</a></strong></p>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927092145.png\" class title=\"输入图片说明\">\n\n<h2 id=\"Linux安装\"><a href=\"#Linux安装\" class=\"headerlink\" title=\"Linux安装\"></a>Linux安装</h2><h3 id=\"下载地址-http-download-redis-io-releases-redis-5-0-7-tar-gz\"><a href=\"#下载地址-http-download-redis-io-releases-redis-5-0-7-tar-gz\" class=\"headerlink\" title=\"下载地址 http://download.redis.io/releases/redis-5.0.7.tar.gz\"></a>下载地址 <a href=\"http://download.redis.io/releases/redis-5.0.7.tar.gz\">http://download.redis.io/releases/redis-5.0.7.tar.gz</a></h3><img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927092233.png\" class title=\"输入图片说明\">\n\n<h3 id=\"安装步骤\"><a href=\"#安装步骤\" class=\"headerlink\" title=\"安装步骤\"></a>安装步骤</h3><ul>\n<li>1 、下载获得 redis-5.0.7.tar.gz 后将它放到我们Linux的目录下 /opt</li>\n<li>2 、/opt 目录下，解压命令 ： tar -zxvf redis-5.0.7.tar.gz</li>\n<li>3 、解压完成后出现文件夹：redis-5.0.</li>\n<li>4 、进入目录： cd redis-5.0.</li>\n<li>5 、在 redis-5.0.7 目录下执行 make 命令</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">运行make命令时故意出现的错误解析：</span><br><span class=\"line\">1. 安装gcc (gcc是linux下的一个编译程序，是c程序的编译工具)</span><br><span class=\"line\">能上网: yum install gcc-c++</span><br><span class=\"line\">版本测试: gcc-v</span><br><span class=\"line\">2. 二次make</span><br><span class=\"line\">3. Jemalloc/jemalloc.h: 没有那个文件或目录</span><br><span class=\"line\">运行 make distclean 之后再make</span><br><span class=\"line\">4. Redis Test（可以不用执行）</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>6 、如果make完成后继续执行 make install</li>\n<li>7 、查看默认安装目录：usr/local/bin 1 /usr 这是一个非常重要的目录，类似于windows下的Program Files,存放用户的程序</li>\n<li>8 、拷贝配置文件（备用）</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">cd /usr/local/bin</span><br><span class=\"line\">ls -l</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 在redis的解压目录下备份redis.conf</span></span><br><span class=\"line\">mkdir myredis</span><br><span class=\"line\">cp redis.conf myredis  # 拷一个备份，养成良好的习惯，我们就修改这个文件</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 修改配置保证可以后台应用</span></span><br><span class=\"line\">vim redis.conf</span><br></pre></td></tr></table></figure>\n\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927092451.png\" class title=\"输入图片说明\">\n\n<ul>\n<li>A、redis.conf配置文件中daemonize守护线程，默认是NO。</li>\n<li>B、daemonize是用来指定redis是否要用守护线程的方式启动。</li>\n</ul>\n<p><strong>daemonize 设置yes或者no区别</strong></p>\n<ul>\n<li><p>daemonize:yes</p>\n<p>  *<br>  redis采用的是单进程多线程的模式。当redis.conf中选项daemonize设置成yes时，代表开启守护进程模式。在该模式下，redis会在后台运行，并将进程pid号写入至redis.conf选项pidfile设置的文件中，此时redis将一直运行，除非手动kill该进程。</p>\n</li>\n<li><p>daemonize:no</p>\n<ul>\n<li>当daemonize选项设置成no时，当前界面将进入redis的命令行界面，exit强制退出或者关闭连接工具(putty,xshell等)都会导致redis进程退出。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"9-、启动测试一下！\"><a href=\"#9-、启动测试一下！\" class=\"headerlink\" title=\"9 、启动测试一下！\"></a>9 、启动测试一下！</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 【shell】启动redis服务</span></span><br><span class=\"line\">[root@192 bin]# cd /usr/local/bin</span><br><span class=\"line\">[root@192 bin]# redis-server /opt/redis-5.0.7/redis.conf</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> redis客户端连接===&gt; 观察地址的变化，如果连接ok,是直接连上的，redis默认端口号 6379</span></span><br><span class=\"line\">[root@192 bin]# redis-cli -p 6379</span><br><span class=\"line\">127.0.0.1:6379&gt; ping</span><br><span class=\"line\">PONG</span><br><span class=\"line\">127.0.0.1:6379&gt; set k1 helloworld</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; get k</span><br><span class=\"line\">&quot;helloworld&quot;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 【shell】ps显示系统当前进程信息</span></span><br><span class=\"line\">[root@192 myredis]# ps -ef|grep redis</span><br><span class=\"line\">root 16005  1  0 04 :45? 00 :00:00 redis-server</span><br><span class=\"line\">127.0.0.1:</span><br><span class=\"line\">root 16031  15692  0 04 :47 pts/0 00 :00:00 redis-cli -p 6379</span><br><span class=\"line\">root 16107  16076  0 04 :51 pts/2 00 :00:00 grep --color=auto redis</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 【redis】关闭连接</span></span><br><span class=\"line\">127.0.0.1:6379&gt; shutdown</span><br><span class=\"line\">not connected&gt; exit</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 【shell】ps显示系统当前进程信息</span></span><br><span class=\"line\">[root@192 myredis]# ps -ef|grep redis</span><br><span class=\"line\">root 16140  16076  0 04 :53 pts/2 00 :00:00 grep --color=auto redis</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"基础知识说明\"><a href=\"#基础知识说明\" class=\"headerlink\" title=\"基础知识说明\"></a>基础知识说明</h2><p>准备工作：开启redis服务，客户端连接</p>\n<blockquote>\n<p>redis压力测试工具—–Redis-benchmark</p>\n</blockquote>\n<p>Redis-benchmark是官方自带的Redis性能测试工具，可以有效的测试Redis服务的性能。</p>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927092755.png\" class title=\"输入图片说明\">\n\n<h3 id=\"redis-性能测试工具可选参数如下所示：\"><a href=\"#redis-性能测试工具可选参数如下所示：\" class=\"headerlink\" title=\"redis 性能测试工具可选参数如下所示：\"></a>redis 性能测试工具可选参数如下所示：</h3><table>\n<thead>\n<tr>\n<th>序号</th>\n<th>选项</th>\n<th>描述</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>-h</td>\n<td>指定服务器主机名</td>\n<td>127.0.0.1</td>\n</tr>\n<tr>\n<td>2</td>\n<td>-p</td>\n<td>指定服务器端口</td>\n<td>6379</td>\n</tr>\n<tr>\n<td>3</td>\n<td>-s</td>\n<td>指定服务器</td>\n<td>socket</td>\n</tr>\n<tr>\n<td>4</td>\n<td>-c</td>\n<td>指定并发连接数</td>\n<td>50</td>\n</tr>\n<tr>\n<td>5</td>\n<td>-n</td>\n<td>指定请求数</td>\n<td>10000</td>\n</tr>\n<tr>\n<td>6</td>\n<td>-d</td>\n<td>以字节的形式指定 SET/GET 值的数据大小</td>\n<td>2</td>\n</tr>\n<tr>\n<td>7</td>\n<td>-k</td>\n<td>1=keep alive 0=reconnect</td>\n<td>1</td>\n</tr>\n<tr>\n<td>8</td>\n<td>-r</td>\n<td>SET/GET/INCR 使用随机 key, SADD 使用随机值</td>\n<td></td>\n</tr>\n<tr>\n<td>9</td>\n<td>-P</td>\n<td>通过管道传输 请求</td>\n<td>1</td>\n</tr>\n<tr>\n<td>10</td>\n<td>-q</td>\n<td>强制退出 redis。仅显示 query/sec 值</td>\n<td></td>\n</tr>\n<tr>\n<td>11</td>\n<td>–csv</td>\n<td>以 CSV 格式输出</td>\n<td></td>\n</tr>\n<tr>\n<td>12</td>\n<td>-l</td>\n<td>生成循环，永久执行测试</td>\n<td></td>\n</tr>\n<tr>\n<td>13</td>\n<td>-t</td>\n<td>仅运行以逗号分隔的测试命令列表。</td>\n<td></td>\n</tr>\n<tr>\n<td>14</td>\n<td>-I</td>\n<td>Idle 模式。仅打开 N 个 idle 连接并等待。</td>\n<td></td>\n</tr>\n</tbody></table>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 测试一： 100 个并发连接， 100000 个请求，检测host为localhost 端口为 6379 的redis服务器性能</span></span><br><span class=\"line\">redis-benchmark -h localhost -p 6379 -c 100 -n 100000</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 测试出来的所有命令只举例一个！</span></span><br><span class=\"line\">====== SET ======</span><br><span class=\"line\"> 100000 requests completed in 1.88 seconds # 对集合写入测试</span><br><span class=\"line\"> 100 parallel clients # 每次请求有 100 个并发客户端</span><br><span class=\"line\"> 3 bytes payload # 每次写入 3 个字节的数据，有效载荷</span><br><span class=\"line\">keep alive: 1 # 保持一个连接，一台服务器来处理这些请求</span><br><span class=\"line\"></span><br><span class=\"line\">17.05% &lt;= 1 milliseconds</span><br><span class=\"line\">97.35% &lt;= 2 milliseconds</span><br><span class=\"line\">99.97% &lt;= 3 milliseconds</span><br><span class=\"line\">100.00% &lt;= 3 milliseconds # 所有请求在 3 毫秒内完成</span><br><span class=\"line\">53248.14 requests per second # 每秒处理 53248.14 次请求</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"基本数据库常识\"><a href=\"#基本数据库常识\" class=\"headerlink\" title=\"基本数据库常识\"></a>基本数据库常识</h3><h3 id=\"默认-16-个数据库，类似数组下标从零开始，初始默认使用零号库\"><a href=\"#默认-16-个数据库，类似数组下标从零开始，初始默认使用零号库\" class=\"headerlink\" title=\"默认 16 个数据库，类似数组下标从零开始，初始默认使用零号库\"></a>默认 16 个数据库，类似数组下标从零开始，初始默认使用零号库</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">查看 redis.conf ，里面有默认的配置</span><br><span class=\"line\">databases 16</span><br><span class=\"line\"></span><br><span class=\"line\"># Set the number of databases. The default database is DB 0, you can select</span><br><span class=\"line\"># a different one on a per-connection basis using SELECT &lt;dbid&gt; where</span><br><span class=\"line\"># dbid is a number between 0 and &#x27;databases&#x27;-1</span><br><span class=\"line\">databases 16</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Select命令切换数据库\"><a href=\"#Select命令切换数据库\" class=\"headerlink\" title=\"Select命令切换数据库\"></a>Select命令切换数据库</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; select 7</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379[7]&gt;</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 不同的库可以存不同的数据</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\">## Dbsize查看当前数据库的key的数量</span></span></span><br><span class=\"line\">127.0.0.1:6379&gt; select 7</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379[7]&gt; DBSIZE</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">127.0.0.1:6379[7]&gt; select 0</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; DBSIZE</span><br><span class=\"line\">(integer) 5</span><br><span class=\"line\">127.0.0.1:6379&gt; keys * # 查看具体的key</span><br><span class=\"line\">1 ) &quot;counter:__rand_int__&quot;</span><br><span class=\"line\">2 ) &quot;mylist&quot;</span><br><span class=\"line\">3 ) &quot;k1&quot;</span><br><span class=\"line\">4 ) &quot;myset:__rand_int__&quot;</span><br><span class=\"line\">5 ) &quot;key:__rand_int__&quot;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Flushdb：清空当前库\"><a href=\"#Flushdb：清空当前库\" class=\"headerlink\" title=\"Flushdb：清空当前库\"></a>Flushdb：清空当前库</h3><h3 id=\"Flushall：清空全部的库\"><a href=\"#Flushall：清空全部的库\" class=\"headerlink\" title=\"Flushall：清空全部的库\"></a>Flushall：清空全部的库</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; DBSIZE</span><br><span class=\"line\">(integer) 5</span><br><span class=\"line\">127.0.0.1:6379&gt; FLUSHDB</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; DBSIZE</span><br><span class=\"line\">(integer) 0</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"为什么默认端口是-6379-？粉丝效应！\"><a href=\"#为什么默认端口是-6379-？粉丝效应！\" class=\"headerlink\" title=\"为什么默认端口是 6379 ？粉丝效应！\"></a>为什么默认端口是 6379 ？粉丝效应！</h3><blockquote>\n<p>为什么redis是单线程</p>\n</blockquote>\n<blockquote>\n<p>我们首先要明白，Redis很快！官方表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了！</p>\n</blockquote>\n<blockquote>\n<p>Redis采用的是基于内存的采用的是单进程单线程模型的 KV 数据库，由C语言编写，官方提供的数据是可以达到100000+的QPS（每秒内查询次数）。这个数据不比采用单进程多线程的同样基于内存的 KV数据库 Memcached 差！</p>\n</blockquote>\n<h3 id=\"Redis为什么这么快？\"><a href=\"#Redis为什么这么快？\" class=\"headerlink\" title=\"Redis为什么这么快？\"></a>Redis为什么这么快？</h3><ul>\n<li><p>1 ）以前一直有个误区，以为：高性能服务器 一定是多线程来实现的 原因很简单因为误区二导致的：多线程 一定比 单线程 效率高，其实不然！ 在说这个事前希望大家都能对 CPU 、 内存 、 硬盘的速度都有了解了！</p>\n</li>\n<li><p>2 ）redis 核心就是 如果我的数据全都在内存里，我单线程的去操作 就是效率最高的，为什么呢，因为 多线程的本质就是 CPU 模拟出来多个线程的情况，这种模拟出来的情况就有一个代价，就是上下文的切<br>换，对于一个内存的系统来说，它没有上下文的切换就是效率最高的。redis 用 单个CPU 绑定一块内存 的数据，然后针对这块内存的数据进行多次读写的时候，都是在一个CPU上完成的，所以它是单线程处<br>理这个事。在内存的情况下，这个方案就是最佳方案。 因为一次CPU上下文的切换大概在 1500ns 左右。从内存中读取 1MB 的连续数据，耗时大约为 250us， 假设1MB的数据由多个线程读取了 1000 次，那么就有 1000<br>次时间上下文的切换，那么就有1500ns *<br>1000 = 1500us ，我单线程的读完1MB数据才250us ,你光时间上下文的切换就用了1500us了，我还不 算你每次读一点数据 的时间。</p>\n</li>\n</ul>\n<h1 id=\"五大数据类型\"><a href=\"#五大数据类型\" class=\"headerlink\" title=\"五大数据类型\"></a>五大数据类型</h1><blockquote>\n<p>官方文档</p>\n</blockquote>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927094518.png\" class title=\"输入图片说明\">\n\n<p>命令文档 <a href=\"http://doc.redisfans.com/\">http://doc.redisfans.com/</a></p>\n<h3 id=\"全段翻译：\"><a href=\"#全段翻译：\" class=\"headerlink\" title=\"全段翻译：\"></a>全段翻译：</h3><blockquote>\n<p>Redis是一个开放源代码（BSD许可）的内存中数据结构存储，用作数据库，缓存和消息代理。它支持数 据结构，例如字符串，哈希，列表，集合，带范围查询的排序集合，位图，超日志，带有半径查询和流 的地理空间索引。Redis具有内置的复制，Lua脚本，LRU驱逐，事务和不同级别的磁盘持久性，并通过 Redis Sentinel和Redis Cluster自动分区提供了高可用性。</p>\n</blockquote>\n<h3 id=\"String-（字符串类型）\"><a href=\"#String-（字符串类型）\" class=\"headerlink\" title=\"String （字符串类型）\"></a>String （字符串类型）</h3><blockquote>\n<p>String是redis最基本的类型，你可以理解成Memcached一模一样的类型，一个key对应一个value。<br><br>String类型是二进制安全的，意思是redis的string可以包含任何数据，比如jpg图片或者序列化的对象。<br><br>String类型是redis最基本的数据类型，一个redis中字符串value最多可以是512M。<br></p>\n</blockquote>\n<h3 id=\"Hash（哈希，类似-Java里的Map）\"><a href=\"#Hash（哈希，类似-Java里的Map）\" class=\"headerlink\" title=\"Hash（哈希，类似 Java里的Map）\"></a>Hash（哈希，类似 Java里的Map）</h3><blockquote>\n<p>Redis hash 是一个键值对集合。<br><br>Redis hash 是一个String类型的field和value的映射表，hash特别适合用于存储对象。<br><br>类似Java里面的Map&lt;String,Object&gt;<br></p>\n</blockquote>\n<h3 id=\"List（列表）\"><a href=\"#List（列表）\" class=\"headerlink\" title=\"List（列表）\"></a>List（列表）</h3><blockquote>\n<p>Redis列表是简单的字符串列表，按照插入顺序排序，你可以添加一个元素到列表的头部（左边）或者尾部（右边）。<br><br>它的底层实际是个链表!</p>\n</blockquote>\n<h3 id=\"Set（集合）\"><a href=\"#Set（集合）\" class=\"headerlink\" title=\"Set（集合）\"></a>Set（集合）</h3><blockquote>\n<p>Redis的Set是String类型的无序集合，它是通过HashTable实现的!</p>\n</blockquote>\n<h3 id=\"Zset（sorted-set：有序集合）\"><a href=\"#Zset（sorted-set：有序集合）\" class=\"headerlink\" title=\"Zset（sorted set：有序集合）\"></a>Zset（sorted set：有序集合）</h3><blockquote>\n<p>Redis zset 和 set 一样，也是String类型元素的集合，且不允许重复的成员。<br><br>不同的是每个元素都会关联一个double类型的分数。<br><br><br>Redis正是通过分数来为集合中的成员进行从小到大的排序，zset的成员是唯一的，但是分数（Score）<br><br>却可以重复。<br></p>\n</blockquote>\n<h2 id=\"Redis键（key）\"><a href=\"#Redis键（key）\" class=\"headerlink\" title=\"Redis键（key）\"></a>Redis键（key）</h2><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> keys * 查看所有的key</span></span><br><span class=\"line\">127.0.0.1:6379&gt; keys *</span><br><span class=\"line\">(empty list or set)</span><br><span class=\"line\">127.0.0.1:6379&gt; set name qinjiang</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; keys *</span><br><span class=\"line\">1 ) &quot;name&quot;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> exists key 的名字，判断某个key是否存在</span></span><br><span class=\"line\">127.0.0.1:6379&gt; EXISTS name</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; EXISTS name1</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> move key db ---&gt; 当前库就没有了，被移除了</span></span><br><span class=\"line\">127.0.0.1:6379&gt; move name 1</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; keys *</span><br><span class=\"line\">(empty list or set)</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> expire key 秒钟：为给定 key 设置生存时间，当 key 过期时(生存时间为 0 )，它会被自动删</span></span><br><span class=\"line\">除。</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ttl key 查看还有多少秒过期，-1 表示永不过期，-2 表示已过期</span></span><br><span class=\"line\">127.0.0.1:6379&gt; set name qinjiang</span><br><span class=\"line\">OK</span><br><span class=\"line\"></span><br><span class=\"line\">127.0.0.1:6379&gt; EXPIRE name 10</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; ttl name</span><br><span class=\"line\">(integer) 4</span><br><span class=\"line\">127.0.0.1:6379&gt; ttl name</span><br><span class=\"line\">(integer) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; ttl name</span><br><span class=\"line\">(integer) 2</span><br><span class=\"line\">127.0.0.1:6379&gt; ttl name</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; ttl name</span><br><span class=\"line\">(integer) -2</span><br><span class=\"line\">127.0.0.1:6379&gt; keys *</span><br><span class=\"line\">(empty list or set)</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"built_in\">type</span> key 查看你的key是什么类型</span></span><br><span class=\"line\">127.0.0.1:6379&gt; set name qinjiang</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; get name</span><br><span class=\"line\">&quot;qinjiang&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; type name</span><br><span class=\"line\">string</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"字符串String\"><a href=\"#字符串String\" class=\"headerlink\" title=\"字符串String\"></a>字符串String</h2><p><code>单值单Value</code></p>\n<p><strong>常用命令说明：</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\">### # ===================================================</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"built_in\">set</span>、get、del、append、strlen</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; set key1 value1 # 设置值</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; get key1  # 获得key</span><br><span class=\"line\">&quot;value1&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; del key1  # 删除key</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; keys *  # 查看全部的key</span><br><span class=\"line\">(empty list or set)</span><br><span class=\"line\">127.0.0.1:6379&gt; exists key1 # 确保 key1 不存在</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; append key1 &quot;hello&quot; # 对不存在的 key 进行 APPEND ，等同于 SET</span><br><span class=\"line\">key1 &quot;hello&quot;</span><br><span class=\"line\">(integer) 5 # 字符长度</span><br><span class=\"line\">127.0.0.1:6379&gt; APPEND key1 &quot;-2333&quot; # 对已存在的字符串进行 APPEND</span><br><span class=\"line\">(integer) 10 # 长度从 5 个字符增加到 10 个字符</span><br><span class=\"line\">127.0.0.1:6379&gt; get key1</span><br><span class=\"line\">&quot;hello-2333&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; STRLEN key1 # # 获取字符串的长度</span><br><span class=\"line\">(integer) 10</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> incr、decr 一定要是数字才能进行加减，+1 和 -1。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> incrby、decrby 命令将 key 中储存的数字加上指定的增量值。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"></span><br><span class=\"line\">127.0.0.1:6379&gt; set views 0 # 设置浏览量为 0</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; incr views  # 浏览 + 1</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; incr views  # 浏览 + 1</span><br><span class=\"line\">(integer) 2</span><br><span class=\"line\">127.0.0.1:6379&gt; decr views  # 浏览 - 1</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; incrby views 10 # +10</span><br><span class=\"line\">(integer) 11</span><br><span class=\"line\">127.0.0.1:6379&gt; decrby views 10 # -10</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> range [范围]</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> getrange 获取指定区间范围内的值，类似between...and的关系，从零到负一表示全部</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; set key2 abcd123456  # 设置key2的值</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; getrange key2 0 -1 # 获得全部的值</span><br><span class=\"line\">&quot;abcd123456&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; getrange key2 0 2 # 截取部分字符串</span><br><span class=\"line\">&quot;abc&quot;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> setrange 设置指定区间范围内的值，格式是setrange key值 具体值</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; get key2</span><br><span class=\"line\">&quot;abcd123456&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; SETRANGE key2 1 xx # 替换值</span><br><span class=\"line\">(integer) 10</span><br><span class=\"line\">127.0.0.1:6379&gt; get key2</span><br><span class=\"line\">&quot;axxd123456&quot;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> setex（<span class=\"built_in\">set</span> with expire）键秒值</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> setnx（<span class=\"built_in\">set</span> <span class=\"keyword\">if</span> not exist）</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; setex key3 60 expire  # 设置过期时间</span><br><span class=\"line\">OK</span><br><span class=\"line\"></span><br><span class=\"line\">127.0.0.1:6379&gt; ttl key3  # 查看剩余的时间</span><br><span class=\"line\">(integer) 55</span><br><span class=\"line\">127.0.0.1:6379&gt; setnx mykey &quot;redis&quot; # 如果不存在就设置，成功返回 1</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; setnx mykey &quot;mongodb&quot; # 如果存在就设置，失败返回 0</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; get mykey</span><br><span class=\"line\">&quot;redis&quot;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> mset Mset 命令用于同时设置一个或多个 key-value 对。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> mget Mget 命令返回所有(一个或多个)给定 key 的值。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 如果给定的 key 里面，有某个 key 不存在，那么这个 key 返回特殊值 nil 。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> msetnx 当所有 key 都成功设置，返回 1 。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 如果所有给定 key 都设置失败(至少有一个 key 已经存在)，那么返回 0 。原子操</span></span><br><span class=\"line\">作</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; mset k10 v10 k11 v11 k12 v12</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; keys *</span><br><span class=\"line\">1 ) &quot;k12&quot;</span><br><span class=\"line\">2 ) &quot;k11&quot;</span><br><span class=\"line\">3 ) &quot;k10&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; mget k10 k11 k12 k13</span><br><span class=\"line\">1 ) &quot;v10&quot;</span><br><span class=\"line\">2 ) &quot;v11&quot;</span><br><span class=\"line\">3 ) &quot;v12&quot;</span><br><span class=\"line\">4 ) (nil)</span><br><span class=\"line\">127.0.0.1:6379&gt; msetnx k10 v10 k15 v15 # 原子性操作！</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; get key15</span><br><span class=\"line\">(nil)</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 传统对象缓存</span></span><br><span class=\"line\">set user:1 value(json数据)</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 可以用来缓存对象</span></span><br><span class=\"line\">mset user:1:name zhangsan user:1:age 2</span><br><span class=\"line\">mget user:1:name user:1:age</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> getset（先get再<span class=\"built_in\">set</span>）</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; getset db mongodb # 没有旧值，返回 nil</span><br><span class=\"line\">(nil)</span><br><span class=\"line\">127.0.0.1:6379&gt; get db</span><br><span class=\"line\">&quot;mongodb&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; getset db redis # 返回旧值 mongodb</span><br><span class=\"line\">&quot;mongodb&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; get db</span><br><span class=\"line\">&quot;redis&quot;</span><br></pre></td></tr></table></figure>\n\n<p>String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。</p>\n<p>常规key-value缓存应用：</p>\n<p>常规计数：微博数，粉丝数等。</p>\n<h2 id=\"列表List\"><a href=\"#列表List\" class=\"headerlink\" title=\"列表List\"></a>列表List</h2><p><code>单值多Value</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\">### # ===================================================</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Lpush：将一个或多个值插入到列表头部。（左）</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> rpush：将一个或多个值插入到列表尾部。（右）</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> lrange：返回列表中指定区间内的元素，区间以偏移量 START 和 END 指定。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 其中 0 表示列表的第一个元素， 1 表示列表的第二个元素，以此类推。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此</span></span><br><span class=\"line\">类推。</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; LPUSH list &quot;one&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; LPUSH list &quot;two&quot;</span><br><span class=\"line\">(integer) 2</span><br><span class=\"line\"></span><br><span class=\"line\">127.0.0.1:6379&gt; RPUSH list &quot;right&quot;</span><br><span class=\"line\">(integer) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; Lrange list 0 -1</span><br><span class=\"line\">1 ) &quot;two&quot;</span><br><span class=\"line\">2 ) &quot;one&quot;</span><br><span class=\"line\">3 ) &quot;right&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; Lrange list 0 1</span><br><span class=\"line\">1 ) &quot;two&quot;</span><br><span class=\"line\">2 ) &quot;one&quot;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> lpop 命令用于移除并返回列表的第一个元素。当列表 key 不存在时，返回 nil 。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> rpop 移除列表的最后一个元素，返回值为移除的元素。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; Lpop list</span><br><span class=\"line\">&quot;two&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; Rpop list</span><br><span class=\"line\">&quot;right&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; Lrange list 0 -1</span><br><span class=\"line\">1 ) &quot;one&quot;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Lindex，按照索引下标获得元素（-1代表最后一个， 0 代表是第一个）</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; Lindex list 1</span><br><span class=\"line\">(nil)</span><br><span class=\"line\">127.0.0.1:6379&gt; Lindex list 0</span><br><span class=\"line\">&quot;one&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; Lindex list -1</span><br><span class=\"line\">&quot;one&quot;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> llen 用于返回列表的长度。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; flushdb</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; Lpush list &quot;one&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; Lpush list &quot;two&quot;</span><br><span class=\"line\">(integer) 2</span><br><span class=\"line\">127.0.0.1:6379&gt; Lpush list &quot;three&quot;</span><br><span class=\"line\">(integer) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; Llen list # 返回列表的长度</span><br><span class=\"line\">(integer) 3</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> lrem key 根据参数 COUNT 的值，移除列表中与参数 VALUE 相等的元素。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; lrem list 1 &quot;two&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; Lrange list 0 -1</span><br><span class=\"line\">1 ) &quot;three&quot;</span><br><span class=\"line\">2 ) &quot;one&quot;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Ltrim key 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区</span></span><br><span class=\"line\">间之内的元素都将被删除。</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"></span><br><span class=\"line\">127.0.0.1:6379&gt; RPUSH mylist &quot;hello&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; RPUSH mylist &quot;hello&quot;</span><br><span class=\"line\">(integer) 2</span><br><span class=\"line\">127.0.0.1:6379&gt; RPUSH mylist &quot;hello2&quot;</span><br><span class=\"line\">(integer) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; RPUSH mylist &quot;hello3&quot;</span><br><span class=\"line\">(integer) 4</span><br><span class=\"line\">127.0.0.1:6379&gt; ltrim mylist 1 2</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class=\"line\">1 ) &quot;hello&quot;</span><br><span class=\"line\">2 ) &quot;hello2&quot;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> rpoplpush 移除列表的最后一个元素，并将该元素添加到另一个列表并返回。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; rpush mylist &quot;hello&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; rpush mylist &quot;foo&quot;</span><br><span class=\"line\">(integer) 2</span><br><span class=\"line\">127.0.0.1:6379&gt; rpush mylist &quot;bar&quot;</span><br><span class=\"line\">(integer) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; rpoplpush mylist myotherlist</span><br><span class=\"line\">&quot;bar&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class=\"line\">1 ) &quot;hello&quot;</span><br><span class=\"line\">2 ) &quot;foo&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; lrange myotherlist 0 -1</span><br><span class=\"line\">1 ) &quot;bar&quot;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> lset key index value 将列表 key 下标为 index 的元素的值设置为 value 。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; exists list  # 对空列表(key 不存在)进行 LSET</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; lset list 0 item # 报错</span><br><span class=\"line\">(error) ERR no such key</span><br><span class=\"line\"></span><br><span class=\"line\">127.0.0.1:6379&gt; lpush list &quot;value1&quot; # 对非空列表进行 LSET</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; lrange list 0 0</span><br><span class=\"line\">1 ) &quot;value1&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; lset list 0 &quot;new&quot; # 更新值</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; lrange list 0 0</span><br><span class=\"line\">1 ) &quot;new&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; lset list 1 &quot;new&quot; # index 超出范围报错</span><br><span class=\"line\">(error) ERR index out of range</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> linsert key before/after pivot value 用于在列表的元素前或者后插入元素。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 将值 value 插入到列表 key 当中，位于值 pivot 之前或之后。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">redis&gt;</span><span class=\"bash\"> RPUSH mylist <span class=\"string\">&quot;Hello&quot;</span></span></span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\"><span class=\"meta\">redis&gt;</span><span class=\"bash\"> RPUSH mylist <span class=\"string\">&quot;World&quot;</span></span></span><br><span class=\"line\">(integer) 2</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">redis&gt;</span><span class=\"bash\"> LINSERT mylist BEFORE <span class=\"string\">&quot;World&quot;</span> <span class=\"string\">&quot;There&quot;</span></span></span><br><span class=\"line\">(integer) 3</span><br><span class=\"line\"><span class=\"meta\">redis&gt;</span><span class=\"bash\"> LRANGE mylist 0 -1</span></span><br><span class=\"line\">1 ) &quot;Hello&quot;</span><br><span class=\"line\">2 ) &quot;There&quot;</span><br><span class=\"line\">3 ) &quot;World&quot;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"性能总结\"><a href=\"#性能总结\" class=\"headerlink\" title=\"性能总结\"></a>性能总结</h3><ul>\n<li>它是一个字符串链表，left，right 都可以插入添加</li>\n<li>如果键不存在，创建新的链表</li>\n<li>如果键已存在，新增内容</li>\n<li>如果值全移除，对应的键也就消失了</li>\n<li>链表的操作无论是头和尾效率都极高，但假如是对中间元素进行操作，效率就很惨淡了。</li>\n</ul>\n<blockquote>\n<p>list就是链表，略有数据结构知识的人都应该能理解其结构。使用Lists结构，我们可以轻松地实现最新消 息排行等功能。List的另一个应用就是消息队列，可以利用List的PUSH操作，将任务存在List中，然后工 作线程再用POP操作将任务取出进行执行。Redis还提供了操作List中某一段的api，你可以直接查询，删 除List中某一段的元素。</p>\n</blockquote>\n<blockquote>\n<p>Redis的list是每个子元素都是String类型的双向链表，可以通过push和pop操作从列表的头部或者尾部添加或者删除元素，这样List即可以作为栈，也可以作为队列。</p>\n</blockquote>\n<h2 id=\"集合Set\"><a href=\"#集合Set\" class=\"headerlink\" title=\"集合Set\"></a>集合Set</h2><p><code>单值多value</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\">### # ===================================================</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sadd 将一个或多个成员元素加入到集合中，不能重复</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> smembers 返回集合中的所有的成员。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sismember 命令判断成员元素是否是集合的成员。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; sadd myset &quot;hello&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; sadd myset &quot;kuangshen&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; sadd myset &quot;kuangshen&quot;</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class=\"line\">1 ) &quot;kuangshen&quot;</span><br><span class=\"line\">2 ) &quot;hello&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; SISMEMBER myset &quot;hello&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; SISMEMBER myset &quot;world&quot;</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> scard，获取集合里面的元素个数</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; scard myset</span><br><span class=\"line\">(integer) 2</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> srem key value 用于移除集合中的一个或多个成员元素</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; srem myset &quot;kuangshen&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\"></span><br><span class=\"line\">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class=\"line\">1 ) &quot;hello&quot;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> srandmember key 命令用于返回集合中的一个随机元素。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class=\"line\">1 ) &quot;kuangshen&quot;</span><br><span class=\"line\">2 ) &quot;world&quot;</span><br><span class=\"line\">3 ) &quot;hello&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; SRANDMEMBER myset</span><br><span class=\"line\">&quot;hello&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; SRANDMEMBER myset 2</span><br><span class=\"line\">1 ) &quot;world&quot;</span><br><span class=\"line\">2 ) &quot;kuangshen&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; SRANDMEMBER myset 2</span><br><span class=\"line\">1 ) &quot;kuangshen&quot;</span><br><span class=\"line\">2 ) &quot;hello&quot;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> spop key 用于移除集合中的指定 key 的一个或多个随机元素</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class=\"line\">1 ) &quot;kuangshen&quot;</span><br><span class=\"line\">2 ) &quot;world&quot;</span><br><span class=\"line\">3 ) &quot;hello&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; spop myset</span><br><span class=\"line\">&quot;world&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; spop myset</span><br><span class=\"line\">&quot;kuangshen&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; spop myset</span><br><span class=\"line\">&quot;hello&quot;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> smove SOURCE DESTINATION MEMBER</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 将指定成员 member 元素从 <span class=\"built_in\">source</span> 集合移动到 destination 集合。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; sadd myset &quot;hello&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; sadd myset &quot;world&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; sadd myset &quot;kuangshen&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; sadd myset2 &quot;set2&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; smove myset myset2 &quot;kuangshen&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class=\"line\">1 ) &quot;world&quot;</span><br><span class=\"line\">2 ) &quot;hello&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; SMEMBERS myset2</span><br><span class=\"line\">1 ) &quot;kuangshen&quot;</span><br><span class=\"line\">2 ) &quot;set2&quot;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">- 数字集合类</span><br><span class=\"line\">  - 差集： sdiff</span><br><span class=\"line\">  - 交集： sinter</span><br><span class=\"line\">  - 并集： sunion</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; sadd key1 &quot;a&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; sadd key1 &quot;b&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; sadd key1 &quot;c&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; sadd key2 &quot;c&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; sadd key2 &quot;d&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; sadd key2 &quot;e&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; SDIFF key1 key2 # 差集</span><br><span class=\"line\">1 ) &quot;a&quot;</span><br><span class=\"line\">2 ) &quot;b&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; SINTER key1 key2 # 交集</span><br><span class=\"line\">1 ) &quot;c&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; SUNION key1 key2 # 并集</span><br><span class=\"line\">1 ) &quot;a&quot;</span><br><span class=\"line\">2 ) &quot;b&quot;</span><br><span class=\"line\">3 ) &quot;c&quot;</span><br><span class=\"line\">4 ) &quot;e&quot;</span><br><span class=\"line\">5 ) &quot;d&quot;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis还为集合提供了求交集、并集、差集等操作，可以非常方便的实现如共同关注、共同喜好、二度好友等功能，对上面的所有集合操作，你还可以使用不同的命令选择将结果返回给客户端还是存集到一个新的集合中。</p>\n</blockquote>\n<h2 id=\"哈希Hash\"><a href=\"#哈希Hash\" class=\"headerlink\" title=\"哈希Hash\"></a>哈希Hash</h2><p><code>kv模式不变，但V是一个键值对</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\">### # ===================================================</span></span></span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hset、hget 命令用于为哈希表中的字段赋值 。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hmset、hmget 同时将多个field-value对设置到哈希表中。会覆盖哈希表中已存在的字段。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hgetall 用于返回哈希表中，所有的字段和值。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hdel 用于删除哈希表 key 中的一个或多个指定字段</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; hset myhash field1 &quot;kuangshen&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; hget myhash field1</span><br><span class=\"line\">&quot;kuangshen&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; HMSET myhash field1 &quot;Hello&quot; field2 &quot;World&quot;</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; HGET myhash field1</span><br><span class=\"line\">&quot;Hello&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; HGET myhash field2</span><br><span class=\"line\">&quot;World&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; hgetall myhash</span><br><span class=\"line\">1 ) &quot;field1&quot;</span><br><span class=\"line\">2 ) &quot;Hello&quot;</span><br><span class=\"line\">3 ) &quot;field2&quot;</span><br><span class=\"line\">4 ) &quot;World&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; HDEL myhash field1</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; hgetall myhash</span><br><span class=\"line\">1 ) &quot;field2&quot;</span><br><span class=\"line\">2 ) &quot;World&quot;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hlen 获取哈希表中字段的数量。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; hlen myhash</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; HMSET myhash field1 &quot;Hello&quot; field2 &quot;World&quot;</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; hlen myhash</span><br><span class=\"line\">(integer) 2</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hexists 查看哈希表的指定字段是否存在。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; hexists myhash field1</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; hexists myhash field3</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hkeys 获取哈希表中的所有域（field）。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hvals 返回哈希表所有域(field)的值。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; HKEYS myhash</span><br><span class=\"line\">1 ) &quot;field2&quot;</span><br><span class=\"line\">2 ) &quot;field1&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; HVALS myhash</span><br><span class=\"line\">1 ) &quot;World&quot;</span><br><span class=\"line\">2 ) &quot;Hello&quot;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hincrby 为哈希表中的字段值加上指定增量值。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; hset myhash field 5</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; HINCRBY myhash field 1</span><br><span class=\"line\">(integer) 6</span><br><span class=\"line\">127.0.0.1:6379&gt; HINCRBY myhash field -1</span><br><span class=\"line\">(integer) 5</span><br><span class=\"line\">127.0.0.1:6379&gt; HINCRBY myhash field -10</span><br><span class=\"line\">(integer) -5</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hsetnx 为哈希表中不存在的的字段赋值 。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; HSETNX myhash field1 &quot;hello&quot;</span><br><span class=\"line\">(integer) 1 # 设置成功，返回 1 。</span><br><span class=\"line\">127.0.0.1:6379&gt; HSETNX myhash field1 &quot;world&quot;</span><br><span class=\"line\">(integer) 0 # 如果给定字段已经存在，返回 0 。</span><br><span class=\"line\">127.0.0.1:6379&gt; HGET myhash field1</span><br><span class=\"line\">&quot;hello&quot;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。存储部分变更的数据，如用户信息等。</p>\n</blockquote>\n<h2 id=\"有序集合Zset\"><a href=\"#有序集合Zset\" class=\"headerlink\" title=\"有序集合Zset\"></a>有序集合Zset</h2><p><code>在set基础上，加一个score值。之前set是k1 v1 v2 v3，现在zset是 k1 score1 v1 score2 v2</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\">### # ===================================================</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> zadd 将一个或多个成员元素及其分数值加入到有序集当中。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> zrange 返回有序集中，指定区间内的成员</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; zadd myset 1 &quot;one&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; zadd myset 2 &quot;two&quot; 3 &quot;three&quot;</span><br><span class=\"line\">(integer) 2</span><br><span class=\"line\">127.0.0.1:6379&gt; ZRANGE myset 0 -1</span><br><span class=\"line\">1 ) &quot;one&quot;</span><br><span class=\"line\">2 ) &quot;two&quot;</span><br><span class=\"line\">3 ) &quot;three&quot;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> zrangebyscore 返回有序集合中指定分数区间的成员列表。有序集成员按分数值递增(从小到大)</span></span><br><span class=\"line\">次序排列。</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; zadd salary 2500 xiaoming</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; zadd salary 5000 xiaohong</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; zadd salary 500 kuangshen</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Inf无穷大量+∞,同样地,-∞可以表示为-Inf。</span></span><br><span class=\"line\">127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf +inf # 显示整个有序集</span><br><span class=\"line\">1 ) &quot;kuangshen&quot;</span><br><span class=\"line\">2 ) &quot;xiaoming&quot;</span><br><span class=\"line\">3 ) &quot;xiaohong&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf +inf withscores # 递增排列</span><br><span class=\"line\">1 ) &quot;kuangshen&quot;</span><br><span class=\"line\">2 ) &quot;500&quot;</span><br><span class=\"line\">3 ) &quot;xiaoming&quot;</span><br><span class=\"line\">4 ) &quot;2500&quot;</span><br><span class=\"line\">5 ) &quot;xiaohong&quot;</span><br><span class=\"line\">6 ) &quot;5000&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; ZREVRANGE salary 0 -1 WITHSCORES  # 递减排列</span><br><span class=\"line\">1 ) &quot;xiaohong&quot;</span><br><span class=\"line\">2 ) &quot;5000&quot;</span><br><span class=\"line\">3 ) &quot;xiaoming&quot;</span><br><span class=\"line\">4 ) &quot;2500&quot;</span><br><span class=\"line\">5 ) &quot;kuangshen&quot;</span><br><span class=\"line\">6 ) &quot;500&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf 2500 WITHSCORES # 显示工资 &lt;=2500</span><br><span class=\"line\">的所有成员</span><br><span class=\"line\">1 ) &quot;kuangshen&quot;</span><br><span class=\"line\">2 ) &quot;500&quot;</span><br><span class=\"line\">3 ) &quot;xiaoming&quot;</span><br><span class=\"line\">4 ) &quot;2500&quot;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\">### # ===================================================</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> zrem 移除有序集中的一个或多个成员</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; ZRANGE salary 0 -1</span><br><span class=\"line\">1 ) &quot;kuangshen&quot;</span><br><span class=\"line\">2 ) &quot;xiaoming&quot;</span><br><span class=\"line\">3 ) &quot;xiaohong&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; zrem salary kuangshen</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; ZRANGE salary 0 -1</span><br><span class=\"line\">1 ) &quot;xiaoming&quot;</span><br><span class=\"line\">2 ) &quot;xiaohong&quot;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> zcard 命令用于计算集合中元素的数量。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; zcard salary</span><br><span class=\"line\">(integer) 2</span><br><span class=\"line\">OK</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> zcount 计算有序集合中指定分数区间的成员数量。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; zadd myset 1 &quot;hello&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; zadd myset 2 &quot;world&quot; 3 &quot;kuangshen&quot;</span><br><span class=\"line\">(integer) 2</span><br><span class=\"line\">127.0.0.1:6379&gt; ZCOUNT myset 1 3</span><br><span class=\"line\">(integer) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; ZCOUNT myset 1 2</span><br><span class=\"line\">(integer) 2</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> zrank 返回有序集中指定成员的排名。其中有序集成员按分数值递增(从小到大)顺序排列。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; zadd salary 2500 xiaoming</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; zadd salary 5000 xiaohong</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; zadd salary 500 kuangshen</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; ZRANGE salary 0 -1 WITHSCORES  # 显示所有成员及其 score 值</span><br><span class=\"line\">1 ) &quot;kuangshen&quot;</span><br><span class=\"line\">2 ) &quot;500&quot;</span><br><span class=\"line\">3 ) &quot;xiaoming&quot;</span><br><span class=\"line\">4 ) &quot;2500&quot;</span><br><span class=\"line\">5 ) &quot;xiaohong&quot;</span><br><span class=\"line\">6 ) &quot;5000&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; zrank salary kuangshen  # 显示 kuangshen 的薪水排名，最少</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; zrank salary xiaohong # 显示 xiaohong 的薪水排名，第三</span><br><span class=\"line\">(integer) 2</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> zrevrank 返回有序集中成员的排名。其中有序集成员按分数值递减(从大到小)排序。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ===================================================</span></span><br><span class=\"line\">127.0.0.1:6379&gt; ZREVRANK salary bright</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列，比如一个存储全班同学成绩的sorted set，其集合value可以是同学的学号，而score就可以是其考试得分，这样在数据插入集合的时候，就已经进行了天然的排序。可以用sorted set来做带权重的队列，比如普通消息的score为 1 ，重要消息的score为 2 ，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。</p>\n</blockquote>\n<blockquote>\n<p>排行榜应用，取TOP N操作 ！</p>\n</blockquote>\n<h1 id=\"三种特殊数据类型\"><a href=\"#三种特殊数据类型\" class=\"headerlink\" title=\"三种特殊数据类型\"></a>三种特殊数据类型</h1><h2 id=\"GEO地理位置\"><a href=\"#GEO地理位置\" class=\"headerlink\" title=\"GEO地理位置\"></a>GEO地理位置</h2><blockquote>\n<p>简介</p>\n</blockquote>\n<blockquote>\n<p>Redis 的 GEO 特性在 Redis 3.2 版本中推出， 这个功能可以将用户给定的地理位置信息储存起来， 并对这些信息进行操作。来实现诸如附近位置、摇一摇这类依赖于地理位置信息的功能。geo的数据类型为zset。</p>\n</blockquote>\n<blockquote>\n<p>GEO 的数据结构总共有六个常用命令：geoadd、geopos、geodist、georadius、georadiusbymember、gethash</p>\n</blockquote>\n<h3 id=\"官方文档：https-www-redis-net-cn-order-3685-html\"><a href=\"#官方文档：https-www-redis-net-cn-order-3685-html\" class=\"headerlink\" title=\"官方文档：https://www.redis.net.cn/order/3685.html\"></a>官方文档：<a href=\"https://www.redis.net.cn/order/3685.html\">https://www.redis.net.cn/order/3685.html</a></h3><h3 id=\"geoadd\"><a href=\"#geoadd\" class=\"headerlink\" title=\"geoadd\"></a>geoadd</h3><p><strong>解析：</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\">### # 语法</span></span></span><br><span class=\"line\">geoadd key longitude latitude member...</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 将给定的空间元素(纬度、经度、名字)添加到指定的键里面。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 这些数据会以有序集he的形式被储存在键里面，从而使得georadius和georadiusbymember这样的命令可以在之后通过位置查询取得这些元素。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> geoadd命令以标准的x,y格式接受参数,所以用户必须先输入经度,然后再输入纬度。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> geoadd能够记录的坐标是有限的:非常接近两极的区域无法被索引。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 有效的经度介于-180-180度之间，有效的纬度介于-85.05112878 度至 85.05112878 度之间。，当用户尝试输入一个超出范围的经度或者纬度时,geoadd命令将返回一个错误。</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"测试：百度搜索经纬度查询，模拟真实数据\"><a href=\"#测试：百度搜索经纬度查询，模拟真实数据\" class=\"headerlink\" title=\"测试：百度搜索经纬度查询，模拟真实数据\"></a>测试：百度搜索经纬度查询，模拟真实数据</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; geoadd china:city 116.23 40.22 北京</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; geoadd china:city 121.48 31.40 上海 113.88 22.55 深圳 120.21</span><br><span class=\"line\">30.20 杭州</span><br><span class=\"line\">(integer) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; geoadd china:city 106.54 29.40 重庆 108.93 34.23 西安 114.02</span><br><span class=\"line\">30.58 武汉</span><br><span class=\"line\">(integer) 3</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"geopos\"><a href=\"#geopos\" class=\"headerlink\" title=\"geopos\"></a>geopos</h3><p><strong>解析：</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">geopos key member [member...]</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">从key里返回所有给定位置元素的位置（经度和纬度）</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"测试：\"><a href=\"#测试：\" class=\"headerlink\" title=\"测试：\"></a>测试：</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; geopos china:city 北京</span><br><span class=\"line\">1 ) 1 ) &quot;116.23000055551528931&quot;</span><br><span class=\"line\">2 ) &quot;40.2200010338739844&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; geopos china:city 上海 重庆</span><br><span class=\"line\">1 ) 1 ) &quot;121.48000091314315796&quot;</span><br><span class=\"line\">2 ) &quot;31.40000025319353938&quot;</span><br><span class=\"line\">2 ) 1 ) &quot;106.54000014066696167&quot;</span><br><span class=\"line\">2 ) &quot;29.39999880018641676&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; geopos china:city 新疆</span><br><span class=\"line\">1 ) (nil)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"geodist\"><a href=\"#geodist\" class=\"headerlink\" title=\"geodist\"></a>geodist</h3><p><strong>解析：</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">geodist key member1 member2 [unit]</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 返回两个给定位置之间的距离，如果两个位置之间的其中一个不存在,那么命令返回空值。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 指定单位的参数unit必须是以下单位的其中一个：</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> m表示单位为米</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> km表示单位为千米</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> mi表示单位为英里</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ft表示单位为英尺</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 如果用户没有显式地指定单位参数,那么geodist默认使用米作为单位。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">geodist命令在计算距离时会假设地球为完美的球形,在极限情况下,这一假设最大会造成0.5%的误差。</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"测试：-1\"><a href=\"#测试：-1\" class=\"headerlink\" title=\"测试：\"></a>测试：</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; geodist china:city 北京 上海</span><br><span class=\"line\">&quot;1088785.4302&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; geodist china:city 北京 上海 km</span><br><span class=\"line\">&quot;1088.7854&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; geodist china:city 重庆 北京 km</span><br><span class=\"line\">&quot;1491.6716&quot;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"georadius\"><a href=\"#georadius\" class=\"headerlink\" title=\"georadius\"></a>georadius</h3><h3 id=\"解析：\"><a href=\"#解析：\" class=\"headerlink\" title=\"解析：\"></a>解析：</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\">### # 语法</span></span></span><br><span class=\"line\">georadius key longitude latitude radius m|km|ft|mi [withcoord][withdist]</span><br><span class=\"line\">[withhash][asc|desc][count count]</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 以给定的经纬度为中心， 找出某一半径内的元素</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"测试：重新连接-redis-cli，增加参数-–raw-，可以强制输出中文，不然会乱码\"><a href=\"#测试：重新连接-redis-cli，增加参数-–raw-，可以强制输出中文，不然会乱码\" class=\"headerlink\" title=\"测试：重新连接 redis-cli，增加参数 –raw ，可以强制输出中文，不然会乱码\"></a>测试：重新连接 redis-cli，增加参数 –raw ，可以强制输出中文，不然会乱码</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@kuangshen bin]# redis-cli --raw -p 6379</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 在 china:city 中寻找坐标 100 30 半径为 1000km 的城市</span></span><br><span class=\"line\">127.0.0.1:6379&gt; georadius china:city 100 30 1000 km</span><br><span class=\"line\">重庆</span><br><span class=\"line\">西安</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> withdist 返回位置名称和中心距离</span></span><br><span class=\"line\">127.0.0.1:6379&gt; georadius china:city 100 30 1000 km withdist</span><br><span class=\"line\">重庆</span><br><span class=\"line\">635.2850</span><br><span class=\"line\">西安</span><br><span class=\"line\">963.3171</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> withcoord 返回位置名称和经纬度</span></span><br><span class=\"line\">127.0.0.1:6379&gt; georadius china:city 100 30 1000 km withcoord</span><br><span class=\"line\">重庆</span><br><span class=\"line\">106.54000014066696167</span><br><span class=\"line\">29.39999880018641676</span><br><span class=\"line\">西安</span><br><span class=\"line\">108.92999857664108276</span><br><span class=\"line\">34.23000121926852302</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> withdist withcoord 返回位置名称 距离 和经纬度 count 限定寻找个数</span></span><br><span class=\"line\">127.0.0.1:6379&gt; georadius china:city 100 30 1000 km withcoord withdist count</span><br><span class=\"line\">1</span><br><span class=\"line\">重庆</span><br><span class=\"line\">635.2850</span><br><span class=\"line\">106.54000014066696167</span><br><span class=\"line\">29.39999880018641676</span><br><span class=\"line\">127.0.0.1:6379&gt; georadius china:city 100 30 1000 km withcoord withdist count</span><br><span class=\"line\">2</span><br><span class=\"line\">重庆</span><br><span class=\"line\">635.2850</span><br><span class=\"line\">106.54000014066696167</span><br><span class=\"line\">29.39999880018641676</span><br><span class=\"line\">西安</span><br><span class=\"line\">963.3171</span><br><span class=\"line\">108.92999857664108276</span><br><span class=\"line\">34.23000121926852302</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"georadiusbymember\"><a href=\"#georadiusbymember\" class=\"headerlink\" title=\"georadiusbymember\"></a>georadiusbymember</h3><h3 id=\"解析：-1\"><a href=\"#解析：-1\" class=\"headerlink\" title=\"解析：\"></a>解析：</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\">### # 语法</span></span></span><br><span class=\"line\">georadiusbymember key member radius m|km|ft|mi [withcoord][withdist]</span><br><span class=\"line\">[withhash][asc|desc][count count]</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 找出位于指定范围内的元素，中心点是由给定的位置元素决定</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"测试：-2\"><a href=\"#测试：-2\" class=\"headerlink\" title=\"测试：\"></a>测试：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city 北京 1000 km</span><br><span class=\"line\">北京</span><br><span class=\"line\">西安</span><br><span class=\"line\">127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city 上海 400 km</span><br><span class=\"line\">杭州</span><br><span class=\"line\">上海</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"geohash\"><a href=\"#geohash\" class=\"headerlink\" title=\"geohash\"></a>geohash</h3><h3 id=\"解析：-2\"><a href=\"#解析：-2\" class=\"headerlink\" title=\"解析：\"></a>解析：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#### # 语法</span><br><span class=\"line\">geohash key member [member...]</span><br><span class=\"line\"># Redis使用geohash将二维经纬度转换为一维字符串，字符串越长表示位置更精确,两个字符串越相似</span><br><span class=\"line\">表示距离越近。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"测试：-3\"><a href=\"#测试：-3\" class=\"headerlink\" title=\"测试：\"></a>测试：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; geohash china:city 北京 重庆</span><br><span class=\"line\">wx4sucu47r0</span><br><span class=\"line\">wm5z22h53v0</span><br><span class=\"line\">127.0.0.1:6379&gt; geohash china:city 北京 上海</span><br><span class=\"line\">wx4sucu47r0</span><br><span class=\"line\">wtw6sk5n300</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"zrem\"><a href=\"#zrem\" class=\"headerlink\" title=\"zrem\"></a>zrem</h3><blockquote>\n<p>GEO没有提供删除成员的命令，但是因为GEO的底层实现是zset，所以可以借用zrem命令实现对地理位置信息的删除.</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; geoadd china:city 116.23 40.22 beijin</span><br><span class=\"line\">1</span><br><span class=\"line\">127.0.0.1:6379&gt; zrange china:city 0 -1 # 查看全部的元素</span><br><span class=\"line\">重庆</span><br><span class=\"line\">西安</span><br><span class=\"line\">深圳</span><br><span class=\"line\">武汉</span><br><span class=\"line\">杭州</span><br><span class=\"line\">上海</span><br><span class=\"line\">beijin</span><br><span class=\"line\">北京</span><br><span class=\"line\">127.0.0.1:6379&gt; zrem china:city beijin  # 移除元素</span><br><span class=\"line\">1</span><br><span class=\"line\">127.0.0.1:6379&gt; zrem china:city 北京 # 移除元素</span><br><span class=\"line\">1</span><br><span class=\"line\">127.0.0.1:6379&gt; zrange china:city 0 -1</span><br><span class=\"line\">重庆</span><br><span class=\"line\">西安</span><br><span class=\"line\">深圳</span><br><span class=\"line\">武汉</span><br><span class=\"line\">杭州</span><br><span class=\"line\">上海</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"HyperLogLog\"><a href=\"#HyperLogLog\" class=\"headerlink\" title=\"HyperLogLog\"></a>HyperLogLog</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>Redis 在 2.8.9 版本添加了 HyperLogLog 结构。</p>\n<p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积 非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。</p>\n<p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p>\n<blockquote>\n<p>HyperLogLog则是一种算法，它提供了不精确的去重计数方案。举个栗子：假如我要统计网页的UV（浏览用户数量，一天内同一个用户多次访问只能算一次），传统的解决方案是使用Set来保存用户id，然后统计Set中的元素数量来获取页面UV。但这种方案只能承载少量用户，一旦用户数量大起来就需要消耗大量的空间来存储用户id。我的目的是统计用户数量而不是保存用户，这简直是个吃力不讨好的方案！而使用Redis的HyperLogLog最多需要12k就可以统计大量的用户数，尽管它大概有0.81%的错误率，但对于统计UV这种不需要很精确的数据是可以忽略不计的。</p>\n</blockquote>\n<h3 id=\"什么是基数？\"><a href=\"#什么是基数？\" class=\"headerlink\" title=\"什么是基数？\"></a>什么是基数？</h3><blockquote>\n<p>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为 5 。基数估计就是在误差可接受的范围内，快速计算基数。</p>\n</blockquote>\n<h3 id=\"基本命令\"><a href=\"#基本命令\" class=\"headerlink\" title=\"基本命令\"></a>基本命令</h3><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>[PFADD key element [element…]</td>\n<td>添加指定元素到 HyperLogLog 中。</td>\n</tr>\n<tr>\n<td>[PFCOUNT key [key…]</td>\n<td>返回给定 HyperLogLog 的基数估算值。</td>\n</tr>\n<tr>\n<td>[PFMERGE destkey sourcekey[sourcekey…]</td>\n<td>将多个 HyperLogLog 合并为一个 HyperLogLog，并集计算</td>\n</tr>\n</tbody></table>\n<h3 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1: 6379 &gt; PFADD mykey a b c d e f g h i j</span><br><span class=\"line\">1</span><br><span class=\"line\">127.0.0.1: 6379 &gt; PFCOUNT mykey</span><br><span class=\"line\">10</span><br><span class=\"line\">127.0.0.1: 6379 &gt; PFADD mykey2 i j z x c v b n m</span><br><span class=\"line\">1</span><br><span class=\"line\">127.0.0.1: 6379 &gt; PFMERGE mykey3 mykey mykey2</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1: 6379 &gt; PFCOUNT mykey3</span><br><span class=\"line\">15</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"BitMap\"><a href=\"#BitMap\" class=\"headerlink\" title=\"BitMap\"></a>BitMap</h2><blockquote>\n<p>简介</p>\n</blockquote>\n<blockquote>\n<p>在开发中，可能会遇到这种情况：需要统计用户的某些信息，如活跃或不活跃，登录或者不登录；又如需要记录用户一年的打卡情况，打卡了是 1 ， 没有打卡是 0 ，如果使用普通的 key/value存储，则要记录365 条记录，如果用户量很大，需要的空间也会很大，所以 Redis 提供了 Bitmap 位图这中数据结构，Bitmap 就是通过操作二进制位来进行记录，即为 0 和 1 ；如果要记录 365 天的打卡情况，使用 Bitmap表示的形式大概如下：0101000111000111………………………，这样有什么好处呢？当然就是节约内存了， 365 天相当于 365 bit，又 1 字节 = 8 bit , 所以相当于使用 46 个字节即可。</p>\n</blockquote>\n<blockquote>\n<p>BitMap 就是通过一个 bit 位来表示某个元素对应的值或者状态, 其中的 key 就是对应元素本身，实际上底层也是通过对字符串的操作来实现。Redis 从 2.2 版本之后新增了setbit, getbit, bitcount 等几个bitmap 相关命令。</p>\n</blockquote>\n<h3 id=\"setbit-设置操作\"><a href=\"#setbit-设置操作\" class=\"headerlink\" title=\"setbit 设置操作\"></a>setbit 设置操作</h3><p>SETBIT key offset value : 设置 key 的第 offset 位为value (1或0)</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 使用 bitmap 来记录上述事例中一周的打卡记录如下所示：</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 周一： 1 ，周二： 0 ，周三： 0 ，周四： 1 ，周五： 1 ，周六： 0 ，周天： 0 （ 1 为打卡， 0 为不打卡）</span></span><br><span class=\"line\">127.0.0.1:6379&gt; setbit sign 0 1</span><br><span class=\"line\">0</span><br><span class=\"line\">127.0.0.1:6379&gt; setbit sign 1 0</span><br><span class=\"line\">0</span><br><span class=\"line\">127.0.0.1:6379&gt; setbit sign 2 0</span><br><span class=\"line\">0</span><br><span class=\"line\">127.0.0.1:6379&gt; setbit sign 3 1</span><br><span class=\"line\">0</span><br><span class=\"line\">127.0.0.1:6379&gt; setbit sign 4 1</span><br><span class=\"line\">0</span><br><span class=\"line\">127.0.0.1:6379&gt; setbit sign 5 0</span><br><span class=\"line\">0</span><br><span class=\"line\">127.0.0.1:6379&gt; setbit sign 6 0</span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"getbit-获取操作\"><a href=\"#getbit-获取操作\" class=\"headerlink\" title=\"getbit 获取操作\"></a>getbit 获取操作</h3><p>GETBIT key offset 获取offset设置的值，未设置过默认返回 0</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; getbit sign 3 # 查看周四是否打卡</span><br><span class=\"line\">1</span><br><span class=\"line\">127.0.0.1:6379&gt; getbit sign 6 # 查看周七是否打卡</span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"bitcount-统计操作\"><a href=\"#bitcount-统计操作\" class=\"headerlink\" title=\"bitcount 统计操作\"></a>bitcount 统计操作</h3><p>bitcount key [start, end] 统计 key 上位为 1 的个数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; bitcount sign</span><br><span class=\"line\">3</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Redis事务\"><a href=\"#Redis事务\" class=\"headerlink\" title=\"Redis事务\"></a>Redis事务</h1><h2 id=\"理论\"><a href=\"#理论\" class=\"headerlink\" title=\"理论\"></a>理论</h2><h3 id=\"Redis事务的概念：\"><a href=\"#Redis事务的概念：\" class=\"headerlink\" title=\"Redis事务的概念：\"></a>Redis事务的概念：</h3><blockquote>\n<p>Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p>\n</blockquote>\n<p>总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。<br><strong>Redis事务没有隔离级别的概念：</strong></p>\n<p>批量操作在发送 EXEC 命令前被放入队列缓存，并不会被实际执行！</p>\n<p><strong>Redis不保证原子性：</strong></p>\n<p>Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。</p>\n<p><strong>Redis事务的三个阶段：</strong></p>\n<ul>\n<li>开始事务</li>\n<li>命令入队</li>\n<li>执行事务</li>\n</ul>\n<h3 id=\"Redis事务相关命令：\"><a href=\"#Redis事务相关命令：\" class=\"headerlink\" title=\"Redis事务相关命令：\"></a>Redis事务相关命令：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">watch key1 key2...  #监视一或多个key,如果在事务执行之前，被监视的key被其他命令改动，则</span><br><span class=\"line\">事务被打断 （ 类似乐观锁 ）</span><br><span class=\"line\">multi # 标记一个事务块的开始（ queued ）</span><br><span class=\"line\">exec # 执行所有事务块的命令 （ 一旦执行exec后，之前加的监控锁都会被取消掉 ）</span><br><span class=\"line\">discard # 取消事务，放弃事务块中的所有命令</span><br><span class=\"line\">unwatch # 取消watch对所有key的监控</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><h3 id=\"正常执行\"><a href=\"#正常执行\" class=\"headerlink\" title=\"正常执行\"></a>正常执行</h3><img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927112345.png\" class title=\"输入图片说明\">\n\n<h3 id=\"放弃事务\"><a href=\"#放弃事务\" class=\"headerlink\" title=\"放弃事务\"></a>放弃事务</h3><img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927112358.png\" class title=\"输入图片说明\">\n\n<p>若在事务队列中存在命令性错误（类似于java编译性错误），则执行EXEC命令时，所有命令都不会执行</p>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927112441.png\" class title=\"输入图片说明\">\n\n<p>若在事务队列中存在语法性错误（类似于java的1/0的运行时异常），则执行EXEC命令时，其他正确命令会被执行，错误命令抛出异常。</p>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927112511.png\" class title=\"输入图片说明\">\n\n<h2 id=\"Watch-监控\"><a href=\"#Watch-监控\" class=\"headerlink\" title=\"Watch 监控\"></a>Watch 监控</h2><h3 id=\"悲观锁：\"><a href=\"#悲观锁：\" class=\"headerlink\" title=\"悲观锁：\"></a>悲观锁：</h3><blockquote>\n<p>悲观锁(Pessimistic Lock),顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿到这个数据就会block直到它拿到锁。传统的关系型数据库里面就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在操作之前先上锁。</p>\n</blockquote>\n<h3 id=\"乐观锁：\"><a href=\"#乐观锁：\" class=\"headerlink\" title=\"乐观锁：\"></a>乐观锁：</h3><blockquote>\n<p>乐观锁(Optimistic Lock),顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁。但是在更新的时候会判断一下再此期间别人有没有去更新这个数据，可以使用版本号等机制，乐观锁适用于多读的应用类型，这样可以提高吞吐量，乐观锁策略：提交版本必须大于记录当前版本才能执行更新。</p>\n</blockquote>\n<h3 id=\"测试：-4\"><a href=\"#测试：-4\" class=\"headerlink\" title=\"测试：\"></a>测试：</h3><ul>\n<li>1 、初始化信用卡可用余额和欠额</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; set balance 100</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; set debt 0</span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>2 、使用watch检测balance，事务期间balance数据未变动，事务执行成功</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; watch balance</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; MULTI</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; decrby balance 20</span><br><span class=\"line\">QUEUED</span><br><span class=\"line\">127.0.0.1:6379&gt; incrby debt 20</span><br><span class=\"line\">QUEUED</span><br><span class=\"line\">127.0.0.1:6379&gt; exec</span><br><span class=\"line\">1 ) (integer) 80</span><br><span class=\"line\">2 ) (integer) 20</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>3 、使用watch检测balance，事务期间balance数据变动，事务执行失败！</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\">### # 窗口一</span></span></span><br><span class=\"line\">127.0.0.1:6379&gt; watch balance</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; MULTI  # 执行完毕后，执行窗口二代码测试</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; decrby balance 20</span><br><span class=\"line\">QUEUED</span><br><span class=\"line\">127.0.0.1:6379&gt; incrby debt 20</span><br><span class=\"line\">QUEUED</span><br><span class=\"line\">127.0.0.1:6379&gt; exec  # 修改失败！</span><br><span class=\"line\">(nil)</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 窗口二</span></span><br><span class=\"line\">127.0.0.1:6379&gt; get balance</span><br><span class=\"line\">&quot;80&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; set balance 200</span><br><span class=\"line\">OK</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 窗口一：出现问题后放弃监视，然后重来！</span></span><br><span class=\"line\">127.0.0.1:6379&gt; UNWATCH  # 放弃监视</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; watch balance</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; MULTI</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; decrby balance 20</span><br><span class=\"line\">QUEUED</span><br><span class=\"line\">127.0.0.1:6379&gt; incrby debt 20</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"说明：\"><a href=\"#说明：\" class=\"headerlink\" title=\"说明：\"></a>说明：</h3><p>一但执行 EXEC 开启事务的执行后，无论事务使用执行成功， WARCH 对变量的监控都将被取消。故当事务执行失败后，需重新执行WATCH命令对变量进行监控，并开启新的事务进行操作。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>watch指令类似于乐观锁，在事务提交时，如果watch监控的多个KEY中任何KEY的值已经被其他客户端更改，则使用EXEC执行事务时，事务队列将不会被执行，同时返回Nullmulti-bulk应答以通知调用者事务执行失败。</p>\n<h1 id=\"Jedis\"><a href=\"#Jedis\" class=\"headerlink\" title=\"Jedis\"></a>Jedis</h1><blockquote>\n<p>Jedis是Redis官方推荐的Java连接开发工具。要在Java开发中使用好Redis中间件，必须对Jedis熟悉才能写成漂亮的代码</p>\n</blockquote>\n<h2 id=\"测试联通\"><a href=\"#测试联通\" class=\"headerlink\" title=\"测试联通\"></a>测试联通</h2><ul>\n<li>1 、新建一个普通的Maven项目</li>\n<li>2 、导入redis的依赖！</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>redis.clients<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>jedis<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.2.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.alibaba<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>fastjson<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.2.58<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>3 、编写测试代码</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.kuang.ping;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> redis.clients.jedis.Jedis;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Ping</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Jedis jedis = <span class=\"keyword\">new</span> Jedis(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">6379</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;连接成功&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//查看服务是否运行</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;服务正在运行: &quot;</span> + jedis.ping());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">*<span class=\"number\">4</span> 、启动redis服务</span><br><span class=\"line\">        *<span class=\"number\">5</span> 、启动测试，结果</span><br><span class=\"line\">        ```shell</span><br><span class=\"line\">        连接成功</span><br><span class=\"line\">        服务正在运行:PONG</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"常用API\"><a href=\"#常用API\" class=\"headerlink\" title=\"常用API\"></a>常用API</h2><h3 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestPassword</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Jedis jedis = <span class=\"keyword\">new</span> Jedis(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">6379</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//验证密码，如果没有设置密码这段代码省略</span></span><br><span class=\"line\">        <span class=\"comment\">// jedis.auth(&quot;password&quot;);</span></span><br><span class=\"line\"></span><br><span class=\"line\">        jedis.connect(); <span class=\"comment\">//连接</span></span><br><span class=\"line\">        jedis.disconnect(); <span class=\"comment\">//断开连接</span></span><br><span class=\"line\"></span><br><span class=\"line\">        jedis.flushAll(); <span class=\"comment\">//清空所有的key</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"对key操作的命令\"><a href=\"#对key操作的命令\" class=\"headerlink\" title=\"对key操作的命令\"></a>对key操作的命令</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestKey</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Jedis jedis = <span class=\"keyword\">new</span> Jedis(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">6379</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;清空数据：&quot;</span> + jedis.flushDB());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;判断某个键是否存在：&quot;</span> + jedis.exists(<span class=\"string\">&quot;username&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;新增&lt;&#x27;username&#x27;,&#x27;kuangshen&#x27;&gt;的键值对：&quot;</span> + jedis.set(<span class=\"string\">&quot;username&quot;</span>, <span class=\"string\">&quot;kuangshen&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;新增&lt;&#x27;password&#x27;,&#x27;password&#x27;&gt;的键值对：&quot;</span> + jedis.set(<span class=\"string\">&quot;password&quot;</span>, <span class=\"string\">&quot;password&quot;</span>));</span><br><span class=\"line\">        System.out.print(<span class=\"string\">&quot;系统中所有的键如下：&quot;</span>);</span><br><span class=\"line\">        Set&lt;String&gt; keys = jedis.keys(<span class=\"string\">&quot;*&quot;</span>);</span><br><span class=\"line\">        System.out.println(keys);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;删除键password:&quot;</span> + jedis.del(<span class=\"string\">&quot;password&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;判断键password是否存在：&quot;</span> + jedis.exists(<span class=\"string\">&quot;password&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;查看键username所存储的值的类型：&quot;</span> + jedis.type(<span class=\"string\">&quot;username&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;随机返回key空间的一个：&quot;</span> + jedis.randomKey());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;重命名key：&quot;</span> + jedis.rename(<span class=\"string\">&quot;username&quot;</span>, <span class=\"string\">&quot;name&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;取出改后的name：&quot;</span> + jedis.get(<span class=\"string\">&quot;name&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;按索引查询：&quot;</span> + jedis.select(<span class=\"number\">0</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;删除当前选择数据库中的所有key：&quot;</span> + jedis.flushDB());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;返回当前数据库中key的数目：&quot;</span> + jedis.dbSize());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;删除所有数据库中的所有key：&quot;</span> + jedis.flushAll());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"对String操作的命令\"><a href=\"#对String操作的命令\" class=\"headerlink\" title=\"对String操作的命令\"></a>对String操作的命令</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestString</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Jedis jedis = <span class=\"keyword\">new</span> Jedis(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">6379</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        jedis.flushDB();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;===========增加数据===========&quot;</span>);</span><br><span class=\"line\">        System.out.println(jedis.set(<span class=\"string\">&quot;key1&quot;</span>, <span class=\"string\">&quot;value1&quot;</span>));</span><br><span class=\"line\">        System.out.println(jedis.set(<span class=\"string\">&quot;key2&quot;</span>, <span class=\"string\">&quot;value2&quot;</span>));</span><br><span class=\"line\">        System.out.println(jedis.set(<span class=\"string\">&quot;key3&quot;</span>, <span class=\"string\">&quot;value3&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;删除键key2:&quot;</span> + jedis.del(<span class=\"string\">&quot;key2&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;获取键key2:&quot;</span> + jedis.get(<span class=\"string\">&quot;key2&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;修改key1:&quot;</span> + jedis.set(<span class=\"string\">&quot;key1&quot;</span>, <span class=\"string\">&quot;value1Changed&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;获取key1的值：&quot;</span> + jedis.get(<span class=\"string\">&quot;key1&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;在key3后面加入值：&quot;</span> + jedis.append(<span class=\"string\">&quot;key3&quot;</span>, <span class=\"string\">&quot;End&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;key3的值：&quot;</span> + jedis.get(<span class=\"string\">&quot;key3&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;增加多个键值对：&quot;</span> + jedis.mset(<span class=\"string\">&quot;key01&quot;</span>, <span class=\"string\">&quot;value01&quot;</span>, <span class=\"string\">&quot;key02&quot;</span>, <span class=\"string\">&quot;value02&quot;</span>, <span class=\"string\">&quot;key03&quot;</span>, <span class=\"string\">&quot;value03&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;获取多个键值对：&quot;</span> + jedis.mget(<span class=\"string\">&quot;key01&quot;</span>, <span class=\"string\">&quot;key02&quot;</span>, <span class=\"string\">&quot;key03&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;获取多个键值对：&quot;</span> + jedis.mget(<span class=\"string\">&quot;key01&quot;</span>, <span class=\"string\">&quot;key02&quot;</span>, <span class=\"string\">&quot;key03&quot;</span>, <span class=\"string\">&quot;key04&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;删除多个键值对：&quot;</span> + jedis.del(<span class=\"string\">&quot;key01&quot;</span>, <span class=\"string\">&quot;key02&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;获取多个键值对：&quot;</span> + jedis.mget(<span class=\"string\">&quot;key01&quot;</span>, <span class=\"string\">&quot;key02&quot;</span>, <span class=\"string\">&quot;key03&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        jedis.flushDB();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;===========新增键值对防止覆盖原先值==============&quot;</span>);</span><br><span class=\"line\">        System.out.println(jedis.setnx(<span class=\"string\">&quot;key1&quot;</span>, <span class=\"string\">&quot;value1&quot;</span>));</span><br><span class=\"line\">        System.out.println(jedis.setnx(<span class=\"string\">&quot;key2&quot;</span>, <span class=\"string\">&quot;value2&quot;</span>));</span><br><span class=\"line\">        System.out.println(jedis.setnx(<span class=\"string\">&quot;key2&quot;</span>, <span class=\"string\">&quot;value2-new&quot;</span>));</span><br><span class=\"line\">        System.out.println(jedis.get(<span class=\"string\">&quot;key1&quot;</span>));</span><br><span class=\"line\">        System.out.println(jedis.get(<span class=\"string\">&quot;key2&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;===========新增键值对并设置有效时间=============&quot;</span>);</span><br><span class=\"line\">        System.out.println(jedis.setex(<span class=\"string\">&quot;key3&quot;</span>, <span class=\"number\">2</span>, <span class=\"string\">&quot;value3&quot;</span>));</span><br><span class=\"line\">        System.out.println(jedis.get(<span class=\"string\">&quot;key3&quot;</span>));</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            TimeUnit.SECONDS.sleep(<span class=\"number\">3</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(jedis.get(<span class=\"string\">&quot;key3&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;===========获取原值，更新为新值==========&quot;</span>);</span><br><span class=\"line\">        System.out.println(jedis.getSet(<span class=\"string\">&quot;key2&quot;</span>, <span class=\"string\">&quot;key2GetSet&quot;</span>));</span><br><span class=\"line\">        System.out.println(jedis.get(<span class=\"string\">&quot;key2&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;获得key2的值的字串：&quot;</span> + jedis.getrange(<span class=\"string\">&quot;key2&quot;</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"对List操作命令\"><a href=\"#对List操作命令\" class=\"headerlink\" title=\"对List操作命令\"></a>对List操作命令</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestList</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Jedis jedis = <span class=\"keyword\">new</span> Jedis(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">6379</span>);</span><br><span class=\"line\">        jedis.flushDB();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;===========添加一个list===========&quot;</span>);</span><br><span class=\"line\">        jedis.lpush(<span class=\"string\">&quot;collections&quot;</span>, <span class=\"string\">&quot;ArrayList&quot;</span>, <span class=\"string\">&quot;Vector&quot;</span>, <span class=\"string\">&quot;Stack&quot;</span>, <span class=\"string\">&quot;HashMap&quot;</span>, <span class=\"string\">&quot;WeakHashMap&quot;</span>, <span class=\"string\">&quot;LinkedHashMap&quot;</span>);</span><br><span class=\"line\">        jedis.lpush(<span class=\"string\">&quot;collections&quot;</span>, <span class=\"string\">&quot;HashSet&quot;</span>);</span><br><span class=\"line\">        jedis.lpush(<span class=\"string\">&quot;collections&quot;</span>, <span class=\"string\">&quot;TreeSet&quot;</span>);</span><br><span class=\"line\">        jedis.lpush(<span class=\"string\">&quot;collections&quot;</span>, <span class=\"string\">&quot;TreeMap&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;collections的内容：&quot;</span> + jedis.lrange(<span class=\"string\">&quot;collections&quot;</span>, <span class=\"number\">0</span>, -<span class=\"number\">1</span>));<span class=\"comment\">//-1代表倒数第一个元素，-2代表倒数第二个元素,end为-1表示查询全部</span></span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;collections区间0-3的元素：&quot;</span> + jedis.lrange(<span class=\"string\">&quot;collections&quot;</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;===============================&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 删除列表指定的值 ，第二个参数为删除的个数（有重复时），后add进去的值先被删，类似于出栈</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;删除指定元素个数：&quot;</span> + jedis.lrem(<span class=\"string\">&quot;collections&quot;</span>, <span class=\"number\">2</span>, <span class=\"string\">&quot;HashMap&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;collections的内容：&quot;</span> + jedis.lrange(<span class=\"string\">&quot;collections&quot;</span>, <span class=\"number\">0</span>, -<span class=\"number\">1</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;删除下表0-3区间之外的元素：&quot;</span> + jedis.ltrim(<span class=\"string\">&quot;collections&quot;</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;collections的内容：&quot;</span> + jedis.lrange(<span class=\"string\">&quot;collections&quot;</span>, <span class=\"number\">0</span>, -<span class=\"number\">1</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;collections列表出栈（左端）：&quot;</span> + jedis.lpop(<span class=\"string\">&quot;collections&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;collections的内容：&quot;</span> + jedis.lrange(<span class=\"string\">&quot;collections&quot;</span>, <span class=\"number\">0</span>, -<span class=\"number\">1</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;collections添加元素，从列表右端，与lpush相对应：&quot;</span> + jedis.rpush(<span class=\"string\">&quot;collections&quot;</span>, <span class=\"string\">&quot;EnumMap&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;collections的内容：&quot;</span> + jedis.lrange(<span class=\"string\">&quot;collections&quot;</span>, <span class=\"number\">0</span>, -<span class=\"number\">1</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;collections列表出栈（右端）：&quot;</span> + jedis.rpop(<span class=\"string\">&quot;collections&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;collections的内容：&quot;</span> + jedis.lrange(<span class=\"string\">&quot;collections&quot;</span>, <span class=\"number\">0</span>, -<span class=\"number\">1</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;修改collections指定下标 1 的内容：&quot;</span> + jedis.lset(<span class=\"string\">&quot;collections&quot;</span>, <span class=\"number\">1</span>, <span class=\"string\">&quot;LinkedArrayList&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;collections的内容：&quot;</span> + jedis.lrange(<span class=\"string\">&quot;collections&quot;</span>, <span class=\"number\">0</span>, -<span class=\"number\">1</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;===============================&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;collections的长度：&quot;</span> + jedis.llen(<span class=\"string\">&quot;collections&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;获取collections下标为 2 的元素：&quot;</span> + jedis.lindex(<span class=\"string\">&quot;collections&quot;</span>, <span class=\"number\">2</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;===============================&quot;</span>);</span><br><span class=\"line\">        jedis.lpush(<span class=\"string\">&quot;sortedList&quot;</span>, <span class=\"string\">&quot;3&quot;</span>, <span class=\"string\">&quot;6&quot;</span>, <span class=\"string\">&quot;2&quot;</span>, <span class=\"string\">&quot;0&quot;</span>, <span class=\"string\">&quot;7&quot;</span>, <span class=\"string\">&quot;4&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;sortedList排序前：&quot;</span> + jedis.lrange(<span class=\"string\">&quot;sortedList&quot;</span>, <span class=\"number\">0</span>, -<span class=\"number\">1</span>));</span><br><span class=\"line\">        System.out.println(jedis.sort(<span class=\"string\">&quot;sortedList&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;sortedList排序后：&quot;</span> + jedis.lrange(<span class=\"string\">&quot;sortedList&quot;</span>, <span class=\"number\">0</span>, -<span class=\"number\">1</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"对Set的操作命令\"><a href=\"#对Set的操作命令\" class=\"headerlink\" title=\"对Set的操作命令\"></a>对Set的操作命令</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestSet</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Jedis jedis = <span class=\"keyword\">new</span> Jedis(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">6379</span>);</span><br><span class=\"line\">        jedis.flushDB();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;============向集合中添加元素（不重复）============&quot;</span>);</span><br><span class=\"line\">        System.out.println(jedis.sadd(<span class=\"string\">&quot;eleSet&quot;</span>, <span class=\"string\">&quot;e1&quot;</span>, <span class=\"string\">&quot;e2&quot;</span>, <span class=\"string\">&quot;e4&quot;</span>, <span class=\"string\">&quot;e3&quot;</span>, <span class=\"string\">&quot;e0&quot;</span>, <span class=\"string\">&quot;e8&quot;</span>, <span class=\"string\">&quot;e7&quot;</span>, <span class=\"string\">&quot;e5&quot;</span>));</span><br><span class=\"line\">        System.out.println(jedis.sadd(<span class=\"string\">&quot;eleSet&quot;</span>, <span class=\"string\">&quot;e6&quot;</span>));</span><br><span class=\"line\">        System.out.println(jedis.sadd(<span class=\"string\">&quot;eleSet&quot;</span>, <span class=\"string\">&quot;e6&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;eleSet的所有元素为：&quot;</span> + jedis.smembers(<span class=\"string\">&quot;eleSet&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;删除一个元素e0：&quot;</span> + jedis.srem(<span class=\"string\">&quot;eleSet&quot;</span>, <span class=\"string\">&quot;e0&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;eleSet的所有元素为：&quot;</span> + jedis.smembers(<span class=\"string\">&quot;eleSet&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;删除两个元素e7和e6：&quot;</span> + jedis.srem(<span class=\"string\">&quot;eleSet&quot;</span>, <span class=\"string\">&quot;e7&quot;</span>, <span class=\"string\">&quot;e6&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;eleSet的所有元素为：&quot;</span> + jedis.smembers(<span class=\"string\">&quot;eleSet&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;随机的移除集合中的一个元素：&quot;</span> + jedis.spop(<span class=\"string\">&quot;eleSet&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;随机的移除集合中的一个元素：&quot;</span> + jedis.spop(<span class=\"string\">&quot;eleSet&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;eleSet的所有元素为：&quot;</span> + jedis.smembers(<span class=\"string\">&quot;eleSet&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;eleSet中包含元素的个数：&quot;</span> + jedis.scard(<span class=\"string\">&quot;eleSet&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;e3是否在eleSet中：&quot;</span> + jedis.sismember(<span class=\"string\">&quot;eleSet&quot;</span>, <span class=\"string\">&quot;e3&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;e1是否在eleSet中：&quot;</span> + jedis.sismember(<span class=\"string\">&quot;eleSet&quot;</span>, <span class=\"string\">&quot;e1&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;e1是否在eleSet中：&quot;</span> + jedis.sismember(<span class=\"string\">&quot;eleSet&quot;</span>, <span class=\"string\">&quot;e5&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;=================================&quot;</span>);</span><br><span class=\"line\">        System.out.println(jedis.sadd(<span class=\"string\">&quot;eleSet1&quot;</span>, <span class=\"string\">&quot;e1&quot;</span>, <span class=\"string\">&quot;e2&quot;</span>, <span class=\"string\">&quot;e4&quot;</span>, <span class=\"string\">&quot;e3&quot;</span>, <span class=\"string\">&quot;e0&quot;</span>, <span class=\"string\">&quot;e8&quot;</span>, <span class=\"string\">&quot;e7&quot;</span>, <span class=\"string\">&quot;e5&quot;</span>));</span><br><span class=\"line\">        System.out.println(jedis.sadd(<span class=\"string\">&quot;eleSet2&quot;</span>, <span class=\"string\">&quot;e1&quot;</span>, <span class=\"string\">&quot;e2&quot;</span>, <span class=\"string\">&quot;e4&quot;</span>, <span class=\"string\">&quot;e3&quot;</span>, <span class=\"string\">&quot;e0&quot;</span>, <span class=\"string\">&quot;e8&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;将eleSet1中删除e1并存入eleSet3中：&quot;</span> + jedis.smove(<span class=\"string\">&quot;eleSet1&quot;</span>, <span class=\"string\">&quot;eleSet3&quot;</span>, <span class=\"string\">&quot;e1&quot;</span>));<span class=\"comment\">//移到集合元素</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;将eleSet1中删除e2并存入eleSet3中：&quot;</span> + jedis.smove(<span class=\"string\">&quot;eleSet1&quot;</span>, <span class=\"string\">&quot;eleSet3&quot;</span>, <span class=\"string\">&quot;e2&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;eleSet1中的元素：&quot;</span> + jedis.smembers(<span class=\"string\">&quot;eleSet1&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;eleSet3中的元素：&quot;</span> + jedis.smembers(<span class=\"string\">&quot;eleSet3&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;============集合运算=================&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;eleSet1中的元素：&quot;</span> + jedis.smembers(<span class=\"string\">&quot;eleSet1&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;eleSet2中的元素：&quot;</span> + jedis.smembers(<span class=\"string\">&quot;eleSet2&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;eleSet1和eleSet2的交集:&quot;</span> + jedis.sinter(<span class=\"string\">&quot;eleSet1&quot;</span>, <span class=\"string\">&quot;eleSet2&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;eleSet1和eleSet2的并集:&quot;</span> + jedis.sunion(<span class=\"string\">&quot;eleSet1&quot;</span>, <span class=\"string\">&quot;eleSet2&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;eleSet1和eleSet2的差集:&quot;</span> + jedis.sdiff(<span class=\"string\">&quot;eleSet1&quot;</span>, <span class=\"string\">&quot;eleSet2&quot;</span>));<span class=\"comment\">//eleSet1中有，eleSet2中没有</span></span><br><span class=\"line\">        jedis.sinterstore(<span class=\"string\">&quot;eleSet4&quot;</span>, <span class=\"string\">&quot;eleSet1&quot;</span>, <span class=\"string\">&quot;eleSet2&quot;</span>);<span class=\"comment\">//求交集并将交集保存到dstkey的集合</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;eleSet4中的元素：&quot;</span> + jedis.smembers(<span class=\"string\">&quot;eleSet4&quot;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"对Hash的操作命令\"><a href=\"#对Hash的操作命令\" class=\"headerlink\" title=\"对Hash的操作命令\"></a>对Hash的操作命令</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestHash</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Jedis jedis = <span class=\"keyword\">new</span> Jedis(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">6379</span>);</span><br><span class=\"line\">        jedis.flushDB();</span><br><span class=\"line\">        Map&lt;String, String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;key1&quot;</span>, <span class=\"string\">&quot;value1&quot;</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;key2&quot;</span>, <span class=\"string\">&quot;value2&quot;</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;key3&quot;</span>, <span class=\"string\">&quot;value3&quot;</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;key4&quot;</span>, <span class=\"string\">&quot;value4&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//添加名称为hash（key）的hash元素</span></span><br><span class=\"line\">        jedis.hmset(<span class=\"string\">&quot;hash&quot;</span>, map);</span><br><span class=\"line\">        <span class=\"comment\">//向名称为hash的hash中添加key为key5，value为value5元素</span></span><br><span class=\"line\">        jedis.hset(<span class=\"string\">&quot;hash&quot;</span>, <span class=\"string\">&quot;key5&quot;</span>, <span class=\"string\">&quot;value5&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;散列hash的所有键值对为：&quot;</span> + jedis.hgetAll(<span class=\"string\">&quot;hash&quot;</span>));<span class=\"comment\">//return Map&lt;String,String&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;散列hash的所有键为：&quot;</span> + jedis.hkeys(<span class=\"string\">&quot;hash&quot;</span>));<span class=\"comment\">//return</span></span><br><span class=\"line\">        Set&lt;String&gt;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;散列hash的所有值为：&quot;</span> + jedis.hvals(<span class=\"string\">&quot;hash&quot;</span>));<span class=\"comment\">//return</span></span><br><span class=\"line\">        List&lt;String&gt;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;将key6保存的值加上一个整数，如果key6不存在则添加key6：&quot;</span> + jedis.hincrBy(<span class=\"string\">&quot;hash&quot;</span>, <span class=\"string\">&quot;key6&quot;</span>, <span class=\"number\">6</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;散列hash的所有键值对为：&quot;</span> + jedis.hgetAll(<span class=\"string\">&quot;hash&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;将key6保存的值加上一个整数，如果key6不存在则添加key6：&quot;</span> + jedis.hincrBy(<span class=\"string\">&quot;hash&quot;</span>, <span class=\"string\">&quot;key6&quot;</span>, <span class=\"number\">3</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;散列hash的所有键值对为：&quot;</span> + jedis.hgetAll(<span class=\"string\">&quot;hash&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;删除一个或者多个键值对：&quot;</span> + jedis.hdel(<span class=\"string\">&quot;hash&quot;</span>, <span class=\"string\">&quot;key2&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;散列hash的所有键值对为：&quot;</span> + jedis.hgetAll(<span class=\"string\">&quot;hash&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;散列hash中键值对的个数：&quot;</span> + jedis.hlen(<span class=\"string\">&quot;hash&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;判断hash中是否存在key2：&quot;</span> + jedis.hexists(<span class=\"string\">&quot;hash&quot;</span>, <span class=\"string\">&quot;key2&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;判断hash中是否存在key3：&quot;</span> + jedis.hexists(<span class=\"string\">&quot;hash&quot;</span>, <span class=\"string\">&quot;key3&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;获取hash中的值：&quot;</span> + jedis.hmget(<span class=\"string\">&quot;hash&quot;</span>, <span class=\"string\">&quot;key3&quot;</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;获取hash中的值：&quot;</span> + jedis.hmget(<span class=\"string\">&quot;hash&quot;</span>, <span class=\"string\">&quot;key3&quot;</span>, <span class=\"string\">&quot;key4&quot;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h2><h3 id=\"基本操作-1\"><a href=\"#基本操作-1\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.kuang.multi;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class=\"line\"><span class=\"keyword\">import</span> redis.clients.jedis.Jedis;</span><br><span class=\"line\"><span class=\"keyword\">import</span> redis.clients.jedis.Transaction;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestMulti</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//创建客户端连接服务端，redis服务端需要被开启</span></span><br><span class=\"line\">        Jedis jedis = <span class=\"keyword\">new</span> Jedis(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">6379</span>);</span><br><span class=\"line\">        jedis.flushDB();</span><br><span class=\"line\"></span><br><span class=\"line\">        JSONObject jsonObject = <span class=\"keyword\">new</span> JSONObject();</span><br><span class=\"line\">        jsonObject.put(<span class=\"string\">&quot;hello&quot;</span>, <span class=\"string\">&quot;world&quot;</span>);</span><br><span class=\"line\">        jsonObject.put(<span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;java&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//开启事务</span></span><br><span class=\"line\">        Transaction multi = jedis.multi();</span><br><span class=\"line\">        String result = jsonObject.toJSONString();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//向redis存入一条数据</span></span><br><span class=\"line\">            multi.set(<span class=\"string\">&quot;json&quot;</span>, result);</span><br><span class=\"line\">            <span class=\"comment\">//再存入一条数据</span></span><br><span class=\"line\">            multi.set(<span class=\"string\">&quot;json2&quot;</span>, result);</span><br><span class=\"line\">            <span class=\"comment\">//这里引发了异常，用 0 作为被除数</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = <span class=\"number\">100</span> / <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"comment\">//如果没有引发异常，执行进入队列的命令</span></span><br><span class=\"line\">            multi.exec();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"comment\">//如果出现异常，回滚</span></span><br><span class=\"line\">            multi.discard();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            System.out.println(jedis.get(<span class=\"string\">&quot;json&quot;</span>));</span><br><span class=\"line\">            System.out.println(jedis.get(<span class=\"string\">&quot;json2&quot;</span>));</span><br><span class=\"line\">            <span class=\"comment\">//最终关闭客户端</span></span><br><span class=\"line\">            jedis.close();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"SpringBoot整合\"><a href=\"#SpringBoot整合\" class=\"headerlink\" title=\"SpringBoot整合\"></a>SpringBoot整合</h1><h2 id=\"基础使用\"><a href=\"#基础使用\" class=\"headerlink\" title=\"基础使用\"></a>基础使用</h2><h3 id=\"概述-1\"><a href=\"#概述-1\" class=\"headerlink\" title=\"概述\"></a>概述</h3><blockquote>\n<p>在SpringBoot中一般使用RedisTemplate提供的方法来操作Redis。那么使用SpringBoot整合Redis需要那些步骤呢。</p>\n</blockquote>\n<ul>\n<li>1 、 JedisPoolConfig (这个是配置连接池)</li>\n<li>2 、 RedisConnectionFactory 这个是配置连接信息，这里的RedisConnectionFactory是一个接口，我们需要使用它的实现类，在SpringD Data Redis方案中提供了以下四种工厂模型：<ul>\n<li>JredisConnectionFactory</li>\n<li>JedisConnectionFactory</li>\n<li>LettuceConnectionFactory</li>\n<li>SrpConnectionFactory</li>\n</ul>\n</li>\n<li>3 、 RedisTemplate 基本操作</li>\n</ul>\n<h3 id=\"导入依赖\"><a href=\"#导入依赖\" class=\"headerlink\" title=\"导入依赖\"></a>导入依赖</h3><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"yaml配置\"><a href=\"#yaml配置\" class=\"headerlink\" title=\"yaml配置\"></a>yaml配置</h3><figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"attr\">redis:</span></span><br><span class=\"line\">    <span class=\"attr\">host:</span> <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span></span><br><span class=\"line\">    <span class=\"attr\">port:</span> <span class=\"number\">6379</span></span><br><span class=\"line\">    <span class=\"attr\">password:</span> <span class=\"number\">123456</span></span><br><span class=\"line\">    <span class=\"attr\">jedis:</span></span><br><span class=\"line\">      <span class=\"attr\">pool:</span></span><br><span class=\"line\">        <span class=\"attr\">max-active:</span> <span class=\"number\">8</span></span><br><span class=\"line\">        <span class=\"attr\">max-wait:</span> <span class=\"string\">-1ms</span></span><br><span class=\"line\">        <span class=\"attr\">max-idle:</span> <span class=\"number\">500</span></span><br><span class=\"line\">        <span class=\"attr\">min-idle:</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"attr\">lettuce:</span></span><br><span class=\"line\">    <span class=\"attr\">shutdown-timeout:</span> <span class=\"string\">0ms</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"测试-1\"><a href=\"#测试-1\" class=\"headerlink\" title=\"测试\"></a>测试</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@SpringBootTest</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SpringbootRedisApplicationTests</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">contextLoads</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        redisTemplate.opsForValue().set(<span class=\"string\">&quot;myKey&quot;</span>, <span class=\"string\">&quot;myValue&quot;</span>);</span><br><span class=\"line\">        System.out.println(redisTemplate.opsForValue().get(<span class=\"string\">&quot;myKey&quot;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"封装工具类\"><a href=\"#封装工具类\" class=\"headerlink\" title=\"封装工具类\"></a>封装工具类</h2><ul>\n<li>1 、新建一个SpringBoot项目</li>\n<li>2 、导入redis的启动器</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>3 、配置redis，可以查看 RedisProperties 分析</li>\n</ul>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Redis服务器地址</span></span><br><span class=\"line\"><span class=\"string\">spring.redis.host=127.0.0.1</span></span><br><span class=\"line\">  <span class=\"comment\"># Redis服务器连接端口</span></span><br><span class=\"line\"><span class=\"string\">spring.redis.port=</span> <span class=\"number\">6379</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>4 、分析 RedisAutoConfiguration 自动配置类</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration(proxyBeanMethods = false)</span></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnClass(RedisOperations.class)</span></span><br><span class=\"line\"><span class=\"meta\">@EnableConfigurationProperties(RedisProperties.class)</span></span><br><span class=\"line\"><span class=\"meta\">@Import(&#123;LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class&#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedisAutoConfiguration</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"meta\">@ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> RedisTemplate&lt;Object, Object&gt;</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">redisTemplate</span><span class=\"params\">(RedisConnectionFactory redisConnectionFactory)</span> <span class=\"keyword\">throws</span> UnknownHostException </span>&#123;</span><br><span class=\"line\">        RedisTemplate&lt;Object, Object&gt; template = <span class=\"keyword\">new</span> RedisTemplate&lt;&gt;();</span><br><span class=\"line\">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> template;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"meta\">@ConditionalOnMissingBean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> StringRedisTemplate <span class=\"title\">stringRedisTemplate</span><span class=\"params\">(RedisConnectionFactory redisConnectionFactory)</span> <span class=\"keyword\">throws</span> UnknownHostException </span>&#123;</span><br><span class=\"line\">        StringRedisTemplate template = <span class=\"keyword\">new</span> StringRedisTemplate();</span><br><span class=\"line\">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> template;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>通过源码可以看出，SpringBoot自动帮我们在容器中生成了一个RedisTemplate和一个StringRedisTemplate。</p>\n</blockquote>\n<blockquote>\n<p>但是，这个RedisTemplate的泛型是&lt;Object,Object&gt;，写代码不方便，需要写好多类型转换的代码；我们需要一个泛型为&lt;String,Object&gt;形式的RedisTemplate。</p>\n</blockquote>\n<blockquote>\n<p>并且，这个RedisTemplate没有设置数据存在Redis时，key及value的序列化方式。</p>\n</blockquote>\n<blockquote>\n<p>看到这个@ConditionalOnMissingBean注解后，就知道如果Spring容器中有了RedisTemplate对象了，这个自动配置的RedisTemplate不会实例化。因此我们可以直接自己写个配置类，配置RedisTemplate。</p>\n</blockquote>\n<ul>\n<li>5 、既然自动配置不好用，就重新配置一个RedisTemplate</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.kuang.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.annotation.JsonAutoDetect;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.annotation.PropertyAccessor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedisConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> RedisTemplate&lt;String, Object&gt; <span class=\"title\">redisTemplate</span><span class=\"params\">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class=\"line\">        RedisTemplate&lt;String, Object&gt; template = <span class=\"keyword\">new</span> RedisTemplate&lt;String, Object&gt;();</span><br><span class=\"line\">        template.setConnectionFactory(factory);</span><br><span class=\"line\">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class=\"keyword\">new</span></span><br><span class=\"line\">                Jackson2JsonRedisSerializer(Object.class);</span><br><span class=\"line\">        ObjectMapper om = <span class=\"keyword\">new</span> ObjectMapper();</span><br><span class=\"line\">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class=\"line\">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class=\"line\">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class=\"line\">        StringRedisSerializer stringRedisSerializer = <span class=\"keyword\">new</span></span><br><span class=\"line\">                StringRedisSerializer();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// key采用String的序列化方式</span></span><br><span class=\"line\">        template.setKeySerializer(stringRedisSerializer);</span><br><span class=\"line\">        <span class=\"comment\">// hash的key也采用String的序列化方式</span></span><br><span class=\"line\">        template.setHashKeySerializer(stringRedisSerializer);</span><br><span class=\"line\">        <span class=\"comment\">// value序列化方式采用jackson</span></span><br><span class=\"line\">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class=\"line\">        <span class=\"comment\">// hash的value序列化方式采用jackson</span></span><br><span class=\"line\">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class=\"line\">        template.afterPropertiesSet();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> template;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>6 、写一个Redis工具类（直接用RedisTemplate操作Redis，需要很多行代码，因此直接封装好一个RedisUtils，这样写代码更方便点。这个RedisUtils交给Spring容器实例化，使用时直接注解注入。）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.kuang.utils;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.util.CollectionUtils;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Set;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.TimeUnit;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedisUtil</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class=\"line\"><span class=\"comment\">// =============================common============================</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 指定缓存失效时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> time 时间(秒)</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">expire</span><span class=\"params\">(String key, <span class=\"keyword\">long</span> time)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (time &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                redisTemplate.expire(key, time, TimeUnit.SECONDS);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 根据key 获取过期时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键 不能为null</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 时间(秒) 返回 0 代表为永久有效</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">getExpire</span><span class=\"params\">(String key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.getExpire(key, TimeUnit.SECONDS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 判断key是否存在</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true 存在 false不存在</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasKey</span><span class=\"params\">(String key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> redisTemplate.hasKey(key);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 删除缓存</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 可以传一个值 或多个</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">del</span><span class=\"params\">(String... key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key != <span class=\"keyword\">null</span> &amp;&amp; key.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key.length == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                redisTemplate.delete(key[<span class=\"number\">0</span>]);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                redisTemplate.delete(CollectionUtils.arrayToList(key));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">// ============================String=============================</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 普通缓存获取</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 值</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">get</span><span class=\"params\">(String key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> key == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : redisTemplate.opsForValue().get(key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 普通缓存放入</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true成功 false失败</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">set</span><span class=\"params\">(String key, Object value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            redisTemplate.opsForValue().set(key, value);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     普通缓存放入并设置时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> time 时间(秒) time要大于 0 如果time小于等于 0 将设置无限期</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true成功 false 失败</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">set</span><span class=\"params\">(String key, Object value, <span class=\"keyword\">long</span> time)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (time &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                redisTemplate.opsForValue().set(key, value, time,</span><br><span class=\"line\">                        TimeUnit.SECONDS);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                set(key, value);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     递增</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> delta 要增加几(大于0)</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">incr</span><span class=\"params\">(String key, <span class=\"keyword\">long</span> delta)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (delta &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;递增因子必须大于0&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.opsForValue().increment(key, delta);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 递减</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> delta 要减少几(小于0)</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">decr</span><span class=\"params\">(String key, <span class=\"keyword\">long</span> delta)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (delta &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;递减因子必须大于0&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.opsForValue().increment(key, -delta);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ================================Map=================================</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * HashGet</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键 不能为null</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> item 项 不能为null</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">hget</span><span class=\"params\">(String key, String item)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.opsForHash().get(key, item);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取hashKey对应的所有键值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 对应的多个键值</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Map&lt;Object, Object&gt; <span class=\"title\">hmget</span><span class=\"params\">(String key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.opsForHash().entries(key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * HashSet</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> map 对应多个键值</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hmset</span><span class=\"params\">(String key, Map&lt;String, Object&gt; map)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            redisTemplate.opsForHash().putAll(key, map);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * HashSet 并设置时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> map 对应多个键值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> time 时间(秒)</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true成功 false失败</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hmset</span><span class=\"params\">(String key, Map&lt;String, Object&gt; map, <span class=\"keyword\">long</span> time)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            redisTemplate.opsForHash().putAll(key, map);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (time &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                expire(key, time);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> item 项</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true 成功 false失败</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hset</span><span class=\"params\">(String key, String item, Object value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            redisTemplate.opsForHash().put(key, item, value);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> item 项</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> time 时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true 成功 false失败</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hset</span><span class=\"params\">(String key, String item, Object value, <span class=\"keyword\">long</span> time)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            redisTemplate.opsForHash().put(key, item, value);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (time &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                expire(key, time);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 删除hash表中的值</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键 不能为null</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> item 项 可以使多个 不能为null</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hdel</span><span class=\"params\">(String key, Object... item)</span> </span>&#123;</span><br><span class=\"line\">        redisTemplate.opsForHash().delete(key, item);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 判断hash表中是否有该项的值</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键 不能为null</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> item 项 不能为null</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true 存在 false不存在</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hHasKey</span><span class=\"params\">(String key, String item)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.opsForHash().hasKey(key, item);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * hash递增 如果不存在,就会创建一个 并把新增后的值返回</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> item 项</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> by 要增加几(大于0)</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">hincr</span><span class=\"params\">(String key, String item, <span class=\"keyword\">double</span> by)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.opsForHash().increment(key, item, by);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * hash递减</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> item 项</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> by 要减少记(小于0)</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">hdecr</span><span class=\"params\">(String key, String item, <span class=\"keyword\">double</span> by)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.opsForHash().increment(key, item, -by);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">// ============================set=============================</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 根据key获取Set中的所有值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Set&lt;Object&gt; <span class=\"title\">sGet</span><span class=\"params\">(String key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> redisTemplate.opsForSet().members(key);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 根据value从一个set中查询,是否存在</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true 存在 false不存在</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sHasKey</span><span class=\"params\">(String key, Object value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> redisTemplate.opsForSet().isMember(key, value);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将数据放入set缓存</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> values 值 可以是多个</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 成功个数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">sSet</span><span class=\"params\">(String key, Object... values)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> redisTemplate.opsForSet().add(key, values);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将set数据放入缓存</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> time 时间(秒)</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> values 值 可以是多个</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 成功个数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">sSetAndTime</span><span class=\"params\">(String key, <span class=\"keyword\">long</span> time, Object... values)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Long count = redisTemplate.opsForSet().add(key, values);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (time &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                expire(key, time);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取set缓存的长度</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">sGetSetSize</span><span class=\"params\">(String key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> redisTemplate.opsForSet().size(key);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 移除值为value的</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> values 值 可以是多个</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 移除的个数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">setRemove</span><span class=\"params\">(String key, Object... values)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Long count = redisTemplate.opsForSet().remove(key, values);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">// ===============================list=================================</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取list缓存的内容</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> start 开始</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> end 结束 0 到 -1代表所有值</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Object&gt; <span class=\"title\">lGet</span><span class=\"params\">(String key, <span class=\"keyword\">long</span> start, <span class=\"keyword\">long</span> end)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> redisTemplate.opsForList().range(key, start, end);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取list缓存的长度</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">lGetListSize</span><span class=\"params\">(String key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> redisTemplate.opsForList().size(key);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 通过索引 获取list中的值</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> index 索引 index&gt;=0时， 0 表头， 1 第二个元素，依次类推；index&lt;0</span></span><br><span class=\"line\"><span class=\"comment\">    时，-1，表尾，-2倒数第二个元素，依次类推</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">lGetIndex</span><span class=\"params\">(String key, <span class=\"keyword\">long</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> redisTemplate.opsForList().index(key, index);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将list放入缓存</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 值</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">lSet</span><span class=\"params\">(String key, Object value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            redisTemplate.opsForList().rightPush(key, value);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将list放入缓存</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> time 时间(秒)</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">lSet</span><span class=\"params\">(String key, Object value, <span class=\"keyword\">long</span> time)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            redisTemplate.opsForList().rightPush(key, value);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (time &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                expire(key, time);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将list放入缓存</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">lSet</span><span class=\"params\">(String key, List&lt;Object&gt; value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将list放入缓存</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> time 时间(秒)</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">lSet</span><span class=\"params\">(String key, List&lt;Object&gt; value, <span class=\"keyword\">long</span> time)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (time &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                expire(key, time);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 根据索引修改list中的某条数据</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> index 索引</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">lUpdateIndex</span><span class=\"params\">(String key, <span class=\"keyword\">long</span> index, Object value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            redisTemplate.opsForList().set(key, index, value);</span><br><span class=\"line\">            ren <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 移除N个值为value</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> count 移除多少个</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 移除的个数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">lRemove</span><span class=\"params\">(String key, <span class=\"keyword\">long</span> count, Object value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Long remove = redisTemplate.opsForList().remove(key, count, value);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> remove;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Redis-conf\"><a href=\"#Redis-conf\" class=\"headerlink\" title=\"Redis.conf\"></a>Redis.conf</h1><h2 id=\"熟悉基本配置\"><a href=\"#熟悉基本配置\" class=\"headerlink\" title=\"熟悉基本配置\"></a>熟悉基本配置</h2><blockquote>\n<p>位置</p>\n</blockquote>\n<p>Redis 的配置文件位于 Redis 安装目录下，文件名为 redis.conf</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">config get *  # 获取全部的配置</span><br></pre></td></tr></table></figure>\n\n<p>配置文件的地址：</p>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927102035.png\" class title=\"输入图片说明\">\n\n<p>我们一般情况下，会单独拷贝出来一份进行操作。来保证初始文件的安全。</p>\n<h3 id=\"Units-单位\"><a href=\"#Units-单位\" class=\"headerlink\" title=\"Units 单位\"></a>Units 单位</h3><img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927102059.png\" class title=\"输入图片说明\">\n\n<ul>\n<li>1 、配置大小单位，开头定义了一些基本的度量单位，只支持bytes，不支持bit</li>\n<li>2 、对 大小写 不敏感</li>\n</ul>\n<h3 id=\"INCLUDES-包含\"><a href=\"#INCLUDES-包含\" class=\"headerlink\" title=\"INCLUDES 包含\"></a>INCLUDES 包含</h3><p>和Spring配置文件类似，可以通过includes包含，redis.conf 可以作为总文件，可以包含其他文件！</p>\n<h3 id=\"NETWORK-网络配置\"><a href=\"#NETWORK-网络配置\" class=\"headerlink\" title=\"NETWORK 网络配置\"></a>NETWORK 网络配置</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">bind 127.0.0.1  # 绑定的ip</span><br><span class=\"line\">protected-mode yes # 保护模式</span><br><span class=\"line\">port 6379 # 默认端口</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"GENERAL-通用\"><a href=\"#GENERAL-通用\" class=\"headerlink\" title=\"GENERAL 通用\"></a>GENERAL 通用</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">daemonize yes # 默认情况下，Redis不作为守护进程运行。需要开启的话，改为 yes</span><br><span class=\"line\"></span><br><span class=\"line\">supervised no  # 可通过upstart和systemd管理Redis守护进程</span><br><span class=\"line\"></span><br><span class=\"line\">pidfile /var/run/redis_6379.pid  # 以后台进程方式运行redis，则需要指定pid 文件</span><br><span class=\"line\"></span><br><span class=\"line\">loglevel notice # 日志级别。可选项有：</span><br><span class=\"line\"># debug（记录大量日志信息，适用于开发、测试阶段）；</span><br><span class=\"line\"># verbose（较多日志信息）；</span><br><span class=\"line\"># notice（适量日志信息，使用于生产环境）；</span><br><span class=\"line\"># warning（仅有部分重要、关键信息才会被记录）。</span><br><span class=\"line\"></span><br><span class=\"line\">logfile &quot;&quot; # 日志文件的位置，当指定为空字符串时，为标准输出</span><br><span class=\"line\">databases 16 # 设置数据库的数目。默认的数据库是DB 0</span><br><span class=\"line\">always-show-logo yes # 是否总是显示logo</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"SNAPSHOPTING-快照\"><a href=\"#SNAPSHOPTING-快照\" class=\"headerlink\" title=\"SNAPSHOPTING 快照\"></a>SNAPSHOPTING 快照</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 900秒（ 15 分钟）内至少 1 个key值改变（则进行数据库保存--持久化）</span><br><span class=\"line\">save 900 1</span><br><span class=\"line\"># 300秒（ 5 分钟）内至少 10 个key值改变（则进行数据库保存--持久化）</span><br><span class=\"line\">save 300 10</span><br><span class=\"line\"># 60秒（ 1 分钟）内至少 10000 个key值改变（则进行数据库保存--持久化）</span><br><span class=\"line\">save 60 10000</span><br><span class=\"line\"></span><br><span class=\"line\">stop-writes-on-bgsave-error yes # 持久化出现错误后，是否依然进行继续进行工作</span><br><span class=\"line\"></span><br><span class=\"line\">rdbcompression yes # 使用压缩rdb文件 yes：压缩，但是需要一些cpu的消耗。no：不压</span><br><span class=\"line\">缩，需要更多的磁盘空间</span><br><span class=\"line\"></span><br><span class=\"line\">rdbchecksum yes # 是否校验rdb文件，更有利于文件的容错性，但是在保存rdb文件的时</span><br><span class=\"line\">候，会有大概10%的性能损耗</span><br><span class=\"line\"></span><br><span class=\"line\">dbfilename dump.rdb  # dbfilenamerdb文件名称</span><br><span class=\"line\"></span><br><span class=\"line\">dir./  # dir 数据目录，数据库的写入会在这个目录。rdb、aof文件也会写在这个目录</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"REPLICATION-复制-我们后面讲主从复制再给大家讲解！这里先跳过！\"><a href=\"#REPLICATION-复制-我们后面讲主从复制再给大家讲解！这里先跳过！\" class=\"headerlink\" title=\"REPLICATION 复制 我们后面讲主从复制再给大家讲解！这里先跳过！\"></a>REPLICATION 复制 我们后面讲主从复制再给大家讲解！这里先跳过！</h3><h3 id=\"SECURITY安全\"><a href=\"#SECURITY安全\" class=\"headerlink\" title=\"SECURITY安全\"></a>SECURITY安全</h3><p>访问密码的查看，设置和取消</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 启动redis</span><br><span class=\"line\"># 连接客户端</span><br><span class=\"line\"></span><br><span class=\"line\"># 获得和设置密码</span><br><span class=\"line\">config get requirepass</span><br><span class=\"line\">config set requirepass &quot;123456&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">#测试ping，发现需要验证</span><br><span class=\"line\">127.0.0.1:6379&gt; ping</span><br><span class=\"line\">NOAUTH Authentication required.</span><br><span class=\"line\"># 验证</span><br><span class=\"line\">127.0.0.1:6379&gt; auth 123456</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; ping</span><br><span class=\"line\">PONG</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"限制\"><a href=\"#限制\" class=\"headerlink\" title=\"限制\"></a>限制</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">maxclients 10000 # 设置能连上redis的最大客户端连接数量</span><br><span class=\"line\">maxmemory &lt;bytes&gt; # redis配置的最大内存容量</span><br><span class=\"line\">maxmemory-policy noeviction # maxmemory-policy 内存达到上限的处理策略</span><br><span class=\"line\">#volatile-lru：利用LRU算法移除设置过过期时间的key。</span><br><span class=\"line\">#volatile-random：随机移除设置过过期时间的key。</span><br><span class=\"line\">#volatile-ttl：移除即将过期的key，根据最近过期时间来删除（辅以TTL）</span><br><span class=\"line\">#allkeys-lru：利用LRU算法移除任何key。</span><br><span class=\"line\">#allkeys-random：随机移除任何key。</span><br><span class=\"line\">#noeviction：不移除任何key，只是返回一个写错误。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"append-only模式\"><a href=\"#append-only模式\" class=\"headerlink\" title=\"append only模式\"></a>append only模式</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">appendonly no # 是否以append only模式作为持久化方式，默认使用的是rdb方式持久化，这种</span><br><span class=\"line\">方式在许多应用中已经足够用了</span><br><span class=\"line\">appendfilename &quot;appendonly.aof&quot; # appendfilename AOF 文件名称</span><br><span class=\"line\">appendfsync everysec  # appendfsync aof持久化策略的配置</span><br><span class=\"line\"># no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快。</span><br><span class=\"line\"># always表示每次写入都执行fsync，以保证数据同步到磁盘。</span><br><span class=\"line\"># everysec表示每秒执行一次fsync，可能会导致丢失这1s数据。</span><br></pre></td></tr></table></figure>\n\n<p>具体的我们会在后面讲解Redis的持久化配置的时候进行讲解！先了解下，听个耳音！</p>\n<h2 id=\"常见配置介绍\"><a href=\"#常见配置介绍\" class=\"headerlink\" title=\"常见配置介绍\"></a>常见配置介绍</h2><p>1 、Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程</p>\n<blockquote>\n<p>daemonize no</p>\n</blockquote>\n<p>2 、当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定</p>\n<blockquote>\n<p>pidfile /var/run/redis.pid</p>\n</blockquote>\n<p>3 、指定Redis监听端口，默认端口为 6379 ，作者在自己的一篇博文中解释了为什么选用 6379 作为默认端口，因为 6379 在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字</p>\n<blockquote>\n<p>port 6379</p>\n</blockquote>\n<p>4 、绑定的主机地址</p>\n<blockquote>\n<p>bind 127.0.0.1</p>\n</blockquote>\n<p>5 、当 客户端闲置多长时间后关闭连接，如果指定为 0 ，表示关闭该功能</p>\n<blockquote>\n<p>timeout 300</p>\n</blockquote>\n<p>6 、指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose</p>\n<blockquote>\n<p>loglevel verbose</p>\n</blockquote>\n<p>7 、日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null</p>\n<blockquote>\n<p>logfile stdout</p>\n</blockquote>\n<p>8 、设置数据库的数量，默认数据库为 0 ，可以使用SELECT 命令在连接上指定数据库id</p>\n<blockquote>\n<p>databases 16</p>\n</blockquote>\n<p>9 、指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</p>\n<blockquote>\n<p>save Redis默认配置文件中提供了三个条件： save 900 1 save 300 10 save 60 10000 分别表示 900 秒（ 15 分钟）内有 1 个更改， 300 秒（ 5 分钟）内有 10 个更改以及 60 秒内有 10000 个更改。</p>\n</blockquote>\n<p>10 、指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大</p>\n<blockquote>\n<p>rdbcompression yes</p>\n</blockquote>\n<p>11 、指定本地数据库文件名，默认值为dump.rdb</p>\n<blockquote>\n<p>dbfilename dump.rdb</p>\n</blockquote>\n<p>12 、指定本地数据库存放目录</p>\n<blockquote>\n<p>dir./</p>\n</blockquote>\n<p>13 、设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步</p>\n<blockquote>\n<p>slaveof</p>\n</blockquote>\n<p>14 、当master服务设置了密码保护时，slav服务连接master的密码</p>\n<blockquote>\n<p>masterauth</p>\n</blockquote>\n<p>15 、设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH 命令提供密码，默认关闭</p>\n<blockquote>\n<p>requirepass foobared</p>\n</blockquote>\n<p>16 、设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients<br>0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息</p>\n<blockquote>\n<p>maxclients 128</p>\n</blockquote>\n<p>17 、指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理<br>后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区</p>\n<blockquote>\n<p>maxmemory</p>\n</blockquote>\n<p>18 、指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为<br>redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no</p>\n<blockquote>\n<p>appendonly no</p>\n</blockquote>\n<p>19 、指定更新日志文件名，默认为appendonly.aof</p>\n<blockquote>\n<p>appendfilename appendonly.aof</p>\n</blockquote>\n<p>20 、指定更新日志条件，共有 3 个可选值：</p>\n<blockquote>\n<p>no：表示等操作系统进行数据缓存同步到磁盘（快）<br><br>always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）<br><br>everysec：表示每秒同步一次（折衷，默认值）<br><br>appendfsync everysec<br></p>\n</blockquote>\n<p>21 、指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制）</p>\n<blockquote>\n<p>vm-enabled no</p>\n</blockquote>\n<p>22 、虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享</p>\n<blockquote>\n<p>vm-swap-file /tmp/redis.swap</p>\n</blockquote>\n<p>23 、将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为 0<br>的时候,其实是所有value都存在于磁盘。默认值为 0</p>\n<blockquote>\n<p>vm-max-memory 0</p>\n</blockquote>\n<p>24 、Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为 32<br>或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值</p>\n<blockquote>\n<p>vm-page-size 32</p>\n</blockquote>\n<p>25 、设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每 8 个pages将消耗1byte的内存。</p>\n<blockquote>\n<p>vm-pages 134217728</p>\n</blockquote>\n<p>26 、设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为 4</p>\n<blockquote>\n<p>vm-max-threads 4</p>\n</blockquote>\n<p>27 、设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启</p>\n<blockquote>\n<p>glueoutputbuf yes</p>\n</blockquote>\n<p>28 、指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</p>\n<blockquote>\n<p>hash-max-zipmap-entries 64<br><br>hash-max-zipmap-value 512</p>\n</blockquote>\n<p>29 、指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍）</p>\n<blockquote>\n<p>activerehashing yes</p>\n</blockquote>\n<blockquote>\n<p>30 、指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件</p>\n</blockquote>\n<blockquote>\n<p>include /path/to/local.conf</p>\n</blockquote>\n<h1 id=\"Redis的持久化\"><a href=\"#Redis的持久化\" class=\"headerlink\" title=\"Redis的持久化\"></a>Redis的持久化</h1><blockquote>\n<p>Redis 是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以 Redis 提供了持久化功能！</p>\n</blockquote>\n<h2 id=\"RDB（Redis-DataBase）\"><a href=\"#RDB（Redis-DataBase）\" class=\"headerlink\" title=\"RDB（Redis DataBase）\"></a>RDB（Redis DataBase）</h2><h3 id=\"什么是RDB\"><a href=\"#什么是RDB\" class=\"headerlink\" title=\"什么是RDB\"></a>什么是RDB</h3><blockquote>\n<p>在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。</p>\n</blockquote>\n<blockquote>\n<p>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。</p>\n</blockquote>\n<h3 id=\"Fork\"><a href=\"#Fork\" class=\"headerlink\" title=\"Fork\"></a>Fork</h3><blockquote>\n<p>Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量，环境变量，程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。</p>\n</blockquote>\n<p><strong>Rdb 保存的是 dump.rdb 文件</strong></p>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927110129.png\" class title=\"输入图片说明\">\n\n<h3 id=\"配置位置及SNAPSHOTTING解析\"><a href=\"#配置位置及SNAPSHOTTING解析\" class=\"headerlink\" title=\"配置位置及SNAPSHOTTING解析\"></a>配置位置及SNAPSHOTTING解析</h3><img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927110152.png\" class title=\"输入图片说明\">\n\n<h3 id=\"这里的触发条件机制，我们可以修改测试一下：\"><a href=\"#这里的触发条件机制，我们可以修改测试一下：\" class=\"headerlink\" title=\"这里的触发条件机制，我们可以修改测试一下：\"></a>这里的触发条件机制，我们可以修改测试一下：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">save 120 10 # 120秒内修改 10 次则触发RDB</span><br></pre></td></tr></table></figure>\n\n<p>RDB 是整合内存的压缩过的Snapshot，RDB 的数据结构，可以配置复合的快照触发条件。 默认：</p>\n<ul>\n<li>1 分钟内改了 1 万次</li>\n<li>5 分钟内改了 10 次</li>\n<li>15 分钟内改了 1 次</li>\n</ul>\n<p>如果想禁用RDB持久化的策略，只要不设置任何save指令，或者给save传入一个空字符串参数也可以。若要修改完毕需要立马生效，可以手动使用 save 命令！立马生效!</p>\n<h3 id=\"其余命令解析\"><a href=\"#其余命令解析\" class=\"headerlink\" title=\"其余命令解析\"></a>其余命令解析</h3><p>Stop-writes-on-bgsave-error：如果配置为no，表示你不在乎数据不一致或者有其他的手段发现和控制，默认为yes。</p>\n<p>rbdcompression：对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩，如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能。</p>\n<p>rdbchecksum：在存储快照后，还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。默认为yes。</p>\n<h3 id=\"如何触发RDB快照\"><a href=\"#如何触发RDB快照\" class=\"headerlink\" title=\"如何触发RDB快照\"></a>如何触发RDB快照</h3><ul>\n<li><p>1 、配置文件中默认的快照配置，建议多用一台机子作为备份，复制一份 dump.rdb</p>\n</li>\n<li><p>2 、命令save或者是bgsave</p>\n<ul>\n<li>save 时只管保存，其他不管，全部阻塞</li>\n<li>bgsave，Redis 会在后台异步进行快照操作，快照同时还可以响应客户端请求。可以通过lastsave命令获取最后一次成功执行快照的时间。</li>\n</ul>\n</li>\n<li><p>3 、执行flushall命令，也会产生 dump.rdb 文件，但里面是空的，无意义!</p>\n</li>\n<li><p>4 、退出的时候也会产生 dump.rdb 文件！</p>\n</li>\n</ul>\n<h3 id=\"如何恢复\"><a href=\"#如何恢复\" class=\"headerlink\" title=\"如何恢复\"></a>如何恢复</h3><ul>\n<li>1 、将备份文件（dump.rdb）移动到redis安装目录并启动服务即可</li>\n<li>2 、CONFIG GET dir 获取目录</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; config get dir</span><br><span class=\"line\">dir</span><br><span class=\"line\">/usr/local/bin</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"优点和缺点\"><a href=\"#优点和缺点\" class=\"headerlink\" title=\"优点和缺点\"></a>优点和缺点</h3><h3 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><ul>\n<li>1 、适合大规模的数据恢复</li>\n<li>2 、对数据完整性和一致性要求不高</li>\n</ul>\n<h3 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h3><ul>\n<li>1 、在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改</li>\n<li>2 、Fork的时候，内存中的数据被克隆了一份，大致 2 倍的膨胀性需要考虑。</li>\n</ul>\n<h3 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h3><img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927111622.png\" class title=\"输入图片说明\">\n\n<h2 id=\"AOF（Append-Only-File）\"><a href=\"#AOF（Append-Only-File）\" class=\"headerlink\" title=\"AOF（Append Only File）\"></a>AOF（Append Only File）</h2><blockquote>\n<p>是什么</p>\n</blockquote>\n<blockquote>\n<p>以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p>\n</blockquote>\n<p><code>Aof保存的是 appendonly.aof 文件</code></p>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927111724.png\" class title=\"输入图片说明\">\n\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">appendonly no # 是否以append only模式作为持久化方式，默认使用的是rdb方式持久化，这</span><br><span class=\"line\">种方式在许多应用中已经足够用了</span><br><span class=\"line\"></span><br><span class=\"line\">appendfilename &quot;appendonly.aof&quot; # appendfilename AOF 文件名称</span><br><span class=\"line\"></span><br><span class=\"line\">appendfsync everysec  # appendfsync aof持久化策略的配置</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> always表示每次写入都执行fsync，以保证数据同步到磁盘。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> everysec表示每秒执行一次fsync，可能会导致丢失这1s数据。</span></span><br><span class=\"line\"></span><br><span class=\"line\">No-appendfsync-on-rewrite #重写时是否可以运用Appendfsync，用默认no即可，保证数据安</span><br><span class=\"line\">全性</span><br><span class=\"line\"></span><br><span class=\"line\">Auto-aof-rewrite-min-size # 设置重写的基准值</span><br><span class=\"line\"></span><br><span class=\"line\">Auto-aof-rewrite-percentage #设置重写的基准值</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"AOF-启动-修复-恢复\"><a href=\"#AOF-启动-修复-恢复\" class=\"headerlink\" title=\"AOF 启动/修复/恢复\"></a>AOF 启动/修复/恢复</h3><p>正常恢复：</p>\n<ul>\n<li>启动：设置Yes，修改默认的appendonly no，改为yes</li>\n<li>将有数据的aof文件复制一份保存到对应目录（config get dir）</li>\n<li>恢复：重启redis然后重新加载</li>\n</ul>\n<p>异常恢复：</p>\n<ul>\n<li>启动：设置Yes</li>\n<li>故意破坏 appendonly.aof 文件！</li>\n<li>修复： redis-check-aof –fix appendonly.aof 进行修复</li>\n<li>恢复：重启 redis 然后重新加载</li>\n</ul>\n<h3 id=\"Rewrite\"><a href=\"#Rewrite\" class=\"headerlink\" title=\"Rewrite\"></a>Rewrite</h3><p>是什么：</p>\n<blockquote>\n<p>AOF 采用文件追加方式，文件会越来越大，为避免出现此种情况，新增了重写机制，当AOF文件的大小超过所设定的阈值时，Redis 就会启动AOF 文件的内容压缩，只保留可以恢复数据的最小指令集，可以使用命令 bgrewriteaof ！</p>\n</blockquote>\n<h3 id=\"重写原理：\"><a href=\"#重写原理：\" class=\"headerlink\" title=\"重写原理：\"></a>重写原理：</h3><blockquote>\n<p>AOF 文件持续增长而过大时，会fork出一条新进程来将文件重写（也是先写临时文件最后再rename），遍历新进程的内存中数据，每条记录有一条的Set语句。重写aof文件的操作，并没有读取旧的aof文件，这点和快照有点类似！</p>\n</blockquote>\n<h3 id=\"触发机制：\"><a href=\"#触发机制：\" class=\"headerlink\" title=\"触发机制：\"></a>触发机制：</h3><blockquote>\n<p>Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的已被且文件大于64M的触发。</p>\n</blockquote>\n<p><code>行家一出手，就只有没有，内行看门道，外行看热闹</code></p>\n<h3 id=\"优点和缺点-1\"><a href=\"#优点和缺点-1\" class=\"headerlink\" title=\"优点和缺点\"></a>优点和缺点</h3><h3 id=\"优点：-1\"><a href=\"#优点：-1\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><ul>\n<li>1 、每修改同步：appendfsync always 同步持久化，每次发生数据变更会被立即记录到磁盘，性能较差但数据完整性比较好</li>\n<li>2 、每秒同步： appendfsync everysec 异步操作，每秒记录 ，如果一秒内宕机，有数据丢失</li>\n<li>3 、不同步： appendfsync no 从不同步</li>\n</ul>\n<h3 id=\"缺点：-1\"><a href=\"#缺点：-1\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h3><ul>\n<li>1 、相同数据集的数据而言，aof 文件要远大于 rdb文件，恢复速度慢于 rdb。</li>\n<li>2 、Aof 运行效率要慢于 rdb，每秒同步策略效率较好，不同步效率和rdb相同。</li>\n</ul>\n<h3 id=\"小总结\"><a href=\"#小总结\" class=\"headerlink\" title=\"小总结\"></a>小总结</h3><img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927112007.png\" class title=\"输入图片说明\">\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li><p>1 、RDB 持久化方式能够在指定的时间间隔内对你的数据进行快照存储</p>\n</li>\n<li><p>2 、AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以Redis 协议追加保存每次写的操作到文件末尾，Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大。</p>\n</li>\n<li><p>3 、只做缓存，如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化</p>\n</li>\n<li><p>4 、同时开启两种持久化方式</p>\n<ul>\n<li>在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。</li>\n<li>RDB<br>的数据不实时，同时使用两者时服务器重启也只会找AOF文件，那要不要只使用AOF呢？作者建议不要，因为RDB更适合用于备份数据库（AOF在不断变化不好备份），快速重启，而且不会有AOF可能潜在的Bug，留着作为一个万一的手段。</li>\n</ul>\n</li>\n<li><p>5 、性能建议</p>\n<ul>\n<li>因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要 15 分钟备份一次就够了，只保留 save 900 1 这条规则。</li>\n<li>如果Enable AOF ，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了，代价一是带来了持续的IO，二是AOF rewrite 的最后将 rewrite<br>过程中产生的新数据写到新文件 造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重写可以改到适当的数值。</li>\n<li>如果不Enable AOF ，仅靠 Master-Slave Repllcation 实现高可用性也可以，能省掉一大笔IO，也减少了rewrite时带来的系统波动。代价是如果Master/Slave<br>同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个 Master/Slave 中的 RDB文件，载入较新的那个，微博就是这种架构。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Redis-发布订阅\"><a href=\"#Redis-发布订阅\" class=\"headerlink\" title=\"Redis 发布订阅\"></a>Redis 发布订阅</h1><p>是什么</p>\n<ul>\n<li>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</li>\n<li>Redis 客户端可以订阅任意数量的频道。</li>\n</ul>\n<p>订阅/发布消息图：</p>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927113113.png\" class title=\"输入图片说明\">\n\n<p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的</p>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927113126.png\" class title=\"输入图片说明\">\n\n<p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：</p>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927113242.png\" class title=\"输入图片说明\">\n\n<h3 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h3><p>这些命令被广泛用于构建即时通信应用，比如网络聊天室(chatroom)和实时广播、实时提醒等。</p>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927113307.png\" class title=\"输入图片说明\">\n\n<h3 id=\"测试-2\"><a href=\"#测试-2\" class=\"headerlink\" title=\"测试\"></a>测试</h3><p>以下实例演示了发布订阅是如何工作的。在我们实例中我们创建了订阅频道名为 redisChat :</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">redis 127.0.0.1:6379&gt; SUBSCRIBE redisChat</span><br><span class=\"line\"></span><br><span class=\"line\">Reading messages... (press Ctrl-C to quit)</span><br><span class=\"line\">1 ) &quot;subscribe&quot;</span><br><span class=\"line\">2 ) &quot;redisChat&quot;</span><br><span class=\"line\">3 ) (integer) 1</span><br></pre></td></tr></table></figure>\n\n<p>现在，我们先重新开启个 redis 客户端，然后在同一个频道 redisChat 发布两次消息，订阅者就能接收到消息。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">redis 127.0.0.1:6379&gt; PUBLISH redisChat &quot;Hello,Redis&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">redis 127.0.0.1:6379&gt; PUBLISH redisChat &quot;Hello，Kuangshen&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 订阅者的客户端会显示如下消息</span></span><br><span class=\"line\">1 ) &quot;message&quot;</span><br><span class=\"line\">2 ) &quot;redisChat&quot;</span><br><span class=\"line\">3 ) &quot;Hello,Redis&quot;</span><br><span class=\"line\">1 ) &quot;message&quot;</span><br><span class=\"line\">2 ) &quot;redisChat&quot;</span><br><span class=\"line\">3 ) &quot;Hello，Kuangshen&quot;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><blockquote>\n<p>Redis是使用C实现的，通过分析 Redis 源码里的 pubsub.c 文件，了解发布和订阅机制的底层实现，籍此加深对 Redis 的理解。</p>\n</blockquote>\n<blockquote>\n<p>Redis 通过 PUBLISH 、SUBSCRIBE 和 PSUBSCRIBE 等命令实现发布和订阅功能。通过 SUBSCRIBE 命令订阅某频道后，redis-server 里维护了一个字典，字典的键就是一个个 channel，而字典的值则是一个链表，链表中保存了所有订阅这个 channel 的客户端。SUBSCRIBE 命令的关键，就是将客户端添加到给定 channel 的订阅链表中。</p>\n</blockquote>\n<blockquote>\n<p>通过 PUBLISH 命令向订阅者发送消息，redis-server 会使用给定的频道作为键，在它所维护的 channel字典中查找记录了订阅这个频道的所有客户端的链表，遍历这个链表，将消息发布给所有订阅者。</p>\n</blockquote>\n<blockquote>\n<p>Pub/Sub 从字面上理解就是发布（Publish）与订阅（Subscribe），在Redis中，你可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。</p>\n</blockquote>\n<h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><blockquote>\n<p>Pub/Sub构建实时消息系统</p>\n</blockquote>\n<blockquote>\n<p>Redis的Pub/Sub系统可以构建实时的消息系统</p>\n</blockquote>\n<blockquote>\n<p>比如很多用Pub/Sub构建的实时聊天系统的例子。</p>\n</blockquote>\n<h1 id=\"Redis主从复制\"><a href=\"#Redis主从复制\" class=\"headerlink\" title=\"Redis主从复制\"></a>Redis主从复制</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><blockquote>\n<p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master/leader)，后者称为从节点(slave/follower)；数据的复制是单向的，只能由主节点到从节点。Master以写为主，Slave 以读为主。</p>\n</blockquote>\n<blockquote>\n<p>默认情况下，每台Redis服务器都是主节点；且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。</p>\n</blockquote>\n<p>主从复制的作用主要包括：</p>\n<ul>\n<li>1 、数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li>\n<li>2 、故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</li>\n<li>3<br>、负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li>\n<li>4 、高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</li>\n</ul>\n<p>一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的，原因如下：</p>\n<ul>\n<li>1 、从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大；</li>\n<li>2 、从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存容量为256G，也不能将所有内存用作Redis存储内存，一般来说，单台Redis最大使用内存不应该超过20G。<br>电商网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是”多读少写”。 对于这种场景，我们可以使如下这种架构：</li>\n</ul>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927113849.png\" class title=\"输入图片说明\">\n\n<h2 id=\"环境配置\"><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h2><p>基本配置</p>\n<p>配从库不配主库，从库配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">slaveof 主库ip 主库端口 # 配置主从</span><br><span class=\"line\">info replication # 查看信息</span><br></pre></td></tr></table></figure>\n\n<p>每次与 master 断开之后，都需要重新连接，除非你配置进 redis.conf 文件！</p>\n<h3 id=\"修改配置文件！\"><a href=\"#修改配置文件！\" class=\"headerlink\" title=\"修改配置文件！\"></a>修改配置文件！</h3><p>准备工作：我们配置主从复制，至少需要三个，一主二从！配置三个客户端！</p>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927113948.png\" class title=\"输入图片说明\">\n\n<ul>\n<li><p>1 、拷贝多个redis.conf 文件</p>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927114022.png\" class title=\"输入图片说明\"></li>\n<li><p>2 、指定端口 6379 ，依次类推</p>\n</li>\n<li><p>3 、开启daemonize yes</p>\n</li>\n<li><p>4 、Pid文件名字 pidfile /var/run/redis_6379.pid , 依次类推</p>\n</li>\n<li><p>5 、Log文件名字 logfile “6379.log” , 依次类推</p>\n</li>\n<li><p>6 、Dump.rdb 名字 dbfilename dump6379.rdb , 依次类推</p>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927114130.png\" class title=\"输入图片说明\"></li>\n</ul>\n<h3 id=\"上面都配置完毕后，-3-个服务通过-3-个不同的配置文件开启，我们的准备环境就OK-了！\"><a href=\"#上面都配置完毕后，-3-个服务通过-3-个不同的配置文件开启，我们的准备环境就OK-了！\" class=\"headerlink\" title=\"上面都配置完毕后， 3 个服务通过 3 个不同的配置文件开启，我们的准备环境就OK 了！\"></a>上面都配置完毕后， 3 个服务通过 3 个不同的配置文件开启，我们的准备环境就OK 了！</h3><img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210927114141.png\" class title=\"输入图片说明\">\n\n<h2 id=\"一主二从\"><a href=\"#一主二从\" class=\"headerlink\" title=\"一主二从\"></a>一主二从</h2><p>一主二仆</p>\n<ul>\n<li><p>1 、环境初始化</p>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210928085838.png\" class title=\"输入图片说明\"></li>\n</ul>\n<p>默认三个都是Master 主节点</p>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210928085902.png\" class title=\"输入图片说明\">\n\n<ul>\n<li><p>2 、配置为一个Master 两个Slave</p>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210928085902.png\" class title=\"输入图片说明\"></li>\n<li><p>3 、在主机设置值，在从机都可以取到！从机不能写值！</p>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210928085936.png\" class title=\"输入图片说明\"></li>\n</ul>\n<p>测试一：主机挂了，查看从机信息，主机恢复，再次查看信息</p>\n<p>测试二：从机挂了，查看主机信息，从机恢复，查看从机信息</p>\n<h3 id=\"层层链路\"><a href=\"#层层链路\" class=\"headerlink\" title=\"层层链路\"></a>层层链路</h3><blockquote>\n<p>上一个Slave 可以是下一个slave 和 Master，Slave 同样可以接收其他 slaves 的连接和同步请求，那么该 slave 作为了链条中下一个的master，可以有效减轻 master 的写压力！</p>\n</blockquote>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210928090032.png\" class title=\"输入图片说明\">\n\n<h3 id=\"测试：-6379-设置值以后-6380-和-6381-都可以获取到！OK！\"><a href=\"#测试：-6379-设置值以后-6380-和-6381-都可以获取到！OK！\" class=\"headerlink\" title=\"测试： 6379 设置值以后 6380 和 6381 都可以获取到！OK！\"></a>测试： 6379 设置值以后 6380 和 6381 都可以获取到！OK！</h3><h3 id=\"谋朝篡位\"><a href=\"#谋朝篡位\" class=\"headerlink\" title=\"谋朝篡位\"></a>谋朝篡位</h3><blockquote>\n<p>一主二从的情况下，如果主机断了，从机可以使用命令 SLAVEOF NO ONE 将自己改为主机！这个时候其余的从机链接到这个节点。对一个从属服务器执行命令 SLAVEOF NO ONE 将使得这个从属服务器关闭复制功能，并从从属服务器转变回主服务器，原来同步所得的数据集不会被丢弃。</p>\n</blockquote>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210928090112.png\" class title=\"输入图片说明\">\n\n<p>主机再回来，也只是一个光杆司令了，从机为了正常使用跑到了新的主机上！</p>\n<h3 id=\"复制原理\"><a href=\"#复制原理\" class=\"headerlink\" title=\"复制原理\"></a>复制原理</h3><blockquote>\n<p>Slave 启动成功连接到 master 后会发送一个sync命令Master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。增量复制：Master 继续将新的所有收集到的修改命令依次传给slave，完成同步但是只要是重新连接master，一次完全同步（全量复制）将被自动执行</p>\n</blockquote>\n<h2 id=\"哨兵模式\"><a href=\"#哨兵模式\" class=\"headerlink\" title=\"哨兵模式\"></a>哨兵模式</h2><p>概述</p>\n<blockquote>\n<p>主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。Redis从2.8开始正式提供了Sentinel（哨兵） 架构来解决这个问题。谋朝篡位的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是 <strong>哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。</strong></p>\n</blockquote>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210928090249.png\" class title=\"输入图片说明\">\n\n<p>这里的哨兵有两个作用</p>\n<ul>\n<li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。</li>\n<li>当哨兵监测到master宕机，会自动将slave切换成master，然后通过 发布订阅模式 通知其他的从服务器，修改配置文件，让它们切换主机。</li>\n</ul>\n<blockquote>\n<p>然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。</p>\n</blockquote>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210928090331.png\" class title=\"输入图片说明\">\n\n<blockquote>\n<p>假设主服务器宕机，哨兵 1 先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵 1 主观的认为主服务器不可用，这个现象成为 主观下线 。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover[故障转移]操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为客观下线 。</p>\n</blockquote>\n<h3 id=\"配置测试\"><a href=\"#配置测试\" class=\"headerlink\" title=\"配置测试\"></a>配置测试</h3><ul>\n<li>1 、调整结构， 6379 带着 80 、 81</li>\n<li>2 、自定义的 /myredis 目录下新建 sentinel.conf 文件，名字千万不要错</li>\n<li>3 、配置哨兵，填写内容<ul>\n<li>sentinel monitor 被监控主机名字 127.0.0.1 6379 1</li>\n<li>上面最后一个数字 1 ，表示主机挂掉后slave投票看让谁接替成为主机，得票数多少后成为主机</li>\n</ul>\n</li>\n<li>4 、启动哨兵<ul>\n<li>Redis-sentinel /myredis/sentinel.conf</li>\n<li>上述目录依照各自的实际情况配置，可能目录不同</li>\n</ul>\n</li>\n<li>5 、正常主从演示</li>\n<li>6 、原有的Master 挂了</li>\n<li>7 、投票新选</li>\n<li>8 、重新主从继续开工，info replication 查查看</li>\n<li>9 、问题：如果之前的master 重启回来，会不会双master 冲突？ 之前的回来只能做小弟了</li>\n</ul>\n<h3 id=\"哨兵模式的优缺点\"><a href=\"#哨兵模式的优缺点\" class=\"headerlink\" title=\"哨兵模式的优缺点\"></a>哨兵模式的优缺点</h3><h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><p>*<br>    1. 哨兵集群模式是基于主从模式的，所有主从的优点，哨兵模式同样具有。<br>*<br>    2. 主从可以切换，故障可以转移，系统可用性更好。<br>*<br>    3. 哨兵模式是主从模式的升级，系统更健壮，可用性更高。</p>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>*<br>    1. Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。<br>*<br>    2. 实现哨兵模式的配置也不简单，甚至可以说有些繁琐</p>\n<h3 id=\"哨兵配置说明\"><a href=\"#哨兵配置说明\" class=\"headerlink\" title=\"哨兵配置说明\"></a>哨兵配置说明</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Example sentinel.conf</span></span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 哨兵sentinel实例运行的端口 默认 26379</span></span><br><span class=\"line\">port 26379</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 哨兵sentinel的工作目录</span></span><br><span class=\"line\">dir /tmp</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 哨兵sentinel监控的redis主节点的 ip port</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> master-name 可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符<span class=\"string\">&quot;.-_&quot;</span>组成。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> quorum 配置多少个sentinel哨兵统一认为master主节点失联 那么这时客观上认为主节点失联了</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span></span><br><span class=\"line\">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都</span></span><br><span class=\"line\">要提供密码</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span></span><br><span class=\"line\">sentinel auth-pass mymaster MySUPER--secret-0123passw0rd</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认 30 秒</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class=\"line\">sentinel down-after-milliseconds mymaster 30000</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，这个数字越小，完成failover所需的时间就越长，但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span></span><br><span class=\"line\">sentinel parallel-syncs mymaster 1</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 故障转移的超时时间 failover-timeout 可以用在以下这些方面：</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">1. 同一个sentinel对同一个master两次failover之间的间隔时间。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">3.当想要取消一个正在进行的failover所需要的时间。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 默认三分钟</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class=\"line\">sentinel failover-timeout mymaster 180000</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> SCRIPTS EXECUTION</span></span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">对于脚本的运行结果有以下规则：</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">若脚本执行后返回 1 ，那么该脚本稍后将会被再次执行，重复次数目前默认为 10</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">若脚本执行后返回 2 ，或者比 2 更高的一个返回值，脚本将不会重复执行。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为 1 时的行为相同。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span></span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">通知脚本</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class=\"line\">sentinel notification-script mymaster /var/redis/notify.sh</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 客户端重新配置主节点参数脚本</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 以下参数将会在调用脚本时传给脚本:</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 目前&lt;state&gt;总是“failover”,</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> &lt;role&gt;是“leader”或者“observer”中的一个。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class=\"line\">sentinel client-reconfig-script mymaster /var/redis/reconfig.sh</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"缓存穿透和雪崩\"><a href=\"#缓存穿透和雪崩\" class=\"headerlink\" title=\"缓存穿透和雪崩\"></a>缓存穿透和雪崩</h1><blockquote>\n<p>Redis缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询方面。但同时，它也带来了一些问题。其中，最要害的问题，就是数据的一致性问题，从严格意义上讲，这个问题无解。如果对数据的一致性要求很高，那么就不能使用缓存。</p>\n</blockquote>\n<blockquote>\n<p>另外的一些典型问题就是，缓存穿透、缓存雪崩和缓存击穿。目前，业界也都有比较流行的解决方案。</p>\n</blockquote>\n<h2 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h2><h3 id=\"概念-1\"><a href=\"#概念-1\" class=\"headerlink\" title=\"概念\"></a>概念</h3><blockquote>\n<p>缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中，于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。</p>\n</blockquote>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><h3 id=\"布隆过滤器\"><a href=\"#布隆过滤器\" class=\"headerlink\" title=\"布隆过滤器\"></a>布隆过滤器</h3><blockquote>\n<p>布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力；</p>\n</blockquote>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210928090903.png\" class title=\"输入图片说明\">\n\n<h3 id=\"缓存空对象\"><a href=\"#缓存空对象\" class=\"headerlink\" title=\"缓存空对象\"></a>缓存空对象</h3><blockquote>\n<p>当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源；</p>\n</blockquote>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210928090930.png\" class title=\"输入图片说明\">\n\n<h3 id=\"但是这种方法会存在两个问题：\"><a href=\"#但是这种方法会存在两个问题：\" class=\"headerlink\" title=\"但是这种方法会存在两个问题：\"></a>但是这种方法会存在两个问题：</h3><ul>\n<li>1 、如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键；</li>\n<li>2 、即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。</li>\n</ul>\n<h2 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h2><h3 id=\"概述-2\"><a href=\"#概述-2\" class=\"headerlink\" title=\"概述\"></a>概述</h3><blockquote>\n<p>这里需要注意和缓存击穿的区别，缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</p>\n</blockquote>\n<blockquote>\n<p>当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大。</p>\n</blockquote>\n<h3 id=\"解决方案-1\"><a href=\"#解决方案-1\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><h3 id=\"设置热点数据永不过期\"><a href=\"#设置热点数据永不过期\" class=\"headerlink\" title=\"设置热点数据永不过期\"></a>设置热点数据永不过期</h3><p>从缓存层面来看，没有设置过期时间，所以不会出现热点 key 过期后产生的问题。</p>\n<h3 id=\"加互斥锁\"><a href=\"#加互斥锁\" class=\"headerlink\" title=\"加互斥锁\"></a>加互斥锁</h3><p>分布式锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。</p>\n<h2 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h2><h3 id=\"概念-2\"><a href=\"#概念-2\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>缓存雪崩，是指在某一个时间段，缓存集中过期失效。</p>\n<blockquote>\n<p>产生雪崩的原因之一，比如在写本文的时候，马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。</p>\n</blockquote>\n<img src=\"/2022/07/19/redis/QQ%E6%88%AA%E5%9B%BE20210928091310.png\" class title=\"输入图片说明\">\n\n<blockquote>\n<p>其实集中过期，倒不是非常致命，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网。因为自然形成的缓存雪崩，一定是在某个时间段集中创建缓存，这个时候，数据库也是可以顶住压力的。无非就是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间就把数据库压垮。</p>\n</blockquote>\n<h3 id=\"解决方案-2\"><a href=\"#解决方案-2\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><h3 id=\"redis高可用\"><a href=\"#redis高可用\" class=\"headerlink\" title=\"redis高可用\"></a>redis高可用</h3><blockquote>\n<p>这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。</p>\n</blockquote>\n<h3 id=\"限流降级\"><a href=\"#限流降级\" class=\"headerlink\" title=\"限流降级\"></a>限流降级</h3><blockquote>\n<p>这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p>\n</blockquote>\n<h3 id=\"数据预热\"><a href=\"#数据预热\" class=\"headerlink\" title=\"数据预热\"></a>数据预热</h3><blockquote>\n<p>数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>\n</blockquote>\n"},{"title":"以管理员身份在当前目录打开命令行窗口","comments":1,"cover":"http://rebp38war.bkt.clouddn.com/img/cmd3.png","top_img":null,"_content":" ![](http://rebp38war.bkt.clouddn.com/img/cmd3.png)\n> 我们在需要打开命令行然后进入到相应目录进行一些操作的时候，一般常规的做法是:`Win+R`打开运行窗口,输入\"`cmd`\"回车打开命令行窗口；<br>假如我们要进入的是E盘project文件夹下的一个blog子文件夹，路径是这样的E:\\project\\blog，首先输入\" `E：`\"回车进入E盘再依次输入\"`cd project`\",\"`cd blog`\";<br>或者在资源管理器的地址栏里复制文件夹地址\"E:\\project\\blogr\", 然后输入cd 再把复制的地址一次性粘贴到cd 后面（适用于文件夹路径较长时，避免一个一个地输入）<br>如果需要进行频繁命令行操作，每次都要通过这样的方式来进行，势必很麻烦。<br>并且我们在很多场景在需要**管理员权限**，如何在这样的使用场景在使用命令行窗口，会令自己非常头疼。\n\n\n> 这里要介绍如何在**右键菜单**里添加一个菜单选项让我们可以在一个文件夹里直接右击鼠标便可以管理员身份打开一个命令行窗口，那样的话将会让工作变得非常轻松。\n\n### 如何操作 ###\n将以下代码复制到一个文本文件，然后保存成 cmd.reg，注意文件后缀是reg，注册表文件。\n```shell\nWindows Registry Editor Version 5.00\n\n; Created by: Shawn Brink\n\n; http://www.sevenforums.com\n\n; Tutorial: http://www.sevenforums.com/tutorials/47415-open-command-window-here-administrator.html\n\n[-HKEY_CLASSES_ROOT\\Directory\\shell\\runas]\n\n[HKEY_CLASSES_ROOT\\Directory\\shell\\runas]\n\n@=\"Open cmd here as Admin\"\n\n\"HasLUAShield\"=\"\"\n\n[HKEY_CLASSES_ROOT\\Directory\\shell\\runas\\command]\n\n@=\"cmd.exe /s /k pushd \\\"%V\\\"\"\n\n[-HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\runas]\n\n[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\runas]\n\n@=\"Open cmd here as Admin\"\n\n\"HasLUAShield\"=\"\"\n\n[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\runas\\command]\n\n@=\"cmd.exe /s /k pushd \\\"%V\\\"\"\n\n[-HKEY_CLASSES_ROOT\\Drive\\shell\\runas]\n\n[HKEY_CLASSES_ROOT\\Drive\\shell\\runas]\n\n@=\"Open cmd here as Admin\"\n\n\"HasLUAShield\"=\"\"\n\n[HKEY_CLASSES_ROOT\\Drive\\shell\\runas\\command]\n\n@=\"cmd.exe /s /k pushd \\\"%V\\\"\"\n```\n![](http://rebp38war.bkt.clouddn.com/img/cmd1.png)\n\n然后双击运行，弹出确定对话框，点击确定，再右键一看，菜单里已经多出一个以管理员身份打开命令行窗口的选项了。\n\n![](http://rebp38war.bkt.clouddn.com/img/cmd2.png)\n\n### 如何去除： ###\n\n假如哪天你不想要这个新加的选项了，请把下面的代码复制，同样保存到一个文本文件然后存为remove.reg，双击运行之。选项就会消失，菜单恢复正常。\n\n\n\t\n\n```shell\nWindows Registry Editor Version 5.00\n\t\n; Created by: Shawn Brink\n\t\n; http://www.sevenforums.com\n\t\n; Tutorial: http://www.sevenforums.com/tutorials/47415-open-command-window-here-administrator.html\n\t\n[-HKEY_CLASSES_ROOT\\Directory\\shell\\runas]\n\t\n[-HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\runas]\n\t\n[-HKEY_CLASSES_ROOT\\Drive\\shell\\runas]\n```","source":"_posts/以管理员身份在当前目录打开命令行窗口.md","raw":"---\ntitle: 以管理员身份在当前目录打开命令行窗口\ncomments: true\ncategories:\n - 工具\ntags:\n - bat\n - windows\ncover: http://rebp38war.bkt.clouddn.com/img/cmd3.png\ntop_img: \n---\n ![](http://rebp38war.bkt.clouddn.com/img/cmd3.png)\n> 我们在需要打开命令行然后进入到相应目录进行一些操作的时候，一般常规的做法是:`Win+R`打开运行窗口,输入\"`cmd`\"回车打开命令行窗口；<br>假如我们要进入的是E盘project文件夹下的一个blog子文件夹，路径是这样的E:\\project\\blog，首先输入\" `E：`\"回车进入E盘再依次输入\"`cd project`\",\"`cd blog`\";<br>或者在资源管理器的地址栏里复制文件夹地址\"E:\\project\\blogr\", 然后输入cd 再把复制的地址一次性粘贴到cd 后面（适用于文件夹路径较长时，避免一个一个地输入）<br>如果需要进行频繁命令行操作，每次都要通过这样的方式来进行，势必很麻烦。<br>并且我们在很多场景在需要**管理员权限**，如何在这样的使用场景在使用命令行窗口，会令自己非常头疼。\n\n\n> 这里要介绍如何在**右键菜单**里添加一个菜单选项让我们可以在一个文件夹里直接右击鼠标便可以管理员身份打开一个命令行窗口，那样的话将会让工作变得非常轻松。\n\n### 如何操作 ###\n将以下代码复制到一个文本文件，然后保存成 cmd.reg，注意文件后缀是reg，注册表文件。\n```shell\nWindows Registry Editor Version 5.00\n\n; Created by: Shawn Brink\n\n; http://www.sevenforums.com\n\n; Tutorial: http://www.sevenforums.com/tutorials/47415-open-command-window-here-administrator.html\n\n[-HKEY_CLASSES_ROOT\\Directory\\shell\\runas]\n\n[HKEY_CLASSES_ROOT\\Directory\\shell\\runas]\n\n@=\"Open cmd here as Admin\"\n\n\"HasLUAShield\"=\"\"\n\n[HKEY_CLASSES_ROOT\\Directory\\shell\\runas\\command]\n\n@=\"cmd.exe /s /k pushd \\\"%V\\\"\"\n\n[-HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\runas]\n\n[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\runas]\n\n@=\"Open cmd here as Admin\"\n\n\"HasLUAShield\"=\"\"\n\n[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\runas\\command]\n\n@=\"cmd.exe /s /k pushd \\\"%V\\\"\"\n\n[-HKEY_CLASSES_ROOT\\Drive\\shell\\runas]\n\n[HKEY_CLASSES_ROOT\\Drive\\shell\\runas]\n\n@=\"Open cmd here as Admin\"\n\n\"HasLUAShield\"=\"\"\n\n[HKEY_CLASSES_ROOT\\Drive\\shell\\runas\\command]\n\n@=\"cmd.exe /s /k pushd \\\"%V\\\"\"\n```\n![](http://rebp38war.bkt.clouddn.com/img/cmd1.png)\n\n然后双击运行，弹出确定对话框，点击确定，再右键一看，菜单里已经多出一个以管理员身份打开命令行窗口的选项了。\n\n![](http://rebp38war.bkt.clouddn.com/img/cmd2.png)\n\n### 如何去除： ###\n\n假如哪天你不想要这个新加的选项了，请把下面的代码复制，同样保存到一个文本文件然后存为remove.reg，双击运行之。选项就会消失，菜单恢复正常。\n\n\n\t\n\n```shell\nWindows Registry Editor Version 5.00\n\t\n; Created by: Shawn Brink\n\t\n; http://www.sevenforums.com\n\t\n; Tutorial: http://www.sevenforums.com/tutorials/47415-open-command-window-here-administrator.html\n\t\n[-HKEY_CLASSES_ROOT\\Directory\\shell\\runas]\n\t\n[-HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\runas]\n\t\n[-HKEY_CLASSES_ROOT\\Drive\\shell\\runas]\n```","slug":"以管理员身份在当前目录打开命令行窗口","published":1,"date":"2021-12-24T08:45:56.949Z","updated":"2022-07-01T04:47:59.774Z","layout":"post","photos":[],"link":"","_id":"cl5w7e741000figvufmqqeznk","content":"<p> <img src=\"http://rebp38war.bkt.clouddn.com/img/cmd3.png\"></p>\n<blockquote>\n<p>我们在需要打开命令行然后进入到相应目录进行一些操作的时候，一般常规的做法是:<code>Win+R</code>打开运行窗口,输入”<code>cmd</code>“回车打开命令行窗口；<br>假如我们要进入的是E盘project文件夹下的一个blog子文件夹，路径是这样的E:\\project\\blog，首先输入” <code>E：</code>“回车进入E盘再依次输入”<code>cd project</code>“,”<code>cd blog</code>“;<br>或者在资源管理器的地址栏里复制文件夹地址”E:\\project\\blogr”, 然后输入cd 再把复制的地址一次性粘贴到cd 后面（适用于文件夹路径较长时，避免一个一个地输入）<br>如果需要进行频繁命令行操作，每次都要通过这样的方式来进行，势必很麻烦。<br>并且我们在很多场景在需要<strong>管理员权限</strong>，如何在这样的使用场景在使用命令行窗口，会令自己非常头疼。</p>\n</blockquote>\n<blockquote>\n<p>这里要介绍如何在<strong>右键菜单</strong>里添加一个菜单选项让我们可以在一个文件夹里直接右击鼠标便可以管理员身份打开一个命令行窗口，那样的话将会让工作变得非常轻松。</p>\n</blockquote>\n<h3 id=\"如何操作\"><a href=\"#如何操作\" class=\"headerlink\" title=\"如何操作\"></a>如何操作</h3><p>将以下代码复制到一个文本文件，然后保存成 cmd.reg，注意文件后缀是reg，注册表文件。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">Windows Registry Editor Version 5.00</span><br><span class=\"line\"></span><br><span class=\"line\">; Created by: Shawn Brink</span><br><span class=\"line\"></span><br><span class=\"line\">; http://www.sevenforums.com</span><br><span class=\"line\"></span><br><span class=\"line\">; Tutorial: http://www.sevenforums.com/tutorials/47415-open-command-window-here-administrator.html</span><br><span class=\"line\"></span><br><span class=\"line\">[-HKEY_CLASSES_ROOT\\Directory\\shell\\runas]</span><br><span class=\"line\"></span><br><span class=\"line\">[HKEY_CLASSES_ROOT\\Directory\\shell\\runas]</span><br><span class=\"line\"></span><br><span class=\"line\">@=&quot;Open cmd here as Admin&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;HasLUAShield&quot;=&quot;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">[HKEY_CLASSES_ROOT\\Directory\\shell\\runas\\command]</span><br><span class=\"line\"></span><br><span class=\"line\">@=&quot;cmd.exe /s /k pushd \\&quot;%V\\&quot;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">[-HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\runas]</span><br><span class=\"line\"></span><br><span class=\"line\">[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\runas]</span><br><span class=\"line\"></span><br><span class=\"line\">@=&quot;Open cmd here as Admin&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;HasLUAShield&quot;=&quot;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\runas\\command]</span><br><span class=\"line\"></span><br><span class=\"line\">@=&quot;cmd.exe /s /k pushd \\&quot;%V\\&quot;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">[-HKEY_CLASSES_ROOT\\Drive\\shell\\runas]</span><br><span class=\"line\"></span><br><span class=\"line\">[HKEY_CLASSES_ROOT\\Drive\\shell\\runas]</span><br><span class=\"line\"></span><br><span class=\"line\">@=&quot;Open cmd here as Admin&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;HasLUAShield&quot;=&quot;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">[HKEY_CLASSES_ROOT\\Drive\\shell\\runas\\command]</span><br><span class=\"line\"></span><br><span class=\"line\">@=&quot;cmd.exe /s /k pushd \\&quot;%V\\&quot;&quot;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://rebp38war.bkt.clouddn.com/img/cmd1.png\"></p>\n<p>然后双击运行，弹出确定对话框，点击确定，再右键一看，菜单里已经多出一个以管理员身份打开命令行窗口的选项了。</p>\n<p><img src=\"http://rebp38war.bkt.clouddn.com/img/cmd2.png\"></p>\n<h3 id=\"如何去除：\"><a href=\"#如何去除：\" class=\"headerlink\" title=\"如何去除：\"></a>如何去除：</h3><p>假如哪天你不想要这个新加的选项了，请把下面的代码复制，同样保存到一个文本文件然后存为remove.reg，双击运行之。选项就会消失，菜单恢复正常。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">Windows Registry Editor Version 5.00</span><br><span class=\"line\">\t</span><br><span class=\"line\">; Created by: Shawn Brink</span><br><span class=\"line\">\t</span><br><span class=\"line\">; http://www.sevenforums.com</span><br><span class=\"line\">\t</span><br><span class=\"line\">; Tutorial: http://www.sevenforums.com/tutorials/47415-open-command-window-here-administrator.html</span><br><span class=\"line\">\t</span><br><span class=\"line\">[-HKEY_CLASSES_ROOT\\Directory\\shell\\runas]</span><br><span class=\"line\">\t</span><br><span class=\"line\">[-HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\runas]</span><br><span class=\"line\">\t</span><br><span class=\"line\">[-HKEY_CLASSES_ROOT\\Drive\\shell\\runas]</span><br></pre></td></tr></table></figure>","site":{"data":{"bangumis":{"wantWatch":[],"watching":[{"title":"凡人修仙传","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/70d11dfab23a3ee81ccf64f18efa139416a633ff.jpg@220w_280h.webp","totalCount":"未完结","id":28223043,"follow":"615.7 万","view":"8.9 亿","danmaku":"490.9 万","coin":"1186.9 万","score":9.7,"des":"看机智的凡人小子韩立如何稳健发展、步步为营，战魔道、夺至宝、驰骋星海、快意恩仇，成为纵横三界的强者。他日仙界重相逢，一声道友尽沧桑。..."},{"title":"恋爱游戏世界对路人角色很不友好","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/c9723d8c77d881a8debba2852d580e97826b43d0.png@220w_280h.webp","totalCount":"全12话","id":28237300,"follow":"151.2 万","view":"5120.4 万","danmaku":"40.6 万","coin":"24.5 万","score":9.1,"des":"从现代日本转生到“恋爱游戏”世界的里昂，发现这里女尊男卑，对男性很不友好。身为路人角色的他，为了摆脱自己因地位低下而被肆意决定的人生，决定活用从游戏中得到的知识，保持路人角色的身份，取得“失落物品”来..."},{"title":"魔法纪录 魔法少女小圆外传 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/9eef1df9ab157be52d2c4d70d3500442f00cafc3.png@220w_280h.webp","totalCount":"全12话","id":28234642,"follow":"237.1 万","view":"907.6 万","danmaku":"5.0 万","coin":"4.9 万","score":7.7,"des":"愿望的代价，究竟是希望还是绝望——。"},{"title":"小林家的龙女仆 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/847e9dbb6876fb37a30199a5c88910704976d45b.png@220w_280h.webp","totalCount":"全13话","id":28234613,"follow":"855.7 万","view":"1.1 亿","danmaku":"49.0 万","coin":"69.0 万","score":9.6,"des":"那位不可思议的龙女仆再度登场！\n因为各种奇妙的原因而作为小林家的女仆而工作中的龙·托尔。\n偶尔（胡说，是经常）给亲爱的小林添麻烦，总算是融入了人类社会，成为了一个完美的（骗人，也就还行）女仆。\n同样是..."},{"title":"国王排名","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/376d7e69a667bcb1c0b934a4e35e07e7fa23110b.png@220w_280h.webp","totalCount":"全23话","id":28235154,"follow":"927.7 万","view":"4.8 亿","danmaku":"250.1 万","coin":"260.9 万","score":7,"des":"国家的丰饶、麾下勇者的数量、\n以及国王本人如何像勇者一般强大，\n这些要素的综合排名，便是所谓的“国王排名”。\n主人公波吉是国王排名第七名的伯斯王治下王国的第一王子。\n但是波吉却生来又聋又哑，贫弱到挥不..."},{"title":"阿松 第三季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0212baa8898d0c819c7fb84015e95b8fca621435.png@220w_280h.webp","totalCount":"全25话","id":28229892,"follow":"67.6 万","view":"938.0 万","danmaku":"13.0 万","coin":"5.4 万","score":9.6,"des":"日本最有名的六胞胎的传说，第三次开幕！！这次会有怎样意想不到的新展开！？..."},{"title":"命运-冠位指定 冠位时间神殿所罗门","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0e094b798388da19a4feffa6a6dabc1dc1dc90cd.jpg@220w_280h.webp","totalCount":"全1话","id":28236225,"follow":"525.5 万","view":"1220.0 万","danmaku":"8.9 万","coin":"15.1 万","score":8.5,"des":"在经过七个特异点的大战后，\n人理存续保障机关迦勒底，终于到达了圣杯探索的最终地点——终局特异点 冠位时间神殿所罗门。\n他们要击败身为罪魁祸首的魔术王所罗门，夺回未来。\n在开战的前一刻，一行人各自度过了..."},{"title":"JOJO的奇妙冒险 星尘远征军","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/47c0108259355d6d2c517ed97f6b90fb777f844f.png@220w_280h.webp","totalCount":"全24话","id":28223481,"follow":"444.2 万","view":"1.5 亿","danmaku":"463.4 万","coin":"45.7 万","score":9.8,"des":"时为1987年，乔瑟夫·乔斯达与“柱之男”们之间的死战后过了50年……乔瑟夫为了为了帮助“被恶灵附身了”的外孙子·空条承太郎而来到了日本。原来那并不是恶灵而是幽波纹（替身）。替身突然出现的原因在于，从..."},{"title":"JOJO的奇妙冒险 星尘远征军 埃及篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f6709b76e88f50aa132d1e09e2d8de9663a09b3e.png@220w_280h.webp","totalCount":"全24话","id":28223483,"follow":"421.9 万","view":"1.3 亿","danmaku":"468.7 万","coin":"44.3 万","score":9.9,"des":"在乔斯达家的宿敌·迪奥（DIO）复活的影响下，一位年轻人——空条承太郎，得到了名为“幽波纹（替身）”的能力。为了拯救因迪奥的诅咒而倒下的母亲荷莉，空条承太郎与外祖父·乔瑟夫以及伙伴们，一起为了打倒迪奥..."},{"title":"JOJO的奇妙冒险 不灭钻石","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/6a04c87e990ab74cd8d555ef45a863de0993b161.png@220w_280h.webp","totalCount":"全39话","id":140552,"follow":"302.3 万","view":"2.1 亿","danmaku":"813.8 万","coin":"55.9 万","score":9.8,"des":"在埃及与宿敌DIO的死斗之后过了11年。1999年，空条承太郎为了与祖父乔瑟夫·乔斯达的私生子东方仗助见面，而来到了日本M县S市杜王町。但，仗助却持有与承太郎相同的特殊能力“替身”。之后，以承太郎的来..."},{"title":"命运-冠位嘉年华","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/c660976f4502a544d990a882ae62194b57753a71.png@220w_280h.webp","totalCount":"全2话","id":28234639,"follow":"479.8 万","view":"862.4 万","danmaku":"4.1 万","coin":"9.1 万","score":9.8,"des":"一起庆祝吧！为了这奇迹般的嘉年华！"},{"title":"伍六七","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/b69e26d9e50514f3fa99eac9ab5aabf2a6e28c88.jpg@220w_280h.webp","totalCount":"全13话","id":6360,"follow":"585.8 万","view":"3.3 亿","danmaku":"227.1 万","coin":"191.8 万","score":9.8,"des":"在某个小岛上，有一个可以伪装成任何东西的廉价刺客，名叫伍六七。平时看上去是个理发师，其实背地里却做着刺客生意。热爱理发事业，喜欢给人剪头发，善用剪刀——剪刀也是他的刺杀武器。由于初入刺客行当，行情十分..."},{"title":"命运-冠位指定 -月光／失落之室-","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3fa5fd2b7afae827b0bf150d7f0cbfc54eda1ff2.png@220w_280h.webp","totalCount":"全1话","id":28234950,"follow":"483.3 万","view":"551.2 万","danmaku":9696,"coin":"2.9 万","score":9.5,"des":"失落之室——。\n这是一个可以看到被夺去亦或是遗失之物的地方。\n这是位于迦勒底被遗忘的角落，不属于任何人的地方。..."},{"title":"致不灭的你","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/1ae94fbb35d8e23bb84926b694509f8b057f96e6.png@220w_280h.webp","totalCount":"全20话","id":28233896,"follow":"476.3 万","view":"1.3 亿","danmaku":"140.1 万","coin":"95.0 万","score":9.6,"des":"本剧讲述了一个情节跌宕、场面宏大的奇幻故事，通过拥有不灭之身的主人公“不死”来探索人生哲理。\n不死起初是一个被投放到人世间的“球”。\n\n它具有“幻化为刺激源形态的能力”和“死后重生的能力”。\n\n先后从..."},{"title":"来自新世界","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/aaa60f9cb17fb4a38df464f1064ca9623e0769cc.jpg@220w_280h.webp","totalCount":"全25话","id":1598,"follow":"115.9 万","view":"1540.9 万","danmaku":"76.3 万","coin":"5.7 万","score":9.5,"des":"1000年后的日本，孩子们不断地消失，只存在想象中的恐怖动物与人类展开殊死战争。反乌托邦式的未来超级社会“新世界”，是口吐真言凭藉“咒力”就能移动物体的人类，与有着等同于普通人智力的生物“妖鼠”共存的..."},{"title":"转生成蜘蛛又怎样！","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f0796e37abac25ba2aa9f23120646aaa9a3d5ea7.png@220w_280h.webp","totalCount":"全24话","id":28231809,"follow":"600.0 万","view":"3.7 亿","danmaku":"190.3 万","coin":"164.6 万","score":7.8,"des":"曾经是一名女高中生的“我”，突然转生变成了幻想世界中的蜘蛛魔物。\n而且，出生地点还是各种凶恶魔物所盘踞的大迷宫。\n“我”以人类的智慧和非同寻常的积极心态为武器，使用蜘蛛的丝网以及陷阱打倒比自己等级高得..."},{"title":"装甲重拳/MEGALOBOX 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/e14dc4a935397fc074c7a12d9520225615209025.png@220w_280h.webp","totalCount":"全13话","id":28233916,"follow":"244.9 万","view":"3435.4 万","danmaku":"19.7 万","coin":"53.1 万","score":9.9,"des":"再一次，为梦想而活——\n\n将肉体与“装甲技术”融合的究极格斗技“装甲拳击”。\n在决出其顶点之人的大会“重拳之巅”上，身穿装甲用自己肉身挑战一切的拳击手“JOE”。\n\n从最下层的比赛开始仅仅花了三个月就..."},{"title":"机动战士高达SEED HD","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/855c88677267d707ebfe4040403692ff2c0938f0.png@220w_280h.webp","totalCount":"全48话","id":497,"follow":"54.8 万","view":"4044.4 万","danmaku":"114.4 万","coin":"6.0 万","score":9.6,"des":"《机动战士高达SEED》是高达系列在2002年至2003年度放映的动画。续作为《机动战士高达SEED Destiny》在2004年播放。因各具魅力的角色，明星云集的声优阵容和高度商业化的宣传而受到较低..."},{"title":"夏目友人帐 唤石者与怪异的访客","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6cf43708b779cde84ad285ff4e3a080de98df0af.png@220w_280h.webp","totalCount":"全1话","id":28234316,"follow":"567.1 万","view":"1374.8 万","danmaku":"18.1 万","coin":"17.9 万","score":9.9,"des":"本作由【唤石者】与【怪异的访客】两个人气短篇集锦而成。讲述生来便能看见各种妖怪的夏目，与自称保镖的猫咪老师一同邂逅的一系列温暖故事。\n【唤石者】一天夏目在森林中遇到一只小妖怪——密实。密实称自己肩负「..."},{"title":"Fate/Grand Order ‐First Order‐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/b75c55d209d156c8631f5ceb21e5c52c834dbb60.jpg@220w_280h.webp","totalCount":"全1话","id":5747,"follow":"250.9 万","view":"3329.7 万","danmaku":"76.7 万","coin":"10.7 万","score":8.3,"des":"【2016年12月31日bilibili独播】2015年。示巴所观测到的未来领域毫无前兆地消失。根据计算，发现——不，是证明了人类将于2017年灭绝。人理延续保障机构·迦勒底将“无法观测的领域”假定为..."},{"title":"伍六七之玄武国篇","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/00843865ea13702eccc4efd64c313fd4c8029c6b.jpg@220w_280h.webp","totalCount":"全10话","id":28232253,"follow":"999.4 万","view":"4.0 亿","danmaku":"177.7 万","coin":"385.3 万","score":9.8,"des":"为了保护小鸡岛居民和这里平静的生活，伍六七和他的伙伴大保和小飞开启了去往玄武国的冒险旅程，去寻找身世的真相和解救小岛的办法，等待他们的又将是更多的未知与奇遇。..."},{"title":"堀与宫村","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/039c4e0b14e27c7a9e5cce2f20a6efd3c8909401.png@220w_280h.webp","totalCount":"全13话","id":28231840,"follow":"695.2 万","view":"2.2 亿","danmaku":"242.1 万","coin":"361.4 万","score":9.8,"des":"不论是谁，都会有不想被人知道的一面。\n\n在学校中漂亮大方、成绩优秀的人气女生堀，私下却打扮土气、忙于家务和照顾弟弟。\n在学校中是阴暗宅男形象的宫村，生活中却是打扮时尚、带耳钉的帅气男生。\n因为一次特别..."},{"title":"奇蛋物语 / WONDER EGG PRIORITY","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/10e0bbc1047b2c45f0f881de334a6f3bfb42a3b6.png@220w_280h.webp","totalCount":"全12话","id":28231851,"follow":"254.9 万","view":"4686.8 万","danmaku":"47.6 万","coin":"65.5 万","score":9.7,"des":"14岁少女·大户爱在深夜散步的途中，\n随着神秘声音的指引，获得了一枚「蛋」。\n\n「如果想要改变世界的话」\n「那么就在现在做出选择」\n「请相信自己——」\n「打破这枚蛋——」\n\n而在打破「蛋」之后，等待着..."},{"title":"Re：从零开始的异世界生活 第二季 后半","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/4f3edbede7fc0bdb52842075cf8faaa1c5953eaa.png@220w_280h.webp","totalCount":"全12话","id":28232073,"follow":"849.9 万","view":"9308.1 万","danmaku":"108.1 万","coin":"230.1 万","score":9.9,"des":"我一定会拯救你。\n在打倒了魔女教大罪司教「怠惰」担当——培提其乌斯·罗曼尼康帝之后，菜月昴和爱蜜莉雅又得以重新开始。\n克服了艰难的诀别，两人终于和解，然而这只是新一轮风波的序幕。\n超乎想象的绝境危机，..."},{"title":"灰与幻想的格林姆迦尔","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/7fb4945f864e9e988212b7d20f206df2677053f8.jpg@220w_280h.webp","totalCount":"全12话","id":106512,"follow":"172.0 万","view":"2343.4 万","danmaku":"63.8 万","coin":"18.3 万","score":9.8,"des":"电视动画《灰与幻想的格林姆迦尔》改编自日本轻小说家十文字青原作白井锐利插画的同名轻小说。\n我们为什么要这么做…？\n哈尔希洛回过神来，才发现自己身处在黑暗当中，他完全不知道自己人在何处，也不明白这个地方..."},{"title":"龙与虎","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/144910805f172d16c5f544f43939a05d8ca20576.jpg@220w_280h.webp","totalCount":"全26话","id":1672,"follow":"336.9 万","view":"6671.9 万","danmaku":"511.9 万","coin":"61.5 万","score":9.7,"des":"樱花飞舞的四月，全新的高中二年级，新的班级……\n眼神凶恶的普通男孩——高须龙儿，遇上了众人害怕、凶暴残忍的“掌中老虎”逢坂大河，还知道了她不欲为人知的秘密。这就是龙虎相争爱与战斗的序幕。\n再加上总是笑..."},{"title":"机动战士高达 铁血的奥尔芬斯 第一季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/f84a80d731d0431c00903d8951fd66623d8237f7.png@220w_280h.webp","totalCount":"全25话","id":4310042,"follow":"62.4 万","view":"2318.6 万","danmaku":"52.2 万","coin":"5.4 万","score":9.5,"des":"主人公三日月·奥古斯，从所属的民间警备公司克律塞安保公司（下称CGS）那里，接受了对少女库德莉亚·蓝那·伯恩斯坦的护卫任务。但CGS受到了摘取反叛之芽的武力组织加拉尔霍恩的袭击，于是在把三日月当做诱饵..."},{"title":"机动战士高达00 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1d7a969e8f1045739c596de89a963e30475aff0e.jpg@220w_280h.webp","totalCount":"全25话","id":1193,"follow":"37.2 万","view":"2458.1 万","danmaku":"61.4 万","coin":"4.1 万","score":9.8,"des":"天人与联合国军的最终决战后过了四年。建立地球联邦政府的人类，为了追求更进一步的国家间之统合，以及人类意识的统一，在联合正规军之外，设立了独立治安维持部队“A-Laws”，目的为对所有危害联合的势力与主..."},{"title":"机动战士高达00","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/35b11bf59eb3fd12f0387951510a5d722d7435e5.jpg@220w_280h.webp","totalCount":"全25话","id":1192,"follow":"62.1 万","view":"2465.5 万","danmaku":"53.6 万","coin":"4.6 万","score":9.7,"des":"在西历2307年，虽然化石燃料枯竭了，但是人类得到了截然不同的新型能源。三台巨大的轨道升降机以及伴随它们的大规模的太阳光发电系统。但是能得到这个系统恩惠的，只有一部分大国和其同盟国而已。\n拥有三台轨道..."},{"title":"Re：从零开始的异世界生活 第二季 前半","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f2425cbdb07cc93bd0d3ba1c0099bfe78f5dc58a.png@220w_280h.webp","totalCount":"全13话","id":28229233,"follow":"774.2 万","view":"1.3 亿","danmaku":"201.4 万","coin":"126.7 万","score":9.7,"des":"我一定会拯救你。\n在打倒了魔女教大罪司教「怠惰」担当——培提其乌斯·罗曼尼康帝之后，菜月昴和爱蜜莉雅又得以重新开始。\n克服了艰难的诀别，两人终于和解，然而这只是新一轮风波的序幕。\n超乎想象的绝境危机，..."},{"title":"超级小白","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3d3e8257d22596f5d3e4395ca759bd1e0fe9b873.jpg@220w_280h.webp","totalCount":"全48话","id":28222671,"follow":"27.4 万","view":"978.0 万","danmaku":"3.6 万","coin":"3.6 万","score":9.6,"des":"为了阻止企图霸占世界的黑暗势力，野原家的普通小狗——小白接肩负重大使命，变身成为了守护世界的“超级小白”。小白将要面对的不仅是发明狗，还有其他意想不到的对手。当然，面对邪恶势力，小白也有着令人惊讶的超..."},{"title":"Re：从零开始的异世界生活 新编集版","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3c125e1aad08643e3eff2fb7d45e740c1a052725.png@220w_280h.webp","totalCount":"全13话","id":28224394,"follow":"631.1 万","view":"7674.2 万","danmaku":"166.2 万","coin":"51.1 万","score":9.6,"des":"在从便利商店回家的路上，突然被异世界召唤的少年菜月昴。在无法依靠任何东西的异世界，无力的少年手唯一的力量……那是“死去然后重新开始”的力量。为了守护最重要的人们，为了取回确实存在着又无可替代的时间，少..."},{"title":"因为太怕痛就全点防御力了","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/8021d3f6b0df6dbba6d32f76eb9cfe2531e166c4.png@220w_280h.webp","totalCount":"全12话","id":28224137,"follow":"620.6 万","view":"2.3 亿","danmaku":"326.8 万","coin":"103.8 万","score":9,"des":"主角本条枫在好友白峰理沙推荐下开始游玩游戏“NewWorld Online”，创建了名为“梅普露”的角色。然而作为游戏初学者，梅普露选择了不受欢迎的大盾当武器，同时因为怕痛而把所有状态点加到防御力的极..."},{"title":"冰海战记","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/c30401817895e67399094b4e669785a104270cdf.jpg@220w_280h.webp","totalCount":"全24话","id":28220475,"follow":"174.4 万","view":"4893.8 万","danmaku":"48.7 万","coin":"36.7 万","score":9.8,"des":"公元10世纪末期，出现了在世界各地出没的最强民族。被讴歌为最强战士的托尔兹，其子托尔芬幼时便生活在战场上，并向往着梦幻大陆“文兰”。这是一个发生在激荡时代的，真正的英雄物语。..."},{"title":"齐木楠雄的灾难 始动篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ba59822eded39b5254fb01448a7f1502101d5624.png@220w_280h.webp","totalCount":"全6话","id":28223748,"follow":"372.4 万","view":"3054.5 万","danmaku":"20.0 万","coin":"17.8 万","score":9.8,"des":"在电视剧中堪称帅气的超能力，对于高中生齐木楠雄来说只是招致灾难的元凶。作为新动画系列展开的楠雄的日常又会如何！？..."},{"title":"OVERLORD Ⅱ","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/851f979c8ebcc7583a43abd4b786c4e2e66b746b.jpg@220w_280h.webp","totalCount":"全13话","id":8792,"follow":"539.3 万","view":"3.8 亿","danmaku":"413.9 万","coin":"114.1 万","score":9.6,"des":"时为2138年。曾卷起一大风潮的虚拟现实体感型网络游戏《YGGDRASIL》即将迎来停服。玩家飞鼠在曾经以同伴和荣华自傲的根据地纳萨力克地下大坟墓，独自一人安静等待着那一刻。但是，不料发生了结束时间已..."},{"title":"夏目友人帐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/99c549494d9425f6455bd45a151f4d26397d6151.png@220w_280h.webp","totalCount":"全13话","id":1660,"follow":"324.0 万","view":"4975.2 万","danmaku":"278.7 万","coin":"15.5 万","score":9.8,"des":"夏目贵志生来拥有强大的灵力，能感知平常人所无法接触的妖怪神明的存在。因父母双亡，他多年间辗转于互相推卸责任的亲戚之间，又受到同龄人的欺负，未曾与任何人深交，造成性格一定程度上的孤僻。夏目本性和善，对于..."}],"watched":[{"title":"装甲重拳/MEGALOBOX","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0c44785cb5d25cc9f648800d251f21a2e236bb8a.png@220w_280h.webp","totalCount":"全13话","id":79472,"follow":"221.9 万","view":"6162.0 万","danmaku":"48.6 万","coin":"32.9 万","score":9.8,"des":"将肉体与“装甲技术”融合的究极格斗技——“MEGALOBOX”，将自己的全部赌在上面的男人们的热血战斗开始！\n今天也立于未认可地区的赌博比赛赛场上的MEGALO拳击手“JNK DOG”。虽然具备实力，..."},{"title":"超能力女儿","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/152c536f8ecaad8f3d7d568d33da81c963a4a722.png@220w_280h.webp","totalCount":"全12话","id":78352,"follow":"293.8 万","view":"9252.2 万","danmaku":"98.5 万","coin":"35.4 万","score":9.6,"des":"支持着芦川组的年轻智力型黑道新田义史，过着被喜欢的壶所包围的悠然自得单身生活。但某一天，随着装在神秘物体里的少女雏来到他家，他的生活为之一变。他被能使用念动力的雏所胁迫，迫不得已开始和她同居！\n容易暴..."},{"title":"OVERLORD Ⅲ","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/dd7a9d0a0bee32b1f43c2656398d8463d12b3069.jpg@220w_280h.webp","totalCount":"全13话","id":102252,"follow":"551.6 万","view":"4.0 亿","danmaku":"399.7 万","coin":"129.2 万","score":9.4,"des":"时间为2138年。曾卷起一大风潮的虚拟现实体感型网络游戏《YGGDRASIL》即将迎来停服。玩家飞鼠在曾经以同伴和荣华自傲的根据地纳萨力克地下大坟墓，独自一人安静等待着那一刻。\n但是，不料发生了“过了..."},{"title":"路人超能100 第一次灵能咨询所员工旅游～舒缓心灵的疗愈之旅~（OVA2）","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/1271324d51634b68980704731987724a1afc60aa.jpg@220w_280h.webp","totalCount":"全1话","id":28222715,"follow":"318.8 万","view":"520.7 万","danmaku":"3.6 万","coin":"4.6 万","score":9.8,"des":"由原作ONE老师担任原案的完全新作OVA！「灵能咨询所」一行人，龙套与灵幻、小酒窝以及新同伴芹泽的目的地，正是缟马县深山中鲜为人知的温泉·疣神温泉。因为灵幻接受了旅馆老板娘的委托，「弄清温泉的恐怖传闻..."},{"title":"少女终末旅行","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1431ca5bb2f7143062e3df8f21b8448cf8cccc13.jpg@220w_280h.webp","totalCount":"全12话","id":6463,"follow":"239.8 万","view":"3714.7 万","danmaku":"100.7 万","coin":"37.2 万","score":9.8,"des":"本作舞台在人类繁华的文明迎来终结的很久以后，人类基本灭绝，甚至生物都不再存在的末日世界。复杂够高的都市成为迷宫般的废墟，得不到维护的机械渐渐停止运转。连何时终结了，何时开始终结的思考都不复存在的这个世..."},{"title":"齐木楠雄的灾难（日播&精选版）","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/eb4f17335f48951945fb9da47e6ee0bc65fa2fbb.jpg@220w_280h.webp","totalCount":"全120话","id":5070,"follow":"187.0 万","view":"2.3 亿","danmaku":"130.7 万","coin":"32.7 万","score":9.6,"des":"高中生·齐木楠雄是超能力者。心灵感应、念动力、透视、预知、瞬间移动、千里眼等，不论任何事情都自由自在。但这任谁都羡慕不已的最强能力，实际上对于本人而言是引来灾难的不幸元凶。因此，他在别人面前封印了超能..."},{"title":"比宇宙更远的地方","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/c9eca3cbc386c63b27461074b8b218898cb7440e.jpg@220w_280h.webp","totalCount":"全13话","id":13032,"follow":"156.0 万","view":"2298.0 万","danmaku":"45.9 万","coin":"23.9 万","score":9.8,"des":"无论何时，我们的第一步总是从好奇心开始。\n不曾看过的风景，不曾听过的声音，不曾闻过的味道，不曾摸过的质感，不曾尝过的食物，以及不曾感受过的澎湃。\n为了重拾不知何时忘却的记忆碎片和不知何时舍弃的感动的旅..."},{"title":"OVERLORD","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/b8e72ea69e57e0b7ac85d8b4d366554fd866df1a.jpg@220w_280h.webp","totalCount":"全13话","id":2576,"follow":"626.2 万","view":"4.1 亿","danmaku":"385.2 万","coin":"84.4 万","score":9.6,"des":"作品主要讲述了某天，一款曾经掀起过大热潮的VRMMORPG「YGGDRASIL」停止了运营。游戏原本会停止一切服务，但过了结束时间后，玩家们却发现不能退出，NPC也产生了各自的思想。现实世界中喜爱电玩..."},{"title":"路人超能100 II(灵能百分百 第二季)","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/216e1bdaf88244215a13b1154116805ee9adbe07.png@220w_280h.webp","totalCount":"全13话","id":4762734,"follow":"284.9 万","view":"1.0 亿","danmaku":"97.8 万","coin":"56.1 万","score":9.9,"des":"当有什么东西达到“100”的时候，就会爆发的少年·路人（龙套）。外表极其普通——不如说是不起眼。不擅长迎合气氛的他，实际上拥有着强力的超能力。盯上了这样的他的能力，而接连现身的伪灵能力者以及宗教团体、..."},{"title":"多罗罗","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3fc16a667502cbff226e585eb660a96a20c7458c.png@220w_280h.webp","totalCount":"全24话","id":4312482,"follow":"452.1 万","view":"1.8 亿","danmaku":"143.9 万","coin":"73.9 万","score":9.4,"des":"他们向着命运抗争，在那尽头等待他们的是人心，还是业障。\n时值乱世。\n名为景光的醍醐将军，向某个寺庙殿堂中的12尊魔神像祈求早日结束战乱。\n作为代价，他的嫡子在出生时就失去了身体的某些部位，被丢弃在河流..."},{"title":"魔法少女小圆","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/7fcaa0e98b561611538ae4deba7949cec4ca39a8.png@220w_280h.webp","totalCount":"全12话","id":2539,"follow":"218.7 万","view":"4199.0 万","danmaku":"201.5 万","coin":"20.0 万","score":9.8,"des":"就读初中二年级的鹿目圆，过着平凡幸福的生活。神秘转学生晓美焰的出现，开始让小圆的命运有了巨大转变。某日一只名为丘比的神秘生物，希望小圆能够与它签订魔法契约，成为“魔法少女”以对抗邪恶的魔女保护世界。正..."}]},"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<p> <img src=\"http://rebp38war.bkt.clouddn.com/img/cmd3.png\"></p>\n<blockquote>\n<p>我们在需要打开命令行然后进入到相应目录进行一些操作的时候，一般常规的做法是:<code>Win+R</code>打开运行窗口,输入”<code>cmd</code>“回车打开命令行窗口；<br>假如我们要进入的是E盘project文件夹下的一个blog子文件夹，路径是这样的E:\\project\\blog，首先输入” <code>E：</code>“回车进入E盘再依次输入”<code>cd project</code>“,”<code>cd blog</code>“;<br>或者在资源管理器的地址栏里复制文件夹地址”E:\\project\\blogr”, 然后输入cd 再把复制的地址一次性粘贴到cd 后面（适用于文件夹路径较长时，避免一个一个地输入）<br>如果需要进行频繁命令行操作，每次都要通过这样的方式来进行，势必很麻烦。<br>并且我们在很多场景在需要<strong>管理员权限</strong>，如何在这样的使用场景在使用命令行窗口，会令自己非常头疼。</p>\n</blockquote>\n<blockquote>\n<p>这里要介绍如何在<strong>右键菜单</strong>里添加一个菜单选项让我们可以在一个文件夹里直接右击鼠标便可以管理员身份打开一个命令行窗口，那样的话将会让工作变得非常轻松。</p>\n</blockquote>\n<h3 id=\"如何操作\"><a href=\"#如何操作\" class=\"headerlink\" title=\"如何操作\"></a>如何操作</h3><p>将以下代码复制到一个文本文件，然后保存成 cmd.reg，注意文件后缀是reg，注册表文件。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">Windows Registry Editor Version 5.00</span><br><span class=\"line\"></span><br><span class=\"line\">; Created by: Shawn Brink</span><br><span class=\"line\"></span><br><span class=\"line\">; http://www.sevenforums.com</span><br><span class=\"line\"></span><br><span class=\"line\">; Tutorial: http://www.sevenforums.com/tutorials/47415-open-command-window-here-administrator.html</span><br><span class=\"line\"></span><br><span class=\"line\">[-HKEY_CLASSES_ROOT\\Directory\\shell\\runas]</span><br><span class=\"line\"></span><br><span class=\"line\">[HKEY_CLASSES_ROOT\\Directory\\shell\\runas]</span><br><span class=\"line\"></span><br><span class=\"line\">@=&quot;Open cmd here as Admin&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;HasLUAShield&quot;=&quot;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">[HKEY_CLASSES_ROOT\\Directory\\shell\\runas\\command]</span><br><span class=\"line\"></span><br><span class=\"line\">@=&quot;cmd.exe /s /k pushd \\&quot;%V\\&quot;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">[-HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\runas]</span><br><span class=\"line\"></span><br><span class=\"line\">[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\runas]</span><br><span class=\"line\"></span><br><span class=\"line\">@=&quot;Open cmd here as Admin&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;HasLUAShield&quot;=&quot;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\runas\\command]</span><br><span class=\"line\"></span><br><span class=\"line\">@=&quot;cmd.exe /s /k pushd \\&quot;%V\\&quot;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">[-HKEY_CLASSES_ROOT\\Drive\\shell\\runas]</span><br><span class=\"line\"></span><br><span class=\"line\">[HKEY_CLASSES_ROOT\\Drive\\shell\\runas]</span><br><span class=\"line\"></span><br><span class=\"line\">@=&quot;Open cmd here as Admin&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;HasLUAShield&quot;=&quot;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">[HKEY_CLASSES_ROOT\\Drive\\shell\\runas\\command]</span><br><span class=\"line\"></span><br><span class=\"line\">@=&quot;cmd.exe /s /k pushd \\&quot;%V\\&quot;&quot;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://rebp38war.bkt.clouddn.com/img/cmd1.png\"></p>\n<p>然后双击运行，弹出确定对话框，点击确定，再右键一看，菜单里已经多出一个以管理员身份打开命令行窗口的选项了。</p>\n<p><img src=\"http://rebp38war.bkt.clouddn.com/img/cmd2.png\"></p>\n<h3 id=\"如何去除：\"><a href=\"#如何去除：\" class=\"headerlink\" title=\"如何去除：\"></a>如何去除：</h3><p>假如哪天你不想要这个新加的选项了，请把下面的代码复制，同样保存到一个文本文件然后存为remove.reg，双击运行之。选项就会消失，菜单恢复正常。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">Windows Registry Editor Version 5.00</span><br><span class=\"line\">\t</span><br><span class=\"line\">; Created by: Shawn Brink</span><br><span class=\"line\">\t</span><br><span class=\"line\">; http://www.sevenforums.com</span><br><span class=\"line\">\t</span><br><span class=\"line\">; Tutorial: http://www.sevenforums.com/tutorials/47415-open-command-window-here-administrator.html</span><br><span class=\"line\">\t</span><br><span class=\"line\">[-HKEY_CLASSES_ROOT\\Directory\\shell\\runas]</span><br><span class=\"line\">\t</span><br><span class=\"line\">[-HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\runas]</span><br><span class=\"line\">\t</span><br><span class=\"line\">[-HKEY_CLASSES_ROOT\\Drive\\shell\\runas]</span><br></pre></td></tr></table></figure>"},{"title":"RocketMQ","date":"2022-07-08T06:51:12.000Z","cover":"http://rebp38war.bkt.clouddn.com/img/7c0175abf66c66d22b32061633d5cf7d.jpeg","_content":"\n# 第1章 RocketMQ概述\n## 一、MQ概述\n### 1 、MQ简介\nMQ，Message Queue，是一种提供消息队列服务的中间件，也称为消息中间件，是一套提供了消息生产、存储、消费全过程API的软件系统。消息即数据。一般消息的体量不会很大。\n\n### 2 、MQ用途\n从网上可以查看到很多的关于MQ用途的叙述，但总结起来其实就以下三点。\n\n* 限流削峰\n    * MQ可以将系统的超量请求暂存其中，以便系统后期可以慢慢进行处理，从而避免了请求的丢失或系统被压垮。\n    ![输入图片说明](rocketmq/QQ截图20220208101908.png \"QQ截图20201229183512.png\")\n\n* 异步解耦\n    * 上游系统对下游系统的调用若为同步调用，则会大大降低系统的吞吐量与并发度，且系统耦合度太高。而异步调用则会解决这些问题。所以两层之间若要实现由同步到异步的转化，一般性做法就是，在这两层间添加一个MQ层。\n\n![输入图片说明](rocketmq/QQ截图20220208102000.png \"QQ截图20201229183512.png\")\n\n* 数据收集\n    * 分布式系统会产生海量级数据流，如：业务日志、监控数据、用户行为等。针对这些数据流进行实时或批量采集汇总，然后对这些数据流进行大数据分析，这是当前互联网平台的必备技术。通过MQ完成此类数据收集是最好的选择。\n### 3 、常见MQ产品\n\n* ActiveMQ\n    * ActiveMQ是使用Java语言开发一款MQ产品。早期很多公司与项目中都在使用。但现在的社区活跃度已经很低。现在的项目中已经很少使用了。\n\n* RabbitMQ\n    * RabbitMQ是使用ErLang语言开发的一款MQ产品。其吞吐量较Kafka与RocketMQ要低，且由于其不是Java语言开发，所以公司内部对其实现定制化开发难度较大。\n\n* Kafka\n    * Kafka是使用Scala/Java语言开发的一款MQ产品。其最大的特点就是高吞吐率，常用于大数据领域的实时计算、日志采集等场景。其没有遵循任何常见的MQ协议，而是使用自研协议。对于Spring CloudNetçix，其仅支持RabbitMQ与Kafka。\n\n* RocketMQ\n    * RocketMQ是使用Java语言开发的一款MQ产品。经过数年阿里双 11 的考验，性能与稳定性非常高。其没有遵循任何常见的MQ协议，而是使用自研协议。对于Spring Cloud Alibaba，其支持RabbitMQ、Kafka，但提倡使用RocketMQ。\n\n#### 对比\n\n关键词|ACTIVEMQ|RABBITMQ|KAFKA|ROCKETMQ\n--|:--:|--:|--:|--:\n开发语言|Java|ErLang|Java|Java\n单机吞吐量|万级|万级|十万级|十万级\nTopic|-|-|百级Topic时会影响系统吞吐量|千级Topic时会影响系统吞吐\n社区活跃度|低|高|高|高\n\n### 4 、MQ常见协议\n\n##### 一般情况下MQ的实现是要遵循一些常规性协议的。常见的协议如下：\n\n###### JMS\n>JMS，Java Messaging Service（Java消息服务）。是Java平台上有关MOM（Message OrientedMiddleware，面向消息的中间件 PO/OO/AO）的技术规范，它便于消息系统中的Java应用程序进行消息交换，并且通过提供标准的产生、发送、接收消息的接口，简化企业应用的开发。ActiveMQ是该协议的典型实现。\n\n###### STOMP\n>STOMP，Streaming Text Orientated Message Protocol（面向流文本的消息协议），是一种MOM设计的简单文本协议。STOMP提供一个可互操作的连接格式，允许客户端与任意STOMP消息代理（Broker）进行交互。ActiveMQ是该协议的典型实现，RabbitMQ通过插件可以支持该协议。\n\n###### AMQP\n>AMQP，Advanced Message Queuing Protocol（高级消息队列协议），一个提供统一消息服务的应用层标准，是应用层协议的一个开放标准，是一种MOM设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同开发语言等条件的限制。 RabbitMQ是该协议的典型实现。\n\n###### MQTT\n>MQTT，Message Queuing Telemetry Transport（消息队列遥测传输），是IBM开发的一个即时通讯协议，是一种二进制协议，主要用于服务器和低功耗IoT（物联网）设备间的通信。该协议支持所有平台，几乎可以把所有联网物品和外部连接起来，被用来当做传感器和致动器的通信协议。 RabbitMQ通过插件可以支持该协议。\n\n## 二、RocketMQ概述\n\n### 1 、RocketMQ简介\n>RocketMQ是一个统一消息引擎、轻量级数据处理平台。RocketMQ是一款阿里巴巴开源的消息中间件。 2016 年 11 月 28 日，阿里巴巴向 Apache 软件基金会捐赠RocketMQ，成为 Apache 孵化项目。 2017 年 9 月 25 日，Apache 宣布 RocketMQ孵化成为 Apache 顶级项目（TLP ），成为国内首个互联网中间件在 Apache 上的顶级项目。\n\n官网地址：http://rocketmq.apache.org\n\n### 2 、RocketMQ发展历程\n![输入图片说明](rocketmq/QQ截图20220208103522.png \"QQ截图20201229183512.png\")\n* 2007 年，阿里开始五彩石项目，Notify作为项目中交易核心消息流转系统，应运而生。Notify系统是RocketMQ的雏形。\n* 2010 年，B2B大规模使用ActiveMQ作为阿里的消息内核。阿里急需一个具有海量堆积能力的消息系统。\n* 2011 年初，Kafka开源。淘宝中间件团队在对Kafka进行了深入研究后，开发了一款新的MQ，MetaQ。\n* 2012 年，MetaQ发展到了v3.0版本，在它基础上进行了进一步的抽象，形成了RocketMQ，然后就将其进行了开源。\n* 2015 年，阿里在RocketMQ的基础上，又推出了一款专门针对阿里云上用户的消息系统Aliware MQ。\n* 2016 年双十一，RocketMQ承载了万亿级消息的流转，跨越了一个新的里程碑。 11 月 28 日，阿里巴巴向 Apache 软件基金会捐赠 RocketMQ，成为 Apache 孵化项目。\n* 2017 年 9 月 25 日，Apache 宣布 RocketMQ孵化成为 Apache 顶级项目（TLP ），成为国内首个互联网中间件在 Apache 上的顶级项目。\n\n# 第 2 章 RocketMQ的安装与启动\n## 一、基本概念\n### 1 消息（Message）\n>消息是指，消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题。\n\n### 2 主题（Topic）\n![输入图片说明](rocketmq/QQ截图20220208103828.png \"QQ截图20201229183512.png\")\n\nTopic表示一类消息的集合，每个主题包含若干条消息，每条消息只能属于一个主题，是RocketMQ进行消息订阅的基本单位。 topic:message 1:n message:topic 1:1\n\n一个生产者可以同时发送多种Topic的消息；而一个消费者只对某种特定的Topic感兴趣，即只可以订阅\n和消费一种Topic的消息。 producer:topic 1:n consumer:topic 1:1\n\n### 3 标签（Tag）\n>为消息设置的标签，用于同一主题下区分不同类型的消息。来自同一业务单元的消息，可以根据不同业务目的在同一主题下设置不同标签。标签能够有效地保持代码的清晰度和连贯性，并优化RocketMQ提供的查询系统。消费者可以根据Tag实现对不同子主题的不同消费逻辑，实现更好的扩展性。\n\nTopic是消息的一级分类，Tag是消息的二级分类。\n* Topic：货物\n    * tag=上海\n    * tag=江苏\n    * tag=浙江\n\n#### ------- 消费者 -----\n\n* topic=货物 tag = 上海\n* topic=货物 tag = 上海|浙江\n* topic=货物 tag = *\n\n### 4 队列（Queue）\n存储消息的物理实体。一个Topic中可以包含多个Queue，每个Queue中存放的就是该Topic的消息。一个Topic的Queue也被称为一个Topic中消息的分区（Partition）。\n\n一个Topic的Queue中的消息只能被一个消费者组中的一个消费者消费。一个Queue中的消息不允许同一个消费者组中的多个消费者同时消费。\n\n![输入图片说明](rocketmq/QQ截图20220208104018.png \"QQ截图20201229183512.png\")\n\n在学习参考其它相关资料时，还会看到一个概念：分片（Sharding）。分片不同于分区。在RocketMQ中，分片指的是存放相应Topic的Broker。每个分片中会创建出相应数量的分区，即Queue，每个Queue的大小都是相同的。\n\n![输入图片说明](rocketmq/QQ截图20220208104611.png \"QQ截图20201229183512.png\")\n\n### 5 消息标识（MessageId/Key）\n\nRocketMQ中每个消息拥有唯一的MessageId，且可以携带具有业务标识的Key，以方便对消息的查询。不过需要注意的是，MessageId有两个：在生产者send()消息时会自动生成一个MessageId（msgId)，当消息到达Broker后，Broker也会自动生成一个MessageId(offsetMsgId)。msgId、offsetMsgId与key都称为消息标识。\n\n* msgId：由producer端生成，其生成规则为：producerIp + 进程pid + MessageClientIDSetter类的ClassLoader的hashCode +当前时间 + AutomicInteger自增计数器\n* offsetMsgId：由broker端生成，其生成规则为：brokerIp + 物理分区的offset（Queue中的偏移量）\n* key：由用户指定的业务相关的唯一标识\n\n## 二、系统架构\n\n![输入图片说明](rocketmq/QQ截图20220208104741.png \"QQ截图20201229183512.png\")\n\nRocketMQ架构上主要分为四部分构成：\n### 1 Producer\n消息生产者，负责生产消息。Producer通过MQ的负载均衡模块选择相应的Broker集群队列进行消息投\n递，投递的过程支持快速失败并且低延迟。\n> 例如，业务系统产生的日志写入到MQ的过程，就是消息生产的过程\n\n> 再如，电商平台中用户提交的秒杀请求写入到MQ的过程，就是消息生产的过程\n\nRocketMQ中的消息生产者都是以生产者组（Producer Group）的形式出现的。生产者组是同一类生产者的集合，这类Producer发送相同Topic类型的消息。一个生产者组可以同时发送多个主题的消息。\n\n### 2 Consumer\n\n消息消费者，负责消费消息。一个消息消费者会从Broker服务器中获取到消息，并对消息进行相关业务处理。\n\n>例如，QoS系统从MQ中读取日志，并对日志进行解析处理的过程就是消息消费的过程。\n\n>再如，电商平台的业务系统从MQ中读取到秒杀请求，并对请求进行处理的过程就是消息消费的过程。\n\nRocketMQ中的消息消费者都是以消费者组（Consumer Group）的形式出现的。消费者组是同一类消费者的集合，这类Consumer消费的是同一个Topic类型的消息。消费者组使得在消息消费方面，实现负载均衡（将一个Topic中的不同的Queue平均分配给同一个Consumer Group的不同的Consumer，注意，并不是将消息负载均衡）和容错（一个Consmer挂了，该Consumer Group中的其它Consumer可以接着消费原Consumer消费的Queue）的目标变得非常容易。\n\n![输入图片说明](rocketmq/QQ截图20220208105007.png \"QQ截图20201229183512.png\")\n\n消费者组中Consumer的数量应该小于等于订阅Topic的Queue数量。如果超出Queue数量，则多出的Consumer将不能消费消息。\n\n![输入图片说明](rocketmq/QQ截图20220208105040.png \"QQ截图20201229183512.png\")\n\n不过，一个Topic类型的消息可以被多个消费者组同时消费。\n>注意，\n* 1 ）消费者组只能消费一个Topic的消息，不能同时消费多个Topic消息\n* 2 ）一个消费者组中的消费者必须订阅完全相同的Topic\n\n### 3 Name Server\n\n#### 功能介绍\n\nNameServer是一个Broker与Topic路由的注册中心，支持Broker的动态注册与发现。\n\nRocketMQ的思想来自于Kafka，而Kafka是依赖了Zookeeper的。所以，在RocketMQ的早期版本，即在MetaQ v1.0与v2.0版本中，也是依赖于Zookeeper的。从MetaQ v3.0，即RocketMQ开始去掉了Zookeeper依赖，使用了自己的NameServer。\n\n#### 主要包括两个功能：\n\n* `Broker管理：`接受Broker集群的注册信息并且保存下来作为路由信息的基本数据；提供心跳检测机制，检查Broker是否还存活。\n* `路由信息管理：`每个NameServer中都保存着Broker集群的整个路由信息和用于客户端查询的队列信息。Producer和Conumser通过NameServer可以获取整个Broker集群的路由信息，从而进行消息的投递和消费。\n\n#### 路由注册\n\nNameServer通常也是以集群的方式部署，不过，NameServer是无状态的，即NameServer集群中的各个节点间是无差异的，各节点间相互不进行信息通讯。那各节点中的数据是如何进行数据同步的呢？在Broker节点启动时，轮询NameServer列表，与每个NameServer节点建立长连接，发起注册请求。在NameServer内部维护着一个Broker列表，用来动态存储Broker的信息。\n\n>注意，这是与其它像zk、Eureka、Nacos等注册中心不同的地方。<br>\n这种NameServer的无状态方式，有什么优缺点：<br>\n优点：NameServer集群搭建简单，扩容简单。<br>\n缺点：对于Broker，必须明确指出所有NameServer地址。否则未指出的将不会去注册。也正因为如此，NameServer并不能随便扩容。因为，若Broker不重新配置，新增的NameServer对于Broker来说是不可见的，其不会向这个NameServer进行注册。\n\nBroker节点为了证明自己是活着的，为了维护与NameServer间的长连接，会将最新的信息以心跳包的方式上报给NameServer，每 30 秒发送一次心跳。心跳包中包含 BrokerId、Broker地址(IP+Port)、Broker名称、Broker所属集群名称等等。NameServer在接收到心跳包后，会更新心跳时间戳，记录这个Broker的最新存活时间。\n\n#### 路由剔除\n\n由于Broker关机、宕机或网络抖动等原因，NameServer没有收到Broker的心跳，NameServer可能会将其从Broker列表中剔除。\n\nNameServer中有一个定时任务，每隔 10 秒就会扫描一次Broker表，查看每一个Broker的最新心跳时间戳距离当前时间是否超过 120 秒，如果超过，则会判定Broker失效，然后将其从Broker列表中剔除。\n\n>扩展：对于RocketMQ日常运维工作，例如Broker升级，需要停掉Broker的工作。OP需要怎么做？<br>\nOP需要将Broker的读写权限禁掉。一旦client(Consumer或Producer)向broker发送请求，都会收到broker的NO_PERMISSION响应，然后client会进行对其它Broker的重试。<br>\n当OP观察到这个Broker没有流量后，再关闭它，实现Broker从NameServer的移除。<br>\nOP：运维工程师<br>\nSRE：Site Reliability Engineer，现场可靠性工程师\n\n#### 路由发现\nRocketMQ的路由发现采用的是Pull模型。当Topic路由信息出现变化时，NameServer不会主动推送给客户端，而是客户端定时拉取主题最新的路由。默认客户端每 30 秒会拉取一次最新的路由。\n\n>扩展：<br>\n1 ）Push模型：推送模型。其实时性较好，是一个“发布-订阅”模型，需要维护一个长连接。而长连接的维护是需要资源成本的。该模型适合于的场景：<br>\n    * 实时性要求较高<br>\n    * Client数量不多，Server数据变化较频繁<br>\n2 ）Pull模型：拉取模型。存在的问题是，实时性较差。\n<br>\n3 ）Long Polling模型：长轮询模型。其是对Push与Pull模型的整合，充分利用了这两种模型的优势，屏蔽了它们的劣势。\n\n#### 客户端NameServer选择策略\n\n>这里的客户端指的是Producer与Consumer\n\n客户端在配置时必须要写上NameServer集群的地址，那么客户端到底连接的是哪个NameServer节点呢？客户端首先会生产一个随机数，然后再与NameServer节点数量取模，此时得到的就是所要连接的节点索引，然后就会进行连接。如果连接失败，则会采用round-robin策略，逐个尝试着去连接其它节点。\n\n首先采用的是`随机策略`进行的选择，失败后采用的是`轮询策略`。\n\n>扩展：Zookeeper Client是如何选择Zookeeper Server的？<br>\n简单来说就是，经过两次Shufæe，然后选择第一台Zookeeper Server。<br>\n详细说就是，将配置文件中的zk server地址进行第一次shufæe，然后随机选择一个。这个选择出的一般都是一个hostname。然后获取到该hostname对应的所有ip，再对这些ip进行第二次shufæe，从shufæe过的结果中取第一个server地址进行连接。\n\n### 4 Broker\n\n#### 功能介绍\n\nBroker充当着消息中转角色，负责存储消息、转发消息。Broker在RocketMQ系统中负责接收并存储从生产者发送来的消息，同时为消费者的拉取请求作准备。Broker同时也存储着消息相关的元数据，包括消费者组消费进度偏移offset、主题、队列等。\n\n>Kafka 0.8版本之后，offset是存放在Broker中的，之前版本是存放在Zookeeper中的。\n\n#### 模块构成\n下图为Broker Server的功能模块示意图。\n\n![输入图片说明](rocketmq/QQ截图20220208110201.png \"QQ截图20201229183512.png\")\n\n`Remoting Module`：整个Broker的实体，负责处理来自clients端的请求。而这个Broker实体则由以下模块构成。\n\n`Client Manager：`客户端管理器。负责接收、解析客户端(Producer/Consumer)请求，管理客户端。例如，维护Consumer的Topic订阅信息\n\n`Store Service：`存储服务。提供方便简单的API接口，处理消息存储到物理硬盘和消息查询功能。\n\n`HA Service：`高可用服务，提供Master Broker 和 Slave Broker之间的数据同步功能。\n\n`Index Service：`索引服务。根据特定的Message key，对投递到Broker的消息进行索引服务，同时也提供根据Message Key对消息进行快速查询的功能。\n\n#### 集群部署\n![输入图片说明](rocketmq/QQ截图20220208110311.png \"QQ截图20201229183512.png\")\n\n为了增强Broker性能与吞吐量，Broker一般都是以集群形式出现的。各集群节点中可能存放着相同Topic的不同Queue。不过，这里有个问题，如果某Broker节点宕机，如何保证数据不丢失呢？其解决方案是，将每个Broker集群节点进行横向扩展，即将Broker节点再建为一个HA集群，解决单点问题。\n\nBroker节点集群是一个主从集群，即集群中具有Master与Slave两种角色。Master负责处理读写操作请求，Slave负责对Master中的数据进行备份。当Master挂掉了，Slave则会自动切换为Master去工作。所以这个Broker集群是主备集群。一个Master可以包含多个Slave，但一个Slave只能隶属于一个Master。Master与Slave 的对应关系是通过指定相同的BrokerName、不同的BrokerId 来确定的。BrokerId为 0 表示Master，非 0 表示Slave。每个Broker与NameServer集群中的所有节点建立长连接，定时注册Topic信息到所有NameServer。\n\n### 5 工作流程\n\n#### 具体流程\n\n* 1 ）启动NameServer，NameServer启动后开始监听端口，等待Broker、Producer、Consumer连接。\n\n* 2 ）启动Broker时，Broker会与所有的NameServer建立并保持长连接，然后每 30 秒向NameServer定时发送心跳包。\n\n* 3 ）发送消息前，可以先创建Topic，创建Topic时需要指定该Topic要存储在哪些Broker上，当然，在创建Topic时也会将Topic与Broker的关系写入到NameServer中。不过，这步是可选的，也可以在发送消息时自动创建Topic。\n\n* 4 ）Producer发送消息，启动时先跟NameServer集群中的其中一台建立长连接，并从NameServer中获取路由信息，即当前发送的Topic消息的Queue与Broker的地址（IP+Port）的映射关系。然后根据算法策略从队选择一个Queue，与队列所在的Broker建立长连接从而向Broker发消息。当然，在获取到路由信息后，Producer会首先将路由信息缓存到本地，再每 30 秒从NameServer更新一次路由信息。\n\n* 5 ）Consumer跟Producer类似，跟其中一台NameServer建立长连接，获取其所订阅Topic的路由信息，然后根据算法策略从路由信息中获取到其所要消费的Queue，然后直接跟Broker建立长连接，开始消费其中的消息。Consumer在获取到路由信息后，同样也会每 30 秒从NameServer更新一次路由信息。不过不同于Producer的是，Consumer还会向Broker发送心跳，以确保Broker的存活状态。\n\n#### Topic的创建模式\n\n手动创建Topic时，有两种模式：\n* 集群模式：该模式下创建的Topic在该集群中，所有Broker中的Queue数量是相同的。\n* Broker模式：该模式下创建的Topic在该集群中，每个Broker中的Queue数量可以不同。\n\n自动创建Topic时，默认采用的是Broker模式，会为每个Broker默认创建 4 个Queue。\n\n#### 读/写队列\n从物理上来讲，读/写队列是同一个队列。所以，不存在读/写队列数据同步问题。读/写队列是逻辑上进行区分的概念。一般情况下，读/写队列数量是相同的。\n\n\n例如，创建Topic时设置的写队列数量为 8 ，读队列数量为 4 ，此时系统会创建 8 个Queue，分别是0 1 2 3 4 5 6 7。Producer会将消息写入到这 8 个队列，但Consumer只会消费0 1 2 3这 4 个队列中的消息，4 5 6 7 中的消息是不会被消费到的。\n\n再如，创建Topic时设置的写队列数量为 4 ，读队列数量为 8 ，此时系统会创建 8 个Queue，分别是0 1 2 3 4 5 6 7。Producer会将消息写入到0 1 2 3 这 4 个队列，但Consumer只会消费0 1 2 3 4 5 6 7这 8 个队列中的消息，但是4 5 6 7中是没有消息的。此时假设Consumer Group中包含两个Consumer，Consumer1消费0 1 2 3，而Consumer2消费4 5 6 7。但实际情况是，Consumer2是没有消息可消费的。\n\n也就是说，当读/写队列数量设置不同时，总是有问题的。那么，为什么要这样设计呢？\n\n其这样设计的目的是为了，方便Topic的Queue的缩容。\n\n例如，原来创建的Topic中包含 16 个Queue，如何能够使其Queue缩容为 8 个，还不会丢失消息？可以动态修改写队列数量为 8 ，读队列数量不变。此时新的消息只能写入到前 8 个队列，而消费都消费的却是16 个队列中的数据。当发现后 8 个Queue中的消息消费完毕后，就可以再将读队列数量动态设置为 8 。整个缩容过程，没有丢失任何消息。\n\nperm用于设置对当前创建Topic的操作权限： 2 表示只写， 4 表示只读， 6 表示读写。\n\n## 三、单机安装与启动\n\n### 1 准备工作\n\n#### 软硬件需求\n\n#### 系统要求是 64 位的，JDK要求是1.8及其以上版本的。\n\n![输入图片说明](rocketmq/QQ截图20220208110713.png \"QQ截图20201229183512.png\")\n\n下载RocketMQ安装包\n\n![输入图片说明](rocketmq/QQ截图20220208110738.png \"QQ截图20201229183512.png\")\n\n将下载的安装包上传到Linux。\n\n![输入图片说明](rocketmq/QQ截图20220208110807.png \"QQ截图20201229183512.png\")\n\n解压。\n\n![输入图片说明](rocketmq/QQ截图20220208110821.png \"QQ截图20201229183512.png\")\n\n### 2 、修改初始内存\n\n修改runserver.sh\n\n使用vim命令打开bin/runserver.sh文件。现将这些值修改为如下：\n\n![输入图片说明](rocketmq/QQ截图20220208110900.png \"QQ截图20201229183512.png\")\n\n修改runbroker.sh\n\n使用vim命令打开bin/runbroker.sh文件。现将这些值修改为如下：\n\n![输入图片说明](rocketmq/QQ截图20220208110924.png \"QQ截图20201229183512.png\")\n### 3 、启动\n\n启动NameServer\n\n```shell\nnohup sh bin/mqnamesrv &\ntail -f ~/logs/rocketmqlogs/namesrv.log\n```\n\n![输入图片说明](rocketmq/QQ截图20220208111000.png \"QQ截图20201229183512.png\")\n\n\n`如果出现mq启动报错ERROR: Please set the JAVA_HOME variable in your environment, We need java(x64)! !!`\n```shell\nln -s /usr/local/jdk1.8.0_191/bin/javac /usr/bin/javac\nln -s  /usr/local/jdk1.8.0_191/bin/jar /usr/bin/jar\nln -s /usr/local/jdk1.8.0_191/bin/java /bin/java\n```\n\n启动broker\n\n```shell\nnohup sh bin/mqbroker -n localhost:9876 &\ntail -f ~/logs/rocketmqlogs/broker.log\n```\n\n![输入图片说明](rocketmq/QQ截图20220208111020.png \"QQ截图20201229183512.png\")\n\n### 4 、发送/接收消息测试\n\n#### 发送消息\n```shell\nexport NAMESRV_ADDR=localhost:9876\nsh bin/tools.sh org.apache.rocketmq.example.quickstart.Producer\n```\n#### 接收消息\n```shell\nsh bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer\n```\n### 5 、关闭Server\n\n无论是关闭name server还是broker，都是使用bin/mqshutdown命令。\n\n```shell\n[root@mqOS rocketmq]# sh bin/mqshutdown broker\nThe mqbroker(1740) is running...\nSend shutdown request to mqbroker(1740) OK\n\n[root@mqOS rocketmq]# sh bin/mqshutdown namesrv\nThe mqnamesrv(1692) is running...\nSend shutdown request to mqnamesrv(1692) OK\n[2]+ 退出 143 nohup sh bin/mqbroker -n localhost:9876\n\n```\n\n## 四、 控制台的安装与启动\n\nRocketMQ有一个可视化的dashboard，通过该控制台可以直观的查看到很多数据。\n\n### 1 下载\n\n下载地址：https://github.com/apache/rocketmq-externals/releases\n\n![输入图片说明](rocketmq/QQ截图20220208111255.png \"QQ截图20201229183512.png\")\n\n### 2 修改配置\n\n修改其src/main/resources中的application.properties配置文件。\n\n* 原来的端口号为 8080 ，修改为一个不常用的\n* 指定RocketMQ的name server地址\n\n![输入图片说明](rocketmq/QQ截图20220208111351.png \"QQ截图20201229183512.png\")\n\n### 3 添加依赖\n\n在解压目录rocketmq-console的pom.xml中添加如下JAXB依赖。\n\n>JAXB，Java Architechture for Xml Binding，用于XML绑定的Java技术，是一个业界标准，是一项可以根据XML Schema生成Java类的技术。\n\n```xml\n<dependency>\n    <groupId>javax.xml.bind</groupId>\n    <artifactId>jaxb-api</artifactId>\n    <version>2.3.0</version>\n</dependency>\n<dependency>\n    <groupId>com.sun.xml.bind</groupId>\n    <artifactId>jaxb-impl</artifactId>\n    <version>2.3.0</version>\n</dependency>\n<dependency>\n    <groupId>com.sun.xml.bind</groupId>\n    <artifactId>jaxb-core</artifactId>\n    <version>2.3.0</version>\n</dependency>\n<dependency>\n    <groupId>javax.activation</groupId>\n    <artifactId>activation</artifactId>\n    <version>1.1.1</version>\n</dependency>\n```\n### 4 打包\n\n在rocketmq-console目录下运行maven的打包命令。\n\n![输入图片说明](rocketmq/QQ截图20220208111536.png \"QQ截图20201229183512.png\")\n\n![输入图片说明](rocketmq/QQ截图20220208111646.png \"QQ截图20201229183512.png\")\n### 5 启动\n![输入图片说明](rocketmq/QQ截图20220208111700.png \"QQ截图20201229183512.png\")\n### 6 访问\n![输入图片说明](rocketmq/QQ截图20220208111724.png \"QQ截图20201229183512.png\")\n\n## 五、集群搭建理论\n\n![输入图片说明](rocketmq/QQ截图20220208111755.png \"QQ截图20201229183512.png\")\n\n### 1 数据复制与刷盘策略\n\n![输入图片说明](rocketmq/QQ截图20220208111822.png \"QQ截图20201229183512.png\")\n\n#### 复制策略\n\n复制策略是Broker的Master与Slave间的数据同步方式。分为同步复制与异步复制：\n\n* 同步复制：消息写入master后，master会等待slave同步数据成功后才向producer返回成功ACK\n* 异步复制：消息写入master后，master立即向producer返回成功ACK，无需等待slave同步数据成功\n\n>异步复制策略会降低系统的写入延迟，RT变小，提高了系统的吞吐量\n\n#### 刷盘策略\n\n刷盘策略指的是broker中消息的落盘方式，即消息发送到broker内存后消息持久化到磁盘的方式。分为同步刷盘与异步刷盘.\n\n* 同步刷盘：当消息持久化到broker的磁盘后才算是消息写入成功。\n* 异步刷盘：当消息写入到broker的内存后即表示消息写入成功，无需等待消息持久化到磁盘。\n\n>1 ）异步刷盘策略会降低系统的写入延迟，RT变小，提高了系统的吞吐量<br>\n2 ）消息写入到Broker的内存，一般是写入到了PageCache<br>\n3 ）对于异步 刷盘策略，消息会写入到PageCache后立即返回成功ACK。但并不会立即做落盘操作，而是当PageCache到达一定量时会自动进行落盘。<br>\n\n\n### 2 Broker集群模式\n\n根据Broker集群中各个节点间关系的不同，Broker集群可以分为以下几类：\n\n#### 单Master\n\n只有一个broker（其本质上就不能称为集群）。这种方式也只能是在测试时使用，生产环境下不能使用，因为存在单点问题。\n\n#### 多Master\n\nbroker集群仅由多个master构成，不存在Slave。同一Topic的各个Queue会平均分布在各个master节点上。\n\n* 优点：配置简单，单个Master宕机或重启维护对应用无影响，在磁盘配置为RAID10时，即使机器宕机不可恢复情况下，由于RAID10磁盘非常可靠，消息也不会丢（异步刷盘丢失少量消息，同步刷盘一条不丢），性能最高；\n* 缺点：单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅（不可消费），消息实时性会受到影响。\n\n>以上优点的前提是，这些Master都配置了RAID磁盘阵列。如果没有配置，一旦出现某Master宕机，则会发生大量消息丢失的情况。\n\n#### 多Master多Slave模式-异步复制\n\nbroker集群由多个master构成，每个master又配置了多个slave（在配置了RAID磁盘阵列的情况下，一个master一般配置一个slave即可）。master与slave的关系是主备关系，即master负责处理消息的读写请求，而slave仅负责消息的备份与master宕机后的角色切换。\n\n异步复制即前面所讲的`复制策略`中的`异步复制策略`，即消息写入master成功后，master立即向producer返回成功ACK，无需等待slave同步数据成功。\n\n该模式的最大特点之一是，当master宕机后slave能够`自动切换`为master。不过由于slave从master的同步具有短暂的延迟（毫秒级），所以当master宕机后，这种异步复制方式可能会存在少量消息的丢失问题。\n\n>Slave从Master同步的延迟越短，其可能丢失的消息就越少<br><br>\n对于Master的RAID磁盘阵列，若使用的也是异步复制策略，同样也存在延迟问题，同样也可能会丢失消息。但RAID阵列的秘诀是微秒级的（因为是由硬盘支持的），所以其丢失的数据量会更少。\n\n#### 多Master多Slave模式-同步双写\n\n该模式是`多Master多Slave模式`的`同步复制`实现。所谓`同步双写`，指的是消息写入master成功后，master会等待slave同步数据成功后才向producer返回成功ACK，即master与slave都要写入成功后才会返回成功ACK，也即`双写`。该模式与`异步复制模式相比`，优点是消息的安全性更高，不存在消息丢失的情况。但单个消息的RT略高，从而导致性能要略低（大约低10%）。\n\n该模式存在一个大的问题：对于目前的版本，Master宕机后，Slave`不会自动切换`到Master。\n\n#### 最佳实践\n\n一般会为Master配置RAID10磁盘阵列，然后再为其配置一个Slave。即利用了RAID10磁盘阵列的高效、安全性，又解决了可能会影响订阅的问题。\n\n>1 ）RAID磁盘阵列的效率要高于Master-Slave集群。因为RAID是硬件支持的。也正因为如此，所以RAID阵列的搭建成本较高。<br><br>\n2 ）多Master+RAID阵列，与多Master多Slave集群的区别是什么？<br>\n1.多Master+RAID阵列，其仅仅可以保证数据不丢失，即不影响消息写入，但其可能会影响到消息的订阅。但其执行效率要远高于`多Master多Slave集群`<br>\n2.多Master多Slave集群，其不仅可以保证数据不丢失，也不会影响消息写入。其运行效率要低于`多Master+RAID阵列`\n\n## 六、磁盘阵列RAID（补充）\n\n### 1 RAID历史\n\n1988 年美国加州大学伯克利分校的 D. A. Patterson 教授等首次在论文 “A Case of Redundant Array of Inexpensive Disks” 中提出了 RAID 概念 ，即`廉价冗余磁盘阵列`（ Redundant Array of Inexpensive Disks ）。由于当时大容量磁盘比较昂贵， RAID 的基本思想是将多个容量较小、相对廉价的磁盘进行有机组合，从而以较低的成本获得与昂贵大容量磁盘相当的容量、性能、可靠性。随着磁盘成本和价格的不断降低， “廉价” 已经毫无意义。因此， RAID 咨询委员会（ RAID Advisory Board, RAB ）决定用“ 独立 ” 替代 “ 廉价 ” ，于时 RAID 变成了`独立磁盘冗余阵列`（ Redundant Array of Independent Disks ）。但这仅仅是名称的变化，实质内容没有改变。\n\n内存：32m 6.4G（IBM 10.1G）\n\n### 2 RAID等级\n\nRAID 这种设计思想很快被业界接纳， RAID 技术作为高性能、高可靠的存储技术，得到了非常广泛的应用。 RAID 主要利用镜像、数据条带和数据校验三种技术来获取高性能、可靠性、容错能力和扩展性，根据对这三种技术的使用策略和组合架构，可以把 RAID 分为不同的等级，以满足不同数据应用的需求。\n\nD. A. Patterson 等的论文中定义了 RAID0 ~ RAID6 原始 RAID 等级。随后存储厂商又不断推出 RAID7、 RAID10、RAID01 、 RAID50 、 RAID53 、 RAID100 等 RAID 等级，但这些并无统一的标准。目前业界与学术界公认的标准是 RAID0 ~ RAID6 ，而在实际应用领域中使用最多的 RAID 等级是 RAID0 、RAID1 、 RAID3 、 RAID5 、 RAID6 和 RAID10。\n\nRAID 每一个等级代表一种实现方法和技术，等级之间并无高低之分。在实际应用中，应当根据用户的数据应用特点，综合考虑可用性、性能和成本来选择合适的 RAID 等级，以及具体的实现方式。\n\n### 3 关键技术\n\n#### 镜像技术\n\n镜像技术是一种冗余技术，为磁盘提供数据备份功能，防止磁盘发生故障而造成数据丢失。对于 RAID而言，采用镜像技术最典型地的用法就是，同时在磁盘阵列中产生两个完全相同的数据副本，并且分布在两个不同的磁盘上。镜像提供了完全的数据冗余能力，当一个数据副本失效不可用时，外部系统仍可正常访问另一副本，不会对应用系统运行和性能产生影响。而且，镜像不需要额外的计算和校验，故障修复非常快，直接复制即可。镜像技术可以从多个副本进行并发读取数据，提供更高的读 I/O 性能，但不能并行写数据，写多个副本通常会导致一定的 I/O 性能下降。\n\n镜像技术提供了非常高的数据安全性，其代价也是非常昂贵的，需要至少双倍的存储空间。高成本限制了镜像的广泛应用，主要应用于至关重要的数据保护，这种场合下的数据丢失可能会造成非常巨大的损失。\n\n#### 数据条带技术\n数据条带化技术是一种自动将 I/O操作负载均衡到多个物理磁盘上的技术。更具体地说就是，将一块连续的数据分成很多小部分并把它们分别存储到不同磁盘上。这就能使多个进程可以并发访问数据的多个不同部分，从而获得最大程度上的 I/O 并行能力，极大地提升性能。\n\n#### 数据校验技术\n数据校验技术是指， RAID 要在写入数据的同时进行校验计算，并将得到的校验数据存储在 RAID 成员磁盘中。校验数据可以集中保存在某个磁盘或分散存储在多个不同磁盘中。当其中一部分数据出错时，就可以对剩余数据和校验数据进行反校验计算重建丢失的数据。\n\n数据校验技术相对于镜像技术的优势在于节省大量开销，但由于每次数据读写都要进行大量的校验运算，对计算机的运算速度要求很高，且必须使用硬件 RAID 控制器。在数据重建恢复方面，检验技术比镜像技术复杂得多且慢得多。\n\n### 4 RAID分类\n\n从实现角度看， RAID 主要分为软 RAID、硬 RAID 以及混合 RAID 三种。\n\n#### 软 RAID\n\n所有功能均有操作系统和 CPU 来完成，没有独立的 RAID 控制处理芯片和 I/O 处理芯片，效率自然最低。\n\n#### 硬 RAID\n\n配备了专门的 RAID 控制处理芯片和 I/O 处理芯片以及阵列缓冲，不占用 CPU 资源。效率很高，但成本也很高。\n\n#### 混合 RAID\n\n具备 RAID 控制处理芯片，但没有专门的I/O 处理芯片，需要 CPU 和驱动程序来完成。性能和成本在软RAID 和硬 RAID 之间。\n\n### 5 常见RAID等级详解\n\n#### JBOD\n\n![输入图片说明](rocketmq/QQ截图20220208113559.png \"QQ截图20201229183512.png\")\n\nJBOD ，Just a Bunch of Disks，磁盘簇。表示一个没有控制软件提供协调控制的磁盘集合，这是 RAID区别与 JBOD 的主要因素。 JBOD 将多个物理磁盘串联起来，提供一个巨大的逻辑磁盘。\n\nJBOD 的数据存放机制是由第一块磁盘开始按顺序往后存储，当前磁盘存储空间用完后，再依次往后面的磁盘存储数据。 JBOD 存储性能完全等同于单块磁盘，而且也不提供数据安全保护。\n\n>其只是简单提供一种扩展存储空间的机制，JBOD可用存储容量等于所有成员磁盘的存储空间之和\n\nJBOD 常指磁盘柜，而不论其是否提供 RAID 功能。不过，JBOD并非官方术语，官方称为Spanning。\n\n#### RAID0\n\n![输入图片说明](rocketmq/QQ截图20220208113758.png \"QQ截图20201229183512.png\")\n\nRAID0 是一种简单的、无数据校验的`数据条带化技术`。实际上不是一种真正的 RAID ，因为它并不提供任何形式的冗余策略。 RAID0 将所在磁盘条带化后组成大容量的存储空间，将数据分散存储在所有磁盘中，以独立访问方式实现多块磁盘的并读访问。\n\n理论上讲，一个由 n 块磁盘组成的 RAID0 ，它的读写性能是单个磁盘性能的 n 倍，但由于总线带宽等多种因素的限制，实际的性能提升低于理论值。由于可以并发执行 I/O 操作，总线带宽得到充分利用。再加上不需要进行数据校验，`RAID0 的性能在所有 RAID 等级中是最高的`。\n\nRAID0 具有低成本、高读写性能、 100% 的高存储空间利用率等优点，但是它不提供数据冗余保护，一旦数据损坏，将无法恢复。\n\n应用场景：对数据的顺序读写要求不高，对数据的安全性和可靠性要求不高，但对系统性能要求很高的场景。\n\n>RAID0与JBOD相同点：<br>\n1 ）存储容量：都是成员磁盘容量总和<br>\n2 ）磁盘利用率，都是100%，即都没有做任何的数据冗余备份<br>\nRAID0与JBOD不同点：<br>\n1 ）JBOD：数据是顺序存放的，一个磁盘存满后才会开始存放到下一个磁盘<br>\n2 ）RAID：各个磁盘中的数据写入是并行的，是通过数据条带技术写入的。其读写性能是JBOD的n倍<br>\n\n#### RAID1\n\n![输入图片说明](rocketmq/QQ截图20220208121758.png \"QQ截图20201229183512.png\")\n\nRAID1 就是一种`镜像技术`，它将数据完全一致地分别写到工作磁盘和镜像磁盘，它的磁盘空间利用率为 50% 。 RAID1 在数据写入时，响应时间会有所影响，但是读数据的时候没有影响。 RAID1 提供了最佳的数据保护，一旦工作磁盘发生故障，系统将自动切换到镜像磁盘，不会影响使用。\n\nRAID1是为了增强数据安全性使两块磁盘数据呈现完全镜像，从而达到安全性好、技术简单、管理方便。 RAID1 拥有完全容错的能力，但实现成本高。\n\n应用场景：对顺序读写性能要求较高，或对数据安全性要求较高的场景。\n\n\n#### RAID10\n\n![输入图片说明](rocketmq/QQ截图20220208122057.png \"QQ截图20201229183512.png\")\n\nRAID10是一个RAID1与RAID0的组合体，所以它继承了RAID0的快速和RAID1的安全。简单来说就是，先做条带，再做镜像。发即将进来的数据先分散到不同的磁盘，再将磁盘中的数据做镜像。\n\n#### RAID01\n\n![输入图片说明](rocketmq/QQ截图20220208122113.png \"QQ截图20201229183512.png\")\n\nRAID01是一个RAID0与RAID1的组合体，所以它继承了RAID0的快速和RAID1的安全。简单来说就是，先做镜像再做条带。即将进来的数据先做镜像，再将镜像数据写入到与之前数据不同的磁盘，即再做条带。\n\n>RAID10要比RAID01的容错率再高，所以生产环境下一般是不使用RAID01的。\n#### 序号 主机名/IP IP 功能 BROKER角色\n\n```\n1 rocketmqOS1 192.168.59.164 NameServer + Broker Master1 + Slave2\n2 rocketmqOS2 192.168.59.165 NameServer + Broker Master2 + Slave1\n```\n\n## 七、集群搭建实践\n\n### 1 集群架构\n\n这里要搭建一个双主双从异步复制的Broker集群。为了方便，这里使用了两台主机来完成集群的搭建。这两台主机的功能与broker角色分配如下表。\n\n序号|主机名/IP|IP|功能|BROKER角色\n--|:--:|--:|--:|--:\n1|rocketmqOS1|192.168.59.164|NameServer + Broker|Master1 + Slave2\n2|rocketmqOS1|192.168.59.165|NameServer + Broker|Master2 + Slave1\n\n### 2 克隆生成rocketmqOS1\n\n克隆rocketmqOS主机，并修改配置。指定主机名为rocketmqOS1。\n\n### 3 修改rocketmqOS1配置文件\n\n#### 配置文件位置\n\n要修改的配置文件在rocketMQ解压目录的conf/2m-2s-async目录中。\n\n![输入图片说明](rocketmq/QQ截图20220208122608.png \"QQ截图20201229183512.png\")\n\n\n#### 修改broker-a.properties\n\n将该配置文件内容修改为如下：\n\n```shell\n# 指定整个broker集群的名称，或者说是RocketMQ集群的名称\nbrokerClusterName=  \n# 指定master-slave集群的名称。一个RocketMQ集群可以包含多个master-slave集群\nbrokerName=broker-a\n# master的brokerId为 0\nbrokerId= 0\n# 指定删除消息存储过期文件的时间为凌晨 4 点\ndeleteWhen= 04\n# 指定未发生更新的消息存储文件的保留时长为 48 小时， 48 小时后过期，将会被删除\nfileReservedTime= 48\n# 指定当前broker为异步复制master\nbrokerRole=ASYNC_MASTER\n# 指定刷盘策略为异步刷盘\nflushDiskType=ASYNC_FLUSH\n# 指定Name Server的地址\nnamesrvAddr=192.168.59.164:9876;192.168.59.165:9876\n```\n\n#### 修改broker-b-s.properties\n\n将该配置文件内容修改为如下：\n\n#### 其它配置\n```shell\nbrokerClusterName=DefaultCluster\n# 指定这是另外一个master-slave集群\nbrokerName=broker-b\n# slave的brokerId为非 0\nbrokerId=1\ndeleteWhen=04\nfileReservedTime=48\n# 指定当前broker为slave\nbrokerRole=SLAVE\nflushDiskType=ASYNC_FLUSH\nnamesrvAddr=192.168.59.164:9876;192.168.59.165:9876\n# 指定Broker对外提供服务的端口，即Broker与producer与consumer通信的端口。默认10911 。由于当前主机同时充当着master1与slave2，而前面的master1使用的是默认端口。这里需要将这两个端口加以区分，以区分出master1与slave2\nlistenPort= 11911\n# 指定消息存储相关的路径。默认路径为~/store目录。由于当前主机同时充当着master1与slave2，master1使用的是默认路径，这里就需要再指定一个不同路径\nstorePathRootDir=~/store-s\nstorePathCommitLog=~/store-s/commitlog\nstorePathConsumeQueue=~/store-s/consumequeue\nstorePathIndex=~/store-s/index\nstoreCheckpoint=~/store-s/checkpoint\nabortFile=~/store-s/abort\n```\n\n#### 除了以上配置外，这些配置文件中还可以设置其它属性。\n```shell\n#指定整个broker集群的名称，或者说是RocketMQ集群的名称\nbrokerClusterName=rocket-MS\n#指定master-slave集群的名称。一个RocketMQ集群可以包含多个master-slave集群\nbrokerName=broker-a\n#0 表示 Master，>0 表示 Slave\nbrokerId=0\n#nameServer地址，分号分割\nnamesrvAddr=nameserver1:9876;nameserver2:9876\n#默认为新建Topic所创建的队列数\ndefaultTopicQueueNums=4\n#是否允许 Broker 自动创建Topic，建议生产环境中关闭\nautoCreateTopicEnable=true\n#是否允许 Broker 自动创建订阅组，建议生产环境中关闭\nautoCreateSubscriptionGroup=true\n#Broker对外提供服务的端口，即Broker与producer与consumer通信的端口\nlistenPort=10911\n#HA高可用监听端口，即Master与Slave间通信的端口，默认值为listenPort+1\nhaListenPort=10912\n#指定删除消息存储过期文件的时间为凌晨 4 点\ndeleteWhen=04\n#指定未发生更新的消息存储文件的保留时长为 48 小时， 48 小时后过期，将会被删除\nfileReservedTime=48\n#指定commitLog目录中每个文件的大小，默认1G\nmapedFileSizeCommitLog=1073741824\n#指定ConsumeQueue的每个Topic的每个Queue文件中可以存放的消息数量，默认30w条\nmapedFileSizeConsumeQueue=300000\n#在清除过期文件时，如果该文件被其他线程所占用（引用数大于 0 ，比如读取消息），此时会阻止此次删除任务，同时在第一次试图删除该文件时记录当前时间戳。该属性则表示从第一次拒绝删除后开始计时，该文件最多可以保留的时长。在此时间内若引用数仍不为 0 ，则删除仍会被拒绝。不过时间到后，文件将被强制删除\ndestroyMapedFileIntervalForcibly=120000\n#指定commitlog、consumequeue所在磁盘分区的最大使用率，超过该值，则需立即清除过期文件\ndiskMaxUsedSpaceRatio=88\n#指定store目录的路径，默认在当前用户主目录中\nstorePathRootDir=/usr/local/rocketmq-all-4.5.0/store\n#commitLog目录路径\nstorePathCommitLog=/usr/local/rocketmq-all-4.5.0/store/commitlog\n#consumeueue目录路径\nstorePathConsumeQueue=/usr/local/rocketmq-all-4.5.0/store/consumequeue\n#index目录路径\nstorePathIndex=/usr/local/rocketmq-all-4.5.0/store/index\n#checkpoint文件路径\nstoreCheckpoint=/usr/local/rocketmq-all-4.5.0/store/checkpoint\n#abort文件路径\nabortFile=/usr/local/rocketmq-all-4.5.0/store/abort\n#指定消息的最大大小\nmaxMessageSize= 65536\n#Broker的角色\n# - ASYNC_MASTER 异步复制Master\n# - SYNC_MASTER 同步双写Master\n# - SLAVE\nbrokerRole=SYNC_MASTER\n#刷盘策略\n# - ASYNC_FLUSH 异步刷盘\n# - SYNC_FLUSH 同步刷盘\nflushDiskType=SYNC_FLUSH\n#发消息线程池数量\nsendMessageThreadPoolNums=128\n#拉消息线程池数量\npullMessageThreadPoolNums=128\n#强制指定本机IP，需要根据每台机器进行修改。官方介绍可为空，系统默认自动识别，但多网卡时IP地址可能读取错误\nbrokerIP1=192.168.3.105\n```\n\n### 4 克隆生成rocketmqOS2\n\n克隆rocketmqOS1主机，并修改配置。指定主机名为rocketmqOS2。\n\n### 5 修改rocketmqOS2配置文件\n\n对于rocketmqOS2主机，同样需要修改rocketMQ解压目录的conf目录的子目录2m-2s-async中的两个配置文件。\n\n#### 修改broker-b.properties\n\n将该配置文件内容修改为如下：\n\n```shell\nbrokerClusterName=DefaultCluster\nbrokerName=broker-b\nbrokerId=0\ndeleteWhen=04\nfileReservedTime=48\nbrokerRole=ASYNC_MASTER\nflushDiskType=ASYNC_FLUSH\nnamesrvAddr=192.168.59.164:9876;192.168.59.165:9876\n```\n\n修改broker-a-s.properties\n\n#### 将该配置文件内容修改为如下：\n\n```shell\nbrokerClusterName=DefaultCluster\nbrokerName=broker-a\nbrokerId=1\ndeleteWhen=04\nfileReservedTime=48\nbrokerRole=SLAVE\nflushDiskType=ASYNC_FLUSH\nnamesrvAddr=192.168.59.164:9876;192.168.59.165:9876\nlistenPort=11911\nstorePathRootDir=~/store-s\nstorePathCommitLog=~/store-s/commitlog\nstorePathConsumeQueue=~/store-s/consumequeue\nstorePathIndex=~/store-s/index\nstoreCheckpoint=~/store-s/checkpoint\nabortFile=~/store-s/abort\n```\n\n### 6 启动服务器\n\n#### 启动NameServer集群\n\n分别启动rocketmqOS1与rocketmqOS2两个主机中的NameServer。启动命令完全相同。\n\n```shell\nnohup sh bin/mqnamesrv &\ntail -f ~/logs/rocketmqlogs/namesrv.log\n```\n#### 启动两个Master\n\n分别启动rocketmqOS1与rocketmqOS2两个主机中的broker master。注意，它们指定所要加载的配置文件是不同的。\n```shell\nnohup sh bin/mqbroker -c conf/2m-2s-async/broker-a.properties &\ntail -f ~/logs/rocketmqlogs/broker.log\n```\n\n```shell\nnohup sh bin/mqbroker -c conf/2m-2s-async/broker-b.properties &\ntail -f ~/logs/rocketmqlogs/broker.log\n```\n#### 启动两个Slave\n\n分别启动rocketmqOS1与rocketmqOS2两个主机中的broker slave。注意，它们指定所要加载的配置文件是不同的。\n\n```shell\nnohup sh bin/mqbroker -c conf/2m-2s-async/broker-b-s.properties &\ntail -f ~/logs/rocketmqlogs/broker.log\n```\n\n```shell\nnohup sh bin/mqbroker -c conf/2m-2s-async/broker-a-s.properties &\ntail -f ~/logs/rocketmqlogs/broker.log\n```\n## 八、mqadmin命令\n\n在mq解压目录的bin目录下有一个mqadmin命令，该命令是一个运维指令，用于对mq的主题，集群，broker 等信息进行管理。\n\n### 1 修改bin/tools.sh\n\n在运行mqadmin命令之前，先要修改mq解压目录下bin/tools.sh配置的JDK的ext目录位置。本机的ext目录在`/usr/java/jdk1.8.0_161/jre/lib/ext`。\n\n使用vim命令打开tools.sh文件，并在JAVA_OPT配置的-Djava.ext.dirs这一行的后面添加ext的路径。\n\n![输入图片说明](rocketmq/QQ截图20220208123848.png \"QQ截图20201229183512.png\")\n\n```shell\nJAVA_OPT=\"${JAVA_OPT} -server -Xms1g -Xmx1g -Xmn256m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=128m\"\nJAVA_OPT=\"${JAVA_OPT} -Djava.ext.dirs=${BASE_DIR}/lib:${JAVA_HOME}/jre/lib/ext:${JAVA_HOME}/lib/ext:/usr/java/jdk1.8.0_161/jre/lib/ext\"\nJAVA_OPT=\"${JAVA_OPT} -cp ${CLASSPATH}\"\n```\n### 2 运行mqadmin\n\n直接运行该命令，可以看到其可以添加的commands。通过这些commands可以完成很多的功能。\n\n```shell\n[root@mqOS rocketmq-all-4.8.0-bin-release]# ./bin/mqadmin\nThe most commonly used mqadmin commands are:\nupdateTopic Update or create topic\ndeleteTopic Delete topic from broker and NameServer.\nupdateSubGroup Update or create subscription group\ndeleteSubGroup Delete subscription group from broker.\nupdateBrokerConfig Update broker's config\nupdateTopicPerm Update topic perm\ntopicRoute Examine topic route info\ntopicStatus Examine topic Status info\ntopicClusterList get cluster info for topic\nbrokerStatus Fetch broker runtime status data\nqueryMsgById Query Message by Id\nqueryMsgByKey Query Message by Key\nqueryMsgByUniqueKey Query Message by Unique key\nqueryMsgByOffset Query Message by offset\nQueryMsgTraceById query a message trace\nprintMsg Print Message Detail\nprintMsgByQueue Print Message Detail\nsendMsgStatus send msg to broker.\nbrokerConsumeStats Fetch broker consume stats data\nproducerConnection Query producer's socket connection and clientversion\nconsumerConnection Query consumer's socket connection, client version and subscription\nconsumerProgress Query consumers's progress, speed\nconsumerStatus Query consumer's internal data structure\ncloneGroupOffset clone offset from other group.\nclusterList List all of clusters\ntopicList Fetch all topic list from name server\nupdateKvConfig Create or update KV config.\ndeleteKvConfig Delete KV config.\nwipeWritePerm Wipe write perm of broker in all name server\nresetOffsetByTime Reset consumer offset by timestamp(without client restart).\nupdateOrderConf Create or update or delete order conf\ncleanExpiredCQ Clean expired ConsumeQueue on broker.\ncleanUnusedTopic Clean unused topic on broker.\nstartMonitoring Start Monitoring\nstatsAll Topic and Consumer tps stats\nallocateMQ Allocate MQ\ncheckMsgSendRT check message send response time\nclusterRT List All clusters Message Send RT\ngetNamesrvConfig Get configs of name server.\nupdateNamesrvConfig Update configs of name server.\ngetBrokerConfig Get broker config by cluster or special broker!\nqueryCq Query cq command.\nsendMessage Send a message\nconsumeMessage Consume message\nupdateAclConfig Update acl config yaml file in broker\ndeleteAccessConfig Delete Acl Config Account in broker\nclusterAclConfigVersion List all of acl config version information in cluster\nupdateGlobalWhiteAddr Update global white address for acl Config File in broker\ngetAccessConfigSubCommand List all of acl config information in cluster\n```\n\n### 3 该命令的官网详解\n\n#### 该命令在官网中有详细的用法解释。\n\nhttps://github.com/apache/rocketmq/blob/master/docs/cn/operation.md\n\n![输入图片说明](rocketmq/QQ截图20220208124241.png \"QQ截图20201229183512.png\")\n\n![输入图片说明](rocketmq/QQ截图20220208124258.png \"QQ截图20201229183512.png\")\n\n# 第 3 章 RocketMQ工作原理\n\n## 一、消息的生产\n\n### 1 消息的生产过程\n\nProducer可以将消息写入到某Broker中的某Queue中，其经历了如下过程：\n\n* Producer发送消息之前，会先向NameServer发出获取消息Topic的路由信息的请求\n* NameServer返回该Topic的路由表及Broker列表\n* Producer根据代码中指定的Queue选择策略，从Queue列表中选出一个队列，用于后续存储消息\n* Produer对消息做一些特殊处理，例如，消息本身超过4M，则会对其进行压缩\n* Producer向选择出的Queue所在的Broker发出RPC请求，将消息发送到选择出的Queue\n\n>路由表：实际是一个Map，key为Topic名称，value是一个QueueData实例列表。QueueData并不是一个Queue对应一个QueueData，而是一个Broker中该Topic的所有Queue对应一个QueueData。即，只要涉及到该Topic的Broker，一个Broker对应一个QueueData。QueueData中包含brokerName。简单来说，路由表的key为Topic名称，value则为所有涉及该Topic的BrokerName列表。\n\n\n>Broker列表：其实际也是一个Map。key为brokerName，value为BrokerData。一个Broker对应一个BrokerData实例，对吗？不对。一套brokerName名称相同的Master-Slave小集群对应一个BrokerData。BrokerData中包含brokerName及一个map。该map的key为brokerId，value为该broker对应的地址。brokerId为 0 表示该broker为Master，非 0 表示Slave。\n\n### 2 Queue选择算法\n\n对于无序消息，其Queue选择算法，也称为消息投递算法，常见的有两种：\n\n#### 轮询算法\n\n默认选择算法。该算法保证了每个Queue中可以均匀的获取到消息。\n\n>该算法存在一个问题：由于某些原因，在某些Broker上的Queue可能投递延迟较严重。从而导致Producer的缓存队列中出现较大的消息积压，影响消息的投递性能。\n\n#### 最小投递延迟算法\n\n该算法会统计每次消息投递的时间延迟，然后根据统计出的结果将消息投递到时间延迟最小的Queue。如果延迟相同，则采用轮询算法投递。该算法可以有效提升消息的投递性能。\n\n>该算法也存在一个问题：消息在Queue上的分配不均匀。投递延迟小的Queue其可能会存在大量的消息。而对该Queue的消费者压力会增大，降低消息的消费能力，可能会导致MQ中消息的堆积。\n\n## 二、消息的存储\n\nRocketMQ中的消息存储在本地文件系统中，这些相关文件默认在当前用户主目录下的store目录中。\n\n![输入图片说明](rocketmq/QQ截图20220208133814.png \"QQ截图20201229183512.png\")\n\n* abort：该文件在Broker启动后会自动创建，正常关闭Broker，该文件会自动消失。若在没有启动Broker的情况下，发现这个文件是存在的，则说明之前Broker的关闭是非正常关闭。\n* checkpoint：其中存储着commitlog、consumequeue、index文件的最后刷盘时间戳\n* commitlog：其中存放着commitlog文件，而消息是写在commitlog文件中的\n* conæg：存放着Broker运行期间的一些配置数据\n* consumequeue：其中存放着consumequeue文件，队列就存放在这个目录中\n* index：其中存放着消息索引文件indexFile\n* lock：运行期间使用到的全局资源锁\n\n### 1 commitlog文件\n\n>说明：在很多资料中commitlog目录中的文件简单就称为commitlog文件。但在源码中，该文件被命名为mappedFile。\n\n#### 目录与文件\n\ncommitlog目录中存放着很多的mappedFile文件，当前Broker中的所有消息都是落盘到这些mappedFile文件中的。mappedFile文件大小为1G（小于等于1G），文件名由 20 位十进制数构成，表示当前文件的第一条消息的起始位移偏移量。\n\n>第一个文件名一定是 20 位 0 构成的。因为第一个文件的第一条消息的偏移量commitlog offset为 0 <br><br>\n当第一个文件放满时，则会自动生成第二个文件继续存放消息。假设第一个文件大小是 1073741820 字节（1G = 1073741824字节），则第二个文件名就是 00000000001073741824 。<br><br>\n以此类推，第n个文件名应该是前n-1个文件大小之和。<br><br>\n一个Broker中所有mappedFile文件的commitlog offset是连续的\n\n\n需要注意的是，一个Broker中仅包含一个commitlog目录，所有的mappedFile文件都是存放在该目录中的。即无论当前Broker中存放着多少Topic的消息，这些消息都是被顺序写入到了mappedFile文件中的。也就是说，这些消息在Broker中存放时并没有被按照Topic进行分类存放。\n\n>mappedFile文件是顺序读写的文件，所有其访问效率很高<br><br>\n无论是SSD磁盘还是SATA磁盘，通常情况下，顺序存取效率都会高于随机存取。\n\n#### 消息单元\n\n![输入图片说明](rocketmq/QQ截图20220208134157.png \"QQ截图20201229183512.png\")\n\nmappedFile文件内容由一个个的`消息单元`构成。每个消息单元中包含消息总长度MsgLen、消息的物理位置physicalOffset、消息体内容Body、消息体长度BodyLength、消息主题Topic、Topic长度 TopicLength、消息生产者BornHost、消息发送时间戳BornTimestamp、消息所在的队列QueueId、消息在Queue中存储的偏移量QueueOffset等近 20 余项消息相关属性。\n\n>需要注意到，消息单元中是包含Queue相关属 性的。所以，我们在后续的学习中，就需要十分留意commitlog与queue间的关系是什么？<br><br>\n一个mappedFile文件中第m+1个消息单元的commitlog offset偏移量<br><br>\nL(m+1) = L(m) + MsgLen(m) (m >= 0)\n\n### 2 consumequeue\n\n![输入图片说明](rocketmq/QQ截图20220208134355.png \"QQ截图20201229183512.png\")\n#### 目录与文件\n\n![输入图片说明](rocketmq/QQ截图20220208134415.png \"QQ截图20201229183512.png\")\n\n为了提高效率，会为每个Topic在~/store/consumequeue中创建一个目录，目录名为Topic名称。在该Topic目录下，会再为每个该Topic的Queue建立一个目录，目录名为queueId。每个目录中存放着若干consumequeue文件，consumequeue文件是commitlog的索引文件，可以根据consumequeue定位到具体的消息。\n\nconsumequeue文件名也由 20 位数字构成，表示当前文件的第一个索引条目的起始位移偏移量。与mappedFile文件名不同的是，其后续文件名是固定的。因为consumequeue文件大小是固定不变的。\n\n#### 索引条目\n\n![输入图片说明](rocketmq/QQ截图20220208134454.png \"QQ截图20201229183512.png\")\n\n每个consumequeue文件可以包含30w个索引条目，每个索引条目包含了三个消息重要属性：消息在mappedFile文件中的偏移量CommitLog Offset、消息长度、消息Tag的hashcode值。这三个属性占 20个字节，所以每个文件的大小是固定的30w * 20字节。\n\n>一个consumequeue文件中所有消息的Topic一定是相同的。但每条消息的Tag可能是不同的。\n### 3 对文件的读写\n\n![输入图片说明](rocketmq/QQ截图20220208134538.png \"QQ截图20201229183512.png\")\n\n#### 消息写入\n\n一条消息进入到Broker后经历了以下几个过程才最终被持久化。\n\n* Broker根据queueId，获取到该消息对应索引条目要在consumequeue目录中的写入偏移量，即QueueOffset\n* 将queueId、queueOffset等数据，与消息一起封装为消息单元\n* 将消息单元写入到commitlog\n* 同时，形成消息索引条目\n* 将消息索引条目分发到相应的consumequeue\n\n#### 消息拉取\n\n* 当Consumer来拉取消息时会经历以下几个步骤：\n    * Consumer获取到其要消费消息所在Queue的消费偏移量offset，计算出其要消费消息的消息offset\n>消费offset即消费进度，consumer对某个Queue的消费offset，即消费到了该Queue的第几条消息<br>\n消息offset = 消费offset + 1\n\n* Consumer向Broker发送拉取请求，其中会包含其要拉取消息的Queue、消息offset及消息Tag。\n* Broker计算在该consumequeue中的queueOffset。\n>queueOffset = 消息offset * 20字节\n\n* 从该queueOffset处开始向后查找第一个指定Tag的索引条目。\n* 解析该索引条目的前 8 个字节，即可定位到该消息在commitlog中的commitlog offset\n* 从对应commitlog offset中读取消息单元，并发送给Consumer\n\n#### 性能提升\n\nRocketMQ中，无论是消息本身还是消息索引，都是存储在磁盘上的。其不会影响消息的消费吗？当然不会。其实RocketMQ的性能在目前的MQ产品中性能是非常高的。因为系统通过一系列相关机制大大提升了性能。\n\n首先，RocketMQ对文件的读写操作是通过`mmap零拷贝`进行的，将对文件的操作转化为直接对内存地址进行操作，从而极大地提高了文件的读写效率。\n\n其次，consumequeue中的数据是顺序存放的，还引入了`PageCache的预读取机制`，使得对consumequeue文件的读取几乎接近于内存读取，即使在有消息堆积情况下也不会影响性能。\n\n>PageCache机制，页缓存机制，是OS对文件的缓存机制，用于加速对文件的读写操作。一般来说，程序对文件进行顺序读写的速度几乎接近于内存读写速度，主要原因是由于OS使用PageCache机制对读写访问操作进行性能优化，将一部分的内存用作PageCache。<br><br>\n1)写操作：OS会先将数据写入到PageCache中，随后会以异步方式由pdæush（page dirty æush)内核线程将Cache中的数据刷盘到物理磁盘<br>\n2)读操作：若用户要读取数据，其首先会从PageCache中读取，若没有命中，则OS在从物理磁盘上加载该数据到PageCache的同时，也会顺序 对其相邻数据块中的数据进行预读取。\n\nRocketMQ中可能会影响性能的是对commitlog文件的读取。因为对commitlog文件来说，读取消息时会产生大量的随机访问，而随机访问会严重影响性能。不过，如果选择合适的系统IO调度算法，比如设置调度算法为Deadline（采用SSD固态硬盘的话），随机读的性能也会有所提升。\n\n### 4 与Kafka的对比\n\nRocketMQ的很多思想来源于Kafka，其中commitlog与consumequeue就是。\n\nRocketMQ中的commitlog目录与consumequeue的结合就类似于Kafka中的partition分区目录。mappedFile文件就类似于Kafka中的segment段。\n\n>Kafka中的Topic的消息被分割为一个或多个partition。partition是一个物理概念，对应到系统上就是topic目录下的一个或多个目录。每个partition中包含的文件称为segment，是具体存放消息的文件。<br><br>\nKafka中消息存放的目录结构是：topic目录下有partition目录，partition目录下有segment文件<br><br>\nKafka中没有二级分类标签Tag这个概念<br><br>\nKafka中无需索引文件。因为生产者是将消息直接写在了partition中的，消费者也是直接从partition中读取数据的\n\n## 三、indexFile\n\n除了通过通常的指定Topic进行消息消费外，RocketMQ还提供了根据key进行消息查询的功能。该查询是通过store目录中的index子目录中的indexFile进行索引实现的快速查询。当然，这个indexFile中的索引数据是在`包含了key的消息`被发送到Broker时写入的。如果消息中没有包含key，则不会写入。\n\n### 1 索引条目结构\n\n每个Broker中会包含一组indexFile，每个indexFile都是以一个`时间戳`命名的（这个indexFile被创建时的时间戳）。每个indexFile文件由三部分构成：indexHeader，slots槽位，indexes索引数据。每个\nindexFile文件中包含500w个slot槽。而每个slot槽又可能会挂载很多的index索引单元。\n\n![输入图片说明](rocketmq/QQ截图20220208135939.png \"QQ截图20201229183512.png\")\n\nindexHeader固定 40 个字节，其中存放着如下数据：\n\n![输入图片说明](rocketmq/QQ截图20220208135949.png \"QQ截图20201229183512.png\")\n\n* beginTimestamp：该indexFile中第一条消息的存储时间\n* endTimestamp：该indexFile中最后一条消息存储时间\n* beginPhyoffset：该indexFile中第一条消息在commitlog中的偏移量commitlog offset\n* endPhyoffset：该indexFile中最后一条消息在commitlog中的偏移量commitlog offset\n* hashSlotCount：已经填充有index的slot数量（并不是每个slot槽下都挂载有index索引单元，这里统计的是所有挂载了index索引单元的slot槽的数量）\n* indexCount：该indexFile中包含的索引单元个数（统计出当前indexFile中所有slot槽下挂载的所有index索引单元的数量之和）\n\nindexFile中最复杂的是Slots与Indexes间的关系。在实际存储时，Indexes是在Slots后面的，但为了便于理解，将它们的关系展示为如下形式：\n\n![输入图片说明](rocketmq/QQ截图20220208140054.png \"QQ截图20201229183512.png\")\n\n`key的hash值 % 500w`的结果即为slot槽位，然后将该slot值修改为该index索引单元的indexNo，根据这个indexNo可以计算出该index单元在indexFile中的位置。不过，该取模结果的重复率是很高的，为了解决该问题，在每个index索引单元中增加了preIndexNo，用于指定该slot中当前index索引单元的前一个index索引单元。而slot中始终存放的是其下最新的index索引单元的indexNo，这样的话，只要找到了slot就可以找到其最新的index索引单元，而通过这个index索引单元就可以找到其之前的所有index索引单元。\n\n>indexNo是一个在indexFile中的流水号，从 0 开始依次递增。即在一个indexFile中所有indexNo是以此递增的。indexNo在index索引单元中是没有体现的，其是通过indexes中依次数出来的。\n\nindex索引单元默写 20 个字节，其中存放着以下四个属性：\n\n![输入图片说明](rocketmq/QQ截图20220208140159.png \"QQ截图20201229183512.png\")\n\n* keyHash：消息中指定的业务key的hash值\n* phyOffset：当前key对应的消息在commitlog中的偏移量commitlog offset\n* timeDiff：当前key对应消息的存储时间与当前indexFile创建时间的时间差\n* preIndexNo：当前slot下当前index索引单元的前一个index索引单元的indexNo\n\n### 2 indexFile的创建\n\nindexFile的文件名为当前文件被创建时的时间戳。这个时间戳有什么用处呢？\n\n根据业务key进行查询时，查询条件除了key之外，还需要指定一个要查询的时间戳，表示要查询不大于该时间戳的最新的消息，即查询指定时间戳之前存储的最新消息。这个时间戳文件名可以简化查询，提高查询效率。具体后面会详细讲解。\n\nindexFile文件是何时创建的？其创建的条件（时机）有两个：\n\n* 当第一条带key的消息发送来后，系统发现没有indexFile，此时会创建第一个indexFile文件\n* 当一个indexFile中挂载的index索引单元数量超出2000w个时，会创建新的indexFile。当带key的消息发送到来后，系统会找到最新的indexFile，并从其indexHeader的最后 4 字节中读取到indexCount。若indexCount >= 2000w时，会创建新的indexFile。\n\n>由于可以推算出，一个indexFile的最大大小是：(40 + 500w * 4 + 2000w * 20)字节\n\n### 3 查询流程\n\n当消费者通过业务key来查询相应的消息时，其需要经过一个相对较复杂的查询流程。不过，在分析查询流程之前，首先要清楚几个定位计算式子：\n```shell\n计算指定消息key的slot槽位序号：\nslot槽位序号 = key的hash % 500w (式子1)\n```\n```shell\n计算槽位序号为n的slot在indexFile中的起始位置：\nslot(n)位置 = 40 + (n - 1) * 4 (式子2)\n```\n```shell\n计算indexNo为m的index在indexFile中的位置：\nindex(m)位置 = 40 + 500w * 4 + (m - 1) * 20 (式子3)\n```\n\n>40 为indexFile中indexHeader的字节数<br>\n500w * 4 是所有slots所占的字节数\n\n#### 具体查询流程如下：\n\n![输入图片说明](rocketmq/QQ截图20220208140740.png \"QQ截图20201229183512.png\")\n## 四、消息的消费\n\n消费者从Broker中获取消息的方式有两种：pull拉取方式和push推动方式。消费者组对于消息消费的模式又分为两种：集群消费Clustering和广播消费Broadcasting。\n\n### 1 获取消费类型\n\n#### 拉取式消费\n\nConsumer主动从Broker中拉取消息，主动权由Consumer控制。一旦获取了批量消息，就会启动消费过程。不过，该方式的实时性较弱，即Broker中有了新的消息时消费者并不能及时发现并消费。\n\n>由于拉取时间间隔是由用户指定的，所以在设置该间隔时需要注意平稳：间隔太短，空请求比例会增加；间隔太长，消息的实时性太差\n\n#### 推送式消费\n\n该模式下Broker收到数据后会主动推送给Consumer。该获取方式一般实时性较高。\n\n该获取方式是典型的`发布-订阅`模式，即Consumer向其关联的Queue注册了监听器，一旦发现有新的消息到来就会触发回调的执行，回调方法是Consumer去Queue中拉取消息。而这些都是基于Consumer与Broker间的长连接的。长连接的维护是需要消耗系统资源的。\n\n#### 对比\n\n* pull：需要应用去实现对关联Queue的遍历，实时性差；但便于应用控制消息的拉取\n* push：封装了对关联Queue的遍历，实时性强，但会占用较多的系统资源\n\n### 2 消费模式\n\n#### 广播消费\n\n![输入图片说明](rocketmq/QQ截图20220208141005.png \"QQ截图20201229183512.png\")\n\n广播消费模式下，相同Consumer Group的每个Consumer实例都接收同一个Topic的全量消息。即每条消息都会被发送到Consumer Group中的每个Consumer。\n\n#### 集群消费\n![输入图片说明](rocketmq/QQ截图20220208141053.png \"QQ截图20201229183512.png\")\n\n集群消费模式下，相同Consumer Group的每个Consumer实例`平均分摊`同一个Topic的消息。即每条消息只会被发送到Consumer Group中的`某个`Consumer。\n\n\n#### 消息进度保存\n\n* 广播模式：消费进度保存在consumer端。因为广播模式下consumer group中每个consumer都会消费所有消息，但它们的消费进度是不同。所以consumer各自保存各自的消费进度。\n* 集群模式：消费进度保存在broker中。consumer group中的所有consumer共同消费同一个Topic中的消息，同一条消息只会被消费一次。消费进度会参与到了消费的负载均衡中，故消费进度是需要共享的。下图是broker中存放的各个Topic的各个Queue的消费进度。\n\n![输入图片说明](rocketmq/QQ截图20220208141202.png \"QQ截图20201229183512.png\")\n\n### 3 Rebalance机制\n\nRebalance机制讨论的前提是：集群消费。\n\n#### 什么是Rebalance\n\nRebalance即再均衡，指的是，将一个Topic下的多个Queue在同一个Consumer Group中的多个Consumer间进行重新分配的过程。\n\n![输入图片说明](rocketmq/QQ截图20220208141304.png \"QQ截图20201229183512.png\")\n\nRebalance机制的本意是为了提升消息的并行消费能力。例如，一个Topic下 5 个队列，在只有 1 个消费者的情况下，这个消费者将负责消费这 5 个队列的消息。如果此时我们增加一个消费者，那么就可以给其中一个消费者分配 2 个队列，给另一个分配 3 个队列，从而提升消息的并行消费能力。\n\n#### Rebalance限制\n\n由于一个队列最多分配给一个消费者，因此当某个消费者组下的消费者实例数量大于队列的数量时，多余的消费者实例将分配不到任何队列。\n\n#### Rebalance危害\n\nRebalance的在提升消费能力的同时，也带来一些问题：\n\n`消费暂停：`在只有一个Consumer时，其负责消费所有队列；在新增了一个Consumer后会触发Rebalance的发生。此时原Consumer就需要暂停部分队列的消费，等到这些队列分配给新的Consumer后，这些暂停消费的队列才能继续被消费。\n\n`消费重复：`Consumer 在消费新分配给自己的队列时，必须接着之前Consumer 提交的消费进度的offset继续消费。然而默认情况下，offset是异步提交的，这个异步性导致提交到Broker的offset与Consumer实际消费的消息并不一致。这个不一致的差值就是可能会重复消费的消息。\n\n\n>同步提交：consumer提交了其消费完毕的一批消息的offset给broker后，需要等待broker的成功ACK。当收到ACK后，consumer才会继续获取并消费下一批消息。在等待ACK期间，consumer是阻塞的。<br><br>\n异步提交：consumer提交了其消费完毕的一批消息的offset给broker后，不需要等待broker的成功ACK。consumer可以直接获取并消费下一批消息。<br><br>\n对于一次性读取消息的数量，需要根据具体业务场景选择一个相对均衡的是很有必要的。因为数量过大，系统性能提升了，但产生重复消费的消息数量可能会增加；数量过小，系统性能会下降，但被重复消费的消息数量可能会减少。\n\n`消费突刺：`由于Rebalance可能导致重复消费，如果需要重复消费的消息过多，或者因为Rebalance暂停时间过长从而导致积压了部分消息。那么有可能会导致在Rebalance结束之后瞬间需要消费很多消息。\n\n#### Rebalance产生的原因\n\n导致Rebalance产生的原因，无非就两个：消费者所订阅Topic的Queue数量发生变化，或消费者组中消费者的数量发生变化。\n\n>1 ）Queue数量发生变化的场景：<br>\nBroker扩容或缩容<br>\nBroker升级运维<br>\nBroker与NameServer间的网络异常<br>\nQueue扩容或缩容<br>\n2 ）消费者数量发生变化的场景：<br>\nConsumer Group扩容或缩容<br>\nConsumer升级运维<br>\nConsumer与NameServer间网络异常<br>\n\n#### Rebalance过程\n\n在Broker中维护着多个Map集合，这些集合中动态存放着当前Topic中Queue的信息、Consumer Group中Consumer实例的信息。一旦发现消费者所订阅的Queue数量发生变化，或消费者组中消费者的数量发生变化，立即向Consumer Group中的每个实例发出Rebalance通知。\n\n>TopicConågManager：key是topic名称，value是TopicConåg。TopicConåg中维护着该Topic中所有Queue的数据。<br><br>\nConsumerManager：key是Consumser Group Id，value是ConsumerGroupInfo。<br>\nConsumerGroupInfo中维护着该Group中所有Consumer实例数据。<br><br>\nConsumerOffsetManager：key为`Topic与订阅该Topic的Group的组合,即topic@group`，value是一个内层Map。内层Map的key为QueueId，内层Map的value为该Queue的消费进度offset。\n\nConsumer实例在接收到通知后会采用Queue分配算法自己获取到相应的Queue，即由Consumer实例自主进行Rebalance。\n\n#### 与Kafka对比\n\n在Kafka中，一旦发现出现了Rebalance条件，Broker会调用Group Coordinator来完成Rebalance。Coordinator是Broker中的一个进程。Coordinator会在Consumer Group中选出一个Group Leader。由这个Leader根据自己本身组情况完成Partition分区的再分配。这个再分配结果会上报给Coordinator，并由Coordinator同步给Group中的所有Consumer实例。\n\nKafka中的Rebalance是由Consumer Leader完成的。而RocketMQ中的Rebalance是由每个Consumer自身完成的，Group中不存在Leader。\n\n### 4 Queue分配算法\n\n一个Topic中的Queue只能由Consumer Group中的一个Consumer进行消费，而一个Consumer可以同时消费多个Queue中的消息。那么Queue与Consumer间的配对关系是如何确定的，即Queue要分配给哪个Consumer进行消费，也是有算法策略的。常见的有四种策略。这些策略是通过在创建Consumer时的构造器传进去的。\n\n#### 平均分配策略\n\n![输入图片说明](rocketmq/QQ截图20220208142527.png \"QQ截图20201229183512.png\")\n\n该算法是要根据`avg = QueueCount / ConsumerCount`的计算结果进行分配的。如果能够整除，则按顺序将avg个Queue逐个分配Consumer；如果不能整除，则将多余出的Queue按照Consumer顺序逐个分配。\n\n\n>该算法即，先计算好每个Consumer应该分得几 个Queue，然后再依次将这些数量的Queue逐个分配个Consumer。\n\n#### 环形平均策略\n\n![输入图片说明](rocketmq/QQ截图20220208142630.png \"QQ截图20201229183512.png\")\n\n环形平均算法是指，根据消费者的顺序，依次在由queue队列组成的环形图中逐个分配。\n\n>该算法不用事先计算每个Consumer需要分配几 个Queue，直接一个一个分即可。\n\n#### 一致性hash策略\n\n![输入图片说明](rocketmq/QQ截图20220208142708.png \"QQ截图20201229183512.png\")\n\n该算法会将consumer的hash值作为Node节点存放到hash环上，然后将queue的hash值也放到hash环上，通过顺时针方向，距离queue最近的那个consumer就是该queue要分配的consumer。\n\n>该算法存在的问题：分配不均。\n\n#### 同机房策略\n\n![输入图片说明](rocketmq/QQ截图20220208142814.png \"QQ截图20201229183512.png\")\n\n该算法会根据queue的部署机房位置和consumer的位置，过滤出当前consumer相同机房的queue。然后按照平均分配策略或环形平均策略对同机房queue进行分配。如果没有同机房queue，则按照平均分配策略或环形平均策略对所有queue进行分配。\n\n#### 对比\n\n一致性hash算法存在的问题：\n\n两种平均分配策略的分配效率较高，一致性hash策略的较低。因为一致性hash算法较复杂。另外，一致性hash策略分配的结果也很大可能上存在不平均的情况。\n\n一致性hash算法存在的意义：\n\n其可以有效减少由于消费者组扩容或缩容所带来的大量的Rebalance。\n\n![输入图片说明](rocketmq/QQ截图20220208142905.png \"QQ截图20201229183512.png\")\n\n一致性hash算法的应用场景：\n\nConsumer数量变化较频繁的场景。\n\n\n### 5 至少一次原则\n\nRocketMQ有一个原则：每条消息必须要被`成功消费`一次。\n\n那么什么是成功消费呢？Consumer在消费完消息后会向其`消费进度记录器`提交其消费消息的offset，offset被成功记录到记录器中，那么这条消费就被成功消费了。\n\n>什么是消费进度记录器？<br>\n对于广播消费模式来说，Consumer本身就是消费进度记录器。<br>\n对于集群消费模式来说，Broker是消费进度记录器。<br>\n\n## 五、订阅关系的一致性\n\n订阅关系的一致性指的是，同一个消费者组（Group ID相同）下所有Consumer实例所订阅的Topic与Tag及对消息的处理逻辑必须完全一致。否则，消息消费的逻辑就会混乱，甚至导致消息丢失。\n\n### 1 正确订阅关系\n\n多个消费者组订阅了多个Topic，并且每个消费者组里的多个消费者实例的订阅关系保持了一致。\n\n![输入图片说明](rocketmq/QQ截图20220208143050.png \"QQ截图20201229183512.png\")\n\n### 2 错误订阅关系\n\n一个消费者组订阅了多个Topic，但是该消费者组里的多个Consumer实例的订阅关系并没有保持一致。\n\n![输入图片说明](rocketmq/QQ截图20220208143107.png \"QQ截图20201229183512.png\")\n\n#### 订阅了不同Topic\n\n该例中的错误在于，同一个消费者组中的两个Consumer实例订阅了不同的Topic。\n\nConsumer实例1-1：（订阅了topic为jodie_test_A，tag为所有的消息）\n\n```java\nProperties properties = new Properties();\nproperties.put(PropertyKeyConst.GROUP_ID, \"GID_jodie_test_1\");\nConsumer consumer = ONSFactory.createConsumer(properties);\nconsumer.subscribe(\"jodie_test_A\", \"*\", new MessageListener() {\n    public Action consume(Message message, ConsumeContext context) {\n        System.out.println(message.getMsgID());\n        return Action.CommitMessage;\n    }\n});\n```\n\nConsumer实例1-2：（订阅了topic为jodie_test_B，tag为所有的消息）\n\n```java\nProperties properties = new Properties();\nproperties.put(PropertyKeyConst.GROUP_ID, \"GID_jodie_test_1\");\nConsumer consumer = ONSFactory.createConsumer(properties);\nconsumer.subscribe(\"jodie_test_B\", \"*\", new MessageListener() {\n    public Action consume(Message message, ConsumeContext context) {\n        System.out.println(message.getMsgID());\n        return Action.CommitMessage;\n    }\n});\n```\n#### 订阅了不同Tag\n\n该例中的错误在于，同一个消费者组中的两个Consumer订阅了相同Topic的不同Tag。\n\nConsumer实例2-1：（订阅了topic为jodie_test_A，tag为TagA的消息）\n\n```java\nProperties properties = new Properties();\nproperties.put(PropertyKeyConst.GROUP_ID, \"GID_jodie_test_2\");\nConsumer consumer = ONSFactory.createConsumer(properties);\nconsumer.subscribe(\"jodie_test_A\", \"TagA\", new MessageListener() {\n    public Action consume(Message message, ConsumeContext context) {\n        System.out.println(message.getMsgID());\n        return Action.CommitMessage;\n    }\n});\n```\nConsumer实例2-2：（订阅了topic为jodie_test_A，tag为所有的消息）\n\n```java\nProperties properties = new Properties();\nproperties.put(PropertyKeyConst.GROUP_ID, \"GID_jodie_test_2\");\nConsumer consumer = ONSFactory.createConsumer(properties);\nconsumer.subscribe(\"jodie_test_A\", \"*\", new MessageListener() {\n    public Action consume(Message message, ConsumeContext context) {\n        System.out.println(message.getMsgID());\n        return Action.CommitMessage;\n    }\n});\n```\n\n#### 订阅了不同数量的Topic\n\n该例中的错误在于，同一个消费者组中的两个Consumer订阅了不同数量的Topic。\n\nConsumer实例3-1：（该Consumer订阅了两个Topic）\n```java\nProperties properties = new Properties();\nproperties.put(PropertyKeyConst.GROUP_ID, \"GID_jodie_test_3\");\nConsumer consumer = ONSFactory.createConsumer(properties);\nconsumer.subscribe(\"jodie_test_A\", \"TagA\", new MessageListener() {\n    public Action consume(Message message, ConsumeContext context) {\n        System.out.println(message.getMsgID());\n        return Action.CommitMessage;\n    }\n});\nconsumer.subscribe(\"jodie_test_B\", \"TagB\", new MessageListener() {\n    public Action consume(Message message, ConsumeContext context) {\n        System.out.println(message.getMsgID());\n        return Action.CommitMessage;\n    }\n});\n```\nConsumer实例3-2：（该Consumer订阅了一个Topic）\n\n```java\nProperties properties = new Properties();\nproperties.put(PropertyKeyConst.GROUP_ID, \"GID_jodie_test_3\");\nConsumer consumer = ONSFactory.createConsumer(properties);\nconsumer.subscribe(\"jodie_test_A\", \"TagB\", new MessageListener() {\n    public Action consume(Message message, ConsumeContext context) {\n        System.out.println(message.getMsgID());\n        return Action.CommitMessage;\n    }\n});\n```\n\n## 六、offset管理\n\n>这里的offset指的是Consumer的消费进度offset。\n\n消费进度offset是用来记录每个Queue的不同消费组的消费进度的。根据消费进度记录器的不同，可以分为两种模式：本地模式和远程模式。\n\n### 1 offset本地管理模式\n\n当消费模式为`广播消费`时，offset使用本地模式存储。因为每条消息会被所有的消费者消费，每个消费者管理自己的消费进度，各个消费者之间不存在消费进度的交集。\n\nConsumer在广播消费模式下offset相关数据以json的形式持久化到Consumer本地磁盘文件中，默认文件路径为当前用户主目录下的`.rocketmq_offsets/${clientId}/${group}/Offsets.json`。其中${clientId}为当前消费者id，默认为ip@DEFAULT；${group}为消费者组名称。\n\n### 2 offset远程管理模式\n\n当消费模式为`集群消费`时，offset使用远程模式管理。因为所有Cosnumer实例对消息采用的是均衡消费，所有Consumer共享Queue的消费进度。\n\nConsumer在集群消费模式下offset相关数据以json的形式持久化到Broker磁盘文件中，文件路径为当前用户主目录下的`store/config/consumerOffset.json`。\n\nBroker启动时会加载这个文件，并写入到一个双层Map（ConsumerOffsetManager）。外层map的key为topic@group，value为内层map。内层map的key为queueId，value为offset。当发生Rebalance时，新的Consumer会从该Map中获取到相应的数据来继续消费。\n\n集群模式下offset采用远程管理模式，主要是为了保证Rebalance机制。\n\n### 3 offset用途\n\n消费者是如何从最开始持续消费消息的？消费者要消费的第一条消息的起始位置是用户自己通过consumer.setConsumeFromWhere()方法指定的。\n\n在Consumer启动后，其要消费的第一条消息的起始位置常用的有三种，这三种位置可以通过枚举类型常量设置。这个枚举类型为ConsumeFromWhere。\n\n![输入图片说明](rocketmq/QQ截图20220208143837.png \"QQ截图20201229183512.png\")\n\n>CONSUME_FROM_LAST_OFFSET：从queue的当前最后一条消息开始消费<br>\nCONSUME_FROM_FIRST_OFFSET：从queue的第一条消息开始消费<br>\nCONSUME_FROM_TIMESTAMP：从指定的具 体时间戳位置的消息开始消费。这个具体时间戳是通过另外一个语句指定的 。<br>\nconsumer.setConsumeTimestamp(“20210701080000”) yyyyMMddHHmmss\n\n当消费完一批消息后，Consumer会提交其消费进度offset给Broker，Broker在收到消费进度后会将其更新到那个双层Map（ConsumerOffsetManager）及consumerOffset.json文件中，然后向该Consumer进行ACK，而ACK内容中包含三项数据：当前消费队列的最小offset（minOffset）、最大offset（maxOffset）、及下次消费的起始offset（nextBeginOffset）。\n\n### 4 重试队列\n\n![输入图片说明](rocketmq/QQ截图20220208143940.png \"QQ截图20201229183512.png\")\n\n当rocketMQ对消息的消费出现异常时，会将发生异常的消息的offset提交到Broker中的重试队列。系统在发生消息消费异常时会为当前的topic@group创建一个重试队列，该队列以%RETRY%开头，到达重试时间后进行消费重试。\n\n### 5 offset的同步提交与异步提交\n\n集群消费模式下，Consumer消费完消息后会向Broker提交消费进度offset，其提交方式分为两种：\n\n`同步提交`：消费者在消费完一批消息后会向broker提交这些消息的offset，然后等待broker的成功响应。若在等待超时之前收到了成功响应，则继续读取下一批消息进行消费（从ACK中获取nextBeginOffset）。若没有收到响应，则会重新提交，直到获取到响应。而在这个等待过程中，消费者是阻塞的。其严重影响了消费者的吞吐量。\n\n`异步提交`：消费者在消费完一批消息后向broker提交offset，但无需等待Broker的成功响应，可以继续读取并消费下一批消息。这种方式增加了消费者的吞吐量。但需要注意，broker在收到提交的offset后，还是会向消费者进行响应的。可能还没有收到ACK，此时Consumer会从Broker中直接获取nextBeginOffset。\n\n## 七、消费幂等\n\n### 1 什么是消费幂等\n\n当出现消费者对某条消息重复消费的情况时，重复消费的结果与消费一次的结果是相同的，并且多次消费并未对业务系统产生任何负面影响，那么这个消费过程就是消费幂等的。\n\n>幂等：若某操作执行多次与执行一次对系统产生的影响是相同的，则称该操作是幂等的。\n\n在互联网应用中，尤其在网络不稳定的情况下，消息很有可能会出现重复发送或重复消费。如果重复的消息可能会影响业务处理，那么就应该对消息做幂等处理。\n\n### 2 消息重复的场景分析\n\n什么情况下可能会出现消息被重复消费呢？最常见的有以下三种情况：\n\n#### 发送时消息重复\n\n当一条消息已被成功发送到Broker并完成持久化，此时出现了网络闪断，从而导致Broker对Producer应答失败。 如果此时Producer意识到消息发送失败并尝试再次发送消息，此时Broker中就可能会出现两条内容相同并且Message ID也相同的消息，那么后续Consumer就一定会消费两次该消息。\n\n#### 消费时消息重复\n\n消息已投递到Consumer并完成业务处理，当Consumer给Broker反馈应答时网络闪断，Broker没有接收到消费成功响应。为了保证消息`至少被消费一次`的原则，Broker将在网络恢复后再次尝试投递之前已被处理过的消息。此时消费者就会收到与之前处理过的内容相同、Message ID也相同的消息。\n\n#### Rebalance时消息重复\n\n当Consumer Group中的Consumer数量发生变化时，或其订阅的Topic的Queue数量发生变化时，会触发Rebalance，此时Consumer可能会收到曾经被消费过的消息。\n\n### 3 通用解决方案\n\n#### 两要素\n\n幂等解决方案的设计中涉及到两项要素：幂等令牌，与唯一性处理。只要充分利用好这两要素，就可以设计出好的幂等解决方案。\n\n* 幂等令牌：是生产者和消费者两者中的既定协议，通常指具备唯一业务标识的字符串。例如，订单号、流水号。一般由Producer随着消息一同发送来的。\n* 唯一性处理：服务端通过采用一定的算法策略，保证同一个业务逻辑不会被重复执行成功多次。例如，对同一笔订单的多次支付操作，只会成功一次。\n\n#### 解决方案\n对于常见的系统，幂等性操作的通用性解决方案是：\n\n* 1. 首先通过缓存去重。在缓存中如果已经存在了某幂等令牌，则说明本次操作是重复性操作；若缓存没有命中，则进入下一步。\n* 2. 在唯一性处理之前，先在数据库中查询幂等令牌作为索引的数据是否存在。若存在，则说明本次操作为重复性操作；若不存在，则进入下一步。\n* 3. 在同一事务中完成三项操作：唯一性处理后，将幂等令牌写入到缓存，并将幂等令牌作为唯一索引的数据写入到DB中。\n\n>第 1 步已经判断过是否是重复性操作了，为什么第 2 步还要再次判断？能够进入第 2 步，说明已经不是重复操作了，第 2 次判断是否重复？<br><br>\n当然不重复。一般缓存中的数据是具有有效期的。缓存中数据的有效期一旦过期，就是发生缓存穿透，使请求直接就到达了DBMS。\n\n#### 解决方案举例\n\n#### 以支付场景为例：\n\n* 1. 当支付请求到达后，首先在Redis缓存中却获取key为支付流水号的缓存value。若value不空，则说明本次支付是重复操作，业务系统直接返回调用侧重复支付标识；若value为空，则进入下一步操作\n* 2. 到DBMS中根据支付流水号查询是否存在相应实例。若存在，则说明本次支付是重复操作，业务系统直接返回调用侧重复支付标识；若不存在，则说明本次操作是首次操作，进入下一步完成唯一性处理\n* 3. 在分布式事务中完成三项操作：\n    * 完成支付任务\n    * 将当前支付流水号作为key，任意字符串作为value，通过set(key, value, expireTime)将数据写入到Redis缓存\n    * 将当前支付流水号作为主键，与其它相关数据共同写入到DBMS\n\n### 4 消费幂等的实现\n\n消费幂等的解决方案很简单：为消息指定不会重复的唯一标识。因为Message ID有可能出现重复的情况，所以真正安全的幂等处理，不建议以Message ID作为处理依据。最好的方式是以业务唯一标识作为幂等处理的关键依据，而业务的唯一标识可以通过消息Key设置。\n\n以支付场景为例，可以将消息的Key设置为订单号，作为幂等处理的依据。具体代码示例如下：\n\n```java\nMessage message = new Message();\nmessage.setKey(\"ORDERID_100\");\nSendResult sendResult = producer.send(message);\n```\n\n消费者收到消息时可以根据消息的Key即订单号来实现消费幂等：\n\n```java\nconsumer.registerMessageListener(new MessageListenerConcurrently() {\n    @Override\n    public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt>msgs,ConsumeConcurrentlyContext context) {\n        for(MessageExt msg:msgs){\n            String key = msg.getKeys();\n            // 根据业务唯一标识Key做幂等处理\n            // ......\n            }\n        return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n    }\n});\n```\n\n>RocketMQ能够保证消息不丢失，但不能保证消息不重复。\n\n## 八、消息堆积与消费延迟\n\n### 1 概念\n\n消息处理流程中，如果Consumer的消费速度跟不上Producer的发送速度，MQ中未处理的消息会越来越多（进的多出的少），这部分消息就被称为`堆积消息`。消息出现堆积进而会造成消息的`消费延迟`。<br>\n以下场景需要重点关注消息堆积和消费延迟问题：\n\n* 业务系统上下游能力不匹配造成的持续堆积，且无法自行恢复。\n* 业务系统对消息的消费实时性要求较高，即使是短暂的堆积造成的消费延迟也无法接受。\n\n### 2 产生原因分析\n\n![输入图片说明](rocketmq/QQ截图20220208144842.png \"QQ截图20201229183512.png\")\n\nConsumer使用长轮询Pull模式消费消息时，分为以下两个阶段：\n\n#### 消息拉取\n\nConsumer通过长轮询Pull模式批量拉取的方式从服务端获取消息，将拉取到的消息缓存到本地缓冲队列中。对于拉取式消费，在内网环境下会有很高的吞吐量，所以这一阶段一般不会成为消息堆积的瓶颈。\n\n>一个单线程单分区的低规格主机(Consumer，4C8G)，其可达到几万的TPS。如果是多个分区多个线程，则可以轻松达到几十万的TPS。\n\n#### 消息消费\n\nConsumer将本地缓存的消息提交到消费线程中，使用业务消费逻辑对消息进行处理，处理完毕后获取到一个结果。这是真正的消息消费过程。此时Consumer的消费能力就完全依赖于消息的`消费耗时`和`消费并发度`了。如果由于业务处理逻辑复杂等原因，导致处理单条消息的耗时较长，则整体的消息吞吐量肯定不会高，此时就会导致Consumer本地缓冲队列达到上限，停止从服务端拉取消息。\n\n#### 结论\n\n消息堆积的主要瓶颈在于客户端的消费能力，而消费能力由`消费耗时`和`消费并发度`决定。注意，消费耗时的优先级要高于消费并发度。即在保证了消费耗时的合理性前提下，再考虑消费并发度问题。\n\n### 3 消费耗时\n\n影响消息处理时长的主要因素是代码逻辑。而代码逻辑中可能会影响处理时长代码主要有两种类型：`CPU内部计算型代码`和`外部I/O操作型代码`。\n\n通常情况下代码中如果没有复杂的递归和循环的话，内部计算耗时相对外部I/O操作来说几乎可以忽略。所以外部IO型代码是影响消息处理时长的主要症结所在。\n\n>外部IO操作型代码举例：<br><br>\n1)读写外部数据库，例如对远程MySQL的访问<br>\n2)读写外部缓存系统，例如对远程Redis的访问<br>\n3)下游系统调用，例如Dubbo的RPC远程调用，Spring Cloud的对下游系统的Http接口调用<br><br>\n关于下游系统调用逻辑需要进行提前梳理，掌握每个调用操作预期的耗时，这样做是为了能够判断消费逻辑中IO操作的耗时是否合理。通常消息堆积是由于下游系统出现了`服务异常`或`达到了DBMS容量限制`，导致消费耗时增加。<br><br>\n服务异常，并不仅仅是系统中出现的类似 500 这样的代码错误，而可能是更加隐蔽的问题。例如，网络带宽问题。<br><br>\n达到了DBMS容量限制，其也会引发消息的消费耗时增加。\n\n### 4 消费并发度\n\n一般情况下，消费者端的消费并发度由单节点线程数和节点数量共同决定，其值为单节点线程数*节点数量。不过，通常需要优先调整单节点的线程数，若单机硬件资源达到了上限，则需要通过横向扩展来提高消费并发度。\n\n>单节点线程数，即单个Consumer所包含的线程数量<br><br>\n节点数量，即Consumer Group所包含的Consumer数量<br><br>\n对于普通消息、延时消息及事务消息，并发度计算都是单节点线程数*节点数量。但对于顺序消息则是不同的。顺序消息的消费并发度等于Topic的Queue分区数量。<br><br>\n1 ）全局顺序消息：该类型消息的Topic只有一个Queue分区。其可以保证该Topic的所有消息被顺序消费。为了保证这个全局顺序性，Consumer Group中在同一时刻只能有一个Consumer的一个线程进行消费。所以其并发度为 1 。<br><br>\n2 ）分区顺序消息：该类型消息的Topic有多个Queue分区。其仅可以保证该Topic的每个Queue分区中的消息被顺序消费，不能保证整个Topic中消息的顺序消费。为了保证这个分区顺序性，每个Queue分区中的消息在Consumer Group中的同一时刻只能有一个Consumer的一个线程进行消费。即，在同一时刻最多会出现多个Queue分蘖有多个Consumer的多个线程并行消费。所以其并发度为Topic的分区数量。\n\n### 5 单机线程数计算\n\n对于一台主机中线程池中线程数的设置需要谨慎，不能盲目直接调大线程数，设置过大的线程数反而会带来大量的线程切换的开销。理想环境下单节点的最优线程数计算模型为：C *（T1 + T2）/ T1。\n\n* C：CPU内核数\n* T1：CPU内部逻辑计算耗时\n* T2：外部IO操作耗时\n\n>最优线程数 = C *（T1 + T2）/ T1 = C * T1/T1 + C * T2/T1 = C + C * T2/T1\n\n>注意，该计算出的数值是理想状态下的理论数据，在生产环境中，不建议直接使用。而是根据当前环境，先设置一个比该值小的数值然后观察其压测效果，然后再根据效果逐步调大线程数，直至找到在该环境中性能最佳时的值。\n\n### 6 如何避免\n\n为了避免在业务使用时出现非预期的消息堆积和消费延迟问题，需要在前期设计阶段对整个业务逻辑进行完善的排查和梳理。其中最重要的就是`梳理消息的消费耗时`和`设置消息消费的并发度`。\n\n#### 梳理消息的消费耗时\n通过压测获取消息的消费耗时，并对耗时较高的操作的代码逻辑进行分析。梳理消息的消费耗时需要关注以下信息：\n\n* 消息消费逻辑的计算复杂度是否过高，代码是否存在无限循环和递归等缺陷。\n* 消息消费逻辑中的I/O操作是否是必须的，能否用本地缓存等方案规避。\n* 消费逻辑中的复杂耗时的操作是否可以做异步化处理。如果可以，是否会造成逻辑错乱。\n\n#### 设置消费并发度\n\n对于消息消费并发度的计算，可以通过以下两步实施：\n\n* 逐步调大单个Consumer节点的线程数，并观测节点的系统指标，得到单个节点最优的消费线程数和消息吞吐量。\n* 根据上下游链路的流量峰值计算出需要设置的节点数\n\n>节点数 = 流量峰值 / 单个节点消息吞吐量\n\n## 九、消息的清理\n\n消息被消费过后会被清理掉吗？不会的。\n\n消息是被顺序存储在commitlog文件的，且消息大小不定长，所以消息的清理是不可能以消息为单位进行清理的，而是以commitlog文件为单位进行清理的。否则会急剧下降清理效率，并实现逻辑复杂。\n\ncommitlog文件存在一个过期时间，默认为 72 小时，即三天。除了用户手动清理外，在以下情况下也会被自动清理，无论文件中的消息是否被消费过：\n\n* 文件过期，且到达清理时间点（默认为凌晨 4 点）后，自动清理过期文件\n* 文件过期，且磁盘空间占用率已达过期清理警戒线（默认75%）后，无论是否达到清理时间点，都会自动清理过期文件\n* 磁盘占用率达到清理警戒线（默认85%）后，开始按照设定好的规则清理文件，无论是否过期。默认会从最老的文件开始清理\n* 磁盘占用率达到系统危险警戒线（默认90%）后，Broker将拒绝消息写入\n\n>需要注意以下几点：<br>\n1 ）对于RocketMQ系统来说，删除一个1G大小的文件，是一个压力巨大的IO操作。在删除过程中，系统性能会骤然下降。所以，其默认清理时间点为凌晨 4 点，访问量最小的时间。也正因如果，我们要保障磁盘空间的空闲率，不要使系统出现在其它时间点删除commitlog文件的情况。<br>\n2 ）官方建议RocketMQ服务的Linux文件系统采用ext4。因为对于文件删除操作，ext4要比ext3性能更好\n\n# 第 4 章 RocketMQ应用\n## 一、普通消息\n### 1 消息发送分类\n\nProducer对于消息的发送方式也有多种选择，不同的方式会产生不同的系统效果。\n\n#### 同步发送消息\n\n同步发送消息是指，Producer发出一条消息后，会在收到MQ返回的ACK之后才发下一条消息。该方式的消息可靠性最高，但消息发送效率太低。\n\n![输入图片说明](rocketmq/QQ截图20220208145933.png \"QQ截图20201229183512.png\")\n\n#### 异步发送消息\n\n异步发送消息是指，Producer发出消息后无需等待MQ返回ACK，直接发送下一条消息。该方式的消息可靠性可以得到保障，消息发送效率也可以。\n\n![输入图片说明](rocketmq/QQ截图20220208150004.png \"QQ截图20201229183512.png\")\n\n#### 单向发送消息\n\n单向发送消息是指，Producer仅负责发送消息，不等待、不处理MQ的ACK。该发送方式时MQ也不返回ACK。该方式的消息发送效率最高，但消息可靠性较差。\n\n![输入图片说明](rocketmq/QQ截图20220208150023.png \"QQ截图20201229183512.png\")\n\n### 2 代码举例\n\n#### 创建工程\n\n创建一个Maven的Java工程rocketmq-test。\n\n导入rocketmq的client依赖。\n```xml\n<properties>\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    <maven.compiler.source>1.8</maven.compiler.source>\n    <maven.compiler.target>1.8</maven.compiler.target>\n</properties>\n<dependencies>\n    <dependency>\n        <groupId>org.apache.rocketmq</groupId>\n        <artifactId>rocketmq-client</artifactId>\n        <version>4.8.0</version>\n    </dependency>\n</dependencies>\n```\n#### 定义同步消息发送生产者\n\n```java\npublic class SyncProducer {\n    public static void main(String[] args) throws Exception {\n        // 创建一个producer，参数为Producer Group名称\n        DefaultMQProducer producer = new DefaultMQProducer(\"pg\");\n        // 指定nameServer地址\n        producer.setNamesrvAddr(\"rocketmqOS:9876\");\n        // 设置当发送失败时重试发送的次数，默认为 2 次\n        producer.setRetryTimesWhenSendFailed( 3 );\n        // 设置发送超时时限为5s，默认3s\n        producer.setSendMsgTimeout( 5000 );\n        // 开启生产者\n        producer.start();\n        // 生产并发送 100 条消息\n        for (int i = 0 ; i < 100 ; i++) {\n            byte[] body = (\"Hi,\" + i).getBytes();\n            Message msg = new Message(\"someTopic\", \"someTag\", body);\n            // 为消息指定key\n            msg.setKeys(\"key-\" + i);\n            // 发送消息\n            SendResult sendResult = producer.send(msg);\n            System.out.println(sendResult);\n        }\n        // 关闭producer\n        producer.shutdown();\n    }\n}\n```\n\n```java\n// 消息发送的状态\npublic enum SendStatus {\n    SEND_OK, // 发送成功\n    FLUSH_DISK_TIMEOUT,  // 刷盘超时。当Broker设置的刷盘策略为同步刷盘时才可能出现这种异常状态。异步刷盘不会出现\n    FLUSH_SLAVE_TIMEOUT, // Slave同步超时。当Broker集群设置的Master-Slave的复制方式为同步复制时才可能出现这种异常状态。异步复制不会出现\n    SLAVE_NOT_AVAILABLE, // 没有可用的Slave。当Broker集群设置为Master-Slave的复制方式为同步复制时才可能出现这种异常状态。异步复制不会出现\n}\n```\n\n#### 定义异步消息发送生产者\n```java\npublic class AsyncProducer {\n    public static void main(String[] args) throws Exception {\n        DefaultMQProducer producer = new DefaultMQProducer(\"pg\");\n        producer.setNamesrvAddr(\"rocketmqOS:9876\");\n        // 指定异步发送失败后不进行重试发送\n        producer.setRetryTimesWhenSendAsyncFailed( 0 );\n        // 指定新创建的Topic的Queue数量为 2 ，默认为 4\n        producer.setDefaultTopicQueueNums( 2 );\n\n        producer.start();\n\n        for (int i = 0 ; i < 100 ; i++) {\n            byte[] body = (\"Hi,\" + i).getBytes();\n            try {\n            Message msg = new Message(\"myTopicA\", \"myTag\", body);\n            // 异步发送。指定回调\n            producer.send(msg, new SendCallback() {\n                    // 当producer接收到MQ发送来的ACK后就会触发该回调方法的执行\n                    @Override\n                    public void onSuccess(SendResult sendResult) {\n                    System.out.println(sendResult);\n                    }\n\n                    @Override\n                    public void onException(Throwable e) {\n                    e.printStackTrace();\n                    }\n                });\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        } // end-for\n        // sleep一会儿\n        // 由于采用的是异步发送，所以若这里不sleep，\n        // 则消息还未发送就会将producer给关闭，报错\n        TimeUnit.SECONDS.sleep( 3 );\n        producer.shutdown();\n    }\n}\n```\n\n#### 定义单向消息发送生产者\n```java\npublic class OnewayProducer {\n    public static void main(String[] args) throws Exception{\n        DefaultMQProducer producer = new DefaultMQProducer(\"pg\");\n        producer.setNamesrvAddr(\"rocketmqOS:9876\");\n        producer.start();\n\n        for (int i = 0 ; i < 10 ; i++) {\n            byte[] body = (\"Hi,\" + i).getBytes();\n            Message msg = new Message(\"single\", \"someTag\", body);\n            // 单向发送\n            producer.sendOneway(msg);\n        }\n        producer.shutdown();\n        System.out.println(\"producer shutdown\");\n    }\n}\n```\n#### 定义消息消费者\n```java\npublic class SomeConsumer {\n    public static void main(String[] args) throws MQClientException {\n        // 定义一个pull消费者\n        // DefaultLitePullConsumer consumer = new\n        DefaultLitePullConsumer(\"cg\");\n        // 定义一个push消费者\n        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(\"cg\");\n        // 指定nameServer\n        consumer.setNamesrvAddr(\"rocketmqOS:9876\");\n        // 指定从第一条消息开始消费\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n        // 指定消费topic与tag\n        consumer.subscribe(\"someTopic\", \"*\");\n        // 指定采用“广播模式”进行消费，默认为“集群模式”\n        // consumer.setMessageModel(MessageModel.BROADCASTING);\n        // 注册消息监听器\n        consumer.registerMessageListener(new MessageListenerConcurrently() {\n            // 一旦broker中有了其订阅的消息就会触发该方法的执行，\n            // 其返回值为当前consumer消费的状态\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,ConsumeConcurrentlyContext context) {\n                // 逐条消费消息\n                for (MessageExt msg : msgs) {\n                    System.out.println(msg);\n                }\n                // 返回消费状态：消费成功\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            }\n        });\n        // 开启消费者消费\n        consumer.start();\n        System.out.println(\"Consumer Started\");\n    }\n}\n```\n\n## 二、顺序消息\n\n### 1 什么是顺序消息\n\n顺序消息指的是，严格按照消息的`发送顺序`进行`消费`的消息(FIFO)。\n\n默认情况下生产者会把消息以Round Robin轮询方式发送到不同的Queue分区队列；而消费消息时会从多个Queue上拉取消息，这种情况下的发送和消费是不能保证顺序的。如果将消息仅发送到同一个Queue中，消费时也只从这个Queue上拉取消息，就严格保证了消息的顺序性。\n\n### 2 为什么需要顺序消息\n\n例如，现在有TOPIC `ORDER_STATUS`(订单状态)，其下有 4 个Queue队列，该Topic中的不同消息用于描述当前订单的不同状态。假设订单有状态：未支付、已支付、发货中、发货成功、发货失败。\n\n根据以上订单状态，生产者从时序上可以生成如下几个消息：\n\n`订单T0000001:未支付 --> 订单T0000001:已支付 --> 订单T0000001:发货中 --> 订单T0000001:发货失败\n\n消息发送到MQ中之后，Queue的选择如果采用轮询策略，消息在MQ的存储可能如下：\n\n![输入图片说明](rocketmq/QQ截图20220208152040.png \"QQ截图20201229183512.png\")\n\n这种情况下，我们希望Consumer消费消息的顺序和我们发送是一致的，然而上述MQ的投递和消费方式，我们无法保证顺序是正确的。对于顺序异常的消息，Consumer即使设置有一定的状态容错，也不能完全处理好这么多种随机出现组合情况。\n\n![输入图片说明](rocketmq/QQ截图20220208152144.png \"QQ截图20201229183512.png\")\n\n基于上述的情况，可以设计如下方案：对于相同订单号的消息，通过一定的策略，将其放置在一个Queue中，然后消费者再采用一定的策略（例如，一个线程独立处理一个queue，保证处理消息的顺序性），能够保证消费的顺序性。\n\n### 3 有序性分类\n\n根据有序范围的不同，RocketMQ可以严格地保证两种消息的有序性：分区有序与全局有序。\n\n#### 全局有序\n\n![输入图片说明](rocketmq/QQ截图20220208152224.png \"QQ截图20201229183512.png\")\n\n当发送和消费参与的Queue只有一个时所保证的有序是整个Topic中消息的顺序， 称为`全局有序`。\n\n>在创建Topic时指定Queue的数量。有三种指定方式：<br><br>\n1 ）在代码中创建Producer时，可以指定其自动创建的Topic的Queue数量<br><br>\n2 ）在RocketMQ可视化控制台中手动创建Topic时指定Queue数量<br><br>\n3 ）使用mqadmin命令手动创建Topic时指定Queue数量<br>\n\n#### 分区有序\n\n![输入图片说明](rocketmq/QQ截图20220208152417.png \"QQ截图20201229183512.png\")\n\n如果有多个Queue参与，其仅可保证在该Queue分区队列上的消息顺序，则称为`分区有序`。\n\n>如何实现Queue的选择？在定义Producer时我们可以指定消息队列选择器，而这个选择器是我们自己实现了MessageQueueSelector接口定义的。<br><br>\n在定义选择器的选择算法时，一般需要使用选择key。这个选择key可以是消息key也可以是其它数据。但无论谁做选择key，都不能重复，都是唯一的。<br><br>\n一般性的选择算法是，让选择key（或其hash值）与该Topic所包含的Queue的数量取模，其结果即为选择出的Queue的QueueId。<br><br>\n取模算法存在一个问题：不同选择key与Queue数量取模结果可能会是相同的，即不同选择key的消息可能会出现在相同的Queue，即同一个Consuemr可能会消费到不同选择key的消息。这个问题如何解决？一般性的作法是，从消息中获取到选择key，对其进行判断。若是当前Consumer需要消费的消息，则直接消费，否则，什么也不做。这种做法要求选择key要能够随着消息一起被Consumer获取到。此时使用消息key作为选择key是比较好的做法。<br><br>\n以上做法会不会出现如下新的问题呢？不属于那个Consumer的消息被拉取走了，那么应该消费该消息的Consumer是否还能再消费该消息呢？同一个Queue中的消息不可能被同一个Group中的不同Consumer同时消费。所以，消费现一个Queue的不同选择key的消息的Consumer一定属于不同的Group。而不同的Group中的Consumer间的消费是相互隔离的，互不影响的。\n\n### 4 代码举例\n```java\npublic class OrderedProducer {\n    public static void main(String[] args) throws Exception {\n        DefaultMQProducer producer = new DefaultMQProducer(\"pg\");\n        producer.setNamesrvAddr(\"rocketmqOS:9876\");\n        producer.start();\n        for (int i = 0 ; i < 100 ; i++) {\n            Integer orderId = i;\n            byte[] body = (\"Hi,\" + i).getBytes();\n            Message msg = new Message(\"TopicA\", \"TagA\", body);\n            SendResult sendResult = producer.send(msg, new MessageQueueSelector() {\n                @Override\n                public MessageQueue select(List<MessageQueue> mqs,Message msg, Object arg) {\n                        Integer id = (Integer) arg;\n                        int index = id % mqs.size();\n                        return mqs.get(index);\n                    }\n                }, orderId);\n            System.out.println(sendResult);\n        }\n        producer.shutdown();\n    }\n}\n```\n## 三、延时消息\n\n### 1 什么是延时消息\n\n当消息写入到Broker后，在指定的时长后才可被消费处理的消息，称为延时消息。\n\n采用RocketMQ的延时消息可以实现`定时任务`的功能，而无需使用定时器。典型的应用场景是，电商交易中超时未支付关闭订单的场景， 12306 平台订票超时未支付取消订票的场景。\n\n>在电商平台中，订单创建时会发送一条延迟消息。这条消息将会在 30 分钟后投递给后台业务系统（Consumer），后台业务系统收到该消息后会判断对应的订单是否已经完成支付。如果未完成，则取消订单，将商品再次放回到库存；如果完成支付，则忽略。<br><br>\n在 12306 平台中，车票预订成功后就会发送一条延迟消息。这条消息将会在 45 分钟后投递给后台业务系统（Consumer），后台业务系统收到该消息后会判断对应的订单是否已经完成支付。如果未完成，则取消预订，将车票再次放回到票池；如果完成支付，则忽略。\n\n### 2 延时等级\n\n延时消息的延迟时长`不支持随意时长`的延迟，是通过特定的延迟等级来指定的。延时等级定义在RocketMQ服务端的MessageStoreConfig类中的如下变量中：\n\n![输入图片说明](rocketmq/QQ截图20220208153410.png \"QQ截图20201229183512.png\")\n\n即，若指定的延时等级为 3 ，则表示延迟时长为10s，即延迟等级是从 1 开始计数的。\n\n当然，如果需要自定义的延时等级，可以通过在broker加载的配置中新增如下配置（例如下面增加了 1天这个等级1d）。配置文件在RocketMQ安装目录下的conf目录中。\n\n```\nmessageDelayLevel = 1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h 1d\n```\n### 3 延时消息实现原理\n\n![输入图片说明](rocketmq/QQ截图20220208153523.png \"QQ截图20201229183512.png\")\n\n#### 具体实现方案是：\n\n#### 修改消息\n\n![输入图片说明](rocketmq/QQ截图20220208153545.png \"QQ截图20201229183512.png\")\n\nProducer将消息发送到Broker后，Broker会首先将消息写入到commitlog文件，然后需要将其分发到相应的consumequeue。不过，在分发之前，系统会先判断消息中是否带有延时等级。若没有，则直接正常分发；若有则需要经历一个复杂的过程：\n\n* 修改消息的Topic为SCHEDULE_TOPIC_XXXX\n* 根据延时等级，在consumequeue目录中SCHEDULE_TOPIC_XXXX主题下创建出相应的queueId目录与consumequeue文件（如果没有这些目录与文件的话）。\n\n>延迟等级delayLevel与queueId的对应关系为queueId = delayLevel -1<br>\n需要注意，在创建queueId目录时，并不是一次性地将所有延迟等级对应的目录全部创建完毕，而是用到哪个延迟等级创建哪个目录\n\n![输入图片说明](rocketmq/QQ截图20220208153635.png \"QQ截图20201229183512.png\")\n\n* 修改消息索引单元内容。索引单元中的Message Tag HashCode部分原本存放的是消息的Tag的Hash值。现修改为消息的`投递时间`。投递时间是指该消息被重新修改为原Topic后再次被写入到commitlog中的时间。`投递时间 = 消息存储时间 + 延时等级时间`。消息存储时间指的是消息被发送到Broker时的时间戳。\n* 将消息索引写入到SCHEDULE_TOPIC_XXXX主题下相应的consumequeue中\n\n>SCHEDULE_TOPIC_XXXX目录中各个延时等级Queue中的消息是如何排序的？<br><br>\n是按照消息投递时间排序的。一个Broker中同一等级的所有延时消息会被写入到consumequeue目录中SCHEDULE_TOPIC_XXXX目录下相同Queue中。即一个Queue中消息投递时间的延迟等级时间是相同的。那么投递时间就取决于于`消息存储时间`了。即按照消息被发送到Broker的时间进行排序的。\n\n#### 投递延时消息\n\nBroker内部有一个延迟消息服务类ScheuleMessageService，其会消费SCHEDULE_TOPIC_XXXX中的消息，即按照每条消息的投递时间，将延时消息投递到目标Topic中。不过，在投递之前会从commitlog中将原来写入的消息再次读出，并将其原来的延时等级设置为 0 ，即原消息变为了一条不延迟的普通消息。然后再次将消息投递到目标Topic中。\n\n>ScheuleMessageService在Broker启动时，会创建并启动一个定时器TImer，用于执行相应的定时任务。系统会根据延时等级的个数，定义相应数量的TimerTask，每个TimerTask负责一个延迟等级消息的消费与投递。每个TimerTask都会检 测相应Queue队列的第一条消息是否到期。若第一条消息未到期，则后面的所有消息更不会到期（消息是按照投递时间排序的）；若第一条消息到期了，则将该消息投递到目标Topic，即消费该消息。\n\n#### 将消息重新写入commitlog\n\n延迟消息服务类ScheuleMessageService将延迟消息再次发送给了commitlog，并再次形成新的消息索引条目，分发到相应Queue。\n\n>这其实就是一次普通消息发送。只不过这次的消息Producer是延迟消息服务类ScheuleMessageService。\n\n### 4 代码举例\n\n定义DelayProducer类\n\n```java\npublic class DelayProducer {\n    public static void main(String[] args) throws Exception {\n        DefaultMQProducer producer = new DefaultMQProducer(\"pg\");\n        producer.setNamesrvAddr(\"rocketmqOS:9876\");\n        producer.start();\n        for (int i = 0 ; i < 10 ; i++) {\n            byte[] body = (\"Hi,\" + i).getBytes();\n            Message msg = new Message(\"TopicB\", \"someTag\", body);\n            // 指定消息延迟等级为 3 级，即延迟10s\n            // msg.setDelayTimeLevel(3);\n            SendResult sendResult = producer.send(msg);\n            // 输出消息被发送的时间\n            System.out.print(new SimpleDateFormat(\"mm:ss\").format(new Date()));\n            System.out.println(\" ,\" + sendResult);\n        }\n        producer.shutdown();\n    }\n}\n```\n\n定义OtherConsumer类\n\n```java\npublic class OtherConsumer {\n    public static void main(String[] args) throws MQClientException {\n        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(\"cg\");\n        consumer.setNamesrvAddr(\"rocketmqOS:9876\");\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET );\n        consumer.subscribe(\"TopicB\", \"*\");\n        consumer.registerMessageListener(new MessageListenerConcurrently() {\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,ConsumeConcurrentlyContext context) {\n            for (MessageExt msg : msgs) {\n                    // 输出消息被消费的时间\n                    System.out.print(new SimpleDateFormat(\"mm:ss\").format(new Date()));\n                    System.out.println(\" ,\" + msg);\n                }\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            }\n        });\n        consumer.start();\n        System.out.println(\"Consumer Started\");\n    }\n}\n```\n\n## 四、事务消息\n\n### 1 问题引入\n\n这里的一个需求场景是：工行用户A向建行用户B转账 1 万元。\n\n我们可以使用同步消息来处理该需求场景：\n\n![输入图片说明](rocketmq/QQ截图20220208154429.png \"QQ截图20201229183512.png\")\n\n* 1. 工行系统发送一个给B增款 1 万元的同步消息M给Broker\n* 2. 消息被Broker成功接收后，向工行系统发送成功ACK\n* 3. 工行系统收到成功ACK后从用户A中扣款 1 万元\n* 4. 建行系统从Broker中获取到消息M\n* 5. 建行系统消费消息M，即向用户B中增加 1 万元\n\n>这其中是有问题的：若第 3 步中的扣款操作失败，但消息已经成功发送到了Broker。对于MQ来说，只要消息写入成功，那么这个消息就可以被消费。此时建行系统中用户B增加了 1 万元。出现了数据不一致问题。\n\n### 2 解决思路\n\n解决思路是，让第 1 、 2 、 3 步具有原子性，要么全部成功，要么全部失败。即消息发送成功后，必须要保证扣款成功。如果扣款失败，则回滚发送成功的消息。而该思路即使用`事务消息`。这里要使用`分布式事务`解决方案。\n\n![输入图片说明](rocketmq/QQ截图20220208154545.png \"QQ截图20201229183512.png\")\n\n#### 使用事务消息来处理该需求场景：\n\n* 1. 事务管理器TM向事务协调器TC发起指令，开启全局事务\n* 2. 工行系统发一个给B增款 1 万元的事务消息M给TC\n* 3. TC会向Broker发送半事务消息prepareHalf，将消息M预提交到Broker。此时的建行系统是看不到Broker中的消息M的\n* 4. Broker会将预提交执行结果Report给TC。\n* 5. 如果预提交失败，则TC会向TM上报预提交失败的响应，全局事务结束；如果预提交成功，TC会调用工行系统的回调操作，去完成工行用户A的预扣款 1 万元的操作\n* 6. 工行系统会向TC发送预扣款执行结果，即本地事务的执行状态\n* 7. TC收到预扣款执行结果后，会将结果上报给TM。\n\n>预扣款执行结果存在三种可能性：<br>\n```java\n// 描述本地事务执行状态\npublic enum LocalTransactionState {\n    COMMIT_MESSAGE,  // 本地事务执行成功\n    ROLLBACK_MESSAGE,  // 本地事务执行失败\n    UNKNOW,  // 不确定，表示需要进行回查以确定本地事务的执行结果\n}\n```\n* 8. TM会根据上报结果向TC发出不同的确认指令\n    * 若预扣款成功（本地事务状态为COMMIT_MESSAGE），则TM向TC发送Global Commit指令\n    * 若预扣款失败（本地事务状态为ROLLBACK_MESSAGE），则TM向TC发送Global Rollback指令\n    * 若现未知状态（本地事务状态为UNKNOW），则会触发工行系统的本地事务状态`回查操作`。回查操作会将回查结果，即COMMIT_MESSAGE或ROLLBACK_MESSAGE Report给TC。TC将结果上报给TM，TM会再向TC发送最终确认指令Global Commit或Global Rollback\n\n* 9. TC在接收到指令后会向Broker与工行系统发出确认指令\n    * TC接收的若是Global Commit指令，则向Broker与工行系统发送Branch Commit指令。此时Broker中的消息M才可被建行系统看到；此时的工行用户A中的扣款操作才真正被确认\n    * TC接收到的若是Global Rollback指令，则向Broker与工行系统发送Branch Rollback指令。此时Broker中的消息M将被撤销；工行用户A中的扣款操作将被回滚\n\n>以上方案就是为了确保`消息投递`与`扣款操作`能够在一个事务中，要成功都成功，有一个失败，则全部回滚。<br><br>\n以上方案并不是一个典型的XA模式。因为XA模式中的分支事务是异步的，而事务消息方案中的消息预提交与预扣款操作间是同步的。\n\n### 3 基础\n\n#### 分布式事务\n对于分布式事务，通俗地说就是，一次操作由若干分支操作组成，这些分支操作分属不同应用，分布在不同服务器上。分布式事务需要保证这些分支操作要么全部成功，要么全部失败。分布式事务与普通事务一样，就是为了保证操作结果的一致性。\n\n#### 事务消息\n\nRocketMQ提供了类似X/Open XA的分布式事务功能，通过事务消息能达到分布式事务的最终一致。XA是一种分布式事务解决方案，一种分布式事务处理模式。\n\n#### 半事务消息\n\n暂不能投递的消息，发送方已经成功地将消息发送到了Broker，但是Broker未收到最终确认指令，此时该消息被标记成“暂不能投递”状态，即不能被消费者看到。处于该种状态下的消息即半事务消息。\n\n#### 本地事务状态\n\nProducer`回调操作`执行的结果为本地事务状态，其会发送给TC，而TC会再发送给TM。TM会根据TC发送来的本地事务状态来决定全局事务确认指令。\n\n```java\n// 描述本地事务执行状态\npublic enum LocalTransactionState {\n    COMMIT_MESSAGE,  // 本地事务执行成功\n    ROLLBACK_MESSAGE,  // 本地事务执行失败\n    UNKNOW,  // 不确定，表示需要进行回查以确定本地事务的执行结果\n}\n```\n\n#### 消息回查\n![输入图片说明](rocketmq/QQ截图20220208155046.png \"QQ截图20201229183512.png\")\n\n消息回查，即重新查询本地事务的执行状态。本例就是重新到DB中查看预扣款操作是否执行成功。\n\n>注意，消息回查不是重新执行回调操作。回调操作是进行预扣款操作，而消息回查则是查看预扣款操作执行的结果。<br><br>\n引发消息回查的原因最常见的有两个：<br>\n1)回调操作返回UNKNWON<br>\n2)TC没有接收到TM的最终全局事务确认指令<br>\n\n#### RocketMQ中的消息回查设置\n\n关于消息回查，有三个常见的属性设置。它们都在broker加载的配置文件中设置，例如：\n\n* transactionTimeout=20，指定TM在 20 秒内应将最终确认状态发送给TC，否则引发消息回查。默认为 60 秒\n* transactionCheckMax=5，指定最多回查 5 次，超过后将丢弃消息并记录错误日志。默认 15 次。\n* transactionCheckInterval=10，指定设置的多次消息回查的时间间隔为 10 秒。默认为 60 秒。\n\n### 4 XA模式三剑客\n\n#### XA协议\n\nXA（Unix Transaction）是一种分布式事务解决方案，一种分布式事务处理模式，是基于XA协议的。<br>\nXA协议由Tuxedo（Transaction for Unix has been Extended for Distributed Operation，分布式操作扩展之后的Unix事务系统）首先提出的，并交给X/Open组织，作为资源管理器与事务管理器的接口标准。\n\n`XA模式中有三个重要组件：TC、TM、RM。`\n\n#### TC\n\nTransaction Coordinator，事务协调者。维护全局和分支事务的状态，驱动全局事务提交或回滚。\n\n```\nRocketMQ中Broker充当着TC。\n```\n#### TM\n\nTransaction Manager，事务管理器。定义全局事务的范围：开始全局事务、提交或回滚全局事务。它实际是全局事务的发起者。\n\n>RocketMQ中事务消息的Producer充当着TM。\n\n#### RM\n\nResource Manager，资源管理器。管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。\n\n>RocketMQ中事务消息的Producer及Broker均是RM。\n\n### 5 XA模式架构\n\n![输入图片说明](rocketmq/QQ截图20220208155359.png \"QQ截图20201229183512.png\")\n\nXA模式是一个典型的2PC，其执行原理如下：\n* 1. TM向TC发起指令，开启一个全局事务。\n* 2. 根据业务要求，各个RM会逐个向TC注册分支事务，然后TC会逐个向RM发出预执行指令。\n* 3. 各个RM在接收到指令后会在进行本地事务预执行。\n* 4. RM将预执行结果Report给TC。当然，这个结果可能是成功，也可能是失败。\n* 5. TC在接收到各个RM的Report后会将汇总结果上报给TM，根据汇总结果TM会向TC发出确认指令。\n    * 若所有结果都是成功响应，则向TC发送Global Commit指令。\n    * 只要有结果是失败响应，则向TC发送Global Rollback指令。\n* 6. TC在接收到指令后再次向RM发送确认指令。\n\n>事务消息方案并不是一个典型的XA模式。因为XA模式中的分支事务是异步的，而事务消息方案中的消息预提交与预扣款操作间是同步的。\n\n### 6 注意\n\n* 事务消息不支持延时消息\n* 对于事务消息要做好幂等性检查，因为事务消息可能不止一次被消费（因为存在回滚后再提交的情况）\n\n### 7 代码举例\n\n\n#### 定义工行事务监听器\n```java\npublic class ICBCTransactionListener implements TransactionListener {\n    // 回调操作方法\n    // 消息预提交成功就会触发该方法的执行，用于完成本地事务\n    @Override\n    public LocalTransactionState executeLocalTransaction(Message msg,Object arg) {\n        System.out.println(\"预提交消息成功：\" + msg);\n        // 假设接收到TAGA的消息就表示扣款操作成功，TAGB的消息表示扣款失败，\n        // TAGC表示扣款结果不清楚，需要执行消息回查\n        if (StringUtils.equals(\"TAGA\", msg.getTags())) {\n            return LocalTransactionState.COMMIT_MESSAGE;\n        } else if (StringUtils.equals(\"TAGB\", msg.getTags())) {\n            return LocalTransactionState.ROLLBACK_MESSAGE;\n        } else if (StringUtils.equals(\"TAGC\", msg.getTags())) {\n            return LocalTransactionState.UNKNOW;\n        }\n            return LocalTransactionState.UNKNOW;\n    }\n\n    // 消息回查方法\n    // 引发消息回查的原因最常见的有两个：\n    // 1)回调操作返回UNKNWON\n    // 2)TC没有接收到TM的最终全局事务确认指令\n    @Override\n    public LocalTransactionState checkLocalTransaction(MessageExt msg) {\n        System.out.println(\"执行消息回查\" + msg.getTags());\n        return LocalTransactionState.COMMIT_MESSAGE;\n    }\n}\n```\n#### 定义事物消息生产者\n\n```java\npublic class TransactionProducer {\n    public static void main(String[] args) throws Exception {\n        TransactionMQProducer producer = new TransactionMQProducer(\"tpg\");\n        producer.setNamesrvAddr(\"rocketmqOS:9876\");\n        /**\n        * 定义一个线程池\n        * @param corePoolSize 线程池中核心线程数量\n        * @param maximumPoolSize 线程池中最多线程数\n        * @param keepAliveTime 这是一个时间。当线程池中线程数量大于核心线程数量是，多余空闲线程的存活时长\n        * @param unit 时间单位\n        * @param workQueue 临时存放任务的队列，其参数就是队列的长度\n        * @param threadFactory 线程工厂\n        */\n        ExecutorService executorService = new ThreadPoolExecutor( 2 , 5 ,100 , TimeUnit.SECONDS,new ArrayBlockingQueue<Runnable>( 2000 ), new ThreadFactory() {\n            @Override\n            public Thread newThread(Runnable r) {\n                Thread thread = new Thread(r);\n                thread.setName(\"client-transaction-msg-check-thread\");\n                return thread;\n            }\n        });\n        // 为生产者指定一个线程池\n        producer.setExecutorService(executorService);\n        // 为生产者添加事务监听器\n        producer.setTransactionListener(new ICBCTransactionListener());\n        producer.start();\n        String[] tags = {\"TAGA\",\"TAGB\",\"TAGC\"};\n        for (int i = 0 ; i < 3 ; i++) {\n            byte[] body = (\"Hi,\" + i).getBytes();\n            Message msg = new Message(\"TTopic\", tags[i], body);\n            // 发送事务消息\n            // 第二个参数用于指定在执行本地事务时要使用的业务参数\n            SendResult sendResult =producer.sendMessageInTransaction(msg,null);\n            System.out.println(\"发送结果为：\" +sendResult.getSendStatus());\n        }\n    }\n}\n```\n#### 定义消费者\n\n直接使用普通消息的SomeConsumer作为消费者即可。\n\n```java\npublic class SomeConsumer {\n    public static void main(String[] args) throws MQClientException {\n        // DefaultLitePullConsumer consumer = new DefaultLitePullConsumer(\"cg\");\n        // 定义一个push消费者\n        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(\"cg\");\n        // 指定nameServer\n        consumer.setNamesrvAddr(\"rocketmqOS:9876\");\n        // 指定从第一条消息开始消费\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n        // 指定消费topic与tag\n        consumer.subscribe(\"TTopic\", \"*\");\n        // 指定采用“广播模式”进行消费，默认为“集群模式”\n        // consumer.setMessageModel(MessageModel.BROADCASTING);\n\n        // 注册消息监听器\n        consumer.registerMessageListener(new MessageListenerConcurrently() {\n            // 一旦broker中有了其订阅的消息就会触发该方法的执行，\n            // 其返回值为当前consumer消费的状态\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,ConsumeConcurrentlyContext context) {\n                // 逐条消费消息\n                for (MessageExt msg : msgs) {\n                    System.out.println(msg);\n                }\n            // 返回消费状态：消费成功\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            }\n        });\n        // 开启消费者消费\n        consumer.start();\n        System.out.println(\"Consumer Started\");\n    }\n}\n```\n\n## 五、批量消息\n\n### 1 批量发送消息\n\n#### 发送限制\n\n生产者进行消息发送时可以一次发送多条消息，这可以大大提升Producer的发送效率。不过需要注意以下几点：\n\n* 批量发送的消息必须具有相同的Topic\n* 批量发送的消息必须具有相同的刷盘策略\n* 批量发送的消息不能是延时消息与事务消息\n\n#### 批量发送大小\n\n默认情况下，一批发送的消息总大小不能超过4MB字节。如果想超出该值，有两种解决方案：\n\n* 方案一：将批量消息进行拆分，拆分为若干不大于4M的消息集合分多次批量发送\n* 方案二：在Producer端与Broker端修改属性\n\n** Producer端需要在发送之前设置Producer的maxMessageSize属性\n\n** Broker端需要修改其加载的配置文件中的maxMessageSize属性\n\n#### 生产者发送的消息大小\n![输入图片说明](rocketmq/QQ截图20220208160513.png \"QQ截图20201229183512.png\")\n\n生产者通过send()方法发送的Message，并不是直接将Message序列化后发送到网络上的，而是通过这个Message生成了一个字符串发送出去的。这个字符串由四部分构成：Topic、消息Body、消息日志（占 20 字节），及用于描述消息的一堆属性key-value。这些属性中包含例如生产者地址、生产时间、要发送的QueueId等。最终写入到Broker中消息单元中的数据都是来自于这些属性。\n\n### 2 批量消费消息\n\n#### 修改批量属性\n![输入图片说明](rocketmq/QQ截图20220208160544.png \"QQ截图20201229183512.png\")\n\nConsumer的MessageListenerConcurrently监听接口的consumeMessage()方法的第一个参数为消息列表，但默认情况下每次只能消费一条消息。若要使其一次可以消费多条消息，则可以通过修改Consumer的consumeMessageBatchMaxSize属性来指定。不过，该值不能超过 32 。因为默认情况下消费者每次可以拉取的消息最多是 32 条。若要修改一次拉取的最大值，则可通过修改Consumer的pullBatchSize属性来指定。\n\n#### 存在的问题\n\nConsumer的pullBatchSize属性与consumeMessageBatchMaxSize属性是否设置的越大越好？当然不是。\n\n* pullBatchSize值设置的越大，Consumer每拉取一次需要的时间就会越长，且在网络上传输出现问题的可能性就越高。若在拉取过程中若出现了问题，那么本批次所有消息都需要全部重新拉取。\n* consumeMessageBatchMaxSize值设置的越大，Consumer的消息并发消费能力越低，且这批被消费的消息具有相同的消费结果。因为consumeMessageBatchMaxSize指定的一批消息只会使用一个线程进行处理，且在处理过程中只要有一个消息处理异常，则这批消息需要全部重新再次消费处理。\n### 3 代码举例\n该批量发送的需求是，不修改最大发送4M的默认值，但要防止发送的批量消息超出4M的限制。\n\n#### 定义消息列表分割器\n```java\n    // 消息列表分割器：其只会处理每条消息的大小不超4M的情况。\n    // 若存在某条消息，其本身大小大于4M，这个分割器无法处理，\n    // 其直接将这条消息构成一个子列表返回。并没有再进行分割\npublic class MessageListSplitter implements Iterator<List<Message>> {\n    // 指定极限值为4M\n    private final int SIZE_LIMIT =  4 * 1024 * 1024 ;\n    // 存放所有要发送的消息\n    private final List<Message> messages;\n    // 要进行批量发送消息的小集合起始索引\n    private int currIndex;\n    public MessageListSplitter(List<Message> messages) {\n        this.messages = messages;\n    }\n    @Override\n    public boolean hasNext() {\n    // 判断当前开始遍历的消息索引要小于消息总数\n    return currIndex < messages.size();\n    }\n    @Override\n    public List<Message> next() {\n        int nextIndex = currIndex;\n        // 记录当前要发送的这一小批次消息列表的大小\n        int totalSize = 0 ;\n        for (; nextIndex < messages.size(); nextIndex++) {\n            // 获取当前遍历的消息\n            Message message = messages.get(nextIndex);\n            // 统计当前遍历的message的大小\n            int tmpSize = message.getTopic().length() + message.getBody().length;\n            Map<String, String> properties = message.getProperties();\n            for (Map.Entry<String, String> entry :properties.entrySet()) {\n                tmpSize += entry.getKey().length() +\n                entry.getValue().length();\n            }\n            tmpSize = tmpSize + 20 ;\n            // 判断当前消息本身是否大于4M\n            if (tmpSize > SIZE_LIMIT) {\n                if (nextIndex - currIndex == 0 ) {\n                    nextIndex++;\n                }\n                break;\n            }\n\n            if (tmpSize + totalSize > SIZE_LIMIT) {\n                break;\n            } else {\n                totalSize += tmpSize;\n            }\n\n        } // end-for\n        // 获取当前messages列表的子集合[currIndex, nextIndex)\n        List<Message> subList = messages.subList(currIndex, nextIndex);\n        // 下次遍历的开始索引\n        currIndex = nextIndex;\n        return subList;\n    }\n}\n```\n\n#### 定义批量消息生产者\n```java\npublic class BatchProducer {\n    public static void main(String[] args) throws Exception {\n        DefaultMQProducer producer = new DefaultMQProducer(\"pg\");\n        producer.setNamesrvAddr(\"rocketmqOS:9876\");\n        // 指定要发送的消息的最大大小，默认是4M\n        // 不过，仅修改该属性是不行的，还需要同时修改broker加载的配置文件中的\n        // maxMessageSize属性\n        // producer.setMaxMessageSize(8 * 1024 * 1024);\n        producer.start();\n\n        // 定义要发送的消息集合\n        List<Message> messages = new ArrayList<>();\n        for (int i = 0 ; i < 100 ; i++) {\n            byte[] body = (\"Hi,\" + i).getBytes();\n            Message msg = new Message(\"someTopic\", \"someTag\", body);\n            messages.add(msg);\n        }\n\n        // 定义消息列表分割器，将消息列表分割为多个不超出4M大小的小列表\n        MessageListSplitter splitter = new MessageListSplitter(messages);\n        while (splitter.hasNext()) {\n            try {\n                List<Message> listItem = splitter.next();\n                producer.send(listItem);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        producer.shutdown();\n    }\n}\n```\n#### 定义批量消息消费者\n\n```java\npublic class BatchConsumer {\n    public static void main(String[] args) throws MQClientException {\n        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(\"cg\");\n        consumer.setNamesrvAddr(\"rocketmqOS:9876\");\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n        consumer.subscribe(\"someTopicA\", \"*\");\n\n        // 指定每次可以消费 10 条消息，默认为 1\n        consumer.setConsumeMessageBatchMaxSize( 10 );\n        // 指定每次可以从Broker拉取 40 条消息，默认为 32\n        consumer.setPullBatchSize( 40 );\n\n        consumer.registerMessageListener(new MessageListenerConcurrently() {\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,ConsumeConcurrentlyContext context) {\n                for (MessageExt msg : msgs) {\n                    System.out.println(msg);\n                }\n                // 消费成功的返回结果\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n                // 消费异常时的返回结果\n                // return ConsumeConcurrentlyStatus.RECONSUME_LATER;\n            }\n        });\n\n        consumer.start();\n        System.out.println(\"Consumer Started\");\n    }\n}\n```\n\n## 六、消息过滤\n\n消息者在进行消息订阅时，除了可以指定要订阅消息的Topic外，还可以对指定Topic中的消息根据指定条件进行过滤，即可以订阅比Topic更加细粒度的消息类型。\n\n对于指定Topic消息的过滤有两种过滤方式：Tag过滤与SQL过滤。\n\n### 1 Tag过滤\n\n通过consumer的subscribe()方法指定要订阅消息的Tag。如果订阅多个Tag的消息，Tag间使用或运算符(双竖线||)连接。\n\n```java\nDefaultMQPushConsumer consumer = new DefaultMQPushConsumer(\"CID_EXAMPLE\");\nconsumer.subscribe(\"TOPIC\", \"TAGA || TAGB || TAGC\");\n```\n### 2 SQL过滤\n\nSQL过滤是一种通过特定表达式对事先埋入到消息中的`用户属性`进行筛选过滤的方式。通过SQL过滤，可以实现对消息的复杂过滤。不过，只有使用`PUSH模式`的消费者才能使用SQL过滤。\n\nSQL过滤表达式中支持多种常量类型与运算符。\n\n支持的常量类型：\n\n* 数值：比如： 123 ，3.1415\n* 字符：必须用单引号包裹起来，比如：'abc'\n* 布尔：TRUE 或 FALSE\n* NULL：特殊的常量，表示空\n\n支持的运算符有：\n\n* 数值比较：>，>=，<，<=，BETWEEN，=\n* 字符比较：=，<>，IN\n* 逻辑运算 ：AND，OR，NOT\n* NULL判断：IS NULL 或者 IS NOT NULL\n\n默认情况下Broker没有开启消息的SQL过滤功能，需要在Broker加载的配置文件中添加如下属性，以开启该功能：\n```shell\nenablePropertyFilter = true\n```\n\n在启动Broker时需要指定这个修改过的配置文件。例如对于单机Broker的启动，其修改的配置文件是conf/broker.conf，启动时使用如下命令：\n\n```shell\nsh bin/mqbroker -n localhost:9876 -c conf/broker.conf &\n```\n### 3 代码举例\n\n定义Tag过滤Producer\n\n```java\npublic class FilterByTagProducer {\n    public static void main(String[] args) throws Exception {\n        DefaultMQProducer producer = new DefaultMQProducer(\"pg\");\n        producer.setNamesrvAddr(\"rocketmqOS:9876\");\n        producer.start();\n        String[] tags = {\"myTagA\",\"myTagB\",\"myTagC\"};\n        for (int i = 0 ; i < 10 ; i++) {\n            byte[] body = (\"Hi,\" + i).getBytes();\n            String tag = tags[i%tags.length];\n            Message msg = new Message(\"myTopic\",tag,body);\n            SendResult sendResult = producer.send(msg);\n            System.out.println(sendResult);\n        }\n        producer.shutdown();\n    }\n}\n```\n\n定义Tag过滤Consumer\n\n```java\npublic class FilterByTagConsumer {\n    public static void main(String[] args) throws Exception {\n        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(\"pg\");\n        consumer.setNamesrvAddr(\"rocketmqOS:9876\");\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n\n        consumer.subscribe(\"myTopic\", \"myTagA || myTagB\");\n        consumer.registerMessageListener(new MessageListenerConcurrently() {\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,ConsumeConcurrentlyContext context) {\n                for (MessageExt me:msgs){\n                    System.out.println(me);\n                }\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            }\n        });\n        consumer.start();\n        System.out.println(\"Consumer Started\");\n    }\n}\n```\n\n定义SQL过滤Producer\n\n```java\npublic class FilterBySQLProducer {\n    public static void main(String[] args) throws Exception {\n        DefaultMQProducer producer = new DefaultMQProducer(\"pg\");\n        producer.setNamesrvAddr(\"rocketmqOS:9876\");\n        producer.start();\n        for (int i = 0 ; i < 10 ; i++) {\n            try {\n                byte[] body = (\"Hi,\" + i).getBytes();\n                Message msg = new Message(\"myTopic\", \"myTag\", body);\n                msg.putUserProperty(\"age\", i + \"\");\n                SendResult sendResult = producer.send(msg);\n                System.out.println(sendResult);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        producer.shutdown();\n    }\n}\n```\n\n定义SQL过滤Consumer\n\n```java\npublic class FilterBySQLConsumer {\n    public static void main(String[] args) throws Exception {\n        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(\"pg\");\n        consumer.setNamesrvAddr(\"rocketmqOS:9876\");\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n        consumer.subscribe(\"myTopic\", MessageSelector.bySql(\"age between 0 and 6\"));\n        consumer.registerMessageListener(new MessageListenerConcurrently() {\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {\n                for (MessageExt me:msgs){\n                    System.out.println(me);\n                }\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            }\n        });\n        consumer.start();\n        System.out.println(\"Consumer Started\");\n    }\n}\n```\n\n## 七、消息发送重试机制\n\n### 1 说明\n\nProducer对发送失败的消息进行重新发送的机制，称为消息发送重试机制，也称为消息重投机制。\n\n#### 对于消息重投，需要注意以下几点：\n\n* 生产者在发送消息时，若采用同步或异步发送方式，发送失败会重试，但oneway消息发送方式发送失败是没有重试机制的\n* 只有普通消息具有发送重试机制，顺序消息是没有的\n* 消息重投机制可以保证消息尽可能发送成功、不丢失，但可能会造成消息重复。消息重复在RocketMQ中是无法避免的问题\n* 消息重复在一般情况下不会发生，当出现消息量大、网络抖动，消息重复就会成为大概率事件\n* producer主动重发、consumer负载变化（发生Rebalance，不会导致消息重复，但可能出现重复消费）也会导致重复消息\n* 消息重复无法避免，但要避免消息的重复消费。\n* 避免消息重复消费的解决方案是，为消息添加唯一标识（例如消息key），使消费者对消息进行消费判断来避免重复消费\n* 消息发送重试有三种策略可以选择：同步发送失败策略、异步发送失败策略、消息刷盘失败策略\n\n### 2 同步发送失败策略\n\n对于普通消息，消息发送默认采用round-robin策略来选择所发送到的队列。如果发送失败，默认重试 2次。但在重试时是不会选择上次发送失败的Broker，而是选择其它Broker。当然，若只有一个Broker其也只能发送到该Broker，但其会尽量发送到该Broker上的其它Queue。\n\n```java\n// 创建一个producer，参数为Producer Group名称\nDefaultMQProducer producer = new DefaultMQProducer(\"pg\");\n// 指定nameServer地址\nproducer.setNamesrvAddr(\"rocketmqOS:9876\");\n// 设置同步发送失败时重试发送的次数，默认为 2 次\nproducer.setRetryTimesWhenSendFailed( 3 );\n// 设置发送超时时限为5s，默认3s\nproducer.setSendMsgTimeout( 5000 );\n```\n\n同时，Broker还具有`失败隔离`功能，使Producer尽量选择未发生过发送失败的Broker作为目标Broker。其可以保证其它消息尽量不发送到问题Broker，为了提升消息发送效率，降低消息发送耗时。\n\n>思考：让我们自己实现`失败隔离`功能，如何来做？<br><br>\n1 ）方案一：Producer中维护某JUC的Map集合，其key是发生失败的时间戳，value为Broker实例。Producer中还维护着一个Set集合，其中存放着所有未发生发送异常的Broker实例。选择目标Broker是从该Set集合中选择的。再定义一个定时任务，定期从Map集合中将长期未发生发送异常的Broker清理出去，并添加到Set集合。<br><br>\n2 ）方案二：为Producer中的Broker实例添加一个标识，例如是一个AtomicBoolean属性。只要该Broker上发生过发送异常，就将其置为true。选择目标Broker就是选择该属性值为false的Broker。再定义一个定时任务，定期将Broker的该属性置为false。<br><br>\n3 ）方案三：为Producer中的Broker实例添加一个标识，例如是一个AtomicLong属性。只要该Broker上发生过发送异常，就使其值增一。选择目标Broker就是选择该属性值最小的Broker。若该值相同，采用轮询方式选择。\n\n\n如果超过重试次数，则抛出异常，由Producer去保证消息不丢。当然当生产者出现RemotingException、MQClientException和MQBrokerException时，Producer会自动重投消息。\n\n### 3 异步发送失败策略\n\n异步发送失败重试时，异步重试不会选择其他broker，仅在同一个broker上做重试，所以该策略无法保证消息不丢。\n\n```java\nDefaultMQProducer producer = new DefaultMQProducer(\"pg\");\nproducer.setNamesrvAddr(\"rocketmqOS:9876\");\n// 指定异步发送失败后不进行重试发送\nproducer.setRetryTimesWhenSendAsyncFailed( 0 );\n```\n### 4 消息刷盘失败策略\n\n消息刷盘超时（Master或Slave）或slave不可用（slave在做数据同步时向master返回状态不是SEND_OK）时，默认是不会将消息尝试发送到其他Broker的。不过，对于重要消息可以通过在Broker的配置文件设置retryAnotherBrokerWhenNotStoreOK属性为true来开启。\n\n## 八、消息消费重试机制\n\n### 1 顺序消息的消费重试\n\n对于顺序消息，当Consumer消费消息失败后，为了保证消息的顺序性，其会自动不断地进行消息重试，直到消费成功。消费重试默认间隔时间为 1000 毫秒。重试期间应用会出现消息消费被阻塞的情况。\n```java\nDefaultMQPushConsumer consumer = new DefaultMQPushConsumer(\"cg\");\n// 顺序消息消费失败的消费重试时间间隔，单位毫秒，默认为 1000 ，其取值范围为[10,30000]\nconsumer.setSuspendCurrentQueueTimeMillis( 100 );\n```\n\n>由于对顺序消息的重试是无休止的，不间断的，直至消费成功，所以，对于顺序消息的消费，务必要保证应用能够及时监控并处理消费失败的情况，避免消费被永久性阻塞。<br><br>\n注意，顺序消息没有发送失败重试机制，但具有消费失败重试机制\n\n### 2 无序消息的消费重试\n\n对于无序消息（普通消息、延时消息、事务消息），当Consumer消费消息失败时，可以通过设置返回状态达到消息重试的效果。不过需要注意，无序消息的重试`只对集群消费方式生效`，广播消费方式不提供失败重试特性。即对于广播消费，消费失败后，失败消息不再重试，继续消费后续消息。\n\n### 3 消费重试次数与间隔\n对于`无序消息集群`消费下的重试消费，每条消息默认最多重试 16 次，但每次重试的间隔时间是不同的，会逐渐变长。每次重试的间隔时间如下表。\n\n重试次数|与上次重试的间隔时间|重试次数|与上次重试的间隔时间\n--|:--:|--:|--:\n1|10秒|9|7分钟\n2|30|10|8 分钟\n3|1分钟|11|9 分钟\n4|2分钟|12|10分钟\n5|3分钟|13|20分钟\n6|4分钟|14|30分钟\n7|5分钟|15|1小时\n8|6分钟|16|2 小时\n\n>若一条消息在一直消费失败的前提下，将会在正常消费后的第 `4 小时 46 分`后进行第 16 次重试。<br>\n若仍然失败，则将消息投递到`死信队列`<br><br>\n修改消费重试次数<br>\n```\nDefaultMQPushConsumer consumer = new DefaultMQPushConsumer(\"cg\");\n// 修改消费重试次数\nconsumer.setMaxReconsumeTimes( 10 );\n```\n>对于修改过的重试次数，将按照以下策略执行：<br>\n1)若修改值小于 16 ，则按照指定间隔进行重试<br>\n2)若修改值大于 16 ，则超过 16 次的重试时间间隔均为 2 小时<br><br>\n对于Consumer Group，若仅修改了一个Consumer的消费重试次数，则会应用到该Group中所有其它Consumer实例。若出现多个Consumer均做了修改的情况，则采用覆盖方式生效。即最后被修改的值会覆盖前面设置的值。\n\n\n### 4 重试队列\n\n对于需要重试消费的消息，并不是Consumer在等待了指定时长后再次去拉取原来的消息进行消费，而是将这些需要重试消费的消息放入到了一个特殊Topic的队列中，而后进行再次消费的。这个特殊的队列就是重试队列。\n\n当出现需要进行重试消费的消息时，Broker会为每个消费组都设置一个Topic名称为`%RETRY%consumerGroup@consumerGroup`的重试队列。\n\n>1 ）这个重试队列是针对消息才组的，而不是针对每个Topic设置的（一个Topic的消息可以让多个消费者组进行消费，所以会为这些消费者组各创建一个重试队列）<br>\n2 ）只有当出现需要进行重试消费的消息时，才会为该消费者组创建重试队列\n\n![输入图片说明](rocketmq/QQ截图20220208163646.png \"QQ截图20201229183512.png\")\n\n>注意，消费重试的时间间隔与`延时消费`的`延时等级`十分相似，除了没有延时等级的前两个时间外，其它的时间都是相同的\n\nBroker对于重试消息的处理是通过`延时消息`实现的。先将消息保存到SCHEDULE_TOPIC_XXXX延迟队列中，延迟时间到后，会将消息投递到%RETRY%consumerGroup@consumerGroup重试队列中。\n\n### 5 消费重试配置方式\n![输入图片说明](rocketmq/QQ截图20220208163740.png \"QQ截图20201229183512.png\")\n\n集群消费方式下，消息消费失败后若希望消费重试，则需要在消息监听器接口的实现中明确进行如下三种方式之一的配置：\n\n* 方式 1 ：返回ConsumeConcurrentlyStatus.RECONSUME_LATER（推荐）\n* 方式 2 ：返回Null\n* 方式 3 ：抛出异常\n\n### 6 消费不重试配置方式\n![输入图片说明](rocketmq/QQ截图20220208163826.png \"QQ截图20201229183512.png\")\n\n集群消费方式下，消息消费失败后若不希望消费重试，则在捕获到异常后同样也返回与消费成功后的相同的结果，即ConsumeConcurrentlyStatus.CONSUME_SUCCESS，则不进行消费重试。\n\n## 九、死信队列\n\n### 1 什么是死信队列\n当一条消息初次消费失败，消息队列会自动进行消费重试；达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确地消费该消息，此时，消息队列不会立刻将消息丢弃，而是将其发送到该消费者对应的特殊队列中。这个队列就是死信队列（Dead-Letter Queue，DLQ），而其中的消息\n则称为死信消息（Dead-Letter Message，DLM）。\n\n>死信队列是用于处理无法被正常消费的消息的。\n\n### 2 死信队列的特征\n\n#### 死信队列具有如下特征：\n\n* 死信队列中的消息不会再被消费者正常消费，即DLQ对于消费者是不可见的\n* 死信存储有效期与正常消息相同，均为 3 天（commitlog文件的过期时间）， 3 天后会被自动删除\n* 死信队列就是一个特殊的Topic，名称为%DLQ%consumerGroup@consumerGroup，即每个消费者组都有一个死信队列\n* 如果一个消费者组未产生死信消息，则不会为其创建相应的死信队列\n\n### 3 死信消息的处理\n\n实际上，当一条消息进入死信队列，就意味着系统中某些地方出现了问题，从而导致消费者无法正常消费该消息，比如代码中原本就存在Bug。因此，对于死信消息，通常需要开发人员进行特殊处理。最关键的步骤是要排查可疑因素，解决代码中可能存在的Bug，然后再将原来的死信消息再次进行投递消费。","source":"_posts/rocketmq.md","raw":"---\ntitle: RocketMQ\ndate: 2022-07-08 14:51:12\ntags: \n - mq\n - 消息中间件\ncategories: 消息中间件\ncover: http://rebp38war.bkt.clouddn.com/img/7c0175abf66c66d22b32061633d5cf7d.jpeg\n---\n\n# 第1章 RocketMQ概述\n## 一、MQ概述\n### 1 、MQ简介\nMQ，Message Queue，是一种提供消息队列服务的中间件，也称为消息中间件，是一套提供了消息生产、存储、消费全过程API的软件系统。消息即数据。一般消息的体量不会很大。\n\n### 2 、MQ用途\n从网上可以查看到很多的关于MQ用途的叙述，但总结起来其实就以下三点。\n\n* 限流削峰\n    * MQ可以将系统的超量请求暂存其中，以便系统后期可以慢慢进行处理，从而避免了请求的丢失或系统被压垮。\n    ![输入图片说明](rocketmq/QQ截图20220208101908.png \"QQ截图20201229183512.png\")\n\n* 异步解耦\n    * 上游系统对下游系统的调用若为同步调用，则会大大降低系统的吞吐量与并发度，且系统耦合度太高。而异步调用则会解决这些问题。所以两层之间若要实现由同步到异步的转化，一般性做法就是，在这两层间添加一个MQ层。\n\n![输入图片说明](rocketmq/QQ截图20220208102000.png \"QQ截图20201229183512.png\")\n\n* 数据收集\n    * 分布式系统会产生海量级数据流，如：业务日志、监控数据、用户行为等。针对这些数据流进行实时或批量采集汇总，然后对这些数据流进行大数据分析，这是当前互联网平台的必备技术。通过MQ完成此类数据收集是最好的选择。\n### 3 、常见MQ产品\n\n* ActiveMQ\n    * ActiveMQ是使用Java语言开发一款MQ产品。早期很多公司与项目中都在使用。但现在的社区活跃度已经很低。现在的项目中已经很少使用了。\n\n* RabbitMQ\n    * RabbitMQ是使用ErLang语言开发的一款MQ产品。其吞吐量较Kafka与RocketMQ要低，且由于其不是Java语言开发，所以公司内部对其实现定制化开发难度较大。\n\n* Kafka\n    * Kafka是使用Scala/Java语言开发的一款MQ产品。其最大的特点就是高吞吐率，常用于大数据领域的实时计算、日志采集等场景。其没有遵循任何常见的MQ协议，而是使用自研协议。对于Spring CloudNetçix，其仅支持RabbitMQ与Kafka。\n\n* RocketMQ\n    * RocketMQ是使用Java语言开发的一款MQ产品。经过数年阿里双 11 的考验，性能与稳定性非常高。其没有遵循任何常见的MQ协议，而是使用自研协议。对于Spring Cloud Alibaba，其支持RabbitMQ、Kafka，但提倡使用RocketMQ。\n\n#### 对比\n\n关键词|ACTIVEMQ|RABBITMQ|KAFKA|ROCKETMQ\n--|:--:|--:|--:|--:\n开发语言|Java|ErLang|Java|Java\n单机吞吐量|万级|万级|十万级|十万级\nTopic|-|-|百级Topic时会影响系统吞吐量|千级Topic时会影响系统吞吐\n社区活跃度|低|高|高|高\n\n### 4 、MQ常见协议\n\n##### 一般情况下MQ的实现是要遵循一些常规性协议的。常见的协议如下：\n\n###### JMS\n>JMS，Java Messaging Service（Java消息服务）。是Java平台上有关MOM（Message OrientedMiddleware，面向消息的中间件 PO/OO/AO）的技术规范，它便于消息系统中的Java应用程序进行消息交换，并且通过提供标准的产生、发送、接收消息的接口，简化企业应用的开发。ActiveMQ是该协议的典型实现。\n\n###### STOMP\n>STOMP，Streaming Text Orientated Message Protocol（面向流文本的消息协议），是一种MOM设计的简单文本协议。STOMP提供一个可互操作的连接格式，允许客户端与任意STOMP消息代理（Broker）进行交互。ActiveMQ是该协议的典型实现，RabbitMQ通过插件可以支持该协议。\n\n###### AMQP\n>AMQP，Advanced Message Queuing Protocol（高级消息队列协议），一个提供统一消息服务的应用层标准，是应用层协议的一个开放标准，是一种MOM设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同开发语言等条件的限制。 RabbitMQ是该协议的典型实现。\n\n###### MQTT\n>MQTT，Message Queuing Telemetry Transport（消息队列遥测传输），是IBM开发的一个即时通讯协议，是一种二进制协议，主要用于服务器和低功耗IoT（物联网）设备间的通信。该协议支持所有平台，几乎可以把所有联网物品和外部连接起来，被用来当做传感器和致动器的通信协议。 RabbitMQ通过插件可以支持该协议。\n\n## 二、RocketMQ概述\n\n### 1 、RocketMQ简介\n>RocketMQ是一个统一消息引擎、轻量级数据处理平台。RocketMQ是一款阿里巴巴开源的消息中间件。 2016 年 11 月 28 日，阿里巴巴向 Apache 软件基金会捐赠RocketMQ，成为 Apache 孵化项目。 2017 年 9 月 25 日，Apache 宣布 RocketMQ孵化成为 Apache 顶级项目（TLP ），成为国内首个互联网中间件在 Apache 上的顶级项目。\n\n官网地址：http://rocketmq.apache.org\n\n### 2 、RocketMQ发展历程\n![输入图片说明](rocketmq/QQ截图20220208103522.png \"QQ截图20201229183512.png\")\n* 2007 年，阿里开始五彩石项目，Notify作为项目中交易核心消息流转系统，应运而生。Notify系统是RocketMQ的雏形。\n* 2010 年，B2B大规模使用ActiveMQ作为阿里的消息内核。阿里急需一个具有海量堆积能力的消息系统。\n* 2011 年初，Kafka开源。淘宝中间件团队在对Kafka进行了深入研究后，开发了一款新的MQ，MetaQ。\n* 2012 年，MetaQ发展到了v3.0版本，在它基础上进行了进一步的抽象，形成了RocketMQ，然后就将其进行了开源。\n* 2015 年，阿里在RocketMQ的基础上，又推出了一款专门针对阿里云上用户的消息系统Aliware MQ。\n* 2016 年双十一，RocketMQ承载了万亿级消息的流转，跨越了一个新的里程碑。 11 月 28 日，阿里巴巴向 Apache 软件基金会捐赠 RocketMQ，成为 Apache 孵化项目。\n* 2017 年 9 月 25 日，Apache 宣布 RocketMQ孵化成为 Apache 顶级项目（TLP ），成为国内首个互联网中间件在 Apache 上的顶级项目。\n\n# 第 2 章 RocketMQ的安装与启动\n## 一、基本概念\n### 1 消息（Message）\n>消息是指，消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题。\n\n### 2 主题（Topic）\n![输入图片说明](rocketmq/QQ截图20220208103828.png \"QQ截图20201229183512.png\")\n\nTopic表示一类消息的集合，每个主题包含若干条消息，每条消息只能属于一个主题，是RocketMQ进行消息订阅的基本单位。 topic:message 1:n message:topic 1:1\n\n一个生产者可以同时发送多种Topic的消息；而一个消费者只对某种特定的Topic感兴趣，即只可以订阅\n和消费一种Topic的消息。 producer:topic 1:n consumer:topic 1:1\n\n### 3 标签（Tag）\n>为消息设置的标签，用于同一主题下区分不同类型的消息。来自同一业务单元的消息，可以根据不同业务目的在同一主题下设置不同标签。标签能够有效地保持代码的清晰度和连贯性，并优化RocketMQ提供的查询系统。消费者可以根据Tag实现对不同子主题的不同消费逻辑，实现更好的扩展性。\n\nTopic是消息的一级分类，Tag是消息的二级分类。\n* Topic：货物\n    * tag=上海\n    * tag=江苏\n    * tag=浙江\n\n#### ------- 消费者 -----\n\n* topic=货物 tag = 上海\n* topic=货物 tag = 上海|浙江\n* topic=货物 tag = *\n\n### 4 队列（Queue）\n存储消息的物理实体。一个Topic中可以包含多个Queue，每个Queue中存放的就是该Topic的消息。一个Topic的Queue也被称为一个Topic中消息的分区（Partition）。\n\n一个Topic的Queue中的消息只能被一个消费者组中的一个消费者消费。一个Queue中的消息不允许同一个消费者组中的多个消费者同时消费。\n\n![输入图片说明](rocketmq/QQ截图20220208104018.png \"QQ截图20201229183512.png\")\n\n在学习参考其它相关资料时，还会看到一个概念：分片（Sharding）。分片不同于分区。在RocketMQ中，分片指的是存放相应Topic的Broker。每个分片中会创建出相应数量的分区，即Queue，每个Queue的大小都是相同的。\n\n![输入图片说明](rocketmq/QQ截图20220208104611.png \"QQ截图20201229183512.png\")\n\n### 5 消息标识（MessageId/Key）\n\nRocketMQ中每个消息拥有唯一的MessageId，且可以携带具有业务标识的Key，以方便对消息的查询。不过需要注意的是，MessageId有两个：在生产者send()消息时会自动生成一个MessageId（msgId)，当消息到达Broker后，Broker也会自动生成一个MessageId(offsetMsgId)。msgId、offsetMsgId与key都称为消息标识。\n\n* msgId：由producer端生成，其生成规则为：producerIp + 进程pid + MessageClientIDSetter类的ClassLoader的hashCode +当前时间 + AutomicInteger自增计数器\n* offsetMsgId：由broker端生成，其生成规则为：brokerIp + 物理分区的offset（Queue中的偏移量）\n* key：由用户指定的业务相关的唯一标识\n\n## 二、系统架构\n\n![输入图片说明](rocketmq/QQ截图20220208104741.png \"QQ截图20201229183512.png\")\n\nRocketMQ架构上主要分为四部分构成：\n### 1 Producer\n消息生产者，负责生产消息。Producer通过MQ的负载均衡模块选择相应的Broker集群队列进行消息投\n递，投递的过程支持快速失败并且低延迟。\n> 例如，业务系统产生的日志写入到MQ的过程，就是消息生产的过程\n\n> 再如，电商平台中用户提交的秒杀请求写入到MQ的过程，就是消息生产的过程\n\nRocketMQ中的消息生产者都是以生产者组（Producer Group）的形式出现的。生产者组是同一类生产者的集合，这类Producer发送相同Topic类型的消息。一个生产者组可以同时发送多个主题的消息。\n\n### 2 Consumer\n\n消息消费者，负责消费消息。一个消息消费者会从Broker服务器中获取到消息，并对消息进行相关业务处理。\n\n>例如，QoS系统从MQ中读取日志，并对日志进行解析处理的过程就是消息消费的过程。\n\n>再如，电商平台的业务系统从MQ中读取到秒杀请求，并对请求进行处理的过程就是消息消费的过程。\n\nRocketMQ中的消息消费者都是以消费者组（Consumer Group）的形式出现的。消费者组是同一类消费者的集合，这类Consumer消费的是同一个Topic类型的消息。消费者组使得在消息消费方面，实现负载均衡（将一个Topic中的不同的Queue平均分配给同一个Consumer Group的不同的Consumer，注意，并不是将消息负载均衡）和容错（一个Consmer挂了，该Consumer Group中的其它Consumer可以接着消费原Consumer消费的Queue）的目标变得非常容易。\n\n![输入图片说明](rocketmq/QQ截图20220208105007.png \"QQ截图20201229183512.png\")\n\n消费者组中Consumer的数量应该小于等于订阅Topic的Queue数量。如果超出Queue数量，则多出的Consumer将不能消费消息。\n\n![输入图片说明](rocketmq/QQ截图20220208105040.png \"QQ截图20201229183512.png\")\n\n不过，一个Topic类型的消息可以被多个消费者组同时消费。\n>注意，\n* 1 ）消费者组只能消费一个Topic的消息，不能同时消费多个Topic消息\n* 2 ）一个消费者组中的消费者必须订阅完全相同的Topic\n\n### 3 Name Server\n\n#### 功能介绍\n\nNameServer是一个Broker与Topic路由的注册中心，支持Broker的动态注册与发现。\n\nRocketMQ的思想来自于Kafka，而Kafka是依赖了Zookeeper的。所以，在RocketMQ的早期版本，即在MetaQ v1.0与v2.0版本中，也是依赖于Zookeeper的。从MetaQ v3.0，即RocketMQ开始去掉了Zookeeper依赖，使用了自己的NameServer。\n\n#### 主要包括两个功能：\n\n* `Broker管理：`接受Broker集群的注册信息并且保存下来作为路由信息的基本数据；提供心跳检测机制，检查Broker是否还存活。\n* `路由信息管理：`每个NameServer中都保存着Broker集群的整个路由信息和用于客户端查询的队列信息。Producer和Conumser通过NameServer可以获取整个Broker集群的路由信息，从而进行消息的投递和消费。\n\n#### 路由注册\n\nNameServer通常也是以集群的方式部署，不过，NameServer是无状态的，即NameServer集群中的各个节点间是无差异的，各节点间相互不进行信息通讯。那各节点中的数据是如何进行数据同步的呢？在Broker节点启动时，轮询NameServer列表，与每个NameServer节点建立长连接，发起注册请求。在NameServer内部维护着一个Broker列表，用来动态存储Broker的信息。\n\n>注意，这是与其它像zk、Eureka、Nacos等注册中心不同的地方。<br>\n这种NameServer的无状态方式，有什么优缺点：<br>\n优点：NameServer集群搭建简单，扩容简单。<br>\n缺点：对于Broker，必须明确指出所有NameServer地址。否则未指出的将不会去注册。也正因为如此，NameServer并不能随便扩容。因为，若Broker不重新配置，新增的NameServer对于Broker来说是不可见的，其不会向这个NameServer进行注册。\n\nBroker节点为了证明自己是活着的，为了维护与NameServer间的长连接，会将最新的信息以心跳包的方式上报给NameServer，每 30 秒发送一次心跳。心跳包中包含 BrokerId、Broker地址(IP+Port)、Broker名称、Broker所属集群名称等等。NameServer在接收到心跳包后，会更新心跳时间戳，记录这个Broker的最新存活时间。\n\n#### 路由剔除\n\n由于Broker关机、宕机或网络抖动等原因，NameServer没有收到Broker的心跳，NameServer可能会将其从Broker列表中剔除。\n\nNameServer中有一个定时任务，每隔 10 秒就会扫描一次Broker表，查看每一个Broker的最新心跳时间戳距离当前时间是否超过 120 秒，如果超过，则会判定Broker失效，然后将其从Broker列表中剔除。\n\n>扩展：对于RocketMQ日常运维工作，例如Broker升级，需要停掉Broker的工作。OP需要怎么做？<br>\nOP需要将Broker的读写权限禁掉。一旦client(Consumer或Producer)向broker发送请求，都会收到broker的NO_PERMISSION响应，然后client会进行对其它Broker的重试。<br>\n当OP观察到这个Broker没有流量后，再关闭它，实现Broker从NameServer的移除。<br>\nOP：运维工程师<br>\nSRE：Site Reliability Engineer，现场可靠性工程师\n\n#### 路由发现\nRocketMQ的路由发现采用的是Pull模型。当Topic路由信息出现变化时，NameServer不会主动推送给客户端，而是客户端定时拉取主题最新的路由。默认客户端每 30 秒会拉取一次最新的路由。\n\n>扩展：<br>\n1 ）Push模型：推送模型。其实时性较好，是一个“发布-订阅”模型，需要维护一个长连接。而长连接的维护是需要资源成本的。该模型适合于的场景：<br>\n    * 实时性要求较高<br>\n    * Client数量不多，Server数据变化较频繁<br>\n2 ）Pull模型：拉取模型。存在的问题是，实时性较差。\n<br>\n3 ）Long Polling模型：长轮询模型。其是对Push与Pull模型的整合，充分利用了这两种模型的优势，屏蔽了它们的劣势。\n\n#### 客户端NameServer选择策略\n\n>这里的客户端指的是Producer与Consumer\n\n客户端在配置时必须要写上NameServer集群的地址，那么客户端到底连接的是哪个NameServer节点呢？客户端首先会生产一个随机数，然后再与NameServer节点数量取模，此时得到的就是所要连接的节点索引，然后就会进行连接。如果连接失败，则会采用round-robin策略，逐个尝试着去连接其它节点。\n\n首先采用的是`随机策略`进行的选择，失败后采用的是`轮询策略`。\n\n>扩展：Zookeeper Client是如何选择Zookeeper Server的？<br>\n简单来说就是，经过两次Shufæe，然后选择第一台Zookeeper Server。<br>\n详细说就是，将配置文件中的zk server地址进行第一次shufæe，然后随机选择一个。这个选择出的一般都是一个hostname。然后获取到该hostname对应的所有ip，再对这些ip进行第二次shufæe，从shufæe过的结果中取第一个server地址进行连接。\n\n### 4 Broker\n\n#### 功能介绍\n\nBroker充当着消息中转角色，负责存储消息、转发消息。Broker在RocketMQ系统中负责接收并存储从生产者发送来的消息，同时为消费者的拉取请求作准备。Broker同时也存储着消息相关的元数据，包括消费者组消费进度偏移offset、主题、队列等。\n\n>Kafka 0.8版本之后，offset是存放在Broker中的，之前版本是存放在Zookeeper中的。\n\n#### 模块构成\n下图为Broker Server的功能模块示意图。\n\n![输入图片说明](rocketmq/QQ截图20220208110201.png \"QQ截图20201229183512.png\")\n\n`Remoting Module`：整个Broker的实体，负责处理来自clients端的请求。而这个Broker实体则由以下模块构成。\n\n`Client Manager：`客户端管理器。负责接收、解析客户端(Producer/Consumer)请求，管理客户端。例如，维护Consumer的Topic订阅信息\n\n`Store Service：`存储服务。提供方便简单的API接口，处理消息存储到物理硬盘和消息查询功能。\n\n`HA Service：`高可用服务，提供Master Broker 和 Slave Broker之间的数据同步功能。\n\n`Index Service：`索引服务。根据特定的Message key，对投递到Broker的消息进行索引服务，同时也提供根据Message Key对消息进行快速查询的功能。\n\n#### 集群部署\n![输入图片说明](rocketmq/QQ截图20220208110311.png \"QQ截图20201229183512.png\")\n\n为了增强Broker性能与吞吐量，Broker一般都是以集群形式出现的。各集群节点中可能存放着相同Topic的不同Queue。不过，这里有个问题，如果某Broker节点宕机，如何保证数据不丢失呢？其解决方案是，将每个Broker集群节点进行横向扩展，即将Broker节点再建为一个HA集群，解决单点问题。\n\nBroker节点集群是一个主从集群，即集群中具有Master与Slave两种角色。Master负责处理读写操作请求，Slave负责对Master中的数据进行备份。当Master挂掉了，Slave则会自动切换为Master去工作。所以这个Broker集群是主备集群。一个Master可以包含多个Slave，但一个Slave只能隶属于一个Master。Master与Slave 的对应关系是通过指定相同的BrokerName、不同的BrokerId 来确定的。BrokerId为 0 表示Master，非 0 表示Slave。每个Broker与NameServer集群中的所有节点建立长连接，定时注册Topic信息到所有NameServer。\n\n### 5 工作流程\n\n#### 具体流程\n\n* 1 ）启动NameServer，NameServer启动后开始监听端口，等待Broker、Producer、Consumer连接。\n\n* 2 ）启动Broker时，Broker会与所有的NameServer建立并保持长连接，然后每 30 秒向NameServer定时发送心跳包。\n\n* 3 ）发送消息前，可以先创建Topic，创建Topic时需要指定该Topic要存储在哪些Broker上，当然，在创建Topic时也会将Topic与Broker的关系写入到NameServer中。不过，这步是可选的，也可以在发送消息时自动创建Topic。\n\n* 4 ）Producer发送消息，启动时先跟NameServer集群中的其中一台建立长连接，并从NameServer中获取路由信息，即当前发送的Topic消息的Queue与Broker的地址（IP+Port）的映射关系。然后根据算法策略从队选择一个Queue，与队列所在的Broker建立长连接从而向Broker发消息。当然，在获取到路由信息后，Producer会首先将路由信息缓存到本地，再每 30 秒从NameServer更新一次路由信息。\n\n* 5 ）Consumer跟Producer类似，跟其中一台NameServer建立长连接，获取其所订阅Topic的路由信息，然后根据算法策略从路由信息中获取到其所要消费的Queue，然后直接跟Broker建立长连接，开始消费其中的消息。Consumer在获取到路由信息后，同样也会每 30 秒从NameServer更新一次路由信息。不过不同于Producer的是，Consumer还会向Broker发送心跳，以确保Broker的存活状态。\n\n#### Topic的创建模式\n\n手动创建Topic时，有两种模式：\n* 集群模式：该模式下创建的Topic在该集群中，所有Broker中的Queue数量是相同的。\n* Broker模式：该模式下创建的Topic在该集群中，每个Broker中的Queue数量可以不同。\n\n自动创建Topic时，默认采用的是Broker模式，会为每个Broker默认创建 4 个Queue。\n\n#### 读/写队列\n从物理上来讲，读/写队列是同一个队列。所以，不存在读/写队列数据同步问题。读/写队列是逻辑上进行区分的概念。一般情况下，读/写队列数量是相同的。\n\n\n例如，创建Topic时设置的写队列数量为 8 ，读队列数量为 4 ，此时系统会创建 8 个Queue，分别是0 1 2 3 4 5 6 7。Producer会将消息写入到这 8 个队列，但Consumer只会消费0 1 2 3这 4 个队列中的消息，4 5 6 7 中的消息是不会被消费到的。\n\n再如，创建Topic时设置的写队列数量为 4 ，读队列数量为 8 ，此时系统会创建 8 个Queue，分别是0 1 2 3 4 5 6 7。Producer会将消息写入到0 1 2 3 这 4 个队列，但Consumer只会消费0 1 2 3 4 5 6 7这 8 个队列中的消息，但是4 5 6 7中是没有消息的。此时假设Consumer Group中包含两个Consumer，Consumer1消费0 1 2 3，而Consumer2消费4 5 6 7。但实际情况是，Consumer2是没有消息可消费的。\n\n也就是说，当读/写队列数量设置不同时，总是有问题的。那么，为什么要这样设计呢？\n\n其这样设计的目的是为了，方便Topic的Queue的缩容。\n\n例如，原来创建的Topic中包含 16 个Queue，如何能够使其Queue缩容为 8 个，还不会丢失消息？可以动态修改写队列数量为 8 ，读队列数量不变。此时新的消息只能写入到前 8 个队列，而消费都消费的却是16 个队列中的数据。当发现后 8 个Queue中的消息消费完毕后，就可以再将读队列数量动态设置为 8 。整个缩容过程，没有丢失任何消息。\n\nperm用于设置对当前创建Topic的操作权限： 2 表示只写， 4 表示只读， 6 表示读写。\n\n## 三、单机安装与启动\n\n### 1 准备工作\n\n#### 软硬件需求\n\n#### 系统要求是 64 位的，JDK要求是1.8及其以上版本的。\n\n![输入图片说明](rocketmq/QQ截图20220208110713.png \"QQ截图20201229183512.png\")\n\n下载RocketMQ安装包\n\n![输入图片说明](rocketmq/QQ截图20220208110738.png \"QQ截图20201229183512.png\")\n\n将下载的安装包上传到Linux。\n\n![输入图片说明](rocketmq/QQ截图20220208110807.png \"QQ截图20201229183512.png\")\n\n解压。\n\n![输入图片说明](rocketmq/QQ截图20220208110821.png \"QQ截图20201229183512.png\")\n\n### 2 、修改初始内存\n\n修改runserver.sh\n\n使用vim命令打开bin/runserver.sh文件。现将这些值修改为如下：\n\n![输入图片说明](rocketmq/QQ截图20220208110900.png \"QQ截图20201229183512.png\")\n\n修改runbroker.sh\n\n使用vim命令打开bin/runbroker.sh文件。现将这些值修改为如下：\n\n![输入图片说明](rocketmq/QQ截图20220208110924.png \"QQ截图20201229183512.png\")\n### 3 、启动\n\n启动NameServer\n\n```shell\nnohup sh bin/mqnamesrv &\ntail -f ~/logs/rocketmqlogs/namesrv.log\n```\n\n![输入图片说明](rocketmq/QQ截图20220208111000.png \"QQ截图20201229183512.png\")\n\n\n`如果出现mq启动报错ERROR: Please set the JAVA_HOME variable in your environment, We need java(x64)! !!`\n```shell\nln -s /usr/local/jdk1.8.0_191/bin/javac /usr/bin/javac\nln -s  /usr/local/jdk1.8.0_191/bin/jar /usr/bin/jar\nln -s /usr/local/jdk1.8.0_191/bin/java /bin/java\n```\n\n启动broker\n\n```shell\nnohup sh bin/mqbroker -n localhost:9876 &\ntail -f ~/logs/rocketmqlogs/broker.log\n```\n\n![输入图片说明](rocketmq/QQ截图20220208111020.png \"QQ截图20201229183512.png\")\n\n### 4 、发送/接收消息测试\n\n#### 发送消息\n```shell\nexport NAMESRV_ADDR=localhost:9876\nsh bin/tools.sh org.apache.rocketmq.example.quickstart.Producer\n```\n#### 接收消息\n```shell\nsh bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer\n```\n### 5 、关闭Server\n\n无论是关闭name server还是broker，都是使用bin/mqshutdown命令。\n\n```shell\n[root@mqOS rocketmq]# sh bin/mqshutdown broker\nThe mqbroker(1740) is running...\nSend shutdown request to mqbroker(1740) OK\n\n[root@mqOS rocketmq]# sh bin/mqshutdown namesrv\nThe mqnamesrv(1692) is running...\nSend shutdown request to mqnamesrv(1692) OK\n[2]+ 退出 143 nohup sh bin/mqbroker -n localhost:9876\n\n```\n\n## 四、 控制台的安装与启动\n\nRocketMQ有一个可视化的dashboard，通过该控制台可以直观的查看到很多数据。\n\n### 1 下载\n\n下载地址：https://github.com/apache/rocketmq-externals/releases\n\n![输入图片说明](rocketmq/QQ截图20220208111255.png \"QQ截图20201229183512.png\")\n\n### 2 修改配置\n\n修改其src/main/resources中的application.properties配置文件。\n\n* 原来的端口号为 8080 ，修改为一个不常用的\n* 指定RocketMQ的name server地址\n\n![输入图片说明](rocketmq/QQ截图20220208111351.png \"QQ截图20201229183512.png\")\n\n### 3 添加依赖\n\n在解压目录rocketmq-console的pom.xml中添加如下JAXB依赖。\n\n>JAXB，Java Architechture for Xml Binding，用于XML绑定的Java技术，是一个业界标准，是一项可以根据XML Schema生成Java类的技术。\n\n```xml\n<dependency>\n    <groupId>javax.xml.bind</groupId>\n    <artifactId>jaxb-api</artifactId>\n    <version>2.3.0</version>\n</dependency>\n<dependency>\n    <groupId>com.sun.xml.bind</groupId>\n    <artifactId>jaxb-impl</artifactId>\n    <version>2.3.0</version>\n</dependency>\n<dependency>\n    <groupId>com.sun.xml.bind</groupId>\n    <artifactId>jaxb-core</artifactId>\n    <version>2.3.0</version>\n</dependency>\n<dependency>\n    <groupId>javax.activation</groupId>\n    <artifactId>activation</artifactId>\n    <version>1.1.1</version>\n</dependency>\n```\n### 4 打包\n\n在rocketmq-console目录下运行maven的打包命令。\n\n![输入图片说明](rocketmq/QQ截图20220208111536.png \"QQ截图20201229183512.png\")\n\n![输入图片说明](rocketmq/QQ截图20220208111646.png \"QQ截图20201229183512.png\")\n### 5 启动\n![输入图片说明](rocketmq/QQ截图20220208111700.png \"QQ截图20201229183512.png\")\n### 6 访问\n![输入图片说明](rocketmq/QQ截图20220208111724.png \"QQ截图20201229183512.png\")\n\n## 五、集群搭建理论\n\n![输入图片说明](rocketmq/QQ截图20220208111755.png \"QQ截图20201229183512.png\")\n\n### 1 数据复制与刷盘策略\n\n![输入图片说明](rocketmq/QQ截图20220208111822.png \"QQ截图20201229183512.png\")\n\n#### 复制策略\n\n复制策略是Broker的Master与Slave间的数据同步方式。分为同步复制与异步复制：\n\n* 同步复制：消息写入master后，master会等待slave同步数据成功后才向producer返回成功ACK\n* 异步复制：消息写入master后，master立即向producer返回成功ACK，无需等待slave同步数据成功\n\n>异步复制策略会降低系统的写入延迟，RT变小，提高了系统的吞吐量\n\n#### 刷盘策略\n\n刷盘策略指的是broker中消息的落盘方式，即消息发送到broker内存后消息持久化到磁盘的方式。分为同步刷盘与异步刷盘.\n\n* 同步刷盘：当消息持久化到broker的磁盘后才算是消息写入成功。\n* 异步刷盘：当消息写入到broker的内存后即表示消息写入成功，无需等待消息持久化到磁盘。\n\n>1 ）异步刷盘策略会降低系统的写入延迟，RT变小，提高了系统的吞吐量<br>\n2 ）消息写入到Broker的内存，一般是写入到了PageCache<br>\n3 ）对于异步 刷盘策略，消息会写入到PageCache后立即返回成功ACK。但并不会立即做落盘操作，而是当PageCache到达一定量时会自动进行落盘。<br>\n\n\n### 2 Broker集群模式\n\n根据Broker集群中各个节点间关系的不同，Broker集群可以分为以下几类：\n\n#### 单Master\n\n只有一个broker（其本质上就不能称为集群）。这种方式也只能是在测试时使用，生产环境下不能使用，因为存在单点问题。\n\n#### 多Master\n\nbroker集群仅由多个master构成，不存在Slave。同一Topic的各个Queue会平均分布在各个master节点上。\n\n* 优点：配置简单，单个Master宕机或重启维护对应用无影响，在磁盘配置为RAID10时，即使机器宕机不可恢复情况下，由于RAID10磁盘非常可靠，消息也不会丢（异步刷盘丢失少量消息，同步刷盘一条不丢），性能最高；\n* 缺点：单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅（不可消费），消息实时性会受到影响。\n\n>以上优点的前提是，这些Master都配置了RAID磁盘阵列。如果没有配置，一旦出现某Master宕机，则会发生大量消息丢失的情况。\n\n#### 多Master多Slave模式-异步复制\n\nbroker集群由多个master构成，每个master又配置了多个slave（在配置了RAID磁盘阵列的情况下，一个master一般配置一个slave即可）。master与slave的关系是主备关系，即master负责处理消息的读写请求，而slave仅负责消息的备份与master宕机后的角色切换。\n\n异步复制即前面所讲的`复制策略`中的`异步复制策略`，即消息写入master成功后，master立即向producer返回成功ACK，无需等待slave同步数据成功。\n\n该模式的最大特点之一是，当master宕机后slave能够`自动切换`为master。不过由于slave从master的同步具有短暂的延迟（毫秒级），所以当master宕机后，这种异步复制方式可能会存在少量消息的丢失问题。\n\n>Slave从Master同步的延迟越短，其可能丢失的消息就越少<br><br>\n对于Master的RAID磁盘阵列，若使用的也是异步复制策略，同样也存在延迟问题，同样也可能会丢失消息。但RAID阵列的秘诀是微秒级的（因为是由硬盘支持的），所以其丢失的数据量会更少。\n\n#### 多Master多Slave模式-同步双写\n\n该模式是`多Master多Slave模式`的`同步复制`实现。所谓`同步双写`，指的是消息写入master成功后，master会等待slave同步数据成功后才向producer返回成功ACK，即master与slave都要写入成功后才会返回成功ACK，也即`双写`。该模式与`异步复制模式相比`，优点是消息的安全性更高，不存在消息丢失的情况。但单个消息的RT略高，从而导致性能要略低（大约低10%）。\n\n该模式存在一个大的问题：对于目前的版本，Master宕机后，Slave`不会自动切换`到Master。\n\n#### 最佳实践\n\n一般会为Master配置RAID10磁盘阵列，然后再为其配置一个Slave。即利用了RAID10磁盘阵列的高效、安全性，又解决了可能会影响订阅的问题。\n\n>1 ）RAID磁盘阵列的效率要高于Master-Slave集群。因为RAID是硬件支持的。也正因为如此，所以RAID阵列的搭建成本较高。<br><br>\n2 ）多Master+RAID阵列，与多Master多Slave集群的区别是什么？<br>\n1.多Master+RAID阵列，其仅仅可以保证数据不丢失，即不影响消息写入，但其可能会影响到消息的订阅。但其执行效率要远高于`多Master多Slave集群`<br>\n2.多Master多Slave集群，其不仅可以保证数据不丢失，也不会影响消息写入。其运行效率要低于`多Master+RAID阵列`\n\n## 六、磁盘阵列RAID（补充）\n\n### 1 RAID历史\n\n1988 年美国加州大学伯克利分校的 D. A. Patterson 教授等首次在论文 “A Case of Redundant Array of Inexpensive Disks” 中提出了 RAID 概念 ，即`廉价冗余磁盘阵列`（ Redundant Array of Inexpensive Disks ）。由于当时大容量磁盘比较昂贵， RAID 的基本思想是将多个容量较小、相对廉价的磁盘进行有机组合，从而以较低的成本获得与昂贵大容量磁盘相当的容量、性能、可靠性。随着磁盘成本和价格的不断降低， “廉价” 已经毫无意义。因此， RAID 咨询委员会（ RAID Advisory Board, RAB ）决定用“ 独立 ” 替代 “ 廉价 ” ，于时 RAID 变成了`独立磁盘冗余阵列`（ Redundant Array of Independent Disks ）。但这仅仅是名称的变化，实质内容没有改变。\n\n内存：32m 6.4G（IBM 10.1G）\n\n### 2 RAID等级\n\nRAID 这种设计思想很快被业界接纳， RAID 技术作为高性能、高可靠的存储技术，得到了非常广泛的应用。 RAID 主要利用镜像、数据条带和数据校验三种技术来获取高性能、可靠性、容错能力和扩展性，根据对这三种技术的使用策略和组合架构，可以把 RAID 分为不同的等级，以满足不同数据应用的需求。\n\nD. A. Patterson 等的论文中定义了 RAID0 ~ RAID6 原始 RAID 等级。随后存储厂商又不断推出 RAID7、 RAID10、RAID01 、 RAID50 、 RAID53 、 RAID100 等 RAID 等级，但这些并无统一的标准。目前业界与学术界公认的标准是 RAID0 ~ RAID6 ，而在实际应用领域中使用最多的 RAID 等级是 RAID0 、RAID1 、 RAID3 、 RAID5 、 RAID6 和 RAID10。\n\nRAID 每一个等级代表一种实现方法和技术，等级之间并无高低之分。在实际应用中，应当根据用户的数据应用特点，综合考虑可用性、性能和成本来选择合适的 RAID 等级，以及具体的实现方式。\n\n### 3 关键技术\n\n#### 镜像技术\n\n镜像技术是一种冗余技术，为磁盘提供数据备份功能，防止磁盘发生故障而造成数据丢失。对于 RAID而言，采用镜像技术最典型地的用法就是，同时在磁盘阵列中产生两个完全相同的数据副本，并且分布在两个不同的磁盘上。镜像提供了完全的数据冗余能力，当一个数据副本失效不可用时，外部系统仍可正常访问另一副本，不会对应用系统运行和性能产生影响。而且，镜像不需要额外的计算和校验，故障修复非常快，直接复制即可。镜像技术可以从多个副本进行并发读取数据，提供更高的读 I/O 性能，但不能并行写数据，写多个副本通常会导致一定的 I/O 性能下降。\n\n镜像技术提供了非常高的数据安全性，其代价也是非常昂贵的，需要至少双倍的存储空间。高成本限制了镜像的广泛应用，主要应用于至关重要的数据保护，这种场合下的数据丢失可能会造成非常巨大的损失。\n\n#### 数据条带技术\n数据条带化技术是一种自动将 I/O操作负载均衡到多个物理磁盘上的技术。更具体地说就是，将一块连续的数据分成很多小部分并把它们分别存储到不同磁盘上。这就能使多个进程可以并发访问数据的多个不同部分，从而获得最大程度上的 I/O 并行能力，极大地提升性能。\n\n#### 数据校验技术\n数据校验技术是指， RAID 要在写入数据的同时进行校验计算，并将得到的校验数据存储在 RAID 成员磁盘中。校验数据可以集中保存在某个磁盘或分散存储在多个不同磁盘中。当其中一部分数据出错时，就可以对剩余数据和校验数据进行反校验计算重建丢失的数据。\n\n数据校验技术相对于镜像技术的优势在于节省大量开销，但由于每次数据读写都要进行大量的校验运算，对计算机的运算速度要求很高，且必须使用硬件 RAID 控制器。在数据重建恢复方面，检验技术比镜像技术复杂得多且慢得多。\n\n### 4 RAID分类\n\n从实现角度看， RAID 主要分为软 RAID、硬 RAID 以及混合 RAID 三种。\n\n#### 软 RAID\n\n所有功能均有操作系统和 CPU 来完成，没有独立的 RAID 控制处理芯片和 I/O 处理芯片，效率自然最低。\n\n#### 硬 RAID\n\n配备了专门的 RAID 控制处理芯片和 I/O 处理芯片以及阵列缓冲，不占用 CPU 资源。效率很高，但成本也很高。\n\n#### 混合 RAID\n\n具备 RAID 控制处理芯片，但没有专门的I/O 处理芯片，需要 CPU 和驱动程序来完成。性能和成本在软RAID 和硬 RAID 之间。\n\n### 5 常见RAID等级详解\n\n#### JBOD\n\n![输入图片说明](rocketmq/QQ截图20220208113559.png \"QQ截图20201229183512.png\")\n\nJBOD ，Just a Bunch of Disks，磁盘簇。表示一个没有控制软件提供协调控制的磁盘集合，这是 RAID区别与 JBOD 的主要因素。 JBOD 将多个物理磁盘串联起来，提供一个巨大的逻辑磁盘。\n\nJBOD 的数据存放机制是由第一块磁盘开始按顺序往后存储，当前磁盘存储空间用完后，再依次往后面的磁盘存储数据。 JBOD 存储性能完全等同于单块磁盘，而且也不提供数据安全保护。\n\n>其只是简单提供一种扩展存储空间的机制，JBOD可用存储容量等于所有成员磁盘的存储空间之和\n\nJBOD 常指磁盘柜，而不论其是否提供 RAID 功能。不过，JBOD并非官方术语，官方称为Spanning。\n\n#### RAID0\n\n![输入图片说明](rocketmq/QQ截图20220208113758.png \"QQ截图20201229183512.png\")\n\nRAID0 是一种简单的、无数据校验的`数据条带化技术`。实际上不是一种真正的 RAID ，因为它并不提供任何形式的冗余策略。 RAID0 将所在磁盘条带化后组成大容量的存储空间，将数据分散存储在所有磁盘中，以独立访问方式实现多块磁盘的并读访问。\n\n理论上讲，一个由 n 块磁盘组成的 RAID0 ，它的读写性能是单个磁盘性能的 n 倍，但由于总线带宽等多种因素的限制，实际的性能提升低于理论值。由于可以并发执行 I/O 操作，总线带宽得到充分利用。再加上不需要进行数据校验，`RAID0 的性能在所有 RAID 等级中是最高的`。\n\nRAID0 具有低成本、高读写性能、 100% 的高存储空间利用率等优点，但是它不提供数据冗余保护，一旦数据损坏，将无法恢复。\n\n应用场景：对数据的顺序读写要求不高，对数据的安全性和可靠性要求不高，但对系统性能要求很高的场景。\n\n>RAID0与JBOD相同点：<br>\n1 ）存储容量：都是成员磁盘容量总和<br>\n2 ）磁盘利用率，都是100%，即都没有做任何的数据冗余备份<br>\nRAID0与JBOD不同点：<br>\n1 ）JBOD：数据是顺序存放的，一个磁盘存满后才会开始存放到下一个磁盘<br>\n2 ）RAID：各个磁盘中的数据写入是并行的，是通过数据条带技术写入的。其读写性能是JBOD的n倍<br>\n\n#### RAID1\n\n![输入图片说明](rocketmq/QQ截图20220208121758.png \"QQ截图20201229183512.png\")\n\nRAID1 就是一种`镜像技术`，它将数据完全一致地分别写到工作磁盘和镜像磁盘，它的磁盘空间利用率为 50% 。 RAID1 在数据写入时，响应时间会有所影响，但是读数据的时候没有影响。 RAID1 提供了最佳的数据保护，一旦工作磁盘发生故障，系统将自动切换到镜像磁盘，不会影响使用。\n\nRAID1是为了增强数据安全性使两块磁盘数据呈现完全镜像，从而达到安全性好、技术简单、管理方便。 RAID1 拥有完全容错的能力，但实现成本高。\n\n应用场景：对顺序读写性能要求较高，或对数据安全性要求较高的场景。\n\n\n#### RAID10\n\n![输入图片说明](rocketmq/QQ截图20220208122057.png \"QQ截图20201229183512.png\")\n\nRAID10是一个RAID1与RAID0的组合体，所以它继承了RAID0的快速和RAID1的安全。简单来说就是，先做条带，再做镜像。发即将进来的数据先分散到不同的磁盘，再将磁盘中的数据做镜像。\n\n#### RAID01\n\n![输入图片说明](rocketmq/QQ截图20220208122113.png \"QQ截图20201229183512.png\")\n\nRAID01是一个RAID0与RAID1的组合体，所以它继承了RAID0的快速和RAID1的安全。简单来说就是，先做镜像再做条带。即将进来的数据先做镜像，再将镜像数据写入到与之前数据不同的磁盘，即再做条带。\n\n>RAID10要比RAID01的容错率再高，所以生产环境下一般是不使用RAID01的。\n#### 序号 主机名/IP IP 功能 BROKER角色\n\n```\n1 rocketmqOS1 192.168.59.164 NameServer + Broker Master1 + Slave2\n2 rocketmqOS2 192.168.59.165 NameServer + Broker Master2 + Slave1\n```\n\n## 七、集群搭建实践\n\n### 1 集群架构\n\n这里要搭建一个双主双从异步复制的Broker集群。为了方便，这里使用了两台主机来完成集群的搭建。这两台主机的功能与broker角色分配如下表。\n\n序号|主机名/IP|IP|功能|BROKER角色\n--|:--:|--:|--:|--:\n1|rocketmqOS1|192.168.59.164|NameServer + Broker|Master1 + Slave2\n2|rocketmqOS1|192.168.59.165|NameServer + Broker|Master2 + Slave1\n\n### 2 克隆生成rocketmqOS1\n\n克隆rocketmqOS主机，并修改配置。指定主机名为rocketmqOS1。\n\n### 3 修改rocketmqOS1配置文件\n\n#### 配置文件位置\n\n要修改的配置文件在rocketMQ解压目录的conf/2m-2s-async目录中。\n\n![输入图片说明](rocketmq/QQ截图20220208122608.png \"QQ截图20201229183512.png\")\n\n\n#### 修改broker-a.properties\n\n将该配置文件内容修改为如下：\n\n```shell\n# 指定整个broker集群的名称，或者说是RocketMQ集群的名称\nbrokerClusterName=  \n# 指定master-slave集群的名称。一个RocketMQ集群可以包含多个master-slave集群\nbrokerName=broker-a\n# master的brokerId为 0\nbrokerId= 0\n# 指定删除消息存储过期文件的时间为凌晨 4 点\ndeleteWhen= 04\n# 指定未发生更新的消息存储文件的保留时长为 48 小时， 48 小时后过期，将会被删除\nfileReservedTime= 48\n# 指定当前broker为异步复制master\nbrokerRole=ASYNC_MASTER\n# 指定刷盘策略为异步刷盘\nflushDiskType=ASYNC_FLUSH\n# 指定Name Server的地址\nnamesrvAddr=192.168.59.164:9876;192.168.59.165:9876\n```\n\n#### 修改broker-b-s.properties\n\n将该配置文件内容修改为如下：\n\n#### 其它配置\n```shell\nbrokerClusterName=DefaultCluster\n# 指定这是另外一个master-slave集群\nbrokerName=broker-b\n# slave的brokerId为非 0\nbrokerId=1\ndeleteWhen=04\nfileReservedTime=48\n# 指定当前broker为slave\nbrokerRole=SLAVE\nflushDiskType=ASYNC_FLUSH\nnamesrvAddr=192.168.59.164:9876;192.168.59.165:9876\n# 指定Broker对外提供服务的端口，即Broker与producer与consumer通信的端口。默认10911 。由于当前主机同时充当着master1与slave2，而前面的master1使用的是默认端口。这里需要将这两个端口加以区分，以区分出master1与slave2\nlistenPort= 11911\n# 指定消息存储相关的路径。默认路径为~/store目录。由于当前主机同时充当着master1与slave2，master1使用的是默认路径，这里就需要再指定一个不同路径\nstorePathRootDir=~/store-s\nstorePathCommitLog=~/store-s/commitlog\nstorePathConsumeQueue=~/store-s/consumequeue\nstorePathIndex=~/store-s/index\nstoreCheckpoint=~/store-s/checkpoint\nabortFile=~/store-s/abort\n```\n\n#### 除了以上配置外，这些配置文件中还可以设置其它属性。\n```shell\n#指定整个broker集群的名称，或者说是RocketMQ集群的名称\nbrokerClusterName=rocket-MS\n#指定master-slave集群的名称。一个RocketMQ集群可以包含多个master-slave集群\nbrokerName=broker-a\n#0 表示 Master，>0 表示 Slave\nbrokerId=0\n#nameServer地址，分号分割\nnamesrvAddr=nameserver1:9876;nameserver2:9876\n#默认为新建Topic所创建的队列数\ndefaultTopicQueueNums=4\n#是否允许 Broker 自动创建Topic，建议生产环境中关闭\nautoCreateTopicEnable=true\n#是否允许 Broker 自动创建订阅组，建议生产环境中关闭\nautoCreateSubscriptionGroup=true\n#Broker对外提供服务的端口，即Broker与producer与consumer通信的端口\nlistenPort=10911\n#HA高可用监听端口，即Master与Slave间通信的端口，默认值为listenPort+1\nhaListenPort=10912\n#指定删除消息存储过期文件的时间为凌晨 4 点\ndeleteWhen=04\n#指定未发生更新的消息存储文件的保留时长为 48 小时， 48 小时后过期，将会被删除\nfileReservedTime=48\n#指定commitLog目录中每个文件的大小，默认1G\nmapedFileSizeCommitLog=1073741824\n#指定ConsumeQueue的每个Topic的每个Queue文件中可以存放的消息数量，默认30w条\nmapedFileSizeConsumeQueue=300000\n#在清除过期文件时，如果该文件被其他线程所占用（引用数大于 0 ，比如读取消息），此时会阻止此次删除任务，同时在第一次试图删除该文件时记录当前时间戳。该属性则表示从第一次拒绝删除后开始计时，该文件最多可以保留的时长。在此时间内若引用数仍不为 0 ，则删除仍会被拒绝。不过时间到后，文件将被强制删除\ndestroyMapedFileIntervalForcibly=120000\n#指定commitlog、consumequeue所在磁盘分区的最大使用率，超过该值，则需立即清除过期文件\ndiskMaxUsedSpaceRatio=88\n#指定store目录的路径，默认在当前用户主目录中\nstorePathRootDir=/usr/local/rocketmq-all-4.5.0/store\n#commitLog目录路径\nstorePathCommitLog=/usr/local/rocketmq-all-4.5.0/store/commitlog\n#consumeueue目录路径\nstorePathConsumeQueue=/usr/local/rocketmq-all-4.5.0/store/consumequeue\n#index目录路径\nstorePathIndex=/usr/local/rocketmq-all-4.5.0/store/index\n#checkpoint文件路径\nstoreCheckpoint=/usr/local/rocketmq-all-4.5.0/store/checkpoint\n#abort文件路径\nabortFile=/usr/local/rocketmq-all-4.5.0/store/abort\n#指定消息的最大大小\nmaxMessageSize= 65536\n#Broker的角色\n# - ASYNC_MASTER 异步复制Master\n# - SYNC_MASTER 同步双写Master\n# - SLAVE\nbrokerRole=SYNC_MASTER\n#刷盘策略\n# - ASYNC_FLUSH 异步刷盘\n# - SYNC_FLUSH 同步刷盘\nflushDiskType=SYNC_FLUSH\n#发消息线程池数量\nsendMessageThreadPoolNums=128\n#拉消息线程池数量\npullMessageThreadPoolNums=128\n#强制指定本机IP，需要根据每台机器进行修改。官方介绍可为空，系统默认自动识别，但多网卡时IP地址可能读取错误\nbrokerIP1=192.168.3.105\n```\n\n### 4 克隆生成rocketmqOS2\n\n克隆rocketmqOS1主机，并修改配置。指定主机名为rocketmqOS2。\n\n### 5 修改rocketmqOS2配置文件\n\n对于rocketmqOS2主机，同样需要修改rocketMQ解压目录的conf目录的子目录2m-2s-async中的两个配置文件。\n\n#### 修改broker-b.properties\n\n将该配置文件内容修改为如下：\n\n```shell\nbrokerClusterName=DefaultCluster\nbrokerName=broker-b\nbrokerId=0\ndeleteWhen=04\nfileReservedTime=48\nbrokerRole=ASYNC_MASTER\nflushDiskType=ASYNC_FLUSH\nnamesrvAddr=192.168.59.164:9876;192.168.59.165:9876\n```\n\n修改broker-a-s.properties\n\n#### 将该配置文件内容修改为如下：\n\n```shell\nbrokerClusterName=DefaultCluster\nbrokerName=broker-a\nbrokerId=1\ndeleteWhen=04\nfileReservedTime=48\nbrokerRole=SLAVE\nflushDiskType=ASYNC_FLUSH\nnamesrvAddr=192.168.59.164:9876;192.168.59.165:9876\nlistenPort=11911\nstorePathRootDir=~/store-s\nstorePathCommitLog=~/store-s/commitlog\nstorePathConsumeQueue=~/store-s/consumequeue\nstorePathIndex=~/store-s/index\nstoreCheckpoint=~/store-s/checkpoint\nabortFile=~/store-s/abort\n```\n\n### 6 启动服务器\n\n#### 启动NameServer集群\n\n分别启动rocketmqOS1与rocketmqOS2两个主机中的NameServer。启动命令完全相同。\n\n```shell\nnohup sh bin/mqnamesrv &\ntail -f ~/logs/rocketmqlogs/namesrv.log\n```\n#### 启动两个Master\n\n分别启动rocketmqOS1与rocketmqOS2两个主机中的broker master。注意，它们指定所要加载的配置文件是不同的。\n```shell\nnohup sh bin/mqbroker -c conf/2m-2s-async/broker-a.properties &\ntail -f ~/logs/rocketmqlogs/broker.log\n```\n\n```shell\nnohup sh bin/mqbroker -c conf/2m-2s-async/broker-b.properties &\ntail -f ~/logs/rocketmqlogs/broker.log\n```\n#### 启动两个Slave\n\n分别启动rocketmqOS1与rocketmqOS2两个主机中的broker slave。注意，它们指定所要加载的配置文件是不同的。\n\n```shell\nnohup sh bin/mqbroker -c conf/2m-2s-async/broker-b-s.properties &\ntail -f ~/logs/rocketmqlogs/broker.log\n```\n\n```shell\nnohup sh bin/mqbroker -c conf/2m-2s-async/broker-a-s.properties &\ntail -f ~/logs/rocketmqlogs/broker.log\n```\n## 八、mqadmin命令\n\n在mq解压目录的bin目录下有一个mqadmin命令，该命令是一个运维指令，用于对mq的主题，集群，broker 等信息进行管理。\n\n### 1 修改bin/tools.sh\n\n在运行mqadmin命令之前，先要修改mq解压目录下bin/tools.sh配置的JDK的ext目录位置。本机的ext目录在`/usr/java/jdk1.8.0_161/jre/lib/ext`。\n\n使用vim命令打开tools.sh文件，并在JAVA_OPT配置的-Djava.ext.dirs这一行的后面添加ext的路径。\n\n![输入图片说明](rocketmq/QQ截图20220208123848.png \"QQ截图20201229183512.png\")\n\n```shell\nJAVA_OPT=\"${JAVA_OPT} -server -Xms1g -Xmx1g -Xmn256m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=128m\"\nJAVA_OPT=\"${JAVA_OPT} -Djava.ext.dirs=${BASE_DIR}/lib:${JAVA_HOME}/jre/lib/ext:${JAVA_HOME}/lib/ext:/usr/java/jdk1.8.0_161/jre/lib/ext\"\nJAVA_OPT=\"${JAVA_OPT} -cp ${CLASSPATH}\"\n```\n### 2 运行mqadmin\n\n直接运行该命令，可以看到其可以添加的commands。通过这些commands可以完成很多的功能。\n\n```shell\n[root@mqOS rocketmq-all-4.8.0-bin-release]# ./bin/mqadmin\nThe most commonly used mqadmin commands are:\nupdateTopic Update or create topic\ndeleteTopic Delete topic from broker and NameServer.\nupdateSubGroup Update or create subscription group\ndeleteSubGroup Delete subscription group from broker.\nupdateBrokerConfig Update broker's config\nupdateTopicPerm Update topic perm\ntopicRoute Examine topic route info\ntopicStatus Examine topic Status info\ntopicClusterList get cluster info for topic\nbrokerStatus Fetch broker runtime status data\nqueryMsgById Query Message by Id\nqueryMsgByKey Query Message by Key\nqueryMsgByUniqueKey Query Message by Unique key\nqueryMsgByOffset Query Message by offset\nQueryMsgTraceById query a message trace\nprintMsg Print Message Detail\nprintMsgByQueue Print Message Detail\nsendMsgStatus send msg to broker.\nbrokerConsumeStats Fetch broker consume stats data\nproducerConnection Query producer's socket connection and clientversion\nconsumerConnection Query consumer's socket connection, client version and subscription\nconsumerProgress Query consumers's progress, speed\nconsumerStatus Query consumer's internal data structure\ncloneGroupOffset clone offset from other group.\nclusterList List all of clusters\ntopicList Fetch all topic list from name server\nupdateKvConfig Create or update KV config.\ndeleteKvConfig Delete KV config.\nwipeWritePerm Wipe write perm of broker in all name server\nresetOffsetByTime Reset consumer offset by timestamp(without client restart).\nupdateOrderConf Create or update or delete order conf\ncleanExpiredCQ Clean expired ConsumeQueue on broker.\ncleanUnusedTopic Clean unused topic on broker.\nstartMonitoring Start Monitoring\nstatsAll Topic and Consumer tps stats\nallocateMQ Allocate MQ\ncheckMsgSendRT check message send response time\nclusterRT List All clusters Message Send RT\ngetNamesrvConfig Get configs of name server.\nupdateNamesrvConfig Update configs of name server.\ngetBrokerConfig Get broker config by cluster or special broker!\nqueryCq Query cq command.\nsendMessage Send a message\nconsumeMessage Consume message\nupdateAclConfig Update acl config yaml file in broker\ndeleteAccessConfig Delete Acl Config Account in broker\nclusterAclConfigVersion List all of acl config version information in cluster\nupdateGlobalWhiteAddr Update global white address for acl Config File in broker\ngetAccessConfigSubCommand List all of acl config information in cluster\n```\n\n### 3 该命令的官网详解\n\n#### 该命令在官网中有详细的用法解释。\n\nhttps://github.com/apache/rocketmq/blob/master/docs/cn/operation.md\n\n![输入图片说明](rocketmq/QQ截图20220208124241.png \"QQ截图20201229183512.png\")\n\n![输入图片说明](rocketmq/QQ截图20220208124258.png \"QQ截图20201229183512.png\")\n\n# 第 3 章 RocketMQ工作原理\n\n## 一、消息的生产\n\n### 1 消息的生产过程\n\nProducer可以将消息写入到某Broker中的某Queue中，其经历了如下过程：\n\n* Producer发送消息之前，会先向NameServer发出获取消息Topic的路由信息的请求\n* NameServer返回该Topic的路由表及Broker列表\n* Producer根据代码中指定的Queue选择策略，从Queue列表中选出一个队列，用于后续存储消息\n* Produer对消息做一些特殊处理，例如，消息本身超过4M，则会对其进行压缩\n* Producer向选择出的Queue所在的Broker发出RPC请求，将消息发送到选择出的Queue\n\n>路由表：实际是一个Map，key为Topic名称，value是一个QueueData实例列表。QueueData并不是一个Queue对应一个QueueData，而是一个Broker中该Topic的所有Queue对应一个QueueData。即，只要涉及到该Topic的Broker，一个Broker对应一个QueueData。QueueData中包含brokerName。简单来说，路由表的key为Topic名称，value则为所有涉及该Topic的BrokerName列表。\n\n\n>Broker列表：其实际也是一个Map。key为brokerName，value为BrokerData。一个Broker对应一个BrokerData实例，对吗？不对。一套brokerName名称相同的Master-Slave小集群对应一个BrokerData。BrokerData中包含brokerName及一个map。该map的key为brokerId，value为该broker对应的地址。brokerId为 0 表示该broker为Master，非 0 表示Slave。\n\n### 2 Queue选择算法\n\n对于无序消息，其Queue选择算法，也称为消息投递算法，常见的有两种：\n\n#### 轮询算法\n\n默认选择算法。该算法保证了每个Queue中可以均匀的获取到消息。\n\n>该算法存在一个问题：由于某些原因，在某些Broker上的Queue可能投递延迟较严重。从而导致Producer的缓存队列中出现较大的消息积压，影响消息的投递性能。\n\n#### 最小投递延迟算法\n\n该算法会统计每次消息投递的时间延迟，然后根据统计出的结果将消息投递到时间延迟最小的Queue。如果延迟相同，则采用轮询算法投递。该算法可以有效提升消息的投递性能。\n\n>该算法也存在一个问题：消息在Queue上的分配不均匀。投递延迟小的Queue其可能会存在大量的消息。而对该Queue的消费者压力会增大，降低消息的消费能力，可能会导致MQ中消息的堆积。\n\n## 二、消息的存储\n\nRocketMQ中的消息存储在本地文件系统中，这些相关文件默认在当前用户主目录下的store目录中。\n\n![输入图片说明](rocketmq/QQ截图20220208133814.png \"QQ截图20201229183512.png\")\n\n* abort：该文件在Broker启动后会自动创建，正常关闭Broker，该文件会自动消失。若在没有启动Broker的情况下，发现这个文件是存在的，则说明之前Broker的关闭是非正常关闭。\n* checkpoint：其中存储着commitlog、consumequeue、index文件的最后刷盘时间戳\n* commitlog：其中存放着commitlog文件，而消息是写在commitlog文件中的\n* conæg：存放着Broker运行期间的一些配置数据\n* consumequeue：其中存放着consumequeue文件，队列就存放在这个目录中\n* index：其中存放着消息索引文件indexFile\n* lock：运行期间使用到的全局资源锁\n\n### 1 commitlog文件\n\n>说明：在很多资料中commitlog目录中的文件简单就称为commitlog文件。但在源码中，该文件被命名为mappedFile。\n\n#### 目录与文件\n\ncommitlog目录中存放着很多的mappedFile文件，当前Broker中的所有消息都是落盘到这些mappedFile文件中的。mappedFile文件大小为1G（小于等于1G），文件名由 20 位十进制数构成，表示当前文件的第一条消息的起始位移偏移量。\n\n>第一个文件名一定是 20 位 0 构成的。因为第一个文件的第一条消息的偏移量commitlog offset为 0 <br><br>\n当第一个文件放满时，则会自动生成第二个文件继续存放消息。假设第一个文件大小是 1073741820 字节（1G = 1073741824字节），则第二个文件名就是 00000000001073741824 。<br><br>\n以此类推，第n个文件名应该是前n-1个文件大小之和。<br><br>\n一个Broker中所有mappedFile文件的commitlog offset是连续的\n\n\n需要注意的是，一个Broker中仅包含一个commitlog目录，所有的mappedFile文件都是存放在该目录中的。即无论当前Broker中存放着多少Topic的消息，这些消息都是被顺序写入到了mappedFile文件中的。也就是说，这些消息在Broker中存放时并没有被按照Topic进行分类存放。\n\n>mappedFile文件是顺序读写的文件，所有其访问效率很高<br><br>\n无论是SSD磁盘还是SATA磁盘，通常情况下，顺序存取效率都会高于随机存取。\n\n#### 消息单元\n\n![输入图片说明](rocketmq/QQ截图20220208134157.png \"QQ截图20201229183512.png\")\n\nmappedFile文件内容由一个个的`消息单元`构成。每个消息单元中包含消息总长度MsgLen、消息的物理位置physicalOffset、消息体内容Body、消息体长度BodyLength、消息主题Topic、Topic长度 TopicLength、消息生产者BornHost、消息发送时间戳BornTimestamp、消息所在的队列QueueId、消息在Queue中存储的偏移量QueueOffset等近 20 余项消息相关属性。\n\n>需要注意到，消息单元中是包含Queue相关属 性的。所以，我们在后续的学习中，就需要十分留意commitlog与queue间的关系是什么？<br><br>\n一个mappedFile文件中第m+1个消息单元的commitlog offset偏移量<br><br>\nL(m+1) = L(m) + MsgLen(m) (m >= 0)\n\n### 2 consumequeue\n\n![输入图片说明](rocketmq/QQ截图20220208134355.png \"QQ截图20201229183512.png\")\n#### 目录与文件\n\n![输入图片说明](rocketmq/QQ截图20220208134415.png \"QQ截图20201229183512.png\")\n\n为了提高效率，会为每个Topic在~/store/consumequeue中创建一个目录，目录名为Topic名称。在该Topic目录下，会再为每个该Topic的Queue建立一个目录，目录名为queueId。每个目录中存放着若干consumequeue文件，consumequeue文件是commitlog的索引文件，可以根据consumequeue定位到具体的消息。\n\nconsumequeue文件名也由 20 位数字构成，表示当前文件的第一个索引条目的起始位移偏移量。与mappedFile文件名不同的是，其后续文件名是固定的。因为consumequeue文件大小是固定不变的。\n\n#### 索引条目\n\n![输入图片说明](rocketmq/QQ截图20220208134454.png \"QQ截图20201229183512.png\")\n\n每个consumequeue文件可以包含30w个索引条目，每个索引条目包含了三个消息重要属性：消息在mappedFile文件中的偏移量CommitLog Offset、消息长度、消息Tag的hashcode值。这三个属性占 20个字节，所以每个文件的大小是固定的30w * 20字节。\n\n>一个consumequeue文件中所有消息的Topic一定是相同的。但每条消息的Tag可能是不同的。\n### 3 对文件的读写\n\n![输入图片说明](rocketmq/QQ截图20220208134538.png \"QQ截图20201229183512.png\")\n\n#### 消息写入\n\n一条消息进入到Broker后经历了以下几个过程才最终被持久化。\n\n* Broker根据queueId，获取到该消息对应索引条目要在consumequeue目录中的写入偏移量，即QueueOffset\n* 将queueId、queueOffset等数据，与消息一起封装为消息单元\n* 将消息单元写入到commitlog\n* 同时，形成消息索引条目\n* 将消息索引条目分发到相应的consumequeue\n\n#### 消息拉取\n\n* 当Consumer来拉取消息时会经历以下几个步骤：\n    * Consumer获取到其要消费消息所在Queue的消费偏移量offset，计算出其要消费消息的消息offset\n>消费offset即消费进度，consumer对某个Queue的消费offset，即消费到了该Queue的第几条消息<br>\n消息offset = 消费offset + 1\n\n* Consumer向Broker发送拉取请求，其中会包含其要拉取消息的Queue、消息offset及消息Tag。\n* Broker计算在该consumequeue中的queueOffset。\n>queueOffset = 消息offset * 20字节\n\n* 从该queueOffset处开始向后查找第一个指定Tag的索引条目。\n* 解析该索引条目的前 8 个字节，即可定位到该消息在commitlog中的commitlog offset\n* 从对应commitlog offset中读取消息单元，并发送给Consumer\n\n#### 性能提升\n\nRocketMQ中，无论是消息本身还是消息索引，都是存储在磁盘上的。其不会影响消息的消费吗？当然不会。其实RocketMQ的性能在目前的MQ产品中性能是非常高的。因为系统通过一系列相关机制大大提升了性能。\n\n首先，RocketMQ对文件的读写操作是通过`mmap零拷贝`进行的，将对文件的操作转化为直接对内存地址进行操作，从而极大地提高了文件的读写效率。\n\n其次，consumequeue中的数据是顺序存放的，还引入了`PageCache的预读取机制`，使得对consumequeue文件的读取几乎接近于内存读取，即使在有消息堆积情况下也不会影响性能。\n\n>PageCache机制，页缓存机制，是OS对文件的缓存机制，用于加速对文件的读写操作。一般来说，程序对文件进行顺序读写的速度几乎接近于内存读写速度，主要原因是由于OS使用PageCache机制对读写访问操作进行性能优化，将一部分的内存用作PageCache。<br><br>\n1)写操作：OS会先将数据写入到PageCache中，随后会以异步方式由pdæush（page dirty æush)内核线程将Cache中的数据刷盘到物理磁盘<br>\n2)读操作：若用户要读取数据，其首先会从PageCache中读取，若没有命中，则OS在从物理磁盘上加载该数据到PageCache的同时，也会顺序 对其相邻数据块中的数据进行预读取。\n\nRocketMQ中可能会影响性能的是对commitlog文件的读取。因为对commitlog文件来说，读取消息时会产生大量的随机访问，而随机访问会严重影响性能。不过，如果选择合适的系统IO调度算法，比如设置调度算法为Deadline（采用SSD固态硬盘的话），随机读的性能也会有所提升。\n\n### 4 与Kafka的对比\n\nRocketMQ的很多思想来源于Kafka，其中commitlog与consumequeue就是。\n\nRocketMQ中的commitlog目录与consumequeue的结合就类似于Kafka中的partition分区目录。mappedFile文件就类似于Kafka中的segment段。\n\n>Kafka中的Topic的消息被分割为一个或多个partition。partition是一个物理概念，对应到系统上就是topic目录下的一个或多个目录。每个partition中包含的文件称为segment，是具体存放消息的文件。<br><br>\nKafka中消息存放的目录结构是：topic目录下有partition目录，partition目录下有segment文件<br><br>\nKafka中没有二级分类标签Tag这个概念<br><br>\nKafka中无需索引文件。因为生产者是将消息直接写在了partition中的，消费者也是直接从partition中读取数据的\n\n## 三、indexFile\n\n除了通过通常的指定Topic进行消息消费外，RocketMQ还提供了根据key进行消息查询的功能。该查询是通过store目录中的index子目录中的indexFile进行索引实现的快速查询。当然，这个indexFile中的索引数据是在`包含了key的消息`被发送到Broker时写入的。如果消息中没有包含key，则不会写入。\n\n### 1 索引条目结构\n\n每个Broker中会包含一组indexFile，每个indexFile都是以一个`时间戳`命名的（这个indexFile被创建时的时间戳）。每个indexFile文件由三部分构成：indexHeader，slots槽位，indexes索引数据。每个\nindexFile文件中包含500w个slot槽。而每个slot槽又可能会挂载很多的index索引单元。\n\n![输入图片说明](rocketmq/QQ截图20220208135939.png \"QQ截图20201229183512.png\")\n\nindexHeader固定 40 个字节，其中存放着如下数据：\n\n![输入图片说明](rocketmq/QQ截图20220208135949.png \"QQ截图20201229183512.png\")\n\n* beginTimestamp：该indexFile中第一条消息的存储时间\n* endTimestamp：该indexFile中最后一条消息存储时间\n* beginPhyoffset：该indexFile中第一条消息在commitlog中的偏移量commitlog offset\n* endPhyoffset：该indexFile中最后一条消息在commitlog中的偏移量commitlog offset\n* hashSlotCount：已经填充有index的slot数量（并不是每个slot槽下都挂载有index索引单元，这里统计的是所有挂载了index索引单元的slot槽的数量）\n* indexCount：该indexFile中包含的索引单元个数（统计出当前indexFile中所有slot槽下挂载的所有index索引单元的数量之和）\n\nindexFile中最复杂的是Slots与Indexes间的关系。在实际存储时，Indexes是在Slots后面的，但为了便于理解，将它们的关系展示为如下形式：\n\n![输入图片说明](rocketmq/QQ截图20220208140054.png \"QQ截图20201229183512.png\")\n\n`key的hash值 % 500w`的结果即为slot槽位，然后将该slot值修改为该index索引单元的indexNo，根据这个indexNo可以计算出该index单元在indexFile中的位置。不过，该取模结果的重复率是很高的，为了解决该问题，在每个index索引单元中增加了preIndexNo，用于指定该slot中当前index索引单元的前一个index索引单元。而slot中始终存放的是其下最新的index索引单元的indexNo，这样的话，只要找到了slot就可以找到其最新的index索引单元，而通过这个index索引单元就可以找到其之前的所有index索引单元。\n\n>indexNo是一个在indexFile中的流水号，从 0 开始依次递增。即在一个indexFile中所有indexNo是以此递增的。indexNo在index索引单元中是没有体现的，其是通过indexes中依次数出来的。\n\nindex索引单元默写 20 个字节，其中存放着以下四个属性：\n\n![输入图片说明](rocketmq/QQ截图20220208140159.png \"QQ截图20201229183512.png\")\n\n* keyHash：消息中指定的业务key的hash值\n* phyOffset：当前key对应的消息在commitlog中的偏移量commitlog offset\n* timeDiff：当前key对应消息的存储时间与当前indexFile创建时间的时间差\n* preIndexNo：当前slot下当前index索引单元的前一个index索引单元的indexNo\n\n### 2 indexFile的创建\n\nindexFile的文件名为当前文件被创建时的时间戳。这个时间戳有什么用处呢？\n\n根据业务key进行查询时，查询条件除了key之外，还需要指定一个要查询的时间戳，表示要查询不大于该时间戳的最新的消息，即查询指定时间戳之前存储的最新消息。这个时间戳文件名可以简化查询，提高查询效率。具体后面会详细讲解。\n\nindexFile文件是何时创建的？其创建的条件（时机）有两个：\n\n* 当第一条带key的消息发送来后，系统发现没有indexFile，此时会创建第一个indexFile文件\n* 当一个indexFile中挂载的index索引单元数量超出2000w个时，会创建新的indexFile。当带key的消息发送到来后，系统会找到最新的indexFile，并从其indexHeader的最后 4 字节中读取到indexCount。若indexCount >= 2000w时，会创建新的indexFile。\n\n>由于可以推算出，一个indexFile的最大大小是：(40 + 500w * 4 + 2000w * 20)字节\n\n### 3 查询流程\n\n当消费者通过业务key来查询相应的消息时，其需要经过一个相对较复杂的查询流程。不过，在分析查询流程之前，首先要清楚几个定位计算式子：\n```shell\n计算指定消息key的slot槽位序号：\nslot槽位序号 = key的hash % 500w (式子1)\n```\n```shell\n计算槽位序号为n的slot在indexFile中的起始位置：\nslot(n)位置 = 40 + (n - 1) * 4 (式子2)\n```\n```shell\n计算indexNo为m的index在indexFile中的位置：\nindex(m)位置 = 40 + 500w * 4 + (m - 1) * 20 (式子3)\n```\n\n>40 为indexFile中indexHeader的字节数<br>\n500w * 4 是所有slots所占的字节数\n\n#### 具体查询流程如下：\n\n![输入图片说明](rocketmq/QQ截图20220208140740.png \"QQ截图20201229183512.png\")\n## 四、消息的消费\n\n消费者从Broker中获取消息的方式有两种：pull拉取方式和push推动方式。消费者组对于消息消费的模式又分为两种：集群消费Clustering和广播消费Broadcasting。\n\n### 1 获取消费类型\n\n#### 拉取式消费\n\nConsumer主动从Broker中拉取消息，主动权由Consumer控制。一旦获取了批量消息，就会启动消费过程。不过，该方式的实时性较弱，即Broker中有了新的消息时消费者并不能及时发现并消费。\n\n>由于拉取时间间隔是由用户指定的，所以在设置该间隔时需要注意平稳：间隔太短，空请求比例会增加；间隔太长，消息的实时性太差\n\n#### 推送式消费\n\n该模式下Broker收到数据后会主动推送给Consumer。该获取方式一般实时性较高。\n\n该获取方式是典型的`发布-订阅`模式，即Consumer向其关联的Queue注册了监听器，一旦发现有新的消息到来就会触发回调的执行，回调方法是Consumer去Queue中拉取消息。而这些都是基于Consumer与Broker间的长连接的。长连接的维护是需要消耗系统资源的。\n\n#### 对比\n\n* pull：需要应用去实现对关联Queue的遍历，实时性差；但便于应用控制消息的拉取\n* push：封装了对关联Queue的遍历，实时性强，但会占用较多的系统资源\n\n### 2 消费模式\n\n#### 广播消费\n\n![输入图片说明](rocketmq/QQ截图20220208141005.png \"QQ截图20201229183512.png\")\n\n广播消费模式下，相同Consumer Group的每个Consumer实例都接收同一个Topic的全量消息。即每条消息都会被发送到Consumer Group中的每个Consumer。\n\n#### 集群消费\n![输入图片说明](rocketmq/QQ截图20220208141053.png \"QQ截图20201229183512.png\")\n\n集群消费模式下，相同Consumer Group的每个Consumer实例`平均分摊`同一个Topic的消息。即每条消息只会被发送到Consumer Group中的`某个`Consumer。\n\n\n#### 消息进度保存\n\n* 广播模式：消费进度保存在consumer端。因为广播模式下consumer group中每个consumer都会消费所有消息，但它们的消费进度是不同。所以consumer各自保存各自的消费进度。\n* 集群模式：消费进度保存在broker中。consumer group中的所有consumer共同消费同一个Topic中的消息，同一条消息只会被消费一次。消费进度会参与到了消费的负载均衡中，故消费进度是需要共享的。下图是broker中存放的各个Topic的各个Queue的消费进度。\n\n![输入图片说明](rocketmq/QQ截图20220208141202.png \"QQ截图20201229183512.png\")\n\n### 3 Rebalance机制\n\nRebalance机制讨论的前提是：集群消费。\n\n#### 什么是Rebalance\n\nRebalance即再均衡，指的是，将一个Topic下的多个Queue在同一个Consumer Group中的多个Consumer间进行重新分配的过程。\n\n![输入图片说明](rocketmq/QQ截图20220208141304.png \"QQ截图20201229183512.png\")\n\nRebalance机制的本意是为了提升消息的并行消费能力。例如，一个Topic下 5 个队列，在只有 1 个消费者的情况下，这个消费者将负责消费这 5 个队列的消息。如果此时我们增加一个消费者，那么就可以给其中一个消费者分配 2 个队列，给另一个分配 3 个队列，从而提升消息的并行消费能力。\n\n#### Rebalance限制\n\n由于一个队列最多分配给一个消费者，因此当某个消费者组下的消费者实例数量大于队列的数量时，多余的消费者实例将分配不到任何队列。\n\n#### Rebalance危害\n\nRebalance的在提升消费能力的同时，也带来一些问题：\n\n`消费暂停：`在只有一个Consumer时，其负责消费所有队列；在新增了一个Consumer后会触发Rebalance的发生。此时原Consumer就需要暂停部分队列的消费，等到这些队列分配给新的Consumer后，这些暂停消费的队列才能继续被消费。\n\n`消费重复：`Consumer 在消费新分配给自己的队列时，必须接着之前Consumer 提交的消费进度的offset继续消费。然而默认情况下，offset是异步提交的，这个异步性导致提交到Broker的offset与Consumer实际消费的消息并不一致。这个不一致的差值就是可能会重复消费的消息。\n\n\n>同步提交：consumer提交了其消费完毕的一批消息的offset给broker后，需要等待broker的成功ACK。当收到ACK后，consumer才会继续获取并消费下一批消息。在等待ACK期间，consumer是阻塞的。<br><br>\n异步提交：consumer提交了其消费完毕的一批消息的offset给broker后，不需要等待broker的成功ACK。consumer可以直接获取并消费下一批消息。<br><br>\n对于一次性读取消息的数量，需要根据具体业务场景选择一个相对均衡的是很有必要的。因为数量过大，系统性能提升了，但产生重复消费的消息数量可能会增加；数量过小，系统性能会下降，但被重复消费的消息数量可能会减少。\n\n`消费突刺：`由于Rebalance可能导致重复消费，如果需要重复消费的消息过多，或者因为Rebalance暂停时间过长从而导致积压了部分消息。那么有可能会导致在Rebalance结束之后瞬间需要消费很多消息。\n\n#### Rebalance产生的原因\n\n导致Rebalance产生的原因，无非就两个：消费者所订阅Topic的Queue数量发生变化，或消费者组中消费者的数量发生变化。\n\n>1 ）Queue数量发生变化的场景：<br>\nBroker扩容或缩容<br>\nBroker升级运维<br>\nBroker与NameServer间的网络异常<br>\nQueue扩容或缩容<br>\n2 ）消费者数量发生变化的场景：<br>\nConsumer Group扩容或缩容<br>\nConsumer升级运维<br>\nConsumer与NameServer间网络异常<br>\n\n#### Rebalance过程\n\n在Broker中维护着多个Map集合，这些集合中动态存放着当前Topic中Queue的信息、Consumer Group中Consumer实例的信息。一旦发现消费者所订阅的Queue数量发生变化，或消费者组中消费者的数量发生变化，立即向Consumer Group中的每个实例发出Rebalance通知。\n\n>TopicConågManager：key是topic名称，value是TopicConåg。TopicConåg中维护着该Topic中所有Queue的数据。<br><br>\nConsumerManager：key是Consumser Group Id，value是ConsumerGroupInfo。<br>\nConsumerGroupInfo中维护着该Group中所有Consumer实例数据。<br><br>\nConsumerOffsetManager：key为`Topic与订阅该Topic的Group的组合,即topic@group`，value是一个内层Map。内层Map的key为QueueId，内层Map的value为该Queue的消费进度offset。\n\nConsumer实例在接收到通知后会采用Queue分配算法自己获取到相应的Queue，即由Consumer实例自主进行Rebalance。\n\n#### 与Kafka对比\n\n在Kafka中，一旦发现出现了Rebalance条件，Broker会调用Group Coordinator来完成Rebalance。Coordinator是Broker中的一个进程。Coordinator会在Consumer Group中选出一个Group Leader。由这个Leader根据自己本身组情况完成Partition分区的再分配。这个再分配结果会上报给Coordinator，并由Coordinator同步给Group中的所有Consumer实例。\n\nKafka中的Rebalance是由Consumer Leader完成的。而RocketMQ中的Rebalance是由每个Consumer自身完成的，Group中不存在Leader。\n\n### 4 Queue分配算法\n\n一个Topic中的Queue只能由Consumer Group中的一个Consumer进行消费，而一个Consumer可以同时消费多个Queue中的消息。那么Queue与Consumer间的配对关系是如何确定的，即Queue要分配给哪个Consumer进行消费，也是有算法策略的。常见的有四种策略。这些策略是通过在创建Consumer时的构造器传进去的。\n\n#### 平均分配策略\n\n![输入图片说明](rocketmq/QQ截图20220208142527.png \"QQ截图20201229183512.png\")\n\n该算法是要根据`avg = QueueCount / ConsumerCount`的计算结果进行分配的。如果能够整除，则按顺序将avg个Queue逐个分配Consumer；如果不能整除，则将多余出的Queue按照Consumer顺序逐个分配。\n\n\n>该算法即，先计算好每个Consumer应该分得几 个Queue，然后再依次将这些数量的Queue逐个分配个Consumer。\n\n#### 环形平均策略\n\n![输入图片说明](rocketmq/QQ截图20220208142630.png \"QQ截图20201229183512.png\")\n\n环形平均算法是指，根据消费者的顺序，依次在由queue队列组成的环形图中逐个分配。\n\n>该算法不用事先计算每个Consumer需要分配几 个Queue，直接一个一个分即可。\n\n#### 一致性hash策略\n\n![输入图片说明](rocketmq/QQ截图20220208142708.png \"QQ截图20201229183512.png\")\n\n该算法会将consumer的hash值作为Node节点存放到hash环上，然后将queue的hash值也放到hash环上，通过顺时针方向，距离queue最近的那个consumer就是该queue要分配的consumer。\n\n>该算法存在的问题：分配不均。\n\n#### 同机房策略\n\n![输入图片说明](rocketmq/QQ截图20220208142814.png \"QQ截图20201229183512.png\")\n\n该算法会根据queue的部署机房位置和consumer的位置，过滤出当前consumer相同机房的queue。然后按照平均分配策略或环形平均策略对同机房queue进行分配。如果没有同机房queue，则按照平均分配策略或环形平均策略对所有queue进行分配。\n\n#### 对比\n\n一致性hash算法存在的问题：\n\n两种平均分配策略的分配效率较高，一致性hash策略的较低。因为一致性hash算法较复杂。另外，一致性hash策略分配的结果也很大可能上存在不平均的情况。\n\n一致性hash算法存在的意义：\n\n其可以有效减少由于消费者组扩容或缩容所带来的大量的Rebalance。\n\n![输入图片说明](rocketmq/QQ截图20220208142905.png \"QQ截图20201229183512.png\")\n\n一致性hash算法的应用场景：\n\nConsumer数量变化较频繁的场景。\n\n\n### 5 至少一次原则\n\nRocketMQ有一个原则：每条消息必须要被`成功消费`一次。\n\n那么什么是成功消费呢？Consumer在消费完消息后会向其`消费进度记录器`提交其消费消息的offset，offset被成功记录到记录器中，那么这条消费就被成功消费了。\n\n>什么是消费进度记录器？<br>\n对于广播消费模式来说，Consumer本身就是消费进度记录器。<br>\n对于集群消费模式来说，Broker是消费进度记录器。<br>\n\n## 五、订阅关系的一致性\n\n订阅关系的一致性指的是，同一个消费者组（Group ID相同）下所有Consumer实例所订阅的Topic与Tag及对消息的处理逻辑必须完全一致。否则，消息消费的逻辑就会混乱，甚至导致消息丢失。\n\n### 1 正确订阅关系\n\n多个消费者组订阅了多个Topic，并且每个消费者组里的多个消费者实例的订阅关系保持了一致。\n\n![输入图片说明](rocketmq/QQ截图20220208143050.png \"QQ截图20201229183512.png\")\n\n### 2 错误订阅关系\n\n一个消费者组订阅了多个Topic，但是该消费者组里的多个Consumer实例的订阅关系并没有保持一致。\n\n![输入图片说明](rocketmq/QQ截图20220208143107.png \"QQ截图20201229183512.png\")\n\n#### 订阅了不同Topic\n\n该例中的错误在于，同一个消费者组中的两个Consumer实例订阅了不同的Topic。\n\nConsumer实例1-1：（订阅了topic为jodie_test_A，tag为所有的消息）\n\n```java\nProperties properties = new Properties();\nproperties.put(PropertyKeyConst.GROUP_ID, \"GID_jodie_test_1\");\nConsumer consumer = ONSFactory.createConsumer(properties);\nconsumer.subscribe(\"jodie_test_A\", \"*\", new MessageListener() {\n    public Action consume(Message message, ConsumeContext context) {\n        System.out.println(message.getMsgID());\n        return Action.CommitMessage;\n    }\n});\n```\n\nConsumer实例1-2：（订阅了topic为jodie_test_B，tag为所有的消息）\n\n```java\nProperties properties = new Properties();\nproperties.put(PropertyKeyConst.GROUP_ID, \"GID_jodie_test_1\");\nConsumer consumer = ONSFactory.createConsumer(properties);\nconsumer.subscribe(\"jodie_test_B\", \"*\", new MessageListener() {\n    public Action consume(Message message, ConsumeContext context) {\n        System.out.println(message.getMsgID());\n        return Action.CommitMessage;\n    }\n});\n```\n#### 订阅了不同Tag\n\n该例中的错误在于，同一个消费者组中的两个Consumer订阅了相同Topic的不同Tag。\n\nConsumer实例2-1：（订阅了topic为jodie_test_A，tag为TagA的消息）\n\n```java\nProperties properties = new Properties();\nproperties.put(PropertyKeyConst.GROUP_ID, \"GID_jodie_test_2\");\nConsumer consumer = ONSFactory.createConsumer(properties);\nconsumer.subscribe(\"jodie_test_A\", \"TagA\", new MessageListener() {\n    public Action consume(Message message, ConsumeContext context) {\n        System.out.println(message.getMsgID());\n        return Action.CommitMessage;\n    }\n});\n```\nConsumer实例2-2：（订阅了topic为jodie_test_A，tag为所有的消息）\n\n```java\nProperties properties = new Properties();\nproperties.put(PropertyKeyConst.GROUP_ID, \"GID_jodie_test_2\");\nConsumer consumer = ONSFactory.createConsumer(properties);\nconsumer.subscribe(\"jodie_test_A\", \"*\", new MessageListener() {\n    public Action consume(Message message, ConsumeContext context) {\n        System.out.println(message.getMsgID());\n        return Action.CommitMessage;\n    }\n});\n```\n\n#### 订阅了不同数量的Topic\n\n该例中的错误在于，同一个消费者组中的两个Consumer订阅了不同数量的Topic。\n\nConsumer实例3-1：（该Consumer订阅了两个Topic）\n```java\nProperties properties = new Properties();\nproperties.put(PropertyKeyConst.GROUP_ID, \"GID_jodie_test_3\");\nConsumer consumer = ONSFactory.createConsumer(properties);\nconsumer.subscribe(\"jodie_test_A\", \"TagA\", new MessageListener() {\n    public Action consume(Message message, ConsumeContext context) {\n        System.out.println(message.getMsgID());\n        return Action.CommitMessage;\n    }\n});\nconsumer.subscribe(\"jodie_test_B\", \"TagB\", new MessageListener() {\n    public Action consume(Message message, ConsumeContext context) {\n        System.out.println(message.getMsgID());\n        return Action.CommitMessage;\n    }\n});\n```\nConsumer实例3-2：（该Consumer订阅了一个Topic）\n\n```java\nProperties properties = new Properties();\nproperties.put(PropertyKeyConst.GROUP_ID, \"GID_jodie_test_3\");\nConsumer consumer = ONSFactory.createConsumer(properties);\nconsumer.subscribe(\"jodie_test_A\", \"TagB\", new MessageListener() {\n    public Action consume(Message message, ConsumeContext context) {\n        System.out.println(message.getMsgID());\n        return Action.CommitMessage;\n    }\n});\n```\n\n## 六、offset管理\n\n>这里的offset指的是Consumer的消费进度offset。\n\n消费进度offset是用来记录每个Queue的不同消费组的消费进度的。根据消费进度记录器的不同，可以分为两种模式：本地模式和远程模式。\n\n### 1 offset本地管理模式\n\n当消费模式为`广播消费`时，offset使用本地模式存储。因为每条消息会被所有的消费者消费，每个消费者管理自己的消费进度，各个消费者之间不存在消费进度的交集。\n\nConsumer在广播消费模式下offset相关数据以json的形式持久化到Consumer本地磁盘文件中，默认文件路径为当前用户主目录下的`.rocketmq_offsets/${clientId}/${group}/Offsets.json`。其中${clientId}为当前消费者id，默认为ip@DEFAULT；${group}为消费者组名称。\n\n### 2 offset远程管理模式\n\n当消费模式为`集群消费`时，offset使用远程模式管理。因为所有Cosnumer实例对消息采用的是均衡消费，所有Consumer共享Queue的消费进度。\n\nConsumer在集群消费模式下offset相关数据以json的形式持久化到Broker磁盘文件中，文件路径为当前用户主目录下的`store/config/consumerOffset.json`。\n\nBroker启动时会加载这个文件，并写入到一个双层Map（ConsumerOffsetManager）。外层map的key为topic@group，value为内层map。内层map的key为queueId，value为offset。当发生Rebalance时，新的Consumer会从该Map中获取到相应的数据来继续消费。\n\n集群模式下offset采用远程管理模式，主要是为了保证Rebalance机制。\n\n### 3 offset用途\n\n消费者是如何从最开始持续消费消息的？消费者要消费的第一条消息的起始位置是用户自己通过consumer.setConsumeFromWhere()方法指定的。\n\n在Consumer启动后，其要消费的第一条消息的起始位置常用的有三种，这三种位置可以通过枚举类型常量设置。这个枚举类型为ConsumeFromWhere。\n\n![输入图片说明](rocketmq/QQ截图20220208143837.png \"QQ截图20201229183512.png\")\n\n>CONSUME_FROM_LAST_OFFSET：从queue的当前最后一条消息开始消费<br>\nCONSUME_FROM_FIRST_OFFSET：从queue的第一条消息开始消费<br>\nCONSUME_FROM_TIMESTAMP：从指定的具 体时间戳位置的消息开始消费。这个具体时间戳是通过另外一个语句指定的 。<br>\nconsumer.setConsumeTimestamp(“20210701080000”) yyyyMMddHHmmss\n\n当消费完一批消息后，Consumer会提交其消费进度offset给Broker，Broker在收到消费进度后会将其更新到那个双层Map（ConsumerOffsetManager）及consumerOffset.json文件中，然后向该Consumer进行ACK，而ACK内容中包含三项数据：当前消费队列的最小offset（minOffset）、最大offset（maxOffset）、及下次消费的起始offset（nextBeginOffset）。\n\n### 4 重试队列\n\n![输入图片说明](rocketmq/QQ截图20220208143940.png \"QQ截图20201229183512.png\")\n\n当rocketMQ对消息的消费出现异常时，会将发生异常的消息的offset提交到Broker中的重试队列。系统在发生消息消费异常时会为当前的topic@group创建一个重试队列，该队列以%RETRY%开头，到达重试时间后进行消费重试。\n\n### 5 offset的同步提交与异步提交\n\n集群消费模式下，Consumer消费完消息后会向Broker提交消费进度offset，其提交方式分为两种：\n\n`同步提交`：消费者在消费完一批消息后会向broker提交这些消息的offset，然后等待broker的成功响应。若在等待超时之前收到了成功响应，则继续读取下一批消息进行消费（从ACK中获取nextBeginOffset）。若没有收到响应，则会重新提交，直到获取到响应。而在这个等待过程中，消费者是阻塞的。其严重影响了消费者的吞吐量。\n\n`异步提交`：消费者在消费完一批消息后向broker提交offset，但无需等待Broker的成功响应，可以继续读取并消费下一批消息。这种方式增加了消费者的吞吐量。但需要注意，broker在收到提交的offset后，还是会向消费者进行响应的。可能还没有收到ACK，此时Consumer会从Broker中直接获取nextBeginOffset。\n\n## 七、消费幂等\n\n### 1 什么是消费幂等\n\n当出现消费者对某条消息重复消费的情况时，重复消费的结果与消费一次的结果是相同的，并且多次消费并未对业务系统产生任何负面影响，那么这个消费过程就是消费幂等的。\n\n>幂等：若某操作执行多次与执行一次对系统产生的影响是相同的，则称该操作是幂等的。\n\n在互联网应用中，尤其在网络不稳定的情况下，消息很有可能会出现重复发送或重复消费。如果重复的消息可能会影响业务处理，那么就应该对消息做幂等处理。\n\n### 2 消息重复的场景分析\n\n什么情况下可能会出现消息被重复消费呢？最常见的有以下三种情况：\n\n#### 发送时消息重复\n\n当一条消息已被成功发送到Broker并完成持久化，此时出现了网络闪断，从而导致Broker对Producer应答失败。 如果此时Producer意识到消息发送失败并尝试再次发送消息，此时Broker中就可能会出现两条内容相同并且Message ID也相同的消息，那么后续Consumer就一定会消费两次该消息。\n\n#### 消费时消息重复\n\n消息已投递到Consumer并完成业务处理，当Consumer给Broker反馈应答时网络闪断，Broker没有接收到消费成功响应。为了保证消息`至少被消费一次`的原则，Broker将在网络恢复后再次尝试投递之前已被处理过的消息。此时消费者就会收到与之前处理过的内容相同、Message ID也相同的消息。\n\n#### Rebalance时消息重复\n\n当Consumer Group中的Consumer数量发生变化时，或其订阅的Topic的Queue数量发生变化时，会触发Rebalance，此时Consumer可能会收到曾经被消费过的消息。\n\n### 3 通用解决方案\n\n#### 两要素\n\n幂等解决方案的设计中涉及到两项要素：幂等令牌，与唯一性处理。只要充分利用好这两要素，就可以设计出好的幂等解决方案。\n\n* 幂等令牌：是生产者和消费者两者中的既定协议，通常指具备唯一业务标识的字符串。例如，订单号、流水号。一般由Producer随着消息一同发送来的。\n* 唯一性处理：服务端通过采用一定的算法策略，保证同一个业务逻辑不会被重复执行成功多次。例如，对同一笔订单的多次支付操作，只会成功一次。\n\n#### 解决方案\n对于常见的系统，幂等性操作的通用性解决方案是：\n\n* 1. 首先通过缓存去重。在缓存中如果已经存在了某幂等令牌，则说明本次操作是重复性操作；若缓存没有命中，则进入下一步。\n* 2. 在唯一性处理之前，先在数据库中查询幂等令牌作为索引的数据是否存在。若存在，则说明本次操作为重复性操作；若不存在，则进入下一步。\n* 3. 在同一事务中完成三项操作：唯一性处理后，将幂等令牌写入到缓存，并将幂等令牌作为唯一索引的数据写入到DB中。\n\n>第 1 步已经判断过是否是重复性操作了，为什么第 2 步还要再次判断？能够进入第 2 步，说明已经不是重复操作了，第 2 次判断是否重复？<br><br>\n当然不重复。一般缓存中的数据是具有有效期的。缓存中数据的有效期一旦过期，就是发生缓存穿透，使请求直接就到达了DBMS。\n\n#### 解决方案举例\n\n#### 以支付场景为例：\n\n* 1. 当支付请求到达后，首先在Redis缓存中却获取key为支付流水号的缓存value。若value不空，则说明本次支付是重复操作，业务系统直接返回调用侧重复支付标识；若value为空，则进入下一步操作\n* 2. 到DBMS中根据支付流水号查询是否存在相应实例。若存在，则说明本次支付是重复操作，业务系统直接返回调用侧重复支付标识；若不存在，则说明本次操作是首次操作，进入下一步完成唯一性处理\n* 3. 在分布式事务中完成三项操作：\n    * 完成支付任务\n    * 将当前支付流水号作为key，任意字符串作为value，通过set(key, value, expireTime)将数据写入到Redis缓存\n    * 将当前支付流水号作为主键，与其它相关数据共同写入到DBMS\n\n### 4 消费幂等的实现\n\n消费幂等的解决方案很简单：为消息指定不会重复的唯一标识。因为Message ID有可能出现重复的情况，所以真正安全的幂等处理，不建议以Message ID作为处理依据。最好的方式是以业务唯一标识作为幂等处理的关键依据，而业务的唯一标识可以通过消息Key设置。\n\n以支付场景为例，可以将消息的Key设置为订单号，作为幂等处理的依据。具体代码示例如下：\n\n```java\nMessage message = new Message();\nmessage.setKey(\"ORDERID_100\");\nSendResult sendResult = producer.send(message);\n```\n\n消费者收到消息时可以根据消息的Key即订单号来实现消费幂等：\n\n```java\nconsumer.registerMessageListener(new MessageListenerConcurrently() {\n    @Override\n    public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt>msgs,ConsumeConcurrentlyContext context) {\n        for(MessageExt msg:msgs){\n            String key = msg.getKeys();\n            // 根据业务唯一标识Key做幂等处理\n            // ......\n            }\n        return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n    }\n});\n```\n\n>RocketMQ能够保证消息不丢失，但不能保证消息不重复。\n\n## 八、消息堆积与消费延迟\n\n### 1 概念\n\n消息处理流程中，如果Consumer的消费速度跟不上Producer的发送速度，MQ中未处理的消息会越来越多（进的多出的少），这部分消息就被称为`堆积消息`。消息出现堆积进而会造成消息的`消费延迟`。<br>\n以下场景需要重点关注消息堆积和消费延迟问题：\n\n* 业务系统上下游能力不匹配造成的持续堆积，且无法自行恢复。\n* 业务系统对消息的消费实时性要求较高，即使是短暂的堆积造成的消费延迟也无法接受。\n\n### 2 产生原因分析\n\n![输入图片说明](rocketmq/QQ截图20220208144842.png \"QQ截图20201229183512.png\")\n\nConsumer使用长轮询Pull模式消费消息时，分为以下两个阶段：\n\n#### 消息拉取\n\nConsumer通过长轮询Pull模式批量拉取的方式从服务端获取消息，将拉取到的消息缓存到本地缓冲队列中。对于拉取式消费，在内网环境下会有很高的吞吐量，所以这一阶段一般不会成为消息堆积的瓶颈。\n\n>一个单线程单分区的低规格主机(Consumer，4C8G)，其可达到几万的TPS。如果是多个分区多个线程，则可以轻松达到几十万的TPS。\n\n#### 消息消费\n\nConsumer将本地缓存的消息提交到消费线程中，使用业务消费逻辑对消息进行处理，处理完毕后获取到一个结果。这是真正的消息消费过程。此时Consumer的消费能力就完全依赖于消息的`消费耗时`和`消费并发度`了。如果由于业务处理逻辑复杂等原因，导致处理单条消息的耗时较长，则整体的消息吞吐量肯定不会高，此时就会导致Consumer本地缓冲队列达到上限，停止从服务端拉取消息。\n\n#### 结论\n\n消息堆积的主要瓶颈在于客户端的消费能力，而消费能力由`消费耗时`和`消费并发度`决定。注意，消费耗时的优先级要高于消费并发度。即在保证了消费耗时的合理性前提下，再考虑消费并发度问题。\n\n### 3 消费耗时\n\n影响消息处理时长的主要因素是代码逻辑。而代码逻辑中可能会影响处理时长代码主要有两种类型：`CPU内部计算型代码`和`外部I/O操作型代码`。\n\n通常情况下代码中如果没有复杂的递归和循环的话，内部计算耗时相对外部I/O操作来说几乎可以忽略。所以外部IO型代码是影响消息处理时长的主要症结所在。\n\n>外部IO操作型代码举例：<br><br>\n1)读写外部数据库，例如对远程MySQL的访问<br>\n2)读写外部缓存系统，例如对远程Redis的访问<br>\n3)下游系统调用，例如Dubbo的RPC远程调用，Spring Cloud的对下游系统的Http接口调用<br><br>\n关于下游系统调用逻辑需要进行提前梳理，掌握每个调用操作预期的耗时，这样做是为了能够判断消费逻辑中IO操作的耗时是否合理。通常消息堆积是由于下游系统出现了`服务异常`或`达到了DBMS容量限制`，导致消费耗时增加。<br><br>\n服务异常，并不仅仅是系统中出现的类似 500 这样的代码错误，而可能是更加隐蔽的问题。例如，网络带宽问题。<br><br>\n达到了DBMS容量限制，其也会引发消息的消费耗时增加。\n\n### 4 消费并发度\n\n一般情况下，消费者端的消费并发度由单节点线程数和节点数量共同决定，其值为单节点线程数*节点数量。不过，通常需要优先调整单节点的线程数，若单机硬件资源达到了上限，则需要通过横向扩展来提高消费并发度。\n\n>单节点线程数，即单个Consumer所包含的线程数量<br><br>\n节点数量，即Consumer Group所包含的Consumer数量<br><br>\n对于普通消息、延时消息及事务消息，并发度计算都是单节点线程数*节点数量。但对于顺序消息则是不同的。顺序消息的消费并发度等于Topic的Queue分区数量。<br><br>\n1 ）全局顺序消息：该类型消息的Topic只有一个Queue分区。其可以保证该Topic的所有消息被顺序消费。为了保证这个全局顺序性，Consumer Group中在同一时刻只能有一个Consumer的一个线程进行消费。所以其并发度为 1 。<br><br>\n2 ）分区顺序消息：该类型消息的Topic有多个Queue分区。其仅可以保证该Topic的每个Queue分区中的消息被顺序消费，不能保证整个Topic中消息的顺序消费。为了保证这个分区顺序性，每个Queue分区中的消息在Consumer Group中的同一时刻只能有一个Consumer的一个线程进行消费。即，在同一时刻最多会出现多个Queue分蘖有多个Consumer的多个线程并行消费。所以其并发度为Topic的分区数量。\n\n### 5 单机线程数计算\n\n对于一台主机中线程池中线程数的设置需要谨慎，不能盲目直接调大线程数，设置过大的线程数反而会带来大量的线程切换的开销。理想环境下单节点的最优线程数计算模型为：C *（T1 + T2）/ T1。\n\n* C：CPU内核数\n* T1：CPU内部逻辑计算耗时\n* T2：外部IO操作耗时\n\n>最优线程数 = C *（T1 + T2）/ T1 = C * T1/T1 + C * T2/T1 = C + C * T2/T1\n\n>注意，该计算出的数值是理想状态下的理论数据，在生产环境中，不建议直接使用。而是根据当前环境，先设置一个比该值小的数值然后观察其压测效果，然后再根据效果逐步调大线程数，直至找到在该环境中性能最佳时的值。\n\n### 6 如何避免\n\n为了避免在业务使用时出现非预期的消息堆积和消费延迟问题，需要在前期设计阶段对整个业务逻辑进行完善的排查和梳理。其中最重要的就是`梳理消息的消费耗时`和`设置消息消费的并发度`。\n\n#### 梳理消息的消费耗时\n通过压测获取消息的消费耗时，并对耗时较高的操作的代码逻辑进行分析。梳理消息的消费耗时需要关注以下信息：\n\n* 消息消费逻辑的计算复杂度是否过高，代码是否存在无限循环和递归等缺陷。\n* 消息消费逻辑中的I/O操作是否是必须的，能否用本地缓存等方案规避。\n* 消费逻辑中的复杂耗时的操作是否可以做异步化处理。如果可以，是否会造成逻辑错乱。\n\n#### 设置消费并发度\n\n对于消息消费并发度的计算，可以通过以下两步实施：\n\n* 逐步调大单个Consumer节点的线程数，并观测节点的系统指标，得到单个节点最优的消费线程数和消息吞吐量。\n* 根据上下游链路的流量峰值计算出需要设置的节点数\n\n>节点数 = 流量峰值 / 单个节点消息吞吐量\n\n## 九、消息的清理\n\n消息被消费过后会被清理掉吗？不会的。\n\n消息是被顺序存储在commitlog文件的，且消息大小不定长，所以消息的清理是不可能以消息为单位进行清理的，而是以commitlog文件为单位进行清理的。否则会急剧下降清理效率，并实现逻辑复杂。\n\ncommitlog文件存在一个过期时间，默认为 72 小时，即三天。除了用户手动清理外，在以下情况下也会被自动清理，无论文件中的消息是否被消费过：\n\n* 文件过期，且到达清理时间点（默认为凌晨 4 点）后，自动清理过期文件\n* 文件过期，且磁盘空间占用率已达过期清理警戒线（默认75%）后，无论是否达到清理时间点，都会自动清理过期文件\n* 磁盘占用率达到清理警戒线（默认85%）后，开始按照设定好的规则清理文件，无论是否过期。默认会从最老的文件开始清理\n* 磁盘占用率达到系统危险警戒线（默认90%）后，Broker将拒绝消息写入\n\n>需要注意以下几点：<br>\n1 ）对于RocketMQ系统来说，删除一个1G大小的文件，是一个压力巨大的IO操作。在删除过程中，系统性能会骤然下降。所以，其默认清理时间点为凌晨 4 点，访问量最小的时间。也正因如果，我们要保障磁盘空间的空闲率，不要使系统出现在其它时间点删除commitlog文件的情况。<br>\n2 ）官方建议RocketMQ服务的Linux文件系统采用ext4。因为对于文件删除操作，ext4要比ext3性能更好\n\n# 第 4 章 RocketMQ应用\n## 一、普通消息\n### 1 消息发送分类\n\nProducer对于消息的发送方式也有多种选择，不同的方式会产生不同的系统效果。\n\n#### 同步发送消息\n\n同步发送消息是指，Producer发出一条消息后，会在收到MQ返回的ACK之后才发下一条消息。该方式的消息可靠性最高，但消息发送效率太低。\n\n![输入图片说明](rocketmq/QQ截图20220208145933.png \"QQ截图20201229183512.png\")\n\n#### 异步发送消息\n\n异步发送消息是指，Producer发出消息后无需等待MQ返回ACK，直接发送下一条消息。该方式的消息可靠性可以得到保障，消息发送效率也可以。\n\n![输入图片说明](rocketmq/QQ截图20220208150004.png \"QQ截图20201229183512.png\")\n\n#### 单向发送消息\n\n单向发送消息是指，Producer仅负责发送消息，不等待、不处理MQ的ACK。该发送方式时MQ也不返回ACK。该方式的消息发送效率最高，但消息可靠性较差。\n\n![输入图片说明](rocketmq/QQ截图20220208150023.png \"QQ截图20201229183512.png\")\n\n### 2 代码举例\n\n#### 创建工程\n\n创建一个Maven的Java工程rocketmq-test。\n\n导入rocketmq的client依赖。\n```xml\n<properties>\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    <maven.compiler.source>1.8</maven.compiler.source>\n    <maven.compiler.target>1.8</maven.compiler.target>\n</properties>\n<dependencies>\n    <dependency>\n        <groupId>org.apache.rocketmq</groupId>\n        <artifactId>rocketmq-client</artifactId>\n        <version>4.8.0</version>\n    </dependency>\n</dependencies>\n```\n#### 定义同步消息发送生产者\n\n```java\npublic class SyncProducer {\n    public static void main(String[] args) throws Exception {\n        // 创建一个producer，参数为Producer Group名称\n        DefaultMQProducer producer = new DefaultMQProducer(\"pg\");\n        // 指定nameServer地址\n        producer.setNamesrvAddr(\"rocketmqOS:9876\");\n        // 设置当发送失败时重试发送的次数，默认为 2 次\n        producer.setRetryTimesWhenSendFailed( 3 );\n        // 设置发送超时时限为5s，默认3s\n        producer.setSendMsgTimeout( 5000 );\n        // 开启生产者\n        producer.start();\n        // 生产并发送 100 条消息\n        for (int i = 0 ; i < 100 ; i++) {\n            byte[] body = (\"Hi,\" + i).getBytes();\n            Message msg = new Message(\"someTopic\", \"someTag\", body);\n            // 为消息指定key\n            msg.setKeys(\"key-\" + i);\n            // 发送消息\n            SendResult sendResult = producer.send(msg);\n            System.out.println(sendResult);\n        }\n        // 关闭producer\n        producer.shutdown();\n    }\n}\n```\n\n```java\n// 消息发送的状态\npublic enum SendStatus {\n    SEND_OK, // 发送成功\n    FLUSH_DISK_TIMEOUT,  // 刷盘超时。当Broker设置的刷盘策略为同步刷盘时才可能出现这种异常状态。异步刷盘不会出现\n    FLUSH_SLAVE_TIMEOUT, // Slave同步超时。当Broker集群设置的Master-Slave的复制方式为同步复制时才可能出现这种异常状态。异步复制不会出现\n    SLAVE_NOT_AVAILABLE, // 没有可用的Slave。当Broker集群设置为Master-Slave的复制方式为同步复制时才可能出现这种异常状态。异步复制不会出现\n}\n```\n\n#### 定义异步消息发送生产者\n```java\npublic class AsyncProducer {\n    public static void main(String[] args) throws Exception {\n        DefaultMQProducer producer = new DefaultMQProducer(\"pg\");\n        producer.setNamesrvAddr(\"rocketmqOS:9876\");\n        // 指定异步发送失败后不进行重试发送\n        producer.setRetryTimesWhenSendAsyncFailed( 0 );\n        // 指定新创建的Topic的Queue数量为 2 ，默认为 4\n        producer.setDefaultTopicQueueNums( 2 );\n\n        producer.start();\n\n        for (int i = 0 ; i < 100 ; i++) {\n            byte[] body = (\"Hi,\" + i).getBytes();\n            try {\n            Message msg = new Message(\"myTopicA\", \"myTag\", body);\n            // 异步发送。指定回调\n            producer.send(msg, new SendCallback() {\n                    // 当producer接收到MQ发送来的ACK后就会触发该回调方法的执行\n                    @Override\n                    public void onSuccess(SendResult sendResult) {\n                    System.out.println(sendResult);\n                    }\n\n                    @Override\n                    public void onException(Throwable e) {\n                    e.printStackTrace();\n                    }\n                });\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        } // end-for\n        // sleep一会儿\n        // 由于采用的是异步发送，所以若这里不sleep，\n        // 则消息还未发送就会将producer给关闭，报错\n        TimeUnit.SECONDS.sleep( 3 );\n        producer.shutdown();\n    }\n}\n```\n\n#### 定义单向消息发送生产者\n```java\npublic class OnewayProducer {\n    public static void main(String[] args) throws Exception{\n        DefaultMQProducer producer = new DefaultMQProducer(\"pg\");\n        producer.setNamesrvAddr(\"rocketmqOS:9876\");\n        producer.start();\n\n        for (int i = 0 ; i < 10 ; i++) {\n            byte[] body = (\"Hi,\" + i).getBytes();\n            Message msg = new Message(\"single\", \"someTag\", body);\n            // 单向发送\n            producer.sendOneway(msg);\n        }\n        producer.shutdown();\n        System.out.println(\"producer shutdown\");\n    }\n}\n```\n#### 定义消息消费者\n```java\npublic class SomeConsumer {\n    public static void main(String[] args) throws MQClientException {\n        // 定义一个pull消费者\n        // DefaultLitePullConsumer consumer = new\n        DefaultLitePullConsumer(\"cg\");\n        // 定义一个push消费者\n        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(\"cg\");\n        // 指定nameServer\n        consumer.setNamesrvAddr(\"rocketmqOS:9876\");\n        // 指定从第一条消息开始消费\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n        // 指定消费topic与tag\n        consumer.subscribe(\"someTopic\", \"*\");\n        // 指定采用“广播模式”进行消费，默认为“集群模式”\n        // consumer.setMessageModel(MessageModel.BROADCASTING);\n        // 注册消息监听器\n        consumer.registerMessageListener(new MessageListenerConcurrently() {\n            // 一旦broker中有了其订阅的消息就会触发该方法的执行，\n            // 其返回值为当前consumer消费的状态\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,ConsumeConcurrentlyContext context) {\n                // 逐条消费消息\n                for (MessageExt msg : msgs) {\n                    System.out.println(msg);\n                }\n                // 返回消费状态：消费成功\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            }\n        });\n        // 开启消费者消费\n        consumer.start();\n        System.out.println(\"Consumer Started\");\n    }\n}\n```\n\n## 二、顺序消息\n\n### 1 什么是顺序消息\n\n顺序消息指的是，严格按照消息的`发送顺序`进行`消费`的消息(FIFO)。\n\n默认情况下生产者会把消息以Round Robin轮询方式发送到不同的Queue分区队列；而消费消息时会从多个Queue上拉取消息，这种情况下的发送和消费是不能保证顺序的。如果将消息仅发送到同一个Queue中，消费时也只从这个Queue上拉取消息，就严格保证了消息的顺序性。\n\n### 2 为什么需要顺序消息\n\n例如，现在有TOPIC `ORDER_STATUS`(订单状态)，其下有 4 个Queue队列，该Topic中的不同消息用于描述当前订单的不同状态。假设订单有状态：未支付、已支付、发货中、发货成功、发货失败。\n\n根据以上订单状态，生产者从时序上可以生成如下几个消息：\n\n`订单T0000001:未支付 --> 订单T0000001:已支付 --> 订单T0000001:发货中 --> 订单T0000001:发货失败\n\n消息发送到MQ中之后，Queue的选择如果采用轮询策略，消息在MQ的存储可能如下：\n\n![输入图片说明](rocketmq/QQ截图20220208152040.png \"QQ截图20201229183512.png\")\n\n这种情况下，我们希望Consumer消费消息的顺序和我们发送是一致的，然而上述MQ的投递和消费方式，我们无法保证顺序是正确的。对于顺序异常的消息，Consumer即使设置有一定的状态容错，也不能完全处理好这么多种随机出现组合情况。\n\n![输入图片说明](rocketmq/QQ截图20220208152144.png \"QQ截图20201229183512.png\")\n\n基于上述的情况，可以设计如下方案：对于相同订单号的消息，通过一定的策略，将其放置在一个Queue中，然后消费者再采用一定的策略（例如，一个线程独立处理一个queue，保证处理消息的顺序性），能够保证消费的顺序性。\n\n### 3 有序性分类\n\n根据有序范围的不同，RocketMQ可以严格地保证两种消息的有序性：分区有序与全局有序。\n\n#### 全局有序\n\n![输入图片说明](rocketmq/QQ截图20220208152224.png \"QQ截图20201229183512.png\")\n\n当发送和消费参与的Queue只有一个时所保证的有序是整个Topic中消息的顺序， 称为`全局有序`。\n\n>在创建Topic时指定Queue的数量。有三种指定方式：<br><br>\n1 ）在代码中创建Producer时，可以指定其自动创建的Topic的Queue数量<br><br>\n2 ）在RocketMQ可视化控制台中手动创建Topic时指定Queue数量<br><br>\n3 ）使用mqadmin命令手动创建Topic时指定Queue数量<br>\n\n#### 分区有序\n\n![输入图片说明](rocketmq/QQ截图20220208152417.png \"QQ截图20201229183512.png\")\n\n如果有多个Queue参与，其仅可保证在该Queue分区队列上的消息顺序，则称为`分区有序`。\n\n>如何实现Queue的选择？在定义Producer时我们可以指定消息队列选择器，而这个选择器是我们自己实现了MessageQueueSelector接口定义的。<br><br>\n在定义选择器的选择算法时，一般需要使用选择key。这个选择key可以是消息key也可以是其它数据。但无论谁做选择key，都不能重复，都是唯一的。<br><br>\n一般性的选择算法是，让选择key（或其hash值）与该Topic所包含的Queue的数量取模，其结果即为选择出的Queue的QueueId。<br><br>\n取模算法存在一个问题：不同选择key与Queue数量取模结果可能会是相同的，即不同选择key的消息可能会出现在相同的Queue，即同一个Consuemr可能会消费到不同选择key的消息。这个问题如何解决？一般性的作法是，从消息中获取到选择key，对其进行判断。若是当前Consumer需要消费的消息，则直接消费，否则，什么也不做。这种做法要求选择key要能够随着消息一起被Consumer获取到。此时使用消息key作为选择key是比较好的做法。<br><br>\n以上做法会不会出现如下新的问题呢？不属于那个Consumer的消息被拉取走了，那么应该消费该消息的Consumer是否还能再消费该消息呢？同一个Queue中的消息不可能被同一个Group中的不同Consumer同时消费。所以，消费现一个Queue的不同选择key的消息的Consumer一定属于不同的Group。而不同的Group中的Consumer间的消费是相互隔离的，互不影响的。\n\n### 4 代码举例\n```java\npublic class OrderedProducer {\n    public static void main(String[] args) throws Exception {\n        DefaultMQProducer producer = new DefaultMQProducer(\"pg\");\n        producer.setNamesrvAddr(\"rocketmqOS:9876\");\n        producer.start();\n        for (int i = 0 ; i < 100 ; i++) {\n            Integer orderId = i;\n            byte[] body = (\"Hi,\" + i).getBytes();\n            Message msg = new Message(\"TopicA\", \"TagA\", body);\n            SendResult sendResult = producer.send(msg, new MessageQueueSelector() {\n                @Override\n                public MessageQueue select(List<MessageQueue> mqs,Message msg, Object arg) {\n                        Integer id = (Integer) arg;\n                        int index = id % mqs.size();\n                        return mqs.get(index);\n                    }\n                }, orderId);\n            System.out.println(sendResult);\n        }\n        producer.shutdown();\n    }\n}\n```\n## 三、延时消息\n\n### 1 什么是延时消息\n\n当消息写入到Broker后，在指定的时长后才可被消费处理的消息，称为延时消息。\n\n采用RocketMQ的延时消息可以实现`定时任务`的功能，而无需使用定时器。典型的应用场景是，电商交易中超时未支付关闭订单的场景， 12306 平台订票超时未支付取消订票的场景。\n\n>在电商平台中，订单创建时会发送一条延迟消息。这条消息将会在 30 分钟后投递给后台业务系统（Consumer），后台业务系统收到该消息后会判断对应的订单是否已经完成支付。如果未完成，则取消订单，将商品再次放回到库存；如果完成支付，则忽略。<br><br>\n在 12306 平台中，车票预订成功后就会发送一条延迟消息。这条消息将会在 45 分钟后投递给后台业务系统（Consumer），后台业务系统收到该消息后会判断对应的订单是否已经完成支付。如果未完成，则取消预订，将车票再次放回到票池；如果完成支付，则忽略。\n\n### 2 延时等级\n\n延时消息的延迟时长`不支持随意时长`的延迟，是通过特定的延迟等级来指定的。延时等级定义在RocketMQ服务端的MessageStoreConfig类中的如下变量中：\n\n![输入图片说明](rocketmq/QQ截图20220208153410.png \"QQ截图20201229183512.png\")\n\n即，若指定的延时等级为 3 ，则表示延迟时长为10s，即延迟等级是从 1 开始计数的。\n\n当然，如果需要自定义的延时等级，可以通过在broker加载的配置中新增如下配置（例如下面增加了 1天这个等级1d）。配置文件在RocketMQ安装目录下的conf目录中。\n\n```\nmessageDelayLevel = 1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h 1d\n```\n### 3 延时消息实现原理\n\n![输入图片说明](rocketmq/QQ截图20220208153523.png \"QQ截图20201229183512.png\")\n\n#### 具体实现方案是：\n\n#### 修改消息\n\n![输入图片说明](rocketmq/QQ截图20220208153545.png \"QQ截图20201229183512.png\")\n\nProducer将消息发送到Broker后，Broker会首先将消息写入到commitlog文件，然后需要将其分发到相应的consumequeue。不过，在分发之前，系统会先判断消息中是否带有延时等级。若没有，则直接正常分发；若有则需要经历一个复杂的过程：\n\n* 修改消息的Topic为SCHEDULE_TOPIC_XXXX\n* 根据延时等级，在consumequeue目录中SCHEDULE_TOPIC_XXXX主题下创建出相应的queueId目录与consumequeue文件（如果没有这些目录与文件的话）。\n\n>延迟等级delayLevel与queueId的对应关系为queueId = delayLevel -1<br>\n需要注意，在创建queueId目录时，并不是一次性地将所有延迟等级对应的目录全部创建完毕，而是用到哪个延迟等级创建哪个目录\n\n![输入图片说明](rocketmq/QQ截图20220208153635.png \"QQ截图20201229183512.png\")\n\n* 修改消息索引单元内容。索引单元中的Message Tag HashCode部分原本存放的是消息的Tag的Hash值。现修改为消息的`投递时间`。投递时间是指该消息被重新修改为原Topic后再次被写入到commitlog中的时间。`投递时间 = 消息存储时间 + 延时等级时间`。消息存储时间指的是消息被发送到Broker时的时间戳。\n* 将消息索引写入到SCHEDULE_TOPIC_XXXX主题下相应的consumequeue中\n\n>SCHEDULE_TOPIC_XXXX目录中各个延时等级Queue中的消息是如何排序的？<br><br>\n是按照消息投递时间排序的。一个Broker中同一等级的所有延时消息会被写入到consumequeue目录中SCHEDULE_TOPIC_XXXX目录下相同Queue中。即一个Queue中消息投递时间的延迟等级时间是相同的。那么投递时间就取决于于`消息存储时间`了。即按照消息被发送到Broker的时间进行排序的。\n\n#### 投递延时消息\n\nBroker内部有一个延迟消息服务类ScheuleMessageService，其会消费SCHEDULE_TOPIC_XXXX中的消息，即按照每条消息的投递时间，将延时消息投递到目标Topic中。不过，在投递之前会从commitlog中将原来写入的消息再次读出，并将其原来的延时等级设置为 0 ，即原消息变为了一条不延迟的普通消息。然后再次将消息投递到目标Topic中。\n\n>ScheuleMessageService在Broker启动时，会创建并启动一个定时器TImer，用于执行相应的定时任务。系统会根据延时等级的个数，定义相应数量的TimerTask，每个TimerTask负责一个延迟等级消息的消费与投递。每个TimerTask都会检 测相应Queue队列的第一条消息是否到期。若第一条消息未到期，则后面的所有消息更不会到期（消息是按照投递时间排序的）；若第一条消息到期了，则将该消息投递到目标Topic，即消费该消息。\n\n#### 将消息重新写入commitlog\n\n延迟消息服务类ScheuleMessageService将延迟消息再次发送给了commitlog，并再次形成新的消息索引条目，分发到相应Queue。\n\n>这其实就是一次普通消息发送。只不过这次的消息Producer是延迟消息服务类ScheuleMessageService。\n\n### 4 代码举例\n\n定义DelayProducer类\n\n```java\npublic class DelayProducer {\n    public static void main(String[] args) throws Exception {\n        DefaultMQProducer producer = new DefaultMQProducer(\"pg\");\n        producer.setNamesrvAddr(\"rocketmqOS:9876\");\n        producer.start();\n        for (int i = 0 ; i < 10 ; i++) {\n            byte[] body = (\"Hi,\" + i).getBytes();\n            Message msg = new Message(\"TopicB\", \"someTag\", body);\n            // 指定消息延迟等级为 3 级，即延迟10s\n            // msg.setDelayTimeLevel(3);\n            SendResult sendResult = producer.send(msg);\n            // 输出消息被发送的时间\n            System.out.print(new SimpleDateFormat(\"mm:ss\").format(new Date()));\n            System.out.println(\" ,\" + sendResult);\n        }\n        producer.shutdown();\n    }\n}\n```\n\n定义OtherConsumer类\n\n```java\npublic class OtherConsumer {\n    public static void main(String[] args) throws MQClientException {\n        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(\"cg\");\n        consumer.setNamesrvAddr(\"rocketmqOS:9876\");\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET );\n        consumer.subscribe(\"TopicB\", \"*\");\n        consumer.registerMessageListener(new MessageListenerConcurrently() {\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,ConsumeConcurrentlyContext context) {\n            for (MessageExt msg : msgs) {\n                    // 输出消息被消费的时间\n                    System.out.print(new SimpleDateFormat(\"mm:ss\").format(new Date()));\n                    System.out.println(\" ,\" + msg);\n                }\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            }\n        });\n        consumer.start();\n        System.out.println(\"Consumer Started\");\n    }\n}\n```\n\n## 四、事务消息\n\n### 1 问题引入\n\n这里的一个需求场景是：工行用户A向建行用户B转账 1 万元。\n\n我们可以使用同步消息来处理该需求场景：\n\n![输入图片说明](rocketmq/QQ截图20220208154429.png \"QQ截图20201229183512.png\")\n\n* 1. 工行系统发送一个给B增款 1 万元的同步消息M给Broker\n* 2. 消息被Broker成功接收后，向工行系统发送成功ACK\n* 3. 工行系统收到成功ACK后从用户A中扣款 1 万元\n* 4. 建行系统从Broker中获取到消息M\n* 5. 建行系统消费消息M，即向用户B中增加 1 万元\n\n>这其中是有问题的：若第 3 步中的扣款操作失败，但消息已经成功发送到了Broker。对于MQ来说，只要消息写入成功，那么这个消息就可以被消费。此时建行系统中用户B增加了 1 万元。出现了数据不一致问题。\n\n### 2 解决思路\n\n解决思路是，让第 1 、 2 、 3 步具有原子性，要么全部成功，要么全部失败。即消息发送成功后，必须要保证扣款成功。如果扣款失败，则回滚发送成功的消息。而该思路即使用`事务消息`。这里要使用`分布式事务`解决方案。\n\n![输入图片说明](rocketmq/QQ截图20220208154545.png \"QQ截图20201229183512.png\")\n\n#### 使用事务消息来处理该需求场景：\n\n* 1. 事务管理器TM向事务协调器TC发起指令，开启全局事务\n* 2. 工行系统发一个给B增款 1 万元的事务消息M给TC\n* 3. TC会向Broker发送半事务消息prepareHalf，将消息M预提交到Broker。此时的建行系统是看不到Broker中的消息M的\n* 4. Broker会将预提交执行结果Report给TC。\n* 5. 如果预提交失败，则TC会向TM上报预提交失败的响应，全局事务结束；如果预提交成功，TC会调用工行系统的回调操作，去完成工行用户A的预扣款 1 万元的操作\n* 6. 工行系统会向TC发送预扣款执行结果，即本地事务的执行状态\n* 7. TC收到预扣款执行结果后，会将结果上报给TM。\n\n>预扣款执行结果存在三种可能性：<br>\n```java\n// 描述本地事务执行状态\npublic enum LocalTransactionState {\n    COMMIT_MESSAGE,  // 本地事务执行成功\n    ROLLBACK_MESSAGE,  // 本地事务执行失败\n    UNKNOW,  // 不确定，表示需要进行回查以确定本地事务的执行结果\n}\n```\n* 8. TM会根据上报结果向TC发出不同的确认指令\n    * 若预扣款成功（本地事务状态为COMMIT_MESSAGE），则TM向TC发送Global Commit指令\n    * 若预扣款失败（本地事务状态为ROLLBACK_MESSAGE），则TM向TC发送Global Rollback指令\n    * 若现未知状态（本地事务状态为UNKNOW），则会触发工行系统的本地事务状态`回查操作`。回查操作会将回查结果，即COMMIT_MESSAGE或ROLLBACK_MESSAGE Report给TC。TC将结果上报给TM，TM会再向TC发送最终确认指令Global Commit或Global Rollback\n\n* 9. TC在接收到指令后会向Broker与工行系统发出确认指令\n    * TC接收的若是Global Commit指令，则向Broker与工行系统发送Branch Commit指令。此时Broker中的消息M才可被建行系统看到；此时的工行用户A中的扣款操作才真正被确认\n    * TC接收到的若是Global Rollback指令，则向Broker与工行系统发送Branch Rollback指令。此时Broker中的消息M将被撤销；工行用户A中的扣款操作将被回滚\n\n>以上方案就是为了确保`消息投递`与`扣款操作`能够在一个事务中，要成功都成功，有一个失败，则全部回滚。<br><br>\n以上方案并不是一个典型的XA模式。因为XA模式中的分支事务是异步的，而事务消息方案中的消息预提交与预扣款操作间是同步的。\n\n### 3 基础\n\n#### 分布式事务\n对于分布式事务，通俗地说就是，一次操作由若干分支操作组成，这些分支操作分属不同应用，分布在不同服务器上。分布式事务需要保证这些分支操作要么全部成功，要么全部失败。分布式事务与普通事务一样，就是为了保证操作结果的一致性。\n\n#### 事务消息\n\nRocketMQ提供了类似X/Open XA的分布式事务功能，通过事务消息能达到分布式事务的最终一致。XA是一种分布式事务解决方案，一种分布式事务处理模式。\n\n#### 半事务消息\n\n暂不能投递的消息，发送方已经成功地将消息发送到了Broker，但是Broker未收到最终确认指令，此时该消息被标记成“暂不能投递”状态，即不能被消费者看到。处于该种状态下的消息即半事务消息。\n\n#### 本地事务状态\n\nProducer`回调操作`执行的结果为本地事务状态，其会发送给TC，而TC会再发送给TM。TM会根据TC发送来的本地事务状态来决定全局事务确认指令。\n\n```java\n// 描述本地事务执行状态\npublic enum LocalTransactionState {\n    COMMIT_MESSAGE,  // 本地事务执行成功\n    ROLLBACK_MESSAGE,  // 本地事务执行失败\n    UNKNOW,  // 不确定，表示需要进行回查以确定本地事务的执行结果\n}\n```\n\n#### 消息回查\n![输入图片说明](rocketmq/QQ截图20220208155046.png \"QQ截图20201229183512.png\")\n\n消息回查，即重新查询本地事务的执行状态。本例就是重新到DB中查看预扣款操作是否执行成功。\n\n>注意，消息回查不是重新执行回调操作。回调操作是进行预扣款操作，而消息回查则是查看预扣款操作执行的结果。<br><br>\n引发消息回查的原因最常见的有两个：<br>\n1)回调操作返回UNKNWON<br>\n2)TC没有接收到TM的最终全局事务确认指令<br>\n\n#### RocketMQ中的消息回查设置\n\n关于消息回查，有三个常见的属性设置。它们都在broker加载的配置文件中设置，例如：\n\n* transactionTimeout=20，指定TM在 20 秒内应将最终确认状态发送给TC，否则引发消息回查。默认为 60 秒\n* transactionCheckMax=5，指定最多回查 5 次，超过后将丢弃消息并记录错误日志。默认 15 次。\n* transactionCheckInterval=10，指定设置的多次消息回查的时间间隔为 10 秒。默认为 60 秒。\n\n### 4 XA模式三剑客\n\n#### XA协议\n\nXA（Unix Transaction）是一种分布式事务解决方案，一种分布式事务处理模式，是基于XA协议的。<br>\nXA协议由Tuxedo（Transaction for Unix has been Extended for Distributed Operation，分布式操作扩展之后的Unix事务系统）首先提出的，并交给X/Open组织，作为资源管理器与事务管理器的接口标准。\n\n`XA模式中有三个重要组件：TC、TM、RM。`\n\n#### TC\n\nTransaction Coordinator，事务协调者。维护全局和分支事务的状态，驱动全局事务提交或回滚。\n\n```\nRocketMQ中Broker充当着TC。\n```\n#### TM\n\nTransaction Manager，事务管理器。定义全局事务的范围：开始全局事务、提交或回滚全局事务。它实际是全局事务的发起者。\n\n>RocketMQ中事务消息的Producer充当着TM。\n\n#### RM\n\nResource Manager，资源管理器。管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。\n\n>RocketMQ中事务消息的Producer及Broker均是RM。\n\n### 5 XA模式架构\n\n![输入图片说明](rocketmq/QQ截图20220208155359.png \"QQ截图20201229183512.png\")\n\nXA模式是一个典型的2PC，其执行原理如下：\n* 1. TM向TC发起指令，开启一个全局事务。\n* 2. 根据业务要求，各个RM会逐个向TC注册分支事务，然后TC会逐个向RM发出预执行指令。\n* 3. 各个RM在接收到指令后会在进行本地事务预执行。\n* 4. RM将预执行结果Report给TC。当然，这个结果可能是成功，也可能是失败。\n* 5. TC在接收到各个RM的Report后会将汇总结果上报给TM，根据汇总结果TM会向TC发出确认指令。\n    * 若所有结果都是成功响应，则向TC发送Global Commit指令。\n    * 只要有结果是失败响应，则向TC发送Global Rollback指令。\n* 6. TC在接收到指令后再次向RM发送确认指令。\n\n>事务消息方案并不是一个典型的XA模式。因为XA模式中的分支事务是异步的，而事务消息方案中的消息预提交与预扣款操作间是同步的。\n\n### 6 注意\n\n* 事务消息不支持延时消息\n* 对于事务消息要做好幂等性检查，因为事务消息可能不止一次被消费（因为存在回滚后再提交的情况）\n\n### 7 代码举例\n\n\n#### 定义工行事务监听器\n```java\npublic class ICBCTransactionListener implements TransactionListener {\n    // 回调操作方法\n    // 消息预提交成功就会触发该方法的执行，用于完成本地事务\n    @Override\n    public LocalTransactionState executeLocalTransaction(Message msg,Object arg) {\n        System.out.println(\"预提交消息成功：\" + msg);\n        // 假设接收到TAGA的消息就表示扣款操作成功，TAGB的消息表示扣款失败，\n        // TAGC表示扣款结果不清楚，需要执行消息回查\n        if (StringUtils.equals(\"TAGA\", msg.getTags())) {\n            return LocalTransactionState.COMMIT_MESSAGE;\n        } else if (StringUtils.equals(\"TAGB\", msg.getTags())) {\n            return LocalTransactionState.ROLLBACK_MESSAGE;\n        } else if (StringUtils.equals(\"TAGC\", msg.getTags())) {\n            return LocalTransactionState.UNKNOW;\n        }\n            return LocalTransactionState.UNKNOW;\n    }\n\n    // 消息回查方法\n    // 引发消息回查的原因最常见的有两个：\n    // 1)回调操作返回UNKNWON\n    // 2)TC没有接收到TM的最终全局事务确认指令\n    @Override\n    public LocalTransactionState checkLocalTransaction(MessageExt msg) {\n        System.out.println(\"执行消息回查\" + msg.getTags());\n        return LocalTransactionState.COMMIT_MESSAGE;\n    }\n}\n```\n#### 定义事物消息生产者\n\n```java\npublic class TransactionProducer {\n    public static void main(String[] args) throws Exception {\n        TransactionMQProducer producer = new TransactionMQProducer(\"tpg\");\n        producer.setNamesrvAddr(\"rocketmqOS:9876\");\n        /**\n        * 定义一个线程池\n        * @param corePoolSize 线程池中核心线程数量\n        * @param maximumPoolSize 线程池中最多线程数\n        * @param keepAliveTime 这是一个时间。当线程池中线程数量大于核心线程数量是，多余空闲线程的存活时长\n        * @param unit 时间单位\n        * @param workQueue 临时存放任务的队列，其参数就是队列的长度\n        * @param threadFactory 线程工厂\n        */\n        ExecutorService executorService = new ThreadPoolExecutor( 2 , 5 ,100 , TimeUnit.SECONDS,new ArrayBlockingQueue<Runnable>( 2000 ), new ThreadFactory() {\n            @Override\n            public Thread newThread(Runnable r) {\n                Thread thread = new Thread(r);\n                thread.setName(\"client-transaction-msg-check-thread\");\n                return thread;\n            }\n        });\n        // 为生产者指定一个线程池\n        producer.setExecutorService(executorService);\n        // 为生产者添加事务监听器\n        producer.setTransactionListener(new ICBCTransactionListener());\n        producer.start();\n        String[] tags = {\"TAGA\",\"TAGB\",\"TAGC\"};\n        for (int i = 0 ; i < 3 ; i++) {\n            byte[] body = (\"Hi,\" + i).getBytes();\n            Message msg = new Message(\"TTopic\", tags[i], body);\n            // 发送事务消息\n            // 第二个参数用于指定在执行本地事务时要使用的业务参数\n            SendResult sendResult =producer.sendMessageInTransaction(msg,null);\n            System.out.println(\"发送结果为：\" +sendResult.getSendStatus());\n        }\n    }\n}\n```\n#### 定义消费者\n\n直接使用普通消息的SomeConsumer作为消费者即可。\n\n```java\npublic class SomeConsumer {\n    public static void main(String[] args) throws MQClientException {\n        // DefaultLitePullConsumer consumer = new DefaultLitePullConsumer(\"cg\");\n        // 定义一个push消费者\n        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(\"cg\");\n        // 指定nameServer\n        consumer.setNamesrvAddr(\"rocketmqOS:9876\");\n        // 指定从第一条消息开始消费\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n        // 指定消费topic与tag\n        consumer.subscribe(\"TTopic\", \"*\");\n        // 指定采用“广播模式”进行消费，默认为“集群模式”\n        // consumer.setMessageModel(MessageModel.BROADCASTING);\n\n        // 注册消息监听器\n        consumer.registerMessageListener(new MessageListenerConcurrently() {\n            // 一旦broker中有了其订阅的消息就会触发该方法的执行，\n            // 其返回值为当前consumer消费的状态\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,ConsumeConcurrentlyContext context) {\n                // 逐条消费消息\n                for (MessageExt msg : msgs) {\n                    System.out.println(msg);\n                }\n            // 返回消费状态：消费成功\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            }\n        });\n        // 开启消费者消费\n        consumer.start();\n        System.out.println(\"Consumer Started\");\n    }\n}\n```\n\n## 五、批量消息\n\n### 1 批量发送消息\n\n#### 发送限制\n\n生产者进行消息发送时可以一次发送多条消息，这可以大大提升Producer的发送效率。不过需要注意以下几点：\n\n* 批量发送的消息必须具有相同的Topic\n* 批量发送的消息必须具有相同的刷盘策略\n* 批量发送的消息不能是延时消息与事务消息\n\n#### 批量发送大小\n\n默认情况下，一批发送的消息总大小不能超过4MB字节。如果想超出该值，有两种解决方案：\n\n* 方案一：将批量消息进行拆分，拆分为若干不大于4M的消息集合分多次批量发送\n* 方案二：在Producer端与Broker端修改属性\n\n** Producer端需要在发送之前设置Producer的maxMessageSize属性\n\n** Broker端需要修改其加载的配置文件中的maxMessageSize属性\n\n#### 生产者发送的消息大小\n![输入图片说明](rocketmq/QQ截图20220208160513.png \"QQ截图20201229183512.png\")\n\n生产者通过send()方法发送的Message，并不是直接将Message序列化后发送到网络上的，而是通过这个Message生成了一个字符串发送出去的。这个字符串由四部分构成：Topic、消息Body、消息日志（占 20 字节），及用于描述消息的一堆属性key-value。这些属性中包含例如生产者地址、生产时间、要发送的QueueId等。最终写入到Broker中消息单元中的数据都是来自于这些属性。\n\n### 2 批量消费消息\n\n#### 修改批量属性\n![输入图片说明](rocketmq/QQ截图20220208160544.png \"QQ截图20201229183512.png\")\n\nConsumer的MessageListenerConcurrently监听接口的consumeMessage()方法的第一个参数为消息列表，但默认情况下每次只能消费一条消息。若要使其一次可以消费多条消息，则可以通过修改Consumer的consumeMessageBatchMaxSize属性来指定。不过，该值不能超过 32 。因为默认情况下消费者每次可以拉取的消息最多是 32 条。若要修改一次拉取的最大值，则可通过修改Consumer的pullBatchSize属性来指定。\n\n#### 存在的问题\n\nConsumer的pullBatchSize属性与consumeMessageBatchMaxSize属性是否设置的越大越好？当然不是。\n\n* pullBatchSize值设置的越大，Consumer每拉取一次需要的时间就会越长，且在网络上传输出现问题的可能性就越高。若在拉取过程中若出现了问题，那么本批次所有消息都需要全部重新拉取。\n* consumeMessageBatchMaxSize值设置的越大，Consumer的消息并发消费能力越低，且这批被消费的消息具有相同的消费结果。因为consumeMessageBatchMaxSize指定的一批消息只会使用一个线程进行处理，且在处理过程中只要有一个消息处理异常，则这批消息需要全部重新再次消费处理。\n### 3 代码举例\n该批量发送的需求是，不修改最大发送4M的默认值，但要防止发送的批量消息超出4M的限制。\n\n#### 定义消息列表分割器\n```java\n    // 消息列表分割器：其只会处理每条消息的大小不超4M的情况。\n    // 若存在某条消息，其本身大小大于4M，这个分割器无法处理，\n    // 其直接将这条消息构成一个子列表返回。并没有再进行分割\npublic class MessageListSplitter implements Iterator<List<Message>> {\n    // 指定极限值为4M\n    private final int SIZE_LIMIT =  4 * 1024 * 1024 ;\n    // 存放所有要发送的消息\n    private final List<Message> messages;\n    // 要进行批量发送消息的小集合起始索引\n    private int currIndex;\n    public MessageListSplitter(List<Message> messages) {\n        this.messages = messages;\n    }\n    @Override\n    public boolean hasNext() {\n    // 判断当前开始遍历的消息索引要小于消息总数\n    return currIndex < messages.size();\n    }\n    @Override\n    public List<Message> next() {\n        int nextIndex = currIndex;\n        // 记录当前要发送的这一小批次消息列表的大小\n        int totalSize = 0 ;\n        for (; nextIndex < messages.size(); nextIndex++) {\n            // 获取当前遍历的消息\n            Message message = messages.get(nextIndex);\n            // 统计当前遍历的message的大小\n            int tmpSize = message.getTopic().length() + message.getBody().length;\n            Map<String, String> properties = message.getProperties();\n            for (Map.Entry<String, String> entry :properties.entrySet()) {\n                tmpSize += entry.getKey().length() +\n                entry.getValue().length();\n            }\n            tmpSize = tmpSize + 20 ;\n            // 判断当前消息本身是否大于4M\n            if (tmpSize > SIZE_LIMIT) {\n                if (nextIndex - currIndex == 0 ) {\n                    nextIndex++;\n                }\n                break;\n            }\n\n            if (tmpSize + totalSize > SIZE_LIMIT) {\n                break;\n            } else {\n                totalSize += tmpSize;\n            }\n\n        } // end-for\n        // 获取当前messages列表的子集合[currIndex, nextIndex)\n        List<Message> subList = messages.subList(currIndex, nextIndex);\n        // 下次遍历的开始索引\n        currIndex = nextIndex;\n        return subList;\n    }\n}\n```\n\n#### 定义批量消息生产者\n```java\npublic class BatchProducer {\n    public static void main(String[] args) throws Exception {\n        DefaultMQProducer producer = new DefaultMQProducer(\"pg\");\n        producer.setNamesrvAddr(\"rocketmqOS:9876\");\n        // 指定要发送的消息的最大大小，默认是4M\n        // 不过，仅修改该属性是不行的，还需要同时修改broker加载的配置文件中的\n        // maxMessageSize属性\n        // producer.setMaxMessageSize(8 * 1024 * 1024);\n        producer.start();\n\n        // 定义要发送的消息集合\n        List<Message> messages = new ArrayList<>();\n        for (int i = 0 ; i < 100 ; i++) {\n            byte[] body = (\"Hi,\" + i).getBytes();\n            Message msg = new Message(\"someTopic\", \"someTag\", body);\n            messages.add(msg);\n        }\n\n        // 定义消息列表分割器，将消息列表分割为多个不超出4M大小的小列表\n        MessageListSplitter splitter = new MessageListSplitter(messages);\n        while (splitter.hasNext()) {\n            try {\n                List<Message> listItem = splitter.next();\n                producer.send(listItem);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        producer.shutdown();\n    }\n}\n```\n#### 定义批量消息消费者\n\n```java\npublic class BatchConsumer {\n    public static void main(String[] args) throws MQClientException {\n        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(\"cg\");\n        consumer.setNamesrvAddr(\"rocketmqOS:9876\");\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n        consumer.subscribe(\"someTopicA\", \"*\");\n\n        // 指定每次可以消费 10 条消息，默认为 1\n        consumer.setConsumeMessageBatchMaxSize( 10 );\n        // 指定每次可以从Broker拉取 40 条消息，默认为 32\n        consumer.setPullBatchSize( 40 );\n\n        consumer.registerMessageListener(new MessageListenerConcurrently() {\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,ConsumeConcurrentlyContext context) {\n                for (MessageExt msg : msgs) {\n                    System.out.println(msg);\n                }\n                // 消费成功的返回结果\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n                // 消费异常时的返回结果\n                // return ConsumeConcurrentlyStatus.RECONSUME_LATER;\n            }\n        });\n\n        consumer.start();\n        System.out.println(\"Consumer Started\");\n    }\n}\n```\n\n## 六、消息过滤\n\n消息者在进行消息订阅时，除了可以指定要订阅消息的Topic外，还可以对指定Topic中的消息根据指定条件进行过滤，即可以订阅比Topic更加细粒度的消息类型。\n\n对于指定Topic消息的过滤有两种过滤方式：Tag过滤与SQL过滤。\n\n### 1 Tag过滤\n\n通过consumer的subscribe()方法指定要订阅消息的Tag。如果订阅多个Tag的消息，Tag间使用或运算符(双竖线||)连接。\n\n```java\nDefaultMQPushConsumer consumer = new DefaultMQPushConsumer(\"CID_EXAMPLE\");\nconsumer.subscribe(\"TOPIC\", \"TAGA || TAGB || TAGC\");\n```\n### 2 SQL过滤\n\nSQL过滤是一种通过特定表达式对事先埋入到消息中的`用户属性`进行筛选过滤的方式。通过SQL过滤，可以实现对消息的复杂过滤。不过，只有使用`PUSH模式`的消费者才能使用SQL过滤。\n\nSQL过滤表达式中支持多种常量类型与运算符。\n\n支持的常量类型：\n\n* 数值：比如： 123 ，3.1415\n* 字符：必须用单引号包裹起来，比如：'abc'\n* 布尔：TRUE 或 FALSE\n* NULL：特殊的常量，表示空\n\n支持的运算符有：\n\n* 数值比较：>，>=，<，<=，BETWEEN，=\n* 字符比较：=，<>，IN\n* 逻辑运算 ：AND，OR，NOT\n* NULL判断：IS NULL 或者 IS NOT NULL\n\n默认情况下Broker没有开启消息的SQL过滤功能，需要在Broker加载的配置文件中添加如下属性，以开启该功能：\n```shell\nenablePropertyFilter = true\n```\n\n在启动Broker时需要指定这个修改过的配置文件。例如对于单机Broker的启动，其修改的配置文件是conf/broker.conf，启动时使用如下命令：\n\n```shell\nsh bin/mqbroker -n localhost:9876 -c conf/broker.conf &\n```\n### 3 代码举例\n\n定义Tag过滤Producer\n\n```java\npublic class FilterByTagProducer {\n    public static void main(String[] args) throws Exception {\n        DefaultMQProducer producer = new DefaultMQProducer(\"pg\");\n        producer.setNamesrvAddr(\"rocketmqOS:9876\");\n        producer.start();\n        String[] tags = {\"myTagA\",\"myTagB\",\"myTagC\"};\n        for (int i = 0 ; i < 10 ; i++) {\n            byte[] body = (\"Hi,\" + i).getBytes();\n            String tag = tags[i%tags.length];\n            Message msg = new Message(\"myTopic\",tag,body);\n            SendResult sendResult = producer.send(msg);\n            System.out.println(sendResult);\n        }\n        producer.shutdown();\n    }\n}\n```\n\n定义Tag过滤Consumer\n\n```java\npublic class FilterByTagConsumer {\n    public static void main(String[] args) throws Exception {\n        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(\"pg\");\n        consumer.setNamesrvAddr(\"rocketmqOS:9876\");\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n\n        consumer.subscribe(\"myTopic\", \"myTagA || myTagB\");\n        consumer.registerMessageListener(new MessageListenerConcurrently() {\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,ConsumeConcurrentlyContext context) {\n                for (MessageExt me:msgs){\n                    System.out.println(me);\n                }\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            }\n        });\n        consumer.start();\n        System.out.println(\"Consumer Started\");\n    }\n}\n```\n\n定义SQL过滤Producer\n\n```java\npublic class FilterBySQLProducer {\n    public static void main(String[] args) throws Exception {\n        DefaultMQProducer producer = new DefaultMQProducer(\"pg\");\n        producer.setNamesrvAddr(\"rocketmqOS:9876\");\n        producer.start();\n        for (int i = 0 ; i < 10 ; i++) {\n            try {\n                byte[] body = (\"Hi,\" + i).getBytes();\n                Message msg = new Message(\"myTopic\", \"myTag\", body);\n                msg.putUserProperty(\"age\", i + \"\");\n                SendResult sendResult = producer.send(msg);\n                System.out.println(sendResult);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        producer.shutdown();\n    }\n}\n```\n\n定义SQL过滤Consumer\n\n```java\npublic class FilterBySQLConsumer {\n    public static void main(String[] args) throws Exception {\n        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(\"pg\");\n        consumer.setNamesrvAddr(\"rocketmqOS:9876\");\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n        consumer.subscribe(\"myTopic\", MessageSelector.bySql(\"age between 0 and 6\"));\n        consumer.registerMessageListener(new MessageListenerConcurrently() {\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {\n                for (MessageExt me:msgs){\n                    System.out.println(me);\n                }\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            }\n        });\n        consumer.start();\n        System.out.println(\"Consumer Started\");\n    }\n}\n```\n\n## 七、消息发送重试机制\n\n### 1 说明\n\nProducer对发送失败的消息进行重新发送的机制，称为消息发送重试机制，也称为消息重投机制。\n\n#### 对于消息重投，需要注意以下几点：\n\n* 生产者在发送消息时，若采用同步或异步发送方式，发送失败会重试，但oneway消息发送方式发送失败是没有重试机制的\n* 只有普通消息具有发送重试机制，顺序消息是没有的\n* 消息重投机制可以保证消息尽可能发送成功、不丢失，但可能会造成消息重复。消息重复在RocketMQ中是无法避免的问题\n* 消息重复在一般情况下不会发生，当出现消息量大、网络抖动，消息重复就会成为大概率事件\n* producer主动重发、consumer负载变化（发生Rebalance，不会导致消息重复，但可能出现重复消费）也会导致重复消息\n* 消息重复无法避免，但要避免消息的重复消费。\n* 避免消息重复消费的解决方案是，为消息添加唯一标识（例如消息key），使消费者对消息进行消费判断来避免重复消费\n* 消息发送重试有三种策略可以选择：同步发送失败策略、异步发送失败策略、消息刷盘失败策略\n\n### 2 同步发送失败策略\n\n对于普通消息，消息发送默认采用round-robin策略来选择所发送到的队列。如果发送失败，默认重试 2次。但在重试时是不会选择上次发送失败的Broker，而是选择其它Broker。当然，若只有一个Broker其也只能发送到该Broker，但其会尽量发送到该Broker上的其它Queue。\n\n```java\n// 创建一个producer，参数为Producer Group名称\nDefaultMQProducer producer = new DefaultMQProducer(\"pg\");\n// 指定nameServer地址\nproducer.setNamesrvAddr(\"rocketmqOS:9876\");\n// 设置同步发送失败时重试发送的次数，默认为 2 次\nproducer.setRetryTimesWhenSendFailed( 3 );\n// 设置发送超时时限为5s，默认3s\nproducer.setSendMsgTimeout( 5000 );\n```\n\n同时，Broker还具有`失败隔离`功能，使Producer尽量选择未发生过发送失败的Broker作为目标Broker。其可以保证其它消息尽量不发送到问题Broker，为了提升消息发送效率，降低消息发送耗时。\n\n>思考：让我们自己实现`失败隔离`功能，如何来做？<br><br>\n1 ）方案一：Producer中维护某JUC的Map集合，其key是发生失败的时间戳，value为Broker实例。Producer中还维护着一个Set集合，其中存放着所有未发生发送异常的Broker实例。选择目标Broker是从该Set集合中选择的。再定义一个定时任务，定期从Map集合中将长期未发生发送异常的Broker清理出去，并添加到Set集合。<br><br>\n2 ）方案二：为Producer中的Broker实例添加一个标识，例如是一个AtomicBoolean属性。只要该Broker上发生过发送异常，就将其置为true。选择目标Broker就是选择该属性值为false的Broker。再定义一个定时任务，定期将Broker的该属性置为false。<br><br>\n3 ）方案三：为Producer中的Broker实例添加一个标识，例如是一个AtomicLong属性。只要该Broker上发生过发送异常，就使其值增一。选择目标Broker就是选择该属性值最小的Broker。若该值相同，采用轮询方式选择。\n\n\n如果超过重试次数，则抛出异常，由Producer去保证消息不丢。当然当生产者出现RemotingException、MQClientException和MQBrokerException时，Producer会自动重投消息。\n\n### 3 异步发送失败策略\n\n异步发送失败重试时，异步重试不会选择其他broker，仅在同一个broker上做重试，所以该策略无法保证消息不丢。\n\n```java\nDefaultMQProducer producer = new DefaultMQProducer(\"pg\");\nproducer.setNamesrvAddr(\"rocketmqOS:9876\");\n// 指定异步发送失败后不进行重试发送\nproducer.setRetryTimesWhenSendAsyncFailed( 0 );\n```\n### 4 消息刷盘失败策略\n\n消息刷盘超时（Master或Slave）或slave不可用（slave在做数据同步时向master返回状态不是SEND_OK）时，默认是不会将消息尝试发送到其他Broker的。不过，对于重要消息可以通过在Broker的配置文件设置retryAnotherBrokerWhenNotStoreOK属性为true来开启。\n\n## 八、消息消费重试机制\n\n### 1 顺序消息的消费重试\n\n对于顺序消息，当Consumer消费消息失败后，为了保证消息的顺序性，其会自动不断地进行消息重试，直到消费成功。消费重试默认间隔时间为 1000 毫秒。重试期间应用会出现消息消费被阻塞的情况。\n```java\nDefaultMQPushConsumer consumer = new DefaultMQPushConsumer(\"cg\");\n// 顺序消息消费失败的消费重试时间间隔，单位毫秒，默认为 1000 ，其取值范围为[10,30000]\nconsumer.setSuspendCurrentQueueTimeMillis( 100 );\n```\n\n>由于对顺序消息的重试是无休止的，不间断的，直至消费成功，所以，对于顺序消息的消费，务必要保证应用能够及时监控并处理消费失败的情况，避免消费被永久性阻塞。<br><br>\n注意，顺序消息没有发送失败重试机制，但具有消费失败重试机制\n\n### 2 无序消息的消费重试\n\n对于无序消息（普通消息、延时消息、事务消息），当Consumer消费消息失败时，可以通过设置返回状态达到消息重试的效果。不过需要注意，无序消息的重试`只对集群消费方式生效`，广播消费方式不提供失败重试特性。即对于广播消费，消费失败后，失败消息不再重试，继续消费后续消息。\n\n### 3 消费重试次数与间隔\n对于`无序消息集群`消费下的重试消费，每条消息默认最多重试 16 次，但每次重试的间隔时间是不同的，会逐渐变长。每次重试的间隔时间如下表。\n\n重试次数|与上次重试的间隔时间|重试次数|与上次重试的间隔时间\n--|:--:|--:|--:\n1|10秒|9|7分钟\n2|30|10|8 分钟\n3|1分钟|11|9 分钟\n4|2分钟|12|10分钟\n5|3分钟|13|20分钟\n6|4分钟|14|30分钟\n7|5分钟|15|1小时\n8|6分钟|16|2 小时\n\n>若一条消息在一直消费失败的前提下，将会在正常消费后的第 `4 小时 46 分`后进行第 16 次重试。<br>\n若仍然失败，则将消息投递到`死信队列`<br><br>\n修改消费重试次数<br>\n```\nDefaultMQPushConsumer consumer = new DefaultMQPushConsumer(\"cg\");\n// 修改消费重试次数\nconsumer.setMaxReconsumeTimes( 10 );\n```\n>对于修改过的重试次数，将按照以下策略执行：<br>\n1)若修改值小于 16 ，则按照指定间隔进行重试<br>\n2)若修改值大于 16 ，则超过 16 次的重试时间间隔均为 2 小时<br><br>\n对于Consumer Group，若仅修改了一个Consumer的消费重试次数，则会应用到该Group中所有其它Consumer实例。若出现多个Consumer均做了修改的情况，则采用覆盖方式生效。即最后被修改的值会覆盖前面设置的值。\n\n\n### 4 重试队列\n\n对于需要重试消费的消息，并不是Consumer在等待了指定时长后再次去拉取原来的消息进行消费，而是将这些需要重试消费的消息放入到了一个特殊Topic的队列中，而后进行再次消费的。这个特殊的队列就是重试队列。\n\n当出现需要进行重试消费的消息时，Broker会为每个消费组都设置一个Topic名称为`%RETRY%consumerGroup@consumerGroup`的重试队列。\n\n>1 ）这个重试队列是针对消息才组的，而不是针对每个Topic设置的（一个Topic的消息可以让多个消费者组进行消费，所以会为这些消费者组各创建一个重试队列）<br>\n2 ）只有当出现需要进行重试消费的消息时，才会为该消费者组创建重试队列\n\n![输入图片说明](rocketmq/QQ截图20220208163646.png \"QQ截图20201229183512.png\")\n\n>注意，消费重试的时间间隔与`延时消费`的`延时等级`十分相似，除了没有延时等级的前两个时间外，其它的时间都是相同的\n\nBroker对于重试消息的处理是通过`延时消息`实现的。先将消息保存到SCHEDULE_TOPIC_XXXX延迟队列中，延迟时间到后，会将消息投递到%RETRY%consumerGroup@consumerGroup重试队列中。\n\n### 5 消费重试配置方式\n![输入图片说明](rocketmq/QQ截图20220208163740.png \"QQ截图20201229183512.png\")\n\n集群消费方式下，消息消费失败后若希望消费重试，则需要在消息监听器接口的实现中明确进行如下三种方式之一的配置：\n\n* 方式 1 ：返回ConsumeConcurrentlyStatus.RECONSUME_LATER（推荐）\n* 方式 2 ：返回Null\n* 方式 3 ：抛出异常\n\n### 6 消费不重试配置方式\n![输入图片说明](rocketmq/QQ截图20220208163826.png \"QQ截图20201229183512.png\")\n\n集群消费方式下，消息消费失败后若不希望消费重试，则在捕获到异常后同样也返回与消费成功后的相同的结果，即ConsumeConcurrentlyStatus.CONSUME_SUCCESS，则不进行消费重试。\n\n## 九、死信队列\n\n### 1 什么是死信队列\n当一条消息初次消费失败，消息队列会自动进行消费重试；达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确地消费该消息，此时，消息队列不会立刻将消息丢弃，而是将其发送到该消费者对应的特殊队列中。这个队列就是死信队列（Dead-Letter Queue，DLQ），而其中的消息\n则称为死信消息（Dead-Letter Message，DLM）。\n\n>死信队列是用于处理无法被正常消费的消息的。\n\n### 2 死信队列的特征\n\n#### 死信队列具有如下特征：\n\n* 死信队列中的消息不会再被消费者正常消费，即DLQ对于消费者是不可见的\n* 死信存储有效期与正常消息相同，均为 3 天（commitlog文件的过期时间）， 3 天后会被自动删除\n* 死信队列就是一个特殊的Topic，名称为%DLQ%consumerGroup@consumerGroup，即每个消费者组都有一个死信队列\n* 如果一个消费者组未产生死信消息，则不会为其创建相应的死信队列\n\n### 3 死信消息的处理\n\n实际上，当一条消息进入死信队列，就意味着系统中某些地方出现了问题，从而导致消费者无法正常消费该消息，比如代码中原本就存在Bug。因此，对于死信消息，通常需要开发人员进行特殊处理。最关键的步骤是要排查可疑因素，解决代码中可能存在的Bug，然后再将原来的死信消息再次进行投递消费。","slug":"rocketmq","published":1,"updated":"2022-07-21T01:46:35.803Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5w7e742000gigvu5db17ik3","content":"<h1 id=\"第1章-RocketMQ概述\"><a href=\"#第1章-RocketMQ概述\" class=\"headerlink\" title=\"第1章 RocketMQ概述\"></a>第1章 RocketMQ概述</h1><h2 id=\"一、MQ概述\"><a href=\"#一、MQ概述\" class=\"headerlink\" title=\"一、MQ概述\"></a>一、MQ概述</h2><h3 id=\"1-、MQ简介\"><a href=\"#1-、MQ简介\" class=\"headerlink\" title=\"1 、MQ简介\"></a>1 、MQ简介</h3><p>MQ，Message Queue，是一种提供消息队列服务的中间件，也称为消息中间件，是一套提供了消息生产、存储、消费全过程API的软件系统。消息即数据。一般消息的体量不会很大。</p>\n<h3 id=\"2-、MQ用途\"><a href=\"#2-、MQ用途\" class=\"headerlink\" title=\"2 、MQ用途\"></a>2 、MQ用途</h3><p>从网上可以查看到很多的关于MQ用途的叙述，但总结起来其实就以下三点。</p>\n<ul>\n<li><p>限流削峰</p>\n<ul>\n<li>MQ可以将系统的超量请求暂存其中，以便系统后期可以慢慢进行处理，从而避免了请求的丢失或系统被压垮。<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208101908.png\" class title=\"输入图片说明\"></li>\n</ul>\n</li>\n<li><p>异步解耦</p>\n<ul>\n<li>上游系统对下游系统的调用若为同步调用，则会大大降低系统的吞吐量与并发度，且系统耦合度太高。而异步调用则会解决这些问题。所以两层之间若要实现由同步到异步的转化，一般性做法就是，在这两层间添加一个MQ层。</li>\n</ul>\n</li>\n</ul>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208102000.png\" class title=\"输入图片说明\">\n\n<ul>\n<li><p>数据收集</p>\n<ul>\n<li>分布式系统会产生海量级数据流，如：业务日志、监控数据、用户行为等。针对这些数据流进行实时或批量采集汇总，然后对这些数据流进行大数据分析，这是当前互联网平台的必备技术。通过MQ完成此类数据收集是最好的选择。<h3 id=\"3-、常见MQ产品\"><a href=\"#3-、常见MQ产品\" class=\"headerlink\" title=\"3 、常见MQ产品\"></a>3 、常见MQ产品</h3></li>\n</ul>\n</li>\n<li><p>ActiveMQ</p>\n<ul>\n<li>ActiveMQ是使用Java语言开发一款MQ产品。早期很多公司与项目中都在使用。但现在的社区活跃度已经很低。现在的项目中已经很少使用了。</li>\n</ul>\n</li>\n<li><p>RabbitMQ</p>\n<ul>\n<li>RabbitMQ是使用ErLang语言开发的一款MQ产品。其吞吐量较Kafka与RocketMQ要低，且由于其不是Java语言开发，所以公司内部对其实现定制化开发难度较大。</li>\n</ul>\n</li>\n<li><p>Kafka</p>\n<ul>\n<li>Kafka是使用Scala/Java语言开发的一款MQ产品。其最大的特点就是高吞吐率，常用于大数据领域的实时计算、日志采集等场景。其没有遵循任何常见的MQ协议，而是使用自研协议。对于Spring CloudNetçix，其仅支持RabbitMQ与Kafka。</li>\n</ul>\n</li>\n<li><p>RocketMQ</p>\n<ul>\n<li>RocketMQ是使用Java语言开发的一款MQ产品。经过数年阿里双 11 的考验，性能与稳定性非常高。其没有遵循任何常见的MQ协议，而是使用自研协议。对于Spring Cloud Alibaba，其支持RabbitMQ、Kafka，但提倡使用RocketMQ。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"对比\"><a href=\"#对比\" class=\"headerlink\" title=\"对比\"></a>对比</h4><table>\n<thead>\n<tr>\n<th>关键词</th>\n<th align=\"center\">ACTIVEMQ</th>\n<th align=\"right\">RABBITMQ</th>\n<th align=\"right\">KAFKA</th>\n<th align=\"right\">ROCKETMQ</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>开发语言</td>\n<td align=\"center\">Java</td>\n<td align=\"right\">ErLang</td>\n<td align=\"right\">Java</td>\n<td align=\"right\">Java</td>\n</tr>\n<tr>\n<td>单机吞吐量</td>\n<td align=\"center\">万级</td>\n<td align=\"right\">万级</td>\n<td align=\"right\">十万级</td>\n<td align=\"right\">十万级</td>\n</tr>\n<tr>\n<td>Topic</td>\n<td align=\"center\">-</td>\n<td align=\"right\">-</td>\n<td align=\"right\">百级Topic时会影响系统吞吐量</td>\n<td align=\"right\">千级Topic时会影响系统吞吐</td>\n</tr>\n<tr>\n<td>社区活跃度</td>\n<td align=\"center\">低</td>\n<td align=\"right\">高</td>\n<td align=\"right\">高</td>\n<td align=\"right\">高</td>\n</tr>\n</tbody></table>\n<h3 id=\"4-、MQ常见协议\"><a href=\"#4-、MQ常见协议\" class=\"headerlink\" title=\"4 、MQ常见协议\"></a>4 、MQ常见协议</h3><h5 id=\"一般情况下MQ的实现是要遵循一些常规性协议的。常见的协议如下：\"><a href=\"#一般情况下MQ的实现是要遵循一些常规性协议的。常见的协议如下：\" class=\"headerlink\" title=\"一般情况下MQ的实现是要遵循一些常规性协议的。常见的协议如下：\"></a>一般情况下MQ的实现是要遵循一些常规性协议的。常见的协议如下：</h5><h6 id=\"JMS\"><a href=\"#JMS\" class=\"headerlink\" title=\"JMS\"></a>JMS</h6><blockquote>\n<p>JMS，Java Messaging Service（Java消息服务）。是Java平台上有关MOM（Message OrientedMiddleware，面向消息的中间件 PO/OO/AO）的技术规范，它便于消息系统中的Java应用程序进行消息交换，并且通过提供标准的产生、发送、接收消息的接口，简化企业应用的开发。ActiveMQ是该协议的典型实现。</p>\n</blockquote>\n<h6 id=\"STOMP\"><a href=\"#STOMP\" class=\"headerlink\" title=\"STOMP\"></a>STOMP</h6><blockquote>\n<p>STOMP，Streaming Text Orientated Message Protocol（面向流文本的消息协议），是一种MOM设计的简单文本协议。STOMP提供一个可互操作的连接格式，允许客户端与任意STOMP消息代理（Broker）进行交互。ActiveMQ是该协议的典型实现，RabbitMQ通过插件可以支持该协议。</p>\n</blockquote>\n<h6 id=\"AMQP\"><a href=\"#AMQP\" class=\"headerlink\" title=\"AMQP\"></a>AMQP</h6><blockquote>\n<p>AMQP，Advanced Message Queuing Protocol（高级消息队列协议），一个提供统一消息服务的应用层标准，是应用层协议的一个开放标准，是一种MOM设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同开发语言等条件的限制。 RabbitMQ是该协议的典型实现。</p>\n</blockquote>\n<h6 id=\"MQTT\"><a href=\"#MQTT\" class=\"headerlink\" title=\"MQTT\"></a>MQTT</h6><blockquote>\n<p>MQTT，Message Queuing Telemetry Transport（消息队列遥测传输），是IBM开发的一个即时通讯协议，是一种二进制协议，主要用于服务器和低功耗IoT（物联网）设备间的通信。该协议支持所有平台，几乎可以把所有联网物品和外部连接起来，被用来当做传感器和致动器的通信协议。 RabbitMQ通过插件可以支持该协议。</p>\n</blockquote>\n<h2 id=\"二、RocketMQ概述\"><a href=\"#二、RocketMQ概述\" class=\"headerlink\" title=\"二、RocketMQ概述\"></a>二、RocketMQ概述</h2><h3 id=\"1-、RocketMQ简介\"><a href=\"#1-、RocketMQ简介\" class=\"headerlink\" title=\"1 、RocketMQ简介\"></a>1 、RocketMQ简介</h3><blockquote>\n<p>RocketMQ是一个统一消息引擎、轻量级数据处理平台。RocketMQ是一款阿里巴巴开源的消息中间件。 2016 年 11 月 28 日，阿里巴巴向 Apache 软件基金会捐赠RocketMQ，成为 Apache 孵化项目。 2017 年 9 月 25 日，Apache 宣布 RocketMQ孵化成为 Apache 顶级项目（TLP ），成为国内首个互联网中间件在 Apache 上的顶级项目。</p>\n</blockquote>\n<p>官网地址：<a href=\"http://rocketmq.apache.org/\">http://rocketmq.apache.org</a></p>\n<h3 id=\"2-、RocketMQ发展历程\"><a href=\"#2-、RocketMQ发展历程\" class=\"headerlink\" title=\"2 、RocketMQ发展历程\"></a>2 、RocketMQ发展历程</h3><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208103522.png\" class title=\"输入图片说明\">\n<ul>\n<li>2007 年，阿里开始五彩石项目，Notify作为项目中交易核心消息流转系统，应运而生。Notify系统是RocketMQ的雏形。</li>\n<li>2010 年，B2B大规模使用ActiveMQ作为阿里的消息内核。阿里急需一个具有海量堆积能力的消息系统。</li>\n<li>2011 年初，Kafka开源。淘宝中间件团队在对Kafka进行了深入研究后，开发了一款新的MQ，MetaQ。</li>\n<li>2012 年，MetaQ发展到了v3.0版本，在它基础上进行了进一步的抽象，形成了RocketMQ，然后就将其进行了开源。</li>\n<li>2015 年，阿里在RocketMQ的基础上，又推出了一款专门针对阿里云上用户的消息系统Aliware MQ。</li>\n<li>2016 年双十一，RocketMQ承载了万亿级消息的流转，跨越了一个新的里程碑。 11 月 28 日，阿里巴巴向 Apache 软件基金会捐赠 RocketMQ，成为 Apache 孵化项目。</li>\n<li>2017 年 9 月 25 日，Apache 宣布 RocketMQ孵化成为 Apache 顶级项目（TLP ），成为国内首个互联网中间件在 Apache 上的顶级项目。</li>\n</ul>\n<h1 id=\"第-2-章-RocketMQ的安装与启动\"><a href=\"#第-2-章-RocketMQ的安装与启动\" class=\"headerlink\" title=\"第 2 章 RocketMQ的安装与启动\"></a>第 2 章 RocketMQ的安装与启动</h1><h2 id=\"一、基本概念\"><a href=\"#一、基本概念\" class=\"headerlink\" title=\"一、基本概念\"></a>一、基本概念</h2><h3 id=\"1-消息（Message）\"><a href=\"#1-消息（Message）\" class=\"headerlink\" title=\"1 消息（Message）\"></a>1 消息（Message）</h3><blockquote>\n<p>消息是指，消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题。</p>\n</blockquote>\n<h3 id=\"2-主题（Topic）\"><a href=\"#2-主题（Topic）\" class=\"headerlink\" title=\"2 主题（Topic）\"></a>2 主题（Topic）</h3><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208103828.png\" class title=\"输入图片说明\">\n\n<p>Topic表示一类消息的集合，每个主题包含若干条消息，每条消息只能属于一个主题，是RocketMQ进行消息订阅的基本单位。 topic:message 1:n message:topic 1:1</p>\n<p>一个生产者可以同时发送多种Topic的消息；而一个消费者只对某种特定的Topic感兴趣，即只可以订阅<br>和消费一种Topic的消息。 producer:topic 1:n consumer:topic 1:1</p>\n<h3 id=\"3-标签（Tag）\"><a href=\"#3-标签（Tag）\" class=\"headerlink\" title=\"3 标签（Tag）\"></a>3 标签（Tag）</h3><blockquote>\n<p>为消息设置的标签，用于同一主题下区分不同类型的消息。来自同一业务单元的消息，可以根据不同业务目的在同一主题下设置不同标签。标签能够有效地保持代码的清晰度和连贯性，并优化RocketMQ提供的查询系统。消费者可以根据Tag实现对不同子主题的不同消费逻辑，实现更好的扩展性。</p>\n</blockquote>\n<p>Topic是消息的一级分类，Tag是消息的二级分类。</p>\n<ul>\n<li>Topic：货物<ul>\n<li>tag=上海</li>\n<li>tag=江苏</li>\n<li>tag=浙江</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"——-消费者-—–\"><a href=\"#——-消费者-—–\" class=\"headerlink\" title=\"——- 消费者 —–\"></a>——- 消费者 —–</h4><ul>\n<li>topic=货物 tag = 上海</li>\n<li>topic=货物 tag = 上海|浙江</li>\n<li>topic=货物 tag = *</li>\n</ul>\n<h3 id=\"4-队列（Queue）\"><a href=\"#4-队列（Queue）\" class=\"headerlink\" title=\"4 队列（Queue）\"></a>4 队列（Queue）</h3><p>存储消息的物理实体。一个Topic中可以包含多个Queue，每个Queue中存放的就是该Topic的消息。一个Topic的Queue也被称为一个Topic中消息的分区（Partition）。</p>\n<p>一个Topic的Queue中的消息只能被一个消费者组中的一个消费者消费。一个Queue中的消息不允许同一个消费者组中的多个消费者同时消费。</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208104018.png\" class title=\"输入图片说明\">\n\n<p>在学习参考其它相关资料时，还会看到一个概念：分片（Sharding）。分片不同于分区。在RocketMQ中，分片指的是存放相应Topic的Broker。每个分片中会创建出相应数量的分区，即Queue，每个Queue的大小都是相同的。</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208104611.png\" class title=\"输入图片说明\">\n\n<h3 id=\"5-消息标识（MessageId-Key）\"><a href=\"#5-消息标识（MessageId-Key）\" class=\"headerlink\" title=\"5 消息标识（MessageId/Key）\"></a>5 消息标识（MessageId/Key）</h3><p>RocketMQ中每个消息拥有唯一的MessageId，且可以携带具有业务标识的Key，以方便对消息的查询。不过需要注意的是，MessageId有两个：在生产者send()消息时会自动生成一个MessageId（msgId)，当消息到达Broker后，Broker也会自动生成一个MessageId(offsetMsgId)。msgId、offsetMsgId与key都称为消息标识。</p>\n<ul>\n<li>msgId：由producer端生成，其生成规则为：producerIp + 进程pid + MessageClientIDSetter类的ClassLoader的hashCode +当前时间 + AutomicInteger自增计数器</li>\n<li>offsetMsgId：由broker端生成，其生成规则为：brokerIp + 物理分区的offset（Queue中的偏移量）</li>\n<li>key：由用户指定的业务相关的唯一标识</li>\n</ul>\n<h2 id=\"二、系统架构\"><a href=\"#二、系统架构\" class=\"headerlink\" title=\"二、系统架构\"></a>二、系统架构</h2><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208104741.png\" class title=\"输入图片说明\">\n\n<p>RocketMQ架构上主要分为四部分构成：</p>\n<h3 id=\"1-Producer\"><a href=\"#1-Producer\" class=\"headerlink\" title=\"1 Producer\"></a>1 Producer</h3><p>消息生产者，负责生产消息。Producer通过MQ的负载均衡模块选择相应的Broker集群队列进行消息投<br>递，投递的过程支持快速失败并且低延迟。</p>\n<blockquote>\n<p>例如，业务系统产生的日志写入到MQ的过程，就是消息生产的过程</p>\n</blockquote>\n<blockquote>\n<p>再如，电商平台中用户提交的秒杀请求写入到MQ的过程，就是消息生产的过程</p>\n</blockquote>\n<p>RocketMQ中的消息生产者都是以生产者组（Producer Group）的形式出现的。生产者组是同一类生产者的集合，这类Producer发送相同Topic类型的消息。一个生产者组可以同时发送多个主题的消息。</p>\n<h3 id=\"2-Consumer\"><a href=\"#2-Consumer\" class=\"headerlink\" title=\"2 Consumer\"></a>2 Consumer</h3><p>消息消费者，负责消费消息。一个消息消费者会从Broker服务器中获取到消息，并对消息进行相关业务处理。</p>\n<blockquote>\n<p>例如，QoS系统从MQ中读取日志，并对日志进行解析处理的过程就是消息消费的过程。</p>\n</blockquote>\n<blockquote>\n<p>再如，电商平台的业务系统从MQ中读取到秒杀请求，并对请求进行处理的过程就是消息消费的过程。</p>\n</blockquote>\n<p>RocketMQ中的消息消费者都是以消费者组（Consumer Group）的形式出现的。消费者组是同一类消费者的集合，这类Consumer消费的是同一个Topic类型的消息。消费者组使得在消息消费方面，实现负载均衡（将一个Topic中的不同的Queue平均分配给同一个Consumer Group的不同的Consumer，注意，并不是将消息负载均衡）和容错（一个Consmer挂了，该Consumer Group中的其它Consumer可以接着消费原Consumer消费的Queue）的目标变得非常容易。</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208105007.png\" class title=\"输入图片说明\">\n\n<p>消费者组中Consumer的数量应该小于等于订阅Topic的Queue数量。如果超出Queue数量，则多出的Consumer将不能消费消息。</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208105040.png\" class title=\"输入图片说明\">\n\n<p>不过，一个Topic类型的消息可以被多个消费者组同时消费。</p>\n<blockquote>\n<p>注意，</p>\n</blockquote>\n<ul>\n<li>1 ）消费者组只能消费一个Topic的消息，不能同时消费多个Topic消息</li>\n<li>2 ）一个消费者组中的消费者必须订阅完全相同的Topic</li>\n</ul>\n<h3 id=\"3-Name-Server\"><a href=\"#3-Name-Server\" class=\"headerlink\" title=\"3 Name Server\"></a>3 Name Server</h3><h4 id=\"功能介绍\"><a href=\"#功能介绍\" class=\"headerlink\" title=\"功能介绍\"></a>功能介绍</h4><p>NameServer是一个Broker与Topic路由的注册中心，支持Broker的动态注册与发现。</p>\n<p>RocketMQ的思想来自于Kafka，而Kafka是依赖了Zookeeper的。所以，在RocketMQ的早期版本，即在MetaQ v1.0与v2.0版本中，也是依赖于Zookeeper的。从MetaQ v3.0，即RocketMQ开始去掉了Zookeeper依赖，使用了自己的NameServer。</p>\n<h4 id=\"主要包括两个功能：\"><a href=\"#主要包括两个功能：\" class=\"headerlink\" title=\"主要包括两个功能：\"></a>主要包括两个功能：</h4><ul>\n<li><code>Broker管理：</code>接受Broker集群的注册信息并且保存下来作为路由信息的基本数据；提供心跳检测机制，检查Broker是否还存活。</li>\n<li><code>路由信息管理：</code>每个NameServer中都保存着Broker集群的整个路由信息和用于客户端查询的队列信息。Producer和Conumser通过NameServer可以获取整个Broker集群的路由信息，从而进行消息的投递和消费。</li>\n</ul>\n<h4 id=\"路由注册\"><a href=\"#路由注册\" class=\"headerlink\" title=\"路由注册\"></a>路由注册</h4><p>NameServer通常也是以集群的方式部署，不过，NameServer是无状态的，即NameServer集群中的各个节点间是无差异的，各节点间相互不进行信息通讯。那各节点中的数据是如何进行数据同步的呢？在Broker节点启动时，轮询NameServer列表，与每个NameServer节点建立长连接，发起注册请求。在NameServer内部维护着一个Broker列表，用来动态存储Broker的信息。</p>\n<blockquote>\n<p>注意，这是与其它像zk、Eureka、Nacos等注册中心不同的地方。<br><br>这种NameServer的无状态方式，有什么优缺点：<br><br>优点：NameServer集群搭建简单，扩容简单。<br><br>缺点：对于Broker，必须明确指出所有NameServer地址。否则未指出的将不会去注册。也正因为如此，NameServer并不能随便扩容。因为，若Broker不重新配置，新增的NameServer对于Broker来说是不可见的，其不会向这个NameServer进行注册。</p>\n</blockquote>\n<p>Broker节点为了证明自己是活着的，为了维护与NameServer间的长连接，会将最新的信息以心跳包的方式上报给NameServer，每 30 秒发送一次心跳。心跳包中包含 BrokerId、Broker地址(IP+Port)、Broker名称、Broker所属集群名称等等。NameServer在接收到心跳包后，会更新心跳时间戳，记录这个Broker的最新存活时间。</p>\n<h4 id=\"路由剔除\"><a href=\"#路由剔除\" class=\"headerlink\" title=\"路由剔除\"></a>路由剔除</h4><p>由于Broker关机、宕机或网络抖动等原因，NameServer没有收到Broker的心跳，NameServer可能会将其从Broker列表中剔除。</p>\n<p>NameServer中有一个定时任务，每隔 10 秒就会扫描一次Broker表，查看每一个Broker的最新心跳时间戳距离当前时间是否超过 120 秒，如果超过，则会判定Broker失效，然后将其从Broker列表中剔除。</p>\n<blockquote>\n<p>扩展：对于RocketMQ日常运维工作，例如Broker升级，需要停掉Broker的工作。OP需要怎么做？<br><br>OP需要将Broker的读写权限禁掉。一旦client(Consumer或Producer)向broker发送请求，都会收到broker的NO_PERMISSION响应，然后client会进行对其它Broker的重试。<br><br>当OP观察到这个Broker没有流量后，再关闭它，实现Broker从NameServer的移除。<br><br>OP：运维工程师<br><br>SRE：Site Reliability Engineer，现场可靠性工程师</p>\n</blockquote>\n<h4 id=\"路由发现\"><a href=\"#路由发现\" class=\"headerlink\" title=\"路由发现\"></a>路由发现</h4><p>RocketMQ的路由发现采用的是Pull模型。当Topic路由信息出现变化时，NameServer不会主动推送给客户端，而是客户端定时拉取主题最新的路由。默认客户端每 30 秒会拉取一次最新的路由。</p>\n<blockquote>\n<p>扩展：<br><br>1 ）Push模型：推送模型。其实时性较好，是一个“发布-订阅”模型，需要维护一个长连接。而长连接的维护是需要资源成本的。该模型适合于的场景：<br><br>    * 实时性要求较高<br><br>    * Client数量不多，Server数据变化较频繁<br><br>2 ）Pull模型：拉取模型。存在的问题是，实时性较差。<br><br><br>3 ）Long Polling模型：长轮询模型。其是对Push与Pull模型的整合，充分利用了这两种模型的优势，屏蔽了它们的劣势。</p>\n</blockquote>\n<h4 id=\"客户端NameServer选择策略\"><a href=\"#客户端NameServer选择策略\" class=\"headerlink\" title=\"客户端NameServer选择策略\"></a>客户端NameServer选择策略</h4><blockquote>\n<p>这里的客户端指的是Producer与Consumer</p>\n</blockquote>\n<p>客户端在配置时必须要写上NameServer集群的地址，那么客户端到底连接的是哪个NameServer节点呢？客户端首先会生产一个随机数，然后再与NameServer节点数量取模，此时得到的就是所要连接的节点索引，然后就会进行连接。如果连接失败，则会采用round-robin策略，逐个尝试着去连接其它节点。</p>\n<p>首先采用的是<code>随机策略</code>进行的选择，失败后采用的是<code>轮询策略</code>。</p>\n<blockquote>\n<p>扩展：Zookeeper Client是如何选择Zookeeper Server的？<br><br>简单来说就是，经过两次Shufæe，然后选择第一台Zookeeper Server。<br><br>详细说就是，将配置文件中的zk server地址进行第一次shufæe，然后随机选择一个。这个选择出的一般都是一个hostname。然后获取到该hostname对应的所有ip，再对这些ip进行第二次shufæe，从shufæe过的结果中取第一个server地址进行连接。</p>\n</blockquote>\n<h3 id=\"4-Broker\"><a href=\"#4-Broker\" class=\"headerlink\" title=\"4 Broker\"></a>4 Broker</h3><h4 id=\"功能介绍-1\"><a href=\"#功能介绍-1\" class=\"headerlink\" title=\"功能介绍\"></a>功能介绍</h4><p>Broker充当着消息中转角色，负责存储消息、转发消息。Broker在RocketMQ系统中负责接收并存储从生产者发送来的消息，同时为消费者的拉取请求作准备。Broker同时也存储着消息相关的元数据，包括消费者组消费进度偏移offset、主题、队列等。</p>\n<blockquote>\n<p>Kafka 0.8版本之后，offset是存放在Broker中的，之前版本是存放在Zookeeper中的。</p>\n</blockquote>\n<h4 id=\"模块构成\"><a href=\"#模块构成\" class=\"headerlink\" title=\"模块构成\"></a>模块构成</h4><p>下图为Broker Server的功能模块示意图。</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208110201.png\" class title=\"输入图片说明\">\n\n<p><code>Remoting Module</code>：整个Broker的实体，负责处理来自clients端的请求。而这个Broker实体则由以下模块构成。</p>\n<p><code>Client Manager：</code>客户端管理器。负责接收、解析客户端(Producer/Consumer)请求，管理客户端。例如，维护Consumer的Topic订阅信息</p>\n<p><code>Store Service：</code>存储服务。提供方便简单的API接口，处理消息存储到物理硬盘和消息查询功能。</p>\n<p><code>HA Service：</code>高可用服务，提供Master Broker 和 Slave Broker之间的数据同步功能。</p>\n<p><code>Index Service：</code>索引服务。根据特定的Message key，对投递到Broker的消息进行索引服务，同时也提供根据Message Key对消息进行快速查询的功能。</p>\n<h4 id=\"集群部署\"><a href=\"#集群部署\" class=\"headerlink\" title=\"集群部署\"></a>集群部署</h4><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208110311.png\" class title=\"输入图片说明\">\n\n<p>为了增强Broker性能与吞吐量，Broker一般都是以集群形式出现的。各集群节点中可能存放着相同Topic的不同Queue。不过，这里有个问题，如果某Broker节点宕机，如何保证数据不丢失呢？其解决方案是，将每个Broker集群节点进行横向扩展，即将Broker节点再建为一个HA集群，解决单点问题。</p>\n<p>Broker节点集群是一个主从集群，即集群中具有Master与Slave两种角色。Master负责处理读写操作请求，Slave负责对Master中的数据进行备份。当Master挂掉了，Slave则会自动切换为Master去工作。所以这个Broker集群是主备集群。一个Master可以包含多个Slave，但一个Slave只能隶属于一个Master。Master与Slave 的对应关系是通过指定相同的BrokerName、不同的BrokerId 来确定的。BrokerId为 0 表示Master，非 0 表示Slave。每个Broker与NameServer集群中的所有节点建立长连接，定时注册Topic信息到所有NameServer。</p>\n<h3 id=\"5-工作流程\"><a href=\"#5-工作流程\" class=\"headerlink\" title=\"5 工作流程\"></a>5 工作流程</h3><h4 id=\"具体流程\"><a href=\"#具体流程\" class=\"headerlink\" title=\"具体流程\"></a>具体流程</h4><ul>\n<li><p>1 ）启动NameServer，NameServer启动后开始监听端口，等待Broker、Producer、Consumer连接。</p>\n</li>\n<li><p>2 ）启动Broker时，Broker会与所有的NameServer建立并保持长连接，然后每 30 秒向NameServer定时发送心跳包。</p>\n</li>\n<li><p>3 ）发送消息前，可以先创建Topic，创建Topic时需要指定该Topic要存储在哪些Broker上，当然，在创建Topic时也会将Topic与Broker的关系写入到NameServer中。不过，这步是可选的，也可以在发送消息时自动创建Topic。</p>\n</li>\n<li><p>4 ）Producer发送消息，启动时先跟NameServer集群中的其中一台建立长连接，并从NameServer中获取路由信息，即当前发送的Topic消息的Queue与Broker的地址（IP+Port）的映射关系。然后根据算法策略从队选择一个Queue，与队列所在的Broker建立长连接从而向Broker发消息。当然，在获取到路由信息后，Producer会首先将路由信息缓存到本地，再每 30 秒从NameServer更新一次路由信息。</p>\n</li>\n<li><p>5 ）Consumer跟Producer类似，跟其中一台NameServer建立长连接，获取其所订阅Topic的路由信息，然后根据算法策略从路由信息中获取到其所要消费的Queue，然后直接跟Broker建立长连接，开始消费其中的消息。Consumer在获取到路由信息后，同样也会每 30 秒从NameServer更新一次路由信息。不过不同于Producer的是，Consumer还会向Broker发送心跳，以确保Broker的存活状态。</p>\n</li>\n</ul>\n<h4 id=\"Topic的创建模式\"><a href=\"#Topic的创建模式\" class=\"headerlink\" title=\"Topic的创建模式\"></a>Topic的创建模式</h4><p>手动创建Topic时，有两种模式：</p>\n<ul>\n<li>集群模式：该模式下创建的Topic在该集群中，所有Broker中的Queue数量是相同的。</li>\n<li>Broker模式：该模式下创建的Topic在该集群中，每个Broker中的Queue数量可以不同。</li>\n</ul>\n<p>自动创建Topic时，默认采用的是Broker模式，会为每个Broker默认创建 4 个Queue。</p>\n<h4 id=\"读-写队列\"><a href=\"#读-写队列\" class=\"headerlink\" title=\"读/写队列\"></a>读/写队列</h4><p>从物理上来讲，读/写队列是同一个队列。所以，不存在读/写队列数据同步问题。读/写队列是逻辑上进行区分的概念。一般情况下，读/写队列数量是相同的。</p>\n<p>例如，创建Topic时设置的写队列数量为 8 ，读队列数量为 4 ，此时系统会创建 8 个Queue，分别是0 1 2 3 4 5 6 7。Producer会将消息写入到这 8 个队列，但Consumer只会消费0 1 2 3这 4 个队列中的消息，4 5 6 7 中的消息是不会被消费到的。</p>\n<p>再如，创建Topic时设置的写队列数量为 4 ，读队列数量为 8 ，此时系统会创建 8 个Queue，分别是0 1 2 3 4 5 6 7。Producer会将消息写入到0 1 2 3 这 4 个队列，但Consumer只会消费0 1 2 3 4 5 6 7这 8 个队列中的消息，但是4 5 6 7中是没有消息的。此时假设Consumer Group中包含两个Consumer，Consumer1消费0 1 2 3，而Consumer2消费4 5 6 7。但实际情况是，Consumer2是没有消息可消费的。</p>\n<p>也就是说，当读/写队列数量设置不同时，总是有问题的。那么，为什么要这样设计呢？</p>\n<p>其这样设计的目的是为了，方便Topic的Queue的缩容。</p>\n<p>例如，原来创建的Topic中包含 16 个Queue，如何能够使其Queue缩容为 8 个，还不会丢失消息？可以动态修改写队列数量为 8 ，读队列数量不变。此时新的消息只能写入到前 8 个队列，而消费都消费的却是16 个队列中的数据。当发现后 8 个Queue中的消息消费完毕后，就可以再将读队列数量动态设置为 8 。整个缩容过程，没有丢失任何消息。</p>\n<p>perm用于设置对当前创建Topic的操作权限： 2 表示只写， 4 表示只读， 6 表示读写。</p>\n<h2 id=\"三、单机安装与启动\"><a href=\"#三、单机安装与启动\" class=\"headerlink\" title=\"三、单机安装与启动\"></a>三、单机安装与启动</h2><h3 id=\"1-准备工作\"><a href=\"#1-准备工作\" class=\"headerlink\" title=\"1 准备工作\"></a>1 准备工作</h3><h4 id=\"软硬件需求\"><a href=\"#软硬件需求\" class=\"headerlink\" title=\"软硬件需求\"></a>软硬件需求</h4><h4 id=\"系统要求是-64-位的，JDK要求是1-8及其以上版本的。\"><a href=\"#系统要求是-64-位的，JDK要求是1-8及其以上版本的。\" class=\"headerlink\" title=\"系统要求是 64 位的，JDK要求是1.8及其以上版本的。\"></a>系统要求是 64 位的，JDK要求是1.8及其以上版本的。</h4><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208110713.png\" class title=\"输入图片说明\">\n\n<p>下载RocketMQ安装包</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208110738.png\" class title=\"输入图片说明\">\n\n<p>将下载的安装包上传到Linux。</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208110807.png\" class title=\"输入图片说明\">\n\n<p>解压。</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208110821.png\" class title=\"输入图片说明\">\n\n<h3 id=\"2-、修改初始内存\"><a href=\"#2-、修改初始内存\" class=\"headerlink\" title=\"2 、修改初始内存\"></a>2 、修改初始内存</h3><p>修改runserver.sh</p>\n<p>使用vim命令打开bin/runserver.sh文件。现将这些值修改为如下：</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208110900.png\" class title=\"输入图片说明\">\n\n<p>修改runbroker.sh</p>\n<p>使用vim命令打开bin/runbroker.sh文件。现将这些值修改为如下：</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208110924.png\" class title=\"输入图片说明\">\n<h3 id=\"3-、启动\"><a href=\"#3-、启动\" class=\"headerlink\" title=\"3 、启动\"></a>3 、启动</h3><p>启动NameServer</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">nohup sh bin/mqnamesrv &amp;</span><br><span class=\"line\">tail -f ~/logs/rocketmqlogs/namesrv.log</span><br></pre></td></tr></table></figure>\n\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208111000.png\" class title=\"输入图片说明\">\n\n\n<p><code>如果出现mq启动报错ERROR: Please set the JAVA_HOME variable in your environment, We need java(x64)! !!</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">ln -s /usr/local/jdk1.8.0_191/bin/javac /usr/bin/javac</span><br><span class=\"line\">ln -s  /usr/local/jdk1.8.0_191/bin/jar /usr/bin/jar</span><br><span class=\"line\">ln -s /usr/local/jdk1.8.0_191/bin/java /bin/java</span><br></pre></td></tr></table></figure>\n\n<p>启动broker</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">nohup sh bin/mqbroker -n localhost:9876 &amp;</span><br><span class=\"line\">tail -f ~/logs/rocketmqlogs/broker.log</span><br></pre></td></tr></table></figure>\n\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208111020.png\" class title=\"输入图片说明\">\n\n<h3 id=\"4-、发送-接收消息测试\"><a href=\"#4-、发送-接收消息测试\" class=\"headerlink\" title=\"4 、发送/接收消息测试\"></a>4 、发送/接收消息测试</h3><h4 id=\"发送消息\"><a href=\"#发送消息\" class=\"headerlink\" title=\"发送消息\"></a>发送消息</h4><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">export NAMESRV_ADDR=localhost:9876</span><br><span class=\"line\">sh bin/tools.sh org.apache.rocketmq.example.quickstart.Producer</span><br></pre></td></tr></table></figure>\n<h4 id=\"接收消息\"><a href=\"#接收消息\" class=\"headerlink\" title=\"接收消息\"></a>接收消息</h4><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">sh bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-、关闭Server\"><a href=\"#5-、关闭Server\" class=\"headerlink\" title=\"5 、关闭Server\"></a>5 、关闭Server</h3><p>无论是关闭name server还是broker，都是使用bin/mqshutdown命令。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@mqOS rocketmq]# sh bin/mqshutdown broker</span><br><span class=\"line\">The mqbroker(1740) is running...</span><br><span class=\"line\">Send shutdown request to mqbroker(1740) OK</span><br><span class=\"line\"></span><br><span class=\"line\">[root@mqOS rocketmq]# sh bin/mqshutdown namesrv</span><br><span class=\"line\">The mqnamesrv(1692) is running...</span><br><span class=\"line\">Send shutdown request to mqnamesrv(1692) OK</span><br><span class=\"line\">[2]+ 退出 143 nohup sh bin/mqbroker -n localhost:9876</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、-控制台的安装与启动\"><a href=\"#四、-控制台的安装与启动\" class=\"headerlink\" title=\"四、 控制台的安装与启动\"></a>四、 控制台的安装与启动</h2><p>RocketMQ有一个可视化的dashboard，通过该控制台可以直观的查看到很多数据。</p>\n<h3 id=\"1-下载\"><a href=\"#1-下载\" class=\"headerlink\" title=\"1 下载\"></a>1 下载</h3><p>下载地址：<a href=\"https://github.com/apache/rocketmq-externals/releases\">https://github.com/apache/rocketmq-externals/releases</a></p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208111255.png\" class title=\"输入图片说明\">\n\n<h3 id=\"2-修改配置\"><a href=\"#2-修改配置\" class=\"headerlink\" title=\"2 修改配置\"></a>2 修改配置</h3><p>修改其src/main/resources中的application.properties配置文件。</p>\n<ul>\n<li>原来的端口号为 8080 ，修改为一个不常用的</li>\n<li>指定RocketMQ的name server地址</li>\n</ul>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208111351.png\" class title=\"输入图片说明\">\n\n<h3 id=\"3-添加依赖\"><a href=\"#3-添加依赖\" class=\"headerlink\" title=\"3 添加依赖\"></a>3 添加依赖</h3><p>在解压目录rocketmq-console的pom.xml中添加如下JAXB依赖。</p>\n<blockquote>\n<p>JAXB，Java Architechture for Xml Binding，用于XML绑定的Java技术，是一个业界标准，是一项可以根据XML Schema生成Java类的技术。</p>\n</blockquote>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>javax.xml.bind<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>jaxb-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.3.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.sun.xml.bind<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>jaxb-impl<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.3.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.sun.xml.bind<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>jaxb-core<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.3.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>javax.activation<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>activation<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.1.1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"4-打包\"><a href=\"#4-打包\" class=\"headerlink\" title=\"4 打包\"></a>4 打包</h3><p>在rocketmq-console目录下运行maven的打包命令。</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208111536.png\" class title=\"输入图片说明\">\n\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208111646.png\" class title=\"输入图片说明\">\n<h3 id=\"5-启动\"><a href=\"#5-启动\" class=\"headerlink\" title=\"5 启动\"></a>5 启动</h3><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208111700.png\" class title=\"输入图片说明\">\n<h3 id=\"6-访问\"><a href=\"#6-访问\" class=\"headerlink\" title=\"6 访问\"></a>6 访问</h3><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208111724.png\" class title=\"输入图片说明\">\n\n<h2 id=\"五、集群搭建理论\"><a href=\"#五、集群搭建理论\" class=\"headerlink\" title=\"五、集群搭建理论\"></a>五、集群搭建理论</h2><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208111755.png\" class title=\"输入图片说明\">\n\n<h3 id=\"1-数据复制与刷盘策略\"><a href=\"#1-数据复制与刷盘策略\" class=\"headerlink\" title=\"1 数据复制与刷盘策略\"></a>1 数据复制与刷盘策略</h3><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208111822.png\" class title=\"输入图片说明\">\n\n<h4 id=\"复制策略\"><a href=\"#复制策略\" class=\"headerlink\" title=\"复制策略\"></a>复制策略</h4><p>复制策略是Broker的Master与Slave间的数据同步方式。分为同步复制与异步复制：</p>\n<ul>\n<li>同步复制：消息写入master后，master会等待slave同步数据成功后才向producer返回成功ACK</li>\n<li>异步复制：消息写入master后，master立即向producer返回成功ACK，无需等待slave同步数据成功</li>\n</ul>\n<blockquote>\n<p>异步复制策略会降低系统的写入延迟，RT变小，提高了系统的吞吐量</p>\n</blockquote>\n<h4 id=\"刷盘策略\"><a href=\"#刷盘策略\" class=\"headerlink\" title=\"刷盘策略\"></a>刷盘策略</h4><p>刷盘策略指的是broker中消息的落盘方式，即消息发送到broker内存后消息持久化到磁盘的方式。分为同步刷盘与异步刷盘.</p>\n<ul>\n<li>同步刷盘：当消息持久化到broker的磁盘后才算是消息写入成功。</li>\n<li>异步刷盘：当消息写入到broker的内存后即表示消息写入成功，无需等待消息持久化到磁盘。</li>\n</ul>\n<blockquote>\n<p>1 ）异步刷盘策略会降低系统的写入延迟，RT变小，提高了系统的吞吐量<br><br>2 ）消息写入到Broker的内存，一般是写入到了PageCache<br><br>3 ）对于异步 刷盘策略，消息会写入到PageCache后立即返回成功ACK。但并不会立即做落盘操作，而是当PageCache到达一定量时会自动进行落盘。<br></p>\n</blockquote>\n<h3 id=\"2-Broker集群模式\"><a href=\"#2-Broker集群模式\" class=\"headerlink\" title=\"2 Broker集群模式\"></a>2 Broker集群模式</h3><p>根据Broker集群中各个节点间关系的不同，Broker集群可以分为以下几类：</p>\n<h4 id=\"单Master\"><a href=\"#单Master\" class=\"headerlink\" title=\"单Master\"></a>单Master</h4><p>只有一个broker（其本质上就不能称为集群）。这种方式也只能是在测试时使用，生产环境下不能使用，因为存在单点问题。</p>\n<h4 id=\"多Master\"><a href=\"#多Master\" class=\"headerlink\" title=\"多Master\"></a>多Master</h4><p>broker集群仅由多个master构成，不存在Slave。同一Topic的各个Queue会平均分布在各个master节点上。</p>\n<ul>\n<li>优点：配置简单，单个Master宕机或重启维护对应用无影响，在磁盘配置为RAID10时，即使机器宕机不可恢复情况下，由于RAID10磁盘非常可靠，消息也不会丢（异步刷盘丢失少量消息，同步刷盘一条不丢），性能最高；</li>\n<li>缺点：单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅（不可消费），消息实时性会受到影响。</li>\n</ul>\n<blockquote>\n<p>以上优点的前提是，这些Master都配置了RAID磁盘阵列。如果没有配置，一旦出现某Master宕机，则会发生大量消息丢失的情况。</p>\n</blockquote>\n<h4 id=\"多Master多Slave模式-异步复制\"><a href=\"#多Master多Slave模式-异步复制\" class=\"headerlink\" title=\"多Master多Slave模式-异步复制\"></a>多Master多Slave模式-异步复制</h4><p>broker集群由多个master构成，每个master又配置了多个slave（在配置了RAID磁盘阵列的情况下，一个master一般配置一个slave即可）。master与slave的关系是主备关系，即master负责处理消息的读写请求，而slave仅负责消息的备份与master宕机后的角色切换。</p>\n<p>异步复制即前面所讲的<code>复制策略</code>中的<code>异步复制策略</code>，即消息写入master成功后，master立即向producer返回成功ACK，无需等待slave同步数据成功。</p>\n<p>该模式的最大特点之一是，当master宕机后slave能够<code>自动切换</code>为master。不过由于slave从master的同步具有短暂的延迟（毫秒级），所以当master宕机后，这种异步复制方式可能会存在少量消息的丢失问题。</p>\n<blockquote>\n<p>Slave从Master同步的延迟越短，其可能丢失的消息就越少<br><br><br>对于Master的RAID磁盘阵列，若使用的也是异步复制策略，同样也存在延迟问题，同样也可能会丢失消息。但RAID阵列的秘诀是微秒级的（因为是由硬盘支持的），所以其丢失的数据量会更少。</p>\n</blockquote>\n<h4 id=\"多Master多Slave模式-同步双写\"><a href=\"#多Master多Slave模式-同步双写\" class=\"headerlink\" title=\"多Master多Slave模式-同步双写\"></a>多Master多Slave模式-同步双写</h4><p>该模式是<code>多Master多Slave模式</code>的<code>同步复制</code>实现。所谓<code>同步双写</code>，指的是消息写入master成功后，master会等待slave同步数据成功后才向producer返回成功ACK，即master与slave都要写入成功后才会返回成功ACK，也即<code>双写</code>。该模式与<code>异步复制模式相比</code>，优点是消息的安全性更高，不存在消息丢失的情况。但单个消息的RT略高，从而导致性能要略低（大约低10%）。</p>\n<p>该模式存在一个大的问题：对于目前的版本，Master宕机后，Slave<code>不会自动切换</code>到Master。</p>\n<h4 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h4><p>一般会为Master配置RAID10磁盘阵列，然后再为其配置一个Slave。即利用了RAID10磁盘阵列的高效、安全性，又解决了可能会影响订阅的问题。</p>\n<blockquote>\n<p>1 ）RAID磁盘阵列的效率要高于Master-Slave集群。因为RAID是硬件支持的。也正因为如此，所以RAID阵列的搭建成本较高。<br><br><br>2 ）多Master+RAID阵列，与多Master多Slave集群的区别是什么？<br><br>1.多Master+RAID阵列，其仅仅可以保证数据不丢失，即不影响消息写入，但其可能会影响到消息的订阅。但其执行效率要远高于<code>多Master多Slave集群</code><br><br>2.多Master多Slave集群，其不仅可以保证数据不丢失，也不会影响消息写入。其运行效率要低于<code>多Master+RAID阵列</code></p>\n</blockquote>\n<h2 id=\"六、磁盘阵列RAID（补充）\"><a href=\"#六、磁盘阵列RAID（补充）\" class=\"headerlink\" title=\"六、磁盘阵列RAID（补充）\"></a>六、磁盘阵列RAID（补充）</h2><h3 id=\"1-RAID历史\"><a href=\"#1-RAID历史\" class=\"headerlink\" title=\"1 RAID历史\"></a>1 RAID历史</h3><p>1988 年美国加州大学伯克利分校的 D. A. Patterson 教授等首次在论文 “A Case of Redundant Array of Inexpensive Disks” 中提出了 RAID 概念 ，即<code>廉价冗余磁盘阵列</code>（ Redundant Array of Inexpensive Disks ）。由于当时大容量磁盘比较昂贵， RAID 的基本思想是将多个容量较小、相对廉价的磁盘进行有机组合，从而以较低的成本获得与昂贵大容量磁盘相当的容量、性能、可靠性。随着磁盘成本和价格的不断降低， “廉价” 已经毫无意义。因此， RAID 咨询委员会（ RAID Advisory Board, RAB ）决定用“ 独立 ” 替代 “ 廉价 ” ，于时 RAID 变成了<code>独立磁盘冗余阵列</code>（ Redundant Array of Independent Disks ）。但这仅仅是名称的变化，实质内容没有改变。</p>\n<p>内存：32m 6.4G（IBM 10.1G）</p>\n<h3 id=\"2-RAID等级\"><a href=\"#2-RAID等级\" class=\"headerlink\" title=\"2 RAID等级\"></a>2 RAID等级</h3><p>RAID 这种设计思想很快被业界接纳， RAID 技术作为高性能、高可靠的存储技术，得到了非常广泛的应用。 RAID 主要利用镜像、数据条带和数据校验三种技术来获取高性能、可靠性、容错能力和扩展性，根据对这三种技术的使用策略和组合架构，可以把 RAID 分为不同的等级，以满足不同数据应用的需求。</p>\n<p>D. A. Patterson 等的论文中定义了 RAID0 ~ RAID6 原始 RAID 等级。随后存储厂商又不断推出 RAID7、 RAID10、RAID01 、 RAID50 、 RAID53 、 RAID100 等 RAID 等级，但这些并无统一的标准。目前业界与学术界公认的标准是 RAID0 ~ RAID6 ，而在实际应用领域中使用最多的 RAID 等级是 RAID0 、RAID1 、 RAID3 、 RAID5 、 RAID6 和 RAID10。</p>\n<p>RAID 每一个等级代表一种实现方法和技术，等级之间并无高低之分。在实际应用中，应当根据用户的数据应用特点，综合考虑可用性、性能和成本来选择合适的 RAID 等级，以及具体的实现方式。</p>\n<h3 id=\"3-关键技术\"><a href=\"#3-关键技术\" class=\"headerlink\" title=\"3 关键技术\"></a>3 关键技术</h3><h4 id=\"镜像技术\"><a href=\"#镜像技术\" class=\"headerlink\" title=\"镜像技术\"></a>镜像技术</h4><p>镜像技术是一种冗余技术，为磁盘提供数据备份功能，防止磁盘发生故障而造成数据丢失。对于 RAID而言，采用镜像技术最典型地的用法就是，同时在磁盘阵列中产生两个完全相同的数据副本，并且分布在两个不同的磁盘上。镜像提供了完全的数据冗余能力，当一个数据副本失效不可用时，外部系统仍可正常访问另一副本，不会对应用系统运行和性能产生影响。而且，镜像不需要额外的计算和校验，故障修复非常快，直接复制即可。镜像技术可以从多个副本进行并发读取数据，提供更高的读 I/O 性能，但不能并行写数据，写多个副本通常会导致一定的 I/O 性能下降。</p>\n<p>镜像技术提供了非常高的数据安全性，其代价也是非常昂贵的，需要至少双倍的存储空间。高成本限制了镜像的广泛应用，主要应用于至关重要的数据保护，这种场合下的数据丢失可能会造成非常巨大的损失。</p>\n<h4 id=\"数据条带技术\"><a href=\"#数据条带技术\" class=\"headerlink\" title=\"数据条带技术\"></a>数据条带技术</h4><p>数据条带化技术是一种自动将 I/O操作负载均衡到多个物理磁盘上的技术。更具体地说就是，将一块连续的数据分成很多小部分并把它们分别存储到不同磁盘上。这就能使多个进程可以并发访问数据的多个不同部分，从而获得最大程度上的 I/O 并行能力，极大地提升性能。</p>\n<h4 id=\"数据校验技术\"><a href=\"#数据校验技术\" class=\"headerlink\" title=\"数据校验技术\"></a>数据校验技术</h4><p>数据校验技术是指， RAID 要在写入数据的同时进行校验计算，并将得到的校验数据存储在 RAID 成员磁盘中。校验数据可以集中保存在某个磁盘或分散存储在多个不同磁盘中。当其中一部分数据出错时，就可以对剩余数据和校验数据进行反校验计算重建丢失的数据。</p>\n<p>数据校验技术相对于镜像技术的优势在于节省大量开销，但由于每次数据读写都要进行大量的校验运算，对计算机的运算速度要求很高，且必须使用硬件 RAID 控制器。在数据重建恢复方面，检验技术比镜像技术复杂得多且慢得多。</p>\n<h3 id=\"4-RAID分类\"><a href=\"#4-RAID分类\" class=\"headerlink\" title=\"4 RAID分类\"></a>4 RAID分类</h3><p>从实现角度看， RAID 主要分为软 RAID、硬 RAID 以及混合 RAID 三种。</p>\n<h4 id=\"软-RAID\"><a href=\"#软-RAID\" class=\"headerlink\" title=\"软 RAID\"></a>软 RAID</h4><p>所有功能均有操作系统和 CPU 来完成，没有独立的 RAID 控制处理芯片和 I/O 处理芯片，效率自然最低。</p>\n<h4 id=\"硬-RAID\"><a href=\"#硬-RAID\" class=\"headerlink\" title=\"硬 RAID\"></a>硬 RAID</h4><p>配备了专门的 RAID 控制处理芯片和 I/O 处理芯片以及阵列缓冲，不占用 CPU 资源。效率很高，但成本也很高。</p>\n<h4 id=\"混合-RAID\"><a href=\"#混合-RAID\" class=\"headerlink\" title=\"混合 RAID\"></a>混合 RAID</h4><p>具备 RAID 控制处理芯片，但没有专门的I/O 处理芯片，需要 CPU 和驱动程序来完成。性能和成本在软RAID 和硬 RAID 之间。</p>\n<h3 id=\"5-常见RAID等级详解\"><a href=\"#5-常见RAID等级详解\" class=\"headerlink\" title=\"5 常见RAID等级详解\"></a>5 常见RAID等级详解</h3><h4 id=\"JBOD\"><a href=\"#JBOD\" class=\"headerlink\" title=\"JBOD\"></a>JBOD</h4><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208113559.png\" class title=\"输入图片说明\">\n\n<p>JBOD ，Just a Bunch of Disks，磁盘簇。表示一个没有控制软件提供协调控制的磁盘集合，这是 RAID区别与 JBOD 的主要因素。 JBOD 将多个物理磁盘串联起来，提供一个巨大的逻辑磁盘。</p>\n<p>JBOD 的数据存放机制是由第一块磁盘开始按顺序往后存储，当前磁盘存储空间用完后，再依次往后面的磁盘存储数据。 JBOD 存储性能完全等同于单块磁盘，而且也不提供数据安全保护。</p>\n<blockquote>\n<p>其只是简单提供一种扩展存储空间的机制，JBOD可用存储容量等于所有成员磁盘的存储空间之和</p>\n</blockquote>\n<p>JBOD 常指磁盘柜，而不论其是否提供 RAID 功能。不过，JBOD并非官方术语，官方称为Spanning。</p>\n<h4 id=\"RAID0\"><a href=\"#RAID0\" class=\"headerlink\" title=\"RAID0\"></a>RAID0</h4><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208113758.png\" class title=\"输入图片说明\">\n\n<p>RAID0 是一种简单的、无数据校验的<code>数据条带化技术</code>。实际上不是一种真正的 RAID ，因为它并不提供任何形式的冗余策略。 RAID0 将所在磁盘条带化后组成大容量的存储空间，将数据分散存储在所有磁盘中，以独立访问方式实现多块磁盘的并读访问。</p>\n<p>理论上讲，一个由 n 块磁盘组成的 RAID0 ，它的读写性能是单个磁盘性能的 n 倍，但由于总线带宽等多种因素的限制，实际的性能提升低于理论值。由于可以并发执行 I/O 操作，总线带宽得到充分利用。再加上不需要进行数据校验，<code>RAID0 的性能在所有 RAID 等级中是最高的</code>。</p>\n<p>RAID0 具有低成本、高读写性能、 100% 的高存储空间利用率等优点，但是它不提供数据冗余保护，一旦数据损坏，将无法恢复。</p>\n<p>应用场景：对数据的顺序读写要求不高，对数据的安全性和可靠性要求不高，但对系统性能要求很高的场景。</p>\n<blockquote>\n<p>RAID0与JBOD相同点：<br><br>1 ）存储容量：都是成员磁盘容量总和<br><br>2 ）磁盘利用率，都是100%，即都没有做任何的数据冗余备份<br><br>RAID0与JBOD不同点：<br><br>1 ）JBOD：数据是顺序存放的，一个磁盘存满后才会开始存放到下一个磁盘<br><br>2 ）RAID：各个磁盘中的数据写入是并行的，是通过数据条带技术写入的。其读写性能是JBOD的n倍<br></p>\n</blockquote>\n<h4 id=\"RAID1\"><a href=\"#RAID1\" class=\"headerlink\" title=\"RAID1\"></a>RAID1</h4><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208121758.png\" class title=\"输入图片说明\">\n\n<p>RAID1 就是一种<code>镜像技术</code>，它将数据完全一致地分别写到工作磁盘和镜像磁盘，它的磁盘空间利用率为 50% 。 RAID1 在数据写入时，响应时间会有所影响，但是读数据的时候没有影响。 RAID1 提供了最佳的数据保护，一旦工作磁盘发生故障，系统将自动切换到镜像磁盘，不会影响使用。</p>\n<p>RAID1是为了增强数据安全性使两块磁盘数据呈现完全镜像，从而达到安全性好、技术简单、管理方便。 RAID1 拥有完全容错的能力，但实现成本高。</p>\n<p>应用场景：对顺序读写性能要求较高，或对数据安全性要求较高的场景。</p>\n<h4 id=\"RAID10\"><a href=\"#RAID10\" class=\"headerlink\" title=\"RAID10\"></a>RAID10</h4><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208122057.png\" class title=\"输入图片说明\">\n\n<p>RAID10是一个RAID1与RAID0的组合体，所以它继承了RAID0的快速和RAID1的安全。简单来说就是，先做条带，再做镜像。发即将进来的数据先分散到不同的磁盘，再将磁盘中的数据做镜像。</p>\n<h4 id=\"RAID01\"><a href=\"#RAID01\" class=\"headerlink\" title=\"RAID01\"></a>RAID01</h4><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208122113.png\" class title=\"输入图片说明\">\n\n<p>RAID01是一个RAID0与RAID1的组合体，所以它继承了RAID0的快速和RAID1的安全。简单来说就是，先做镜像再做条带。即将进来的数据先做镜像，再将镜像数据写入到与之前数据不同的磁盘，即再做条带。</p>\n<blockquote>\n<p>RAID10要比RAID01的容错率再高，所以生产环境下一般是不使用RAID01的。</p>\n</blockquote>\n<h4 id=\"序号-主机名-IP-IP-功能-BROKER角色\"><a href=\"#序号-主机名-IP-IP-功能-BROKER角色\" class=\"headerlink\" title=\"序号 主机名/IP IP 功能 BROKER角色\"></a>序号 主机名/IP IP 功能 BROKER角色</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1 rocketmqOS1 192.168.59.164 NameServer + Broker Master1 + Slave2</span><br><span class=\"line\">2 rocketmqOS2 192.168.59.165 NameServer + Broker Master2 + Slave1</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"七、集群搭建实践\"><a href=\"#七、集群搭建实践\" class=\"headerlink\" title=\"七、集群搭建实践\"></a>七、集群搭建实践</h2><h3 id=\"1-集群架构\"><a href=\"#1-集群架构\" class=\"headerlink\" title=\"1 集群架构\"></a>1 集群架构</h3><p>这里要搭建一个双主双从异步复制的Broker集群。为了方便，这里使用了两台主机来完成集群的搭建。这两台主机的功能与broker角色分配如下表。</p>\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th align=\"center\">主机名/IP</th>\n<th align=\"right\">IP</th>\n<th align=\"right\">功能</th>\n<th align=\"right\">BROKER角色</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td align=\"center\">rocketmqOS1</td>\n<td align=\"right\">192.168.59.164</td>\n<td align=\"right\">NameServer + Broker</td>\n<td align=\"right\">Master1 + Slave2</td>\n</tr>\n<tr>\n<td>2</td>\n<td align=\"center\">rocketmqOS1</td>\n<td align=\"right\">192.168.59.165</td>\n<td align=\"right\">NameServer + Broker</td>\n<td align=\"right\">Master2 + Slave1</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-克隆生成rocketmqOS1\"><a href=\"#2-克隆生成rocketmqOS1\" class=\"headerlink\" title=\"2 克隆生成rocketmqOS1\"></a>2 克隆生成rocketmqOS1</h3><p>克隆rocketmqOS主机，并修改配置。指定主机名为rocketmqOS1。</p>\n<h3 id=\"3-修改rocketmqOS1配置文件\"><a href=\"#3-修改rocketmqOS1配置文件\" class=\"headerlink\" title=\"3 修改rocketmqOS1配置文件\"></a>3 修改rocketmqOS1配置文件</h3><h4 id=\"配置文件位置\"><a href=\"#配置文件位置\" class=\"headerlink\" title=\"配置文件位置\"></a>配置文件位置</h4><p>要修改的配置文件在rocketMQ解压目录的conf/2m-2s-async目录中。</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208122608.png\" class title=\"输入图片说明\">\n\n\n<h4 id=\"修改broker-a-properties\"><a href=\"#修改broker-a-properties\" class=\"headerlink\" title=\"修改broker-a.properties\"></a>修改broker-a.properties</h4><p>将该配置文件内容修改为如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 指定整个broker集群的名称，或者说是RocketMQ集群的名称</span></span><br><span class=\"line\">brokerClusterName=  </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 指定master-slave集群的名称。一个RocketMQ集群可以包含多个master-slave集群</span></span><br><span class=\"line\">brokerName=broker-a</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> master的brokerId为 0</span></span><br><span class=\"line\">brokerId= 0</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 指定删除消息存储过期文件的时间为凌晨 4 点</span></span><br><span class=\"line\">deleteWhen= 04</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 指定未发生更新的消息存储文件的保留时长为 48 小时， 48 小时后过期，将会被删除</span></span><br><span class=\"line\">fileReservedTime= 48</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 指定当前broker为异步复制master</span></span><br><span class=\"line\">brokerRole=ASYNC_MASTER</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 指定刷盘策略为异步刷盘</span></span><br><span class=\"line\">flushDiskType=ASYNC_FLUSH</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 指定Name Server的地址</span></span><br><span class=\"line\">namesrvAddr=192.168.59.164:9876;192.168.59.165:9876</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"修改broker-b-s-properties\"><a href=\"#修改broker-b-s-properties\" class=\"headerlink\" title=\"修改broker-b-s.properties\"></a>修改broker-b-s.properties</h4><p>将该配置文件内容修改为如下：</p>\n<h4 id=\"其它配置\"><a href=\"#其它配置\" class=\"headerlink\" title=\"其它配置\"></a>其它配置</h4><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">brokerClusterName=DefaultCluster</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 指定这是另外一个master-slave集群</span></span><br><span class=\"line\">brokerName=broker-b</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> slave的brokerId为非 0</span></span><br><span class=\"line\">brokerId=1</span><br><span class=\"line\">deleteWhen=04</span><br><span class=\"line\">fileReservedTime=48</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 指定当前broker为slave</span></span><br><span class=\"line\">brokerRole=SLAVE</span><br><span class=\"line\">flushDiskType=ASYNC_FLUSH</span><br><span class=\"line\">namesrvAddr=192.168.59.164:9876;192.168.59.165:9876</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 指定Broker对外提供服务的端口，即Broker与producer与consumer通信的端口。默认10911 。由于当前主机同时充当着master1与slave2，而前面的master1使用的是默认端口。这里需要将这两个端口加以区分，以区分出master1与slave2</span></span><br><span class=\"line\">listenPort= 11911</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 指定消息存储相关的路径。默认路径为~/store目录。由于当前主机同时充当着master1与slave2，master1使用的是默认路径，这里就需要再指定一个不同路径</span></span><br><span class=\"line\">storePathRootDir=~/store-s</span><br><span class=\"line\">storePathCommitLog=~/store-s/commitlog</span><br><span class=\"line\">storePathConsumeQueue=~/store-s/consumequeue</span><br><span class=\"line\">storePathIndex=~/store-s/index</span><br><span class=\"line\">storeCheckpoint=~/store-s/checkpoint</span><br><span class=\"line\">abortFile=~/store-s/abort</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"除了以上配置外，这些配置文件中还可以设置其它属性。\"><a href=\"#除了以上配置外，这些配置文件中还可以设置其它属性。\" class=\"headerlink\" title=\"除了以上配置外，这些配置文件中还可以设置其它属性。\"></a>除了以上配置外，这些配置文件中还可以设置其它属性。</h4><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">指定整个broker集群的名称，或者说是RocketMQ集群的名称</span></span><br><span class=\"line\">brokerClusterName=rocket-MS</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">指定master-slave集群的名称。一个RocketMQ集群可以包含多个master-slave集群</span></span><br><span class=\"line\">brokerName=broker-a</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">0 表示 Master，&gt;0 表示 Slave</span></span><br><span class=\"line\">brokerId=0</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">nameServer地址，分号分割</span></span><br><span class=\"line\">namesrvAddr=nameserver1:9876;nameserver2:9876</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">默认为新建Topic所创建的队列数</span></span><br><span class=\"line\">defaultTopicQueueNums=4</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">是否允许 Broker 自动创建Topic，建议生产环境中关闭</span></span><br><span class=\"line\">autoCreateTopicEnable=true</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">是否允许 Broker 自动创建订阅组，建议生产环境中关闭</span></span><br><span class=\"line\">autoCreateSubscriptionGroup=true</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">Broker对外提供服务的端口，即Broker与producer与consumer通信的端口</span></span><br><span class=\"line\">listenPort=10911</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">HA高可用监听端口，即Master与Slave间通信的端口，默认值为listenPort+1</span></span><br><span class=\"line\">haListenPort=10912</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">指定删除消息存储过期文件的时间为凌晨 4 点</span></span><br><span class=\"line\">deleteWhen=04</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">指定未发生更新的消息存储文件的保留时长为 48 小时， 48 小时后过期，将会被删除</span></span><br><span class=\"line\">fileReservedTime=48</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">指定commitLog目录中每个文件的大小，默认1G</span></span><br><span class=\"line\">mapedFileSizeCommitLog=1073741824</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">指定ConsumeQueue的每个Topic的每个Queue文件中可以存放的消息数量，默认30w条</span></span><br><span class=\"line\">mapedFileSizeConsumeQueue=300000</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">在清除过期文件时，如果该文件被其他线程所占用（引用数大于 0 ，比如读取消息），此时会阻止此次删除任务，同时在第一次试图删除该文件时记录当前时间戳。该属性则表示从第一次拒绝删除后开始计时，该文件最多可以保留的时长。在此时间内若引用数仍不为 0 ，则删除仍会被拒绝。不过时间到后，文件将被强制删除</span></span><br><span class=\"line\">destroyMapedFileIntervalForcibly=120000</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">指定commitlog、consumequeue所在磁盘分区的最大使用率，超过该值，则需立即清除过期文件</span></span><br><span class=\"line\">diskMaxUsedSpaceRatio=88</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">指定store目录的路径，默认在当前用户主目录中</span></span><br><span class=\"line\">storePathRootDir=/usr/local/rocketmq-all-4.5.0/store</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">commitLog目录路径</span></span><br><span class=\"line\">storePathCommitLog=/usr/local/rocketmq-all-4.5.0/store/commitlog</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">consumeueue目录路径</span></span><br><span class=\"line\">storePathConsumeQueue=/usr/local/rocketmq-all-4.5.0/store/consumequeue</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">index目录路径</span></span><br><span class=\"line\">storePathIndex=/usr/local/rocketmq-all-4.5.0/store/index</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">checkpoint文件路径</span></span><br><span class=\"line\">storeCheckpoint=/usr/local/rocketmq-all-4.5.0/store/checkpoint</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">abort文件路径</span></span><br><span class=\"line\">abortFile=/usr/local/rocketmq-all-4.5.0/store/abort</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">指定消息的最大大小</span></span><br><span class=\"line\">maxMessageSize= 65536</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">Broker的角色</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> - ASYNC_MASTER 异步复制Master</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> - SYNC_MASTER 同步双写Master</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> - SLAVE</span></span><br><span class=\"line\">brokerRole=SYNC_MASTER</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">刷盘策略</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> - ASYNC_FLUSH 异步刷盘</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> - SYNC_FLUSH 同步刷盘</span></span><br><span class=\"line\">flushDiskType=SYNC_FLUSH</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">发消息线程池数量</span></span><br><span class=\"line\">sendMessageThreadPoolNums=128</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">拉消息线程池数量</span></span><br><span class=\"line\">pullMessageThreadPoolNums=128</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">强制指定本机IP，需要根据每台机器进行修改。官方介绍可为空，系统默认自动识别，但多网卡时IP地址可能读取错误</span></span><br><span class=\"line\">brokerIP1=192.168.3.105</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-克隆生成rocketmqOS2\"><a href=\"#4-克隆生成rocketmqOS2\" class=\"headerlink\" title=\"4 克隆生成rocketmqOS2\"></a>4 克隆生成rocketmqOS2</h3><p>克隆rocketmqOS1主机，并修改配置。指定主机名为rocketmqOS2。</p>\n<h3 id=\"5-修改rocketmqOS2配置文件\"><a href=\"#5-修改rocketmqOS2配置文件\" class=\"headerlink\" title=\"5 修改rocketmqOS2配置文件\"></a>5 修改rocketmqOS2配置文件</h3><p>对于rocketmqOS2主机，同样需要修改rocketMQ解压目录的conf目录的子目录2m-2s-async中的两个配置文件。</p>\n<h4 id=\"修改broker-b-properties\"><a href=\"#修改broker-b-properties\" class=\"headerlink\" title=\"修改broker-b.properties\"></a>修改broker-b.properties</h4><p>将该配置文件内容修改为如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">brokerClusterName=DefaultCluster</span><br><span class=\"line\">brokerName=broker-b</span><br><span class=\"line\">brokerId=0</span><br><span class=\"line\">deleteWhen=04</span><br><span class=\"line\">fileReservedTime=48</span><br><span class=\"line\">brokerRole=ASYNC_MASTER</span><br><span class=\"line\">flushDiskType=ASYNC_FLUSH</span><br><span class=\"line\">namesrvAddr=192.168.59.164:9876;192.168.59.165:9876</span><br></pre></td></tr></table></figure>\n\n<p>修改broker-a-s.properties</p>\n<h4 id=\"将该配置文件内容修改为如下：\"><a href=\"#将该配置文件内容修改为如下：\" class=\"headerlink\" title=\"将该配置文件内容修改为如下：\"></a>将该配置文件内容修改为如下：</h4><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">brokerClusterName=DefaultCluster</span><br><span class=\"line\">brokerName=broker-a</span><br><span class=\"line\">brokerId=1</span><br><span class=\"line\">deleteWhen=04</span><br><span class=\"line\">fileReservedTime=48</span><br><span class=\"line\">brokerRole=SLAVE</span><br><span class=\"line\">flushDiskType=ASYNC_FLUSH</span><br><span class=\"line\">namesrvAddr=192.168.59.164:9876;192.168.59.165:9876</span><br><span class=\"line\">listenPort=11911</span><br><span class=\"line\">storePathRootDir=~/store-s</span><br><span class=\"line\">storePathCommitLog=~/store-s/commitlog</span><br><span class=\"line\">storePathConsumeQueue=~/store-s/consumequeue</span><br><span class=\"line\">storePathIndex=~/store-s/index</span><br><span class=\"line\">storeCheckpoint=~/store-s/checkpoint</span><br><span class=\"line\">abortFile=~/store-s/abort</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-启动服务器\"><a href=\"#6-启动服务器\" class=\"headerlink\" title=\"6 启动服务器\"></a>6 启动服务器</h3><h4 id=\"启动NameServer集群\"><a href=\"#启动NameServer集群\" class=\"headerlink\" title=\"启动NameServer集群\"></a>启动NameServer集群</h4><p>分别启动rocketmqOS1与rocketmqOS2两个主机中的NameServer。启动命令完全相同。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">nohup sh bin/mqnamesrv &amp;</span><br><span class=\"line\">tail -f ~/logs/rocketmqlogs/namesrv.log</span><br></pre></td></tr></table></figure>\n<h4 id=\"启动两个Master\"><a href=\"#启动两个Master\" class=\"headerlink\" title=\"启动两个Master\"></a>启动两个Master</h4><p>分别启动rocketmqOS1与rocketmqOS2两个主机中的broker master。注意，它们指定所要加载的配置文件是不同的。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">nohup sh bin/mqbroker -c conf/2m-2s-async/broker-a.properties &amp;</span><br><span class=\"line\">tail -f ~/logs/rocketmqlogs/broker.log</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">nohup sh bin/mqbroker -c conf/2m-2s-async/broker-b.properties &amp;</span><br><span class=\"line\">tail -f ~/logs/rocketmqlogs/broker.log</span><br></pre></td></tr></table></figure>\n<h4 id=\"启动两个Slave\"><a href=\"#启动两个Slave\" class=\"headerlink\" title=\"启动两个Slave\"></a>启动两个Slave</h4><p>分别启动rocketmqOS1与rocketmqOS2两个主机中的broker slave。注意，它们指定所要加载的配置文件是不同的。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">nohup sh bin/mqbroker -c conf/2m-2s-async/broker-b-s.properties &amp;</span><br><span class=\"line\">tail -f ~/logs/rocketmqlogs/broker.log</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">nohup sh bin/mqbroker -c conf/2m-2s-async/broker-a-s.properties &amp;</span><br><span class=\"line\">tail -f ~/logs/rocketmqlogs/broker.log</span><br></pre></td></tr></table></figure>\n<h2 id=\"八、mqadmin命令\"><a href=\"#八、mqadmin命令\" class=\"headerlink\" title=\"八、mqadmin命令\"></a>八、mqadmin命令</h2><p>在mq解压目录的bin目录下有一个mqadmin命令，该命令是一个运维指令，用于对mq的主题，集群，broker 等信息进行管理。</p>\n<h3 id=\"1-修改bin-tools-sh\"><a href=\"#1-修改bin-tools-sh\" class=\"headerlink\" title=\"1 修改bin/tools.sh\"></a>1 修改bin/tools.sh</h3><p>在运行mqadmin命令之前，先要修改mq解压目录下bin/tools.sh配置的JDK的ext目录位置。本机的ext目录在<code>/usr/java/jdk1.8.0_161/jre/lib/ext</code>。</p>\n<p>使用vim命令打开tools.sh文件，并在JAVA_OPT配置的-Djava.ext.dirs这一行的后面添加ext的路径。</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208123848.png\" class title=\"输入图片说明\">\n\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms1g -Xmx1g -Xmn256m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=128m&quot;</span><br><span class=\"line\">JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -Djava.ext.dirs=$&#123;BASE_DIR&#125;/lib:$&#123;JAVA_HOME&#125;/jre/lib/ext:$&#123;JAVA_HOME&#125;/lib/ext:/usr/java/jdk1.8.0_161/jre/lib/ext&quot;</span><br><span class=\"line\">JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -cp $&#123;CLASSPATH&#125;&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-运行mqadmin\"><a href=\"#2-运行mqadmin\" class=\"headerlink\" title=\"2 运行mqadmin\"></a>2 运行mqadmin</h3><p>直接运行该命令，可以看到其可以添加的commands。通过这些commands可以完成很多的功能。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@mqOS rocketmq-all-4.8.0-bin-release]# ./bin/mqadmin</span><br><span class=\"line\">The most commonly used mqadmin commands are:</span><br><span class=\"line\">updateTopic Update or create topic</span><br><span class=\"line\">deleteTopic Delete topic from broker and NameServer.</span><br><span class=\"line\">updateSubGroup Update or create subscription group</span><br><span class=\"line\">deleteSubGroup Delete subscription group from broker.</span><br><span class=\"line\">updateBrokerConfig Update broker&#x27;s config</span><br><span class=\"line\">updateTopicPerm Update topic perm</span><br><span class=\"line\">topicRoute Examine topic route info</span><br><span class=\"line\">topicStatus Examine topic Status info</span><br><span class=\"line\">topicClusterList get cluster info for topic</span><br><span class=\"line\">brokerStatus Fetch broker runtime status data</span><br><span class=\"line\">queryMsgById Query Message by Id</span><br><span class=\"line\">queryMsgByKey Query Message by Key</span><br><span class=\"line\">queryMsgByUniqueKey Query Message by Unique key</span><br><span class=\"line\">queryMsgByOffset Query Message by offset</span><br><span class=\"line\">QueryMsgTraceById query a message trace</span><br><span class=\"line\">printMsg Print Message Detail</span><br><span class=\"line\">printMsgByQueue Print Message Detail</span><br><span class=\"line\">sendMsgStatus send msg to broker.</span><br><span class=\"line\">brokerConsumeStats Fetch broker consume stats data</span><br><span class=\"line\">producerConnection Query producer&#x27;s socket connection and clientversion</span><br><span class=\"line\">consumerConnection Query consumer&#x27;s socket connection, client version and subscription</span><br><span class=\"line\">consumerProgress Query consumers&#x27;s progress, speed</span><br><span class=\"line\">consumerStatus Query consumer&#x27;s internal data structure</span><br><span class=\"line\">cloneGroupOffset clone offset from other group.</span><br><span class=\"line\">clusterList List all of clusters</span><br><span class=\"line\">topicList Fetch all topic list from name server</span><br><span class=\"line\">updateKvConfig Create or update KV config.</span><br><span class=\"line\">deleteKvConfig Delete KV config.</span><br><span class=\"line\">wipeWritePerm Wipe write perm of broker in all name server</span><br><span class=\"line\">resetOffsetByTime Reset consumer offset by timestamp(without client restart).</span><br><span class=\"line\">updateOrderConf Create or update or delete order conf</span><br><span class=\"line\">cleanExpiredCQ Clean expired ConsumeQueue on broker.</span><br><span class=\"line\">cleanUnusedTopic Clean unused topic on broker.</span><br><span class=\"line\">startMonitoring Start Monitoring</span><br><span class=\"line\">statsAll Topic and Consumer tps stats</span><br><span class=\"line\">allocateMQ Allocate MQ</span><br><span class=\"line\">checkMsgSendRT check message send response time</span><br><span class=\"line\">clusterRT List All clusters Message Send RT</span><br><span class=\"line\">getNamesrvConfig Get configs of name server.</span><br><span class=\"line\">updateNamesrvConfig Update configs of name server.</span><br><span class=\"line\">getBrokerConfig Get broker config by cluster or special broker!</span><br><span class=\"line\">queryCq Query cq command.</span><br><span class=\"line\">sendMessage Send a message</span><br><span class=\"line\">consumeMessage Consume message</span><br><span class=\"line\">updateAclConfig Update acl config yaml file in broker</span><br><span class=\"line\">deleteAccessConfig Delete Acl Config Account in broker</span><br><span class=\"line\">clusterAclConfigVersion List all of acl config version information in cluster</span><br><span class=\"line\">updateGlobalWhiteAddr Update global white address for acl Config File in broker</span><br><span class=\"line\">getAccessConfigSubCommand List all of acl config information in cluster</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-该命令的官网详解\"><a href=\"#3-该命令的官网详解\" class=\"headerlink\" title=\"3 该命令的官网详解\"></a>3 该命令的官网详解</h3><h4 id=\"该命令在官网中有详细的用法解释。\"><a href=\"#该命令在官网中有详细的用法解释。\" class=\"headerlink\" title=\"该命令在官网中有详细的用法解释。\"></a>该命令在官网中有详细的用法解释。</h4><p><a href=\"https://github.com/apache/rocketmq/blob/master/docs/cn/operation.md\">https://github.com/apache/rocketmq/blob/master/docs/cn/operation.md</a></p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208124241.png\" class title=\"输入图片说明\">\n\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208124258.png\" class title=\"输入图片说明\">\n\n<h1 id=\"第-3-章-RocketMQ工作原理\"><a href=\"#第-3-章-RocketMQ工作原理\" class=\"headerlink\" title=\"第 3 章 RocketMQ工作原理\"></a>第 3 章 RocketMQ工作原理</h1><h2 id=\"一、消息的生产\"><a href=\"#一、消息的生产\" class=\"headerlink\" title=\"一、消息的生产\"></a>一、消息的生产</h2><h3 id=\"1-消息的生产过程\"><a href=\"#1-消息的生产过程\" class=\"headerlink\" title=\"1 消息的生产过程\"></a>1 消息的生产过程</h3><p>Producer可以将消息写入到某Broker中的某Queue中，其经历了如下过程：</p>\n<ul>\n<li>Producer发送消息之前，会先向NameServer发出获取消息Topic的路由信息的请求</li>\n<li>NameServer返回该Topic的路由表及Broker列表</li>\n<li>Producer根据代码中指定的Queue选择策略，从Queue列表中选出一个队列，用于后续存储消息</li>\n<li>Produer对消息做一些特殊处理，例如，消息本身超过4M，则会对其进行压缩</li>\n<li>Producer向选择出的Queue所在的Broker发出RPC请求，将消息发送到选择出的Queue</li>\n</ul>\n<blockquote>\n<p>路由表：实际是一个Map，key为Topic名称，value是一个QueueData实例列表。QueueData并不是一个Queue对应一个QueueData，而是一个Broker中该Topic的所有Queue对应一个QueueData。即，只要涉及到该Topic的Broker，一个Broker对应一个QueueData。QueueData中包含brokerName。简单来说，路由表的key为Topic名称，value则为所有涉及该Topic的BrokerName列表。</p>\n</blockquote>\n<blockquote>\n<p>Broker列表：其实际也是一个Map。key为brokerName，value为BrokerData。一个Broker对应一个BrokerData实例，对吗？不对。一套brokerName名称相同的Master-Slave小集群对应一个BrokerData。BrokerData中包含brokerName及一个map。该map的key为brokerId，value为该broker对应的地址。brokerId为 0 表示该broker为Master，非 0 表示Slave。</p>\n</blockquote>\n<h3 id=\"2-Queue选择算法\"><a href=\"#2-Queue选择算法\" class=\"headerlink\" title=\"2 Queue选择算法\"></a>2 Queue选择算法</h3><p>对于无序消息，其Queue选择算法，也称为消息投递算法，常见的有两种：</p>\n<h4 id=\"轮询算法\"><a href=\"#轮询算法\" class=\"headerlink\" title=\"轮询算法\"></a>轮询算法</h4><p>默认选择算法。该算法保证了每个Queue中可以均匀的获取到消息。</p>\n<blockquote>\n<p>该算法存在一个问题：由于某些原因，在某些Broker上的Queue可能投递延迟较严重。从而导致Producer的缓存队列中出现较大的消息积压，影响消息的投递性能。</p>\n</blockquote>\n<h4 id=\"最小投递延迟算法\"><a href=\"#最小投递延迟算法\" class=\"headerlink\" title=\"最小投递延迟算法\"></a>最小投递延迟算法</h4><p>该算法会统计每次消息投递的时间延迟，然后根据统计出的结果将消息投递到时间延迟最小的Queue。如果延迟相同，则采用轮询算法投递。该算法可以有效提升消息的投递性能。</p>\n<blockquote>\n<p>该算法也存在一个问题：消息在Queue上的分配不均匀。投递延迟小的Queue其可能会存在大量的消息。而对该Queue的消费者压力会增大，降低消息的消费能力，可能会导致MQ中消息的堆积。</p>\n</blockquote>\n<h2 id=\"二、消息的存储\"><a href=\"#二、消息的存储\" class=\"headerlink\" title=\"二、消息的存储\"></a>二、消息的存储</h2><p>RocketMQ中的消息存储在本地文件系统中，这些相关文件默认在当前用户主目录下的store目录中。</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208133814.png\" class title=\"输入图片说明\">\n\n<ul>\n<li>abort：该文件在Broker启动后会自动创建，正常关闭Broker，该文件会自动消失。若在没有启动Broker的情况下，发现这个文件是存在的，则说明之前Broker的关闭是非正常关闭。</li>\n<li>checkpoint：其中存储着commitlog、consumequeue、index文件的最后刷盘时间戳</li>\n<li>commitlog：其中存放着commitlog文件，而消息是写在commitlog文件中的</li>\n<li>conæg：存放着Broker运行期间的一些配置数据</li>\n<li>consumequeue：其中存放着consumequeue文件，队列就存放在这个目录中</li>\n<li>index：其中存放着消息索引文件indexFile</li>\n<li>lock：运行期间使用到的全局资源锁</li>\n</ul>\n<h3 id=\"1-commitlog文件\"><a href=\"#1-commitlog文件\" class=\"headerlink\" title=\"1 commitlog文件\"></a>1 commitlog文件</h3><blockquote>\n<p>说明：在很多资料中commitlog目录中的文件简单就称为commitlog文件。但在源码中，该文件被命名为mappedFile。</p>\n</blockquote>\n<h4 id=\"目录与文件\"><a href=\"#目录与文件\" class=\"headerlink\" title=\"目录与文件\"></a>目录与文件</h4><p>commitlog目录中存放着很多的mappedFile文件，当前Broker中的所有消息都是落盘到这些mappedFile文件中的。mappedFile文件大小为1G（小于等于1G），文件名由 20 位十进制数构成，表示当前文件的第一条消息的起始位移偏移量。</p>\n<blockquote>\n<p>第一个文件名一定是 20 位 0 构成的。因为第一个文件的第一条消息的偏移量commitlog offset为 0 <br><br><br>当第一个文件放满时，则会自动生成第二个文件继续存放消息。假设第一个文件大小是 1073741820 字节（1G = 1073741824字节），则第二个文件名就是 00000000001073741824 。<br><br><br>以此类推，第n个文件名应该是前n-1个文件大小之和。<br><br><br>一个Broker中所有mappedFile文件的commitlog offset是连续的</p>\n</blockquote>\n<p>需要注意的是，一个Broker中仅包含一个commitlog目录，所有的mappedFile文件都是存放在该目录中的。即无论当前Broker中存放着多少Topic的消息，这些消息都是被顺序写入到了mappedFile文件中的。也就是说，这些消息在Broker中存放时并没有被按照Topic进行分类存放。</p>\n<blockquote>\n<p>mappedFile文件是顺序读写的文件，所有其访问效率很高<br><br><br>无论是SSD磁盘还是SATA磁盘，通常情况下，顺序存取效率都会高于随机存取。</p>\n</blockquote>\n<h4 id=\"消息单元\"><a href=\"#消息单元\" class=\"headerlink\" title=\"消息单元\"></a>消息单元</h4><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208134157.png\" class title=\"输入图片说明\">\n\n<p>mappedFile文件内容由一个个的<code>消息单元</code>构成。每个消息单元中包含消息总长度MsgLen、消息的物理位置physicalOffset、消息体内容Body、消息体长度BodyLength、消息主题Topic、Topic长度 TopicLength、消息生产者BornHost、消息发送时间戳BornTimestamp、消息所在的队列QueueId、消息在Queue中存储的偏移量QueueOffset等近 20 余项消息相关属性。</p>\n<blockquote>\n<p>需要注意到，消息单元中是包含Queue相关属 性的。所以，我们在后续的学习中，就需要十分留意commitlog与queue间的关系是什么？<br><br><br>一个mappedFile文件中第m+1个消息单元的commitlog offset偏移量<br><br><br>L(m+1) = L(m) + MsgLen(m) (m &gt;= 0)</p>\n</blockquote>\n<h3 id=\"2-consumequeue\"><a href=\"#2-consumequeue\" class=\"headerlink\" title=\"2 consumequeue\"></a>2 consumequeue</h3><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208134355.png\" class title=\"输入图片说明\">\n<h4 id=\"目录与文件-1\"><a href=\"#目录与文件-1\" class=\"headerlink\" title=\"目录与文件\"></a>目录与文件</h4><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208134415.png\" class title=\"输入图片说明\">\n\n<p>为了提高效率，会为每个Topic在~/store/consumequeue中创建一个目录，目录名为Topic名称。在该Topic目录下，会再为每个该Topic的Queue建立一个目录，目录名为queueId。每个目录中存放着若干consumequeue文件，consumequeue文件是commitlog的索引文件，可以根据consumequeue定位到具体的消息。</p>\n<p>consumequeue文件名也由 20 位数字构成，表示当前文件的第一个索引条目的起始位移偏移量。与mappedFile文件名不同的是，其后续文件名是固定的。因为consumequeue文件大小是固定不变的。</p>\n<h4 id=\"索引条目\"><a href=\"#索引条目\" class=\"headerlink\" title=\"索引条目\"></a>索引条目</h4><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208134454.png\" class title=\"输入图片说明\">\n\n<p>每个consumequeue文件可以包含30w个索引条目，每个索引条目包含了三个消息重要属性：消息在mappedFile文件中的偏移量CommitLog Offset、消息长度、消息Tag的hashcode值。这三个属性占 20个字节，所以每个文件的大小是固定的30w * 20字节。</p>\n<blockquote>\n<p>一个consumequeue文件中所有消息的Topic一定是相同的。但每条消息的Tag可能是不同的。</p>\n</blockquote>\n<h3 id=\"3-对文件的读写\"><a href=\"#3-对文件的读写\" class=\"headerlink\" title=\"3 对文件的读写\"></a>3 对文件的读写</h3><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208134538.png\" class title=\"输入图片说明\">\n\n<h4 id=\"消息写入\"><a href=\"#消息写入\" class=\"headerlink\" title=\"消息写入\"></a>消息写入</h4><p>一条消息进入到Broker后经历了以下几个过程才最终被持久化。</p>\n<ul>\n<li>Broker根据queueId，获取到该消息对应索引条目要在consumequeue目录中的写入偏移量，即QueueOffset</li>\n<li>将queueId、queueOffset等数据，与消息一起封装为消息单元</li>\n<li>将消息单元写入到commitlog</li>\n<li>同时，形成消息索引条目</li>\n<li>将消息索引条目分发到相应的consumequeue</li>\n</ul>\n<h4 id=\"消息拉取\"><a href=\"#消息拉取\" class=\"headerlink\" title=\"消息拉取\"></a>消息拉取</h4><ul>\n<li><p>当Consumer来拉取消息时会经历以下几个步骤：</p>\n<ul>\n<li>Consumer获取到其要消费消息所在Queue的消费偏移量offset，计算出其要消费消息的消息offset<blockquote>\n<p>消费offset即消费进度，consumer对某个Queue的消费offset，即消费到了该Queue的第几条消息<br><br>消息offset = 消费offset + 1</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>Consumer向Broker发送拉取请求，其中会包含其要拉取消息的Queue、消息offset及消息Tag。</p>\n</li>\n<li><p>Broker计算在该consumequeue中的queueOffset。</p>\n<blockquote>\n<p>queueOffset = 消息offset * 20字节</p>\n</blockquote>\n</li>\n<li><p>从该queueOffset处开始向后查找第一个指定Tag的索引条目。</p>\n</li>\n<li><p>解析该索引条目的前 8 个字节，即可定位到该消息在commitlog中的commitlog offset</p>\n</li>\n<li><p>从对应commitlog offset中读取消息单元，并发送给Consumer</p>\n</li>\n</ul>\n<h4 id=\"性能提升\"><a href=\"#性能提升\" class=\"headerlink\" title=\"性能提升\"></a>性能提升</h4><p>RocketMQ中，无论是消息本身还是消息索引，都是存储在磁盘上的。其不会影响消息的消费吗？当然不会。其实RocketMQ的性能在目前的MQ产品中性能是非常高的。因为系统通过一系列相关机制大大提升了性能。</p>\n<p>首先，RocketMQ对文件的读写操作是通过<code>mmap零拷贝</code>进行的，将对文件的操作转化为直接对内存地址进行操作，从而极大地提高了文件的读写效率。</p>\n<p>其次，consumequeue中的数据是顺序存放的，还引入了<code>PageCache的预读取机制</code>，使得对consumequeue文件的读取几乎接近于内存读取，即使在有消息堆积情况下也不会影响性能。</p>\n<blockquote>\n<p>PageCache机制，页缓存机制，是OS对文件的缓存机制，用于加速对文件的读写操作。一般来说，程序对文件进行顺序读写的速度几乎接近于内存读写速度，主要原因是由于OS使用PageCache机制对读写访问操作进行性能优化，将一部分的内存用作PageCache。<br><br><br>1)写操作：OS会先将数据写入到PageCache中，随后会以异步方式由pdæush（page dirty æush)内核线程将Cache中的数据刷盘到物理磁盘<br><br>2)读操作：若用户要读取数据，其首先会从PageCache中读取，若没有命中，则OS在从物理磁盘上加载该数据到PageCache的同时，也会顺序 对其相邻数据块中的数据进行预读取。</p>\n</blockquote>\n<p>RocketMQ中可能会影响性能的是对commitlog文件的读取。因为对commitlog文件来说，读取消息时会产生大量的随机访问，而随机访问会严重影响性能。不过，如果选择合适的系统IO调度算法，比如设置调度算法为Deadline（采用SSD固态硬盘的话），随机读的性能也会有所提升。</p>\n<h3 id=\"4-与Kafka的对比\"><a href=\"#4-与Kafka的对比\" class=\"headerlink\" title=\"4 与Kafka的对比\"></a>4 与Kafka的对比</h3><p>RocketMQ的很多思想来源于Kafka，其中commitlog与consumequeue就是。</p>\n<p>RocketMQ中的commitlog目录与consumequeue的结合就类似于Kafka中的partition分区目录。mappedFile文件就类似于Kafka中的segment段。</p>\n<blockquote>\n<p>Kafka中的Topic的消息被分割为一个或多个partition。partition是一个物理概念，对应到系统上就是topic目录下的一个或多个目录。每个partition中包含的文件称为segment，是具体存放消息的文件。<br><br><br>Kafka中消息存放的目录结构是：topic目录下有partition目录，partition目录下有segment文件<br><br><br>Kafka中没有二级分类标签Tag这个概念<br><br><br>Kafka中无需索引文件。因为生产者是将消息直接写在了partition中的，消费者也是直接从partition中读取数据的</p>\n</blockquote>\n<h2 id=\"三、indexFile\"><a href=\"#三、indexFile\" class=\"headerlink\" title=\"三、indexFile\"></a>三、indexFile</h2><p>除了通过通常的指定Topic进行消息消费外，RocketMQ还提供了根据key进行消息查询的功能。该查询是通过store目录中的index子目录中的indexFile进行索引实现的快速查询。当然，这个indexFile中的索引数据是在<code>包含了key的消息</code>被发送到Broker时写入的。如果消息中没有包含key，则不会写入。</p>\n<h3 id=\"1-索引条目结构\"><a href=\"#1-索引条目结构\" class=\"headerlink\" title=\"1 索引条目结构\"></a>1 索引条目结构</h3><p>每个Broker中会包含一组indexFile，每个indexFile都是以一个<code>时间戳</code>命名的（这个indexFile被创建时的时间戳）。每个indexFile文件由三部分构成：indexHeader，slots槽位，indexes索引数据。每个<br>indexFile文件中包含500w个slot槽。而每个slot槽又可能会挂载很多的index索引单元。</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208135939.png\" class title=\"输入图片说明\">\n\n<p>indexHeader固定 40 个字节，其中存放着如下数据：</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208135949.png\" class title=\"输入图片说明\">\n\n<ul>\n<li>beginTimestamp：该indexFile中第一条消息的存储时间</li>\n<li>endTimestamp：该indexFile中最后一条消息存储时间</li>\n<li>beginPhyoffset：该indexFile中第一条消息在commitlog中的偏移量commitlog offset</li>\n<li>endPhyoffset：该indexFile中最后一条消息在commitlog中的偏移量commitlog offset</li>\n<li>hashSlotCount：已经填充有index的slot数量（并不是每个slot槽下都挂载有index索引单元，这里统计的是所有挂载了index索引单元的slot槽的数量）</li>\n<li>indexCount：该indexFile中包含的索引单元个数（统计出当前indexFile中所有slot槽下挂载的所有index索引单元的数量之和）</li>\n</ul>\n<p>indexFile中最复杂的是Slots与Indexes间的关系。在实际存储时，Indexes是在Slots后面的，但为了便于理解，将它们的关系展示为如下形式：</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208140054.png\" class title=\"输入图片说明\">\n\n<p><code>key的hash值 % 500w</code>的结果即为slot槽位，然后将该slot值修改为该index索引单元的indexNo，根据这个indexNo可以计算出该index单元在indexFile中的位置。不过，该取模结果的重复率是很高的，为了解决该问题，在每个index索引单元中增加了preIndexNo，用于指定该slot中当前index索引单元的前一个index索引单元。而slot中始终存放的是其下最新的index索引单元的indexNo，这样的话，只要找到了slot就可以找到其最新的index索引单元，而通过这个index索引单元就可以找到其之前的所有index索引单元。</p>\n<blockquote>\n<p>indexNo是一个在indexFile中的流水号，从 0 开始依次递增。即在一个indexFile中所有indexNo是以此递增的。indexNo在index索引单元中是没有体现的，其是通过indexes中依次数出来的。</p>\n</blockquote>\n<p>index索引单元默写 20 个字节，其中存放着以下四个属性：</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208140159.png\" class title=\"输入图片说明\">\n\n<ul>\n<li>keyHash：消息中指定的业务key的hash值</li>\n<li>phyOffset：当前key对应的消息在commitlog中的偏移量commitlog offset</li>\n<li>timeDiff：当前key对应消息的存储时间与当前indexFile创建时间的时间差</li>\n<li>preIndexNo：当前slot下当前index索引单元的前一个index索引单元的indexNo</li>\n</ul>\n<h3 id=\"2-indexFile的创建\"><a href=\"#2-indexFile的创建\" class=\"headerlink\" title=\"2 indexFile的创建\"></a>2 indexFile的创建</h3><p>indexFile的文件名为当前文件被创建时的时间戳。这个时间戳有什么用处呢？</p>\n<p>根据业务key进行查询时，查询条件除了key之外，还需要指定一个要查询的时间戳，表示要查询不大于该时间戳的最新的消息，即查询指定时间戳之前存储的最新消息。这个时间戳文件名可以简化查询，提高查询效率。具体后面会详细讲解。</p>\n<p>indexFile文件是何时创建的？其创建的条件（时机）有两个：</p>\n<ul>\n<li>当第一条带key的消息发送来后，系统发现没有indexFile，此时会创建第一个indexFile文件</li>\n<li>当一个indexFile中挂载的index索引单元数量超出2000w个时，会创建新的indexFile。当带key的消息发送到来后，系统会找到最新的indexFile，并从其indexHeader的最后 4 字节中读取到indexCount。若indexCount &gt;= 2000w时，会创建新的indexFile。</li>\n</ul>\n<blockquote>\n<p>由于可以推算出，一个indexFile的最大大小是：(40 + 500w * 4 + 2000w * 20)字节</p>\n</blockquote>\n<h3 id=\"3-查询流程\"><a href=\"#3-查询流程\" class=\"headerlink\" title=\"3 查询流程\"></a>3 查询流程</h3><p>当消费者通过业务key来查询相应的消息时，其需要经过一个相对较复杂的查询流程。不过，在分析查询流程之前，首先要清楚几个定位计算式子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">计算指定消息key的slot槽位序号：</span><br><span class=\"line\">slot槽位序号 = key的hash % 500w (式子1)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">计算槽位序号为n的slot在indexFile中的起始位置：</span><br><span class=\"line\">slot(n)位置 = 40 + (n - 1) * 4 (式子2)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">计算indexNo为m的index在indexFile中的位置：</span><br><span class=\"line\">index(m)位置 = 40 + 500w * 4 + (m - 1) * 20 (式子3)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>40 为indexFile中indexHeader的字节数<br><br>500w * 4 是所有slots所占的字节数</p>\n</blockquote>\n<h4 id=\"具体查询流程如下：\"><a href=\"#具体查询流程如下：\" class=\"headerlink\" title=\"具体查询流程如下：\"></a>具体查询流程如下：</h4><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208140740.png\" class title=\"输入图片说明\">\n<h2 id=\"四、消息的消费\"><a href=\"#四、消息的消费\" class=\"headerlink\" title=\"四、消息的消费\"></a>四、消息的消费</h2><p>消费者从Broker中获取消息的方式有两种：pull拉取方式和push推动方式。消费者组对于消息消费的模式又分为两种：集群消费Clustering和广播消费Broadcasting。</p>\n<h3 id=\"1-获取消费类型\"><a href=\"#1-获取消费类型\" class=\"headerlink\" title=\"1 获取消费类型\"></a>1 获取消费类型</h3><h4 id=\"拉取式消费\"><a href=\"#拉取式消费\" class=\"headerlink\" title=\"拉取式消费\"></a>拉取式消费</h4><p>Consumer主动从Broker中拉取消息，主动权由Consumer控制。一旦获取了批量消息，就会启动消费过程。不过，该方式的实时性较弱，即Broker中有了新的消息时消费者并不能及时发现并消费。</p>\n<blockquote>\n<p>由于拉取时间间隔是由用户指定的，所以在设置该间隔时需要注意平稳：间隔太短，空请求比例会增加；间隔太长，消息的实时性太差</p>\n</blockquote>\n<h4 id=\"推送式消费\"><a href=\"#推送式消费\" class=\"headerlink\" title=\"推送式消费\"></a>推送式消费</h4><p>该模式下Broker收到数据后会主动推送给Consumer。该获取方式一般实时性较高。</p>\n<p>该获取方式是典型的<code>发布-订阅</code>模式，即Consumer向其关联的Queue注册了监听器，一旦发现有新的消息到来就会触发回调的执行，回调方法是Consumer去Queue中拉取消息。而这些都是基于Consumer与Broker间的长连接的。长连接的维护是需要消耗系统资源的。</p>\n<h4 id=\"对比-1\"><a href=\"#对比-1\" class=\"headerlink\" title=\"对比\"></a>对比</h4><ul>\n<li>pull：需要应用去实现对关联Queue的遍历，实时性差；但便于应用控制消息的拉取</li>\n<li>push：封装了对关联Queue的遍历，实时性强，但会占用较多的系统资源</li>\n</ul>\n<h3 id=\"2-消费模式\"><a href=\"#2-消费模式\" class=\"headerlink\" title=\"2 消费模式\"></a>2 消费模式</h3><h4 id=\"广播消费\"><a href=\"#广播消费\" class=\"headerlink\" title=\"广播消费\"></a>广播消费</h4><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208141005.png\" class title=\"输入图片说明\">\n\n<p>广播消费模式下，相同Consumer Group的每个Consumer实例都接收同一个Topic的全量消息。即每条消息都会被发送到Consumer Group中的每个Consumer。</p>\n<h4 id=\"集群消费\"><a href=\"#集群消费\" class=\"headerlink\" title=\"集群消费\"></a>集群消费</h4><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208141053.png\" class title=\"输入图片说明\">\n\n<p>集群消费模式下，相同Consumer Group的每个Consumer实例<code>平均分摊</code>同一个Topic的消息。即每条消息只会被发送到Consumer Group中的<code>某个</code>Consumer。</p>\n<h4 id=\"消息进度保存\"><a href=\"#消息进度保存\" class=\"headerlink\" title=\"消息进度保存\"></a>消息进度保存</h4><ul>\n<li>广播模式：消费进度保存在consumer端。因为广播模式下consumer group中每个consumer都会消费所有消息，但它们的消费进度是不同。所以consumer各自保存各自的消费进度。</li>\n<li>集群模式：消费进度保存在broker中。consumer group中的所有consumer共同消费同一个Topic中的消息，同一条消息只会被消费一次。消费进度会参与到了消费的负载均衡中，故消费进度是需要共享的。下图是broker中存放的各个Topic的各个Queue的消费进度。</li>\n</ul>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208141202.png\" class title=\"输入图片说明\">\n\n<h3 id=\"3-Rebalance机制\"><a href=\"#3-Rebalance机制\" class=\"headerlink\" title=\"3 Rebalance机制\"></a>3 Rebalance机制</h3><p>Rebalance机制讨论的前提是：集群消费。</p>\n<h4 id=\"什么是Rebalance\"><a href=\"#什么是Rebalance\" class=\"headerlink\" title=\"什么是Rebalance\"></a>什么是Rebalance</h4><p>Rebalance即再均衡，指的是，将一个Topic下的多个Queue在同一个Consumer Group中的多个Consumer间进行重新分配的过程。</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208141304.png\" class title=\"输入图片说明\">\n\n<p>Rebalance机制的本意是为了提升消息的并行消费能力。例如，一个Topic下 5 个队列，在只有 1 个消费者的情况下，这个消费者将负责消费这 5 个队列的消息。如果此时我们增加一个消费者，那么就可以给其中一个消费者分配 2 个队列，给另一个分配 3 个队列，从而提升消息的并行消费能力。</p>\n<h4 id=\"Rebalance限制\"><a href=\"#Rebalance限制\" class=\"headerlink\" title=\"Rebalance限制\"></a>Rebalance限制</h4><p>由于一个队列最多分配给一个消费者，因此当某个消费者组下的消费者实例数量大于队列的数量时，多余的消费者实例将分配不到任何队列。</p>\n<h4 id=\"Rebalance危害\"><a href=\"#Rebalance危害\" class=\"headerlink\" title=\"Rebalance危害\"></a>Rebalance危害</h4><p>Rebalance的在提升消费能力的同时，也带来一些问题：</p>\n<p><code>消费暂停：</code>在只有一个Consumer时，其负责消费所有队列；在新增了一个Consumer后会触发Rebalance的发生。此时原Consumer就需要暂停部分队列的消费，等到这些队列分配给新的Consumer后，这些暂停消费的队列才能继续被消费。</p>\n<p><code>消费重复：</code>Consumer 在消费新分配给自己的队列时，必须接着之前Consumer 提交的消费进度的offset继续消费。然而默认情况下，offset是异步提交的，这个异步性导致提交到Broker的offset与Consumer实际消费的消息并不一致。这个不一致的差值就是可能会重复消费的消息。</p>\n<blockquote>\n<p>同步提交：consumer提交了其消费完毕的一批消息的offset给broker后，需要等待broker的成功ACK。当收到ACK后，consumer才会继续获取并消费下一批消息。在等待ACK期间，consumer是阻塞的。<br><br><br>异步提交：consumer提交了其消费完毕的一批消息的offset给broker后，不需要等待broker的成功ACK。consumer可以直接获取并消费下一批消息。<br><br><br>对于一次性读取消息的数量，需要根据具体业务场景选择一个相对均衡的是很有必要的。因为数量过大，系统性能提升了，但产生重复消费的消息数量可能会增加；数量过小，系统性能会下降，但被重复消费的消息数量可能会减少。</p>\n</blockquote>\n<p><code>消费突刺：</code>由于Rebalance可能导致重复消费，如果需要重复消费的消息过多，或者因为Rebalance暂停时间过长从而导致积压了部分消息。那么有可能会导致在Rebalance结束之后瞬间需要消费很多消息。</p>\n<h4 id=\"Rebalance产生的原因\"><a href=\"#Rebalance产生的原因\" class=\"headerlink\" title=\"Rebalance产生的原因\"></a>Rebalance产生的原因</h4><p>导致Rebalance产生的原因，无非就两个：消费者所订阅Topic的Queue数量发生变化，或消费者组中消费者的数量发生变化。</p>\n<blockquote>\n<p>1 ）Queue数量发生变化的场景：<br><br>Broker扩容或缩容<br><br>Broker升级运维<br><br>Broker与NameServer间的网络异常<br><br>Queue扩容或缩容<br><br>2 ）消费者数量发生变化的场景：<br><br>Consumer Group扩容或缩容<br><br>Consumer升级运维<br><br>Consumer与NameServer间网络异常<br></p>\n</blockquote>\n<h4 id=\"Rebalance过程\"><a href=\"#Rebalance过程\" class=\"headerlink\" title=\"Rebalance过程\"></a>Rebalance过程</h4><p>在Broker中维护着多个Map集合，这些集合中动态存放着当前Topic中Queue的信息、Consumer Group中Consumer实例的信息。一旦发现消费者所订阅的Queue数量发生变化，或消费者组中消费者的数量发生变化，立即向Consumer Group中的每个实例发出Rebalance通知。</p>\n<blockquote>\n<p>TopicConågManager：key是topic名称，value是TopicConåg。TopicConåg中维护着该Topic中所有Queue的数据。<br><br><br>ConsumerManager：key是Consumser Group Id，value是ConsumerGroupInfo。<br><br>ConsumerGroupInfo中维护着该Group中所有Consumer实例数据。<br><br><br>ConsumerOffsetManager：key为<code>Topic与订阅该Topic的Group的组合,即topic@group</code>，value是一个内层Map。内层Map的key为QueueId，内层Map的value为该Queue的消费进度offset。</p>\n</blockquote>\n<p>Consumer实例在接收到通知后会采用Queue分配算法自己获取到相应的Queue，即由Consumer实例自主进行Rebalance。</p>\n<h4 id=\"与Kafka对比\"><a href=\"#与Kafka对比\" class=\"headerlink\" title=\"与Kafka对比\"></a>与Kafka对比</h4><p>在Kafka中，一旦发现出现了Rebalance条件，Broker会调用Group Coordinator来完成Rebalance。Coordinator是Broker中的一个进程。Coordinator会在Consumer Group中选出一个Group Leader。由这个Leader根据自己本身组情况完成Partition分区的再分配。这个再分配结果会上报给Coordinator，并由Coordinator同步给Group中的所有Consumer实例。</p>\n<p>Kafka中的Rebalance是由Consumer Leader完成的。而RocketMQ中的Rebalance是由每个Consumer自身完成的，Group中不存在Leader。</p>\n<h3 id=\"4-Queue分配算法\"><a href=\"#4-Queue分配算法\" class=\"headerlink\" title=\"4 Queue分配算法\"></a>4 Queue分配算法</h3><p>一个Topic中的Queue只能由Consumer Group中的一个Consumer进行消费，而一个Consumer可以同时消费多个Queue中的消息。那么Queue与Consumer间的配对关系是如何确定的，即Queue要分配给哪个Consumer进行消费，也是有算法策略的。常见的有四种策略。这些策略是通过在创建Consumer时的构造器传进去的。</p>\n<h4 id=\"平均分配策略\"><a href=\"#平均分配策略\" class=\"headerlink\" title=\"平均分配策略\"></a>平均分配策略</h4><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208142527.png\" class title=\"输入图片说明\">\n\n<p>该算法是要根据<code>avg = QueueCount / ConsumerCount</code>的计算结果进行分配的。如果能够整除，则按顺序将avg个Queue逐个分配Consumer；如果不能整除，则将多余出的Queue按照Consumer顺序逐个分配。</p>\n<blockquote>\n<p>该算法即，先计算好每个Consumer应该分得几 个Queue，然后再依次将这些数量的Queue逐个分配个Consumer。</p>\n</blockquote>\n<h4 id=\"环形平均策略\"><a href=\"#环形平均策略\" class=\"headerlink\" title=\"环形平均策略\"></a>环形平均策略</h4><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208142630.png\" class title=\"输入图片说明\">\n\n<p>环形平均算法是指，根据消费者的顺序，依次在由queue队列组成的环形图中逐个分配。</p>\n<blockquote>\n<p>该算法不用事先计算每个Consumer需要分配几 个Queue，直接一个一个分即可。</p>\n</blockquote>\n<h4 id=\"一致性hash策略\"><a href=\"#一致性hash策略\" class=\"headerlink\" title=\"一致性hash策略\"></a>一致性hash策略</h4><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208142708.png\" class title=\"输入图片说明\">\n\n<p>该算法会将consumer的hash值作为Node节点存放到hash环上，然后将queue的hash值也放到hash环上，通过顺时针方向，距离queue最近的那个consumer就是该queue要分配的consumer。</p>\n<blockquote>\n<p>该算法存在的问题：分配不均。</p>\n</blockquote>\n<h4 id=\"同机房策略\"><a href=\"#同机房策略\" class=\"headerlink\" title=\"同机房策略\"></a>同机房策略</h4><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208142814.png\" class title=\"输入图片说明\">\n\n<p>该算法会根据queue的部署机房位置和consumer的位置，过滤出当前consumer相同机房的queue。然后按照平均分配策略或环形平均策略对同机房queue进行分配。如果没有同机房queue，则按照平均分配策略或环形平均策略对所有queue进行分配。</p>\n<h4 id=\"对比-2\"><a href=\"#对比-2\" class=\"headerlink\" title=\"对比\"></a>对比</h4><p>一致性hash算法存在的问题：</p>\n<p>两种平均分配策略的分配效率较高，一致性hash策略的较低。因为一致性hash算法较复杂。另外，一致性hash策略分配的结果也很大可能上存在不平均的情况。</p>\n<p>一致性hash算法存在的意义：</p>\n<p>其可以有效减少由于消费者组扩容或缩容所带来的大量的Rebalance。</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208142905.png\" class title=\"输入图片说明\">\n\n<p>一致性hash算法的应用场景：</p>\n<p>Consumer数量变化较频繁的场景。</p>\n<h3 id=\"5-至少一次原则\"><a href=\"#5-至少一次原则\" class=\"headerlink\" title=\"5 至少一次原则\"></a>5 至少一次原则</h3><p>RocketMQ有一个原则：每条消息必须要被<code>成功消费</code>一次。</p>\n<p>那么什么是成功消费呢？Consumer在消费完消息后会向其<code>消费进度记录器</code>提交其消费消息的offset，offset被成功记录到记录器中，那么这条消费就被成功消费了。</p>\n<blockquote>\n<p>什么是消费进度记录器？<br><br>对于广播消费模式来说，Consumer本身就是消费进度记录器。<br><br>对于集群消费模式来说，Broker是消费进度记录器。<br></p>\n</blockquote>\n<h2 id=\"五、订阅关系的一致性\"><a href=\"#五、订阅关系的一致性\" class=\"headerlink\" title=\"五、订阅关系的一致性\"></a>五、订阅关系的一致性</h2><p>订阅关系的一致性指的是，同一个消费者组（Group ID相同）下所有Consumer实例所订阅的Topic与Tag及对消息的处理逻辑必须完全一致。否则，消息消费的逻辑就会混乱，甚至导致消息丢失。</p>\n<h3 id=\"1-正确订阅关系\"><a href=\"#1-正确订阅关系\" class=\"headerlink\" title=\"1 正确订阅关系\"></a>1 正确订阅关系</h3><p>多个消费者组订阅了多个Topic，并且每个消费者组里的多个消费者实例的订阅关系保持了一致。</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208143050.png\" class title=\"输入图片说明\">\n\n<h3 id=\"2-错误订阅关系\"><a href=\"#2-错误订阅关系\" class=\"headerlink\" title=\"2 错误订阅关系\"></a>2 错误订阅关系</h3><p>一个消费者组订阅了多个Topic，但是该消费者组里的多个Consumer实例的订阅关系并没有保持一致。</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208143107.png\" class title=\"输入图片说明\">\n\n<h4 id=\"订阅了不同Topic\"><a href=\"#订阅了不同Topic\" class=\"headerlink\" title=\"订阅了不同Topic\"></a>订阅了不同Topic</h4><p>该例中的错误在于，同一个消费者组中的两个Consumer实例订阅了不同的Topic。</p>\n<p>Consumer实例1-1：（订阅了topic为jodie_test_A，tag为所有的消息）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Properties properties = <span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\">properties.put(PropertyKeyConst.GROUP_ID, <span class=\"string\">&quot;GID_jodie_test_1&quot;</span>);</span><br><span class=\"line\">Consumer consumer = ONSFactory.createConsumer(properties);</span><br><span class=\"line\">consumer.subscribe(<span class=\"string\">&quot;jodie_test_A&quot;</span>, <span class=\"string\">&quot;*&quot;</span>, <span class=\"keyword\">new</span> MessageListener() &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Action <span class=\"title\">consume</span><span class=\"params\">(Message message, ConsumeContext context)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(message.getMsgID());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Action.CommitMessage;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>Consumer实例1-2：（订阅了topic为jodie_test_B，tag为所有的消息）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Properties properties = <span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\">properties.put(PropertyKeyConst.GROUP_ID, <span class=\"string\">&quot;GID_jodie_test_1&quot;</span>);</span><br><span class=\"line\">Consumer consumer = ONSFactory.createConsumer(properties);</span><br><span class=\"line\">consumer.subscribe(<span class=\"string\">&quot;jodie_test_B&quot;</span>, <span class=\"string\">&quot;*&quot;</span>, <span class=\"keyword\">new</span> MessageListener() &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Action <span class=\"title\">consume</span><span class=\"params\">(Message message, ConsumeContext context)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(message.getMsgID());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Action.CommitMessage;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"订阅了不同Tag\"><a href=\"#订阅了不同Tag\" class=\"headerlink\" title=\"订阅了不同Tag\"></a>订阅了不同Tag</h4><p>该例中的错误在于，同一个消费者组中的两个Consumer订阅了相同Topic的不同Tag。</p>\n<p>Consumer实例2-1：（订阅了topic为jodie_test_A，tag为TagA的消息）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Properties properties = <span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\">properties.put(PropertyKeyConst.GROUP_ID, <span class=\"string\">&quot;GID_jodie_test_2&quot;</span>);</span><br><span class=\"line\">Consumer consumer = ONSFactory.createConsumer(properties);</span><br><span class=\"line\">consumer.subscribe(<span class=\"string\">&quot;jodie_test_A&quot;</span>, <span class=\"string\">&quot;TagA&quot;</span>, <span class=\"keyword\">new</span> MessageListener() &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Action <span class=\"title\">consume</span><span class=\"params\">(Message message, ConsumeContext context)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(message.getMsgID());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Action.CommitMessage;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>Consumer实例2-2：（订阅了topic为jodie_test_A，tag为所有的消息）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Properties properties = <span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\">properties.put(PropertyKeyConst.GROUP_ID, <span class=\"string\">&quot;GID_jodie_test_2&quot;</span>);</span><br><span class=\"line\">Consumer consumer = ONSFactory.createConsumer(properties);</span><br><span class=\"line\">consumer.subscribe(<span class=\"string\">&quot;jodie_test_A&quot;</span>, <span class=\"string\">&quot;*&quot;</span>, <span class=\"keyword\">new</span> MessageListener() &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Action <span class=\"title\">consume</span><span class=\"params\">(Message message, ConsumeContext context)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(message.getMsgID());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Action.CommitMessage;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"订阅了不同数量的Topic\"><a href=\"#订阅了不同数量的Topic\" class=\"headerlink\" title=\"订阅了不同数量的Topic\"></a>订阅了不同数量的Topic</h4><p>该例中的错误在于，同一个消费者组中的两个Consumer订阅了不同数量的Topic。</p>\n<p>Consumer实例3-1：（该Consumer订阅了两个Topic）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Properties properties = <span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\">properties.put(PropertyKeyConst.GROUP_ID, <span class=\"string\">&quot;GID_jodie_test_3&quot;</span>);</span><br><span class=\"line\">Consumer consumer = ONSFactory.createConsumer(properties);</span><br><span class=\"line\">consumer.subscribe(<span class=\"string\">&quot;jodie_test_A&quot;</span>, <span class=\"string\">&quot;TagA&quot;</span>, <span class=\"keyword\">new</span> MessageListener() &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Action <span class=\"title\">consume</span><span class=\"params\">(Message message, ConsumeContext context)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(message.getMsgID());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Action.CommitMessage;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">consumer.subscribe(<span class=\"string\">&quot;jodie_test_B&quot;</span>, <span class=\"string\">&quot;TagB&quot;</span>, <span class=\"keyword\">new</span> MessageListener() &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Action <span class=\"title\">consume</span><span class=\"params\">(Message message, ConsumeContext context)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(message.getMsgID());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Action.CommitMessage;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>Consumer实例3-2：（该Consumer订阅了一个Topic）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Properties properties = <span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\">properties.put(PropertyKeyConst.GROUP_ID, <span class=\"string\">&quot;GID_jodie_test_3&quot;</span>);</span><br><span class=\"line\">Consumer consumer = ONSFactory.createConsumer(properties);</span><br><span class=\"line\">consumer.subscribe(<span class=\"string\">&quot;jodie_test_A&quot;</span>, <span class=\"string\">&quot;TagB&quot;</span>, <span class=\"keyword\">new</span> MessageListener() &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Action <span class=\"title\">consume</span><span class=\"params\">(Message message, ConsumeContext context)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(message.getMsgID());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Action.CommitMessage;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"六、offset管理\"><a href=\"#六、offset管理\" class=\"headerlink\" title=\"六、offset管理\"></a>六、offset管理</h2><blockquote>\n<p>这里的offset指的是Consumer的消费进度offset。</p>\n</blockquote>\n<p>消费进度offset是用来记录每个Queue的不同消费组的消费进度的。根据消费进度记录器的不同，可以分为两种模式：本地模式和远程模式。</p>\n<h3 id=\"1-offset本地管理模式\"><a href=\"#1-offset本地管理模式\" class=\"headerlink\" title=\"1 offset本地管理模式\"></a>1 offset本地管理模式</h3><p>当消费模式为<code>广播消费</code>时，offset使用本地模式存储。因为每条消息会被所有的消费者消费，每个消费者管理自己的消费进度，各个消费者之间不存在消费进度的交集。</p>\n<p>Consumer在广播消费模式下offset相关数据以json的形式持久化到Consumer本地磁盘文件中，默认文件路径为当前用户主目录下的<code>.rocketmq_offsets/$&#123;clientId&#125;/$&#123;group&#125;/Offsets.json</code>。其中${clientId}为当前消费者id，默认为ip@DEFAULT；${group}为消费者组名称。</p>\n<h3 id=\"2-offset远程管理模式\"><a href=\"#2-offset远程管理模式\" class=\"headerlink\" title=\"2 offset远程管理模式\"></a>2 offset远程管理模式</h3><p>当消费模式为<code>集群消费</code>时，offset使用远程模式管理。因为所有Cosnumer实例对消息采用的是均衡消费，所有Consumer共享Queue的消费进度。</p>\n<p>Consumer在集群消费模式下offset相关数据以json的形式持久化到Broker磁盘文件中，文件路径为当前用户主目录下的<code>store/config/consumerOffset.json</code>。</p>\n<p>Broker启动时会加载这个文件，并写入到一个双层Map（ConsumerOffsetManager）。外层map的key为topic@group，value为内层map。内层map的key为queueId，value为offset。当发生Rebalance时，新的Consumer会从该Map中获取到相应的数据来继续消费。</p>\n<p>集群模式下offset采用远程管理模式，主要是为了保证Rebalance机制。</p>\n<h3 id=\"3-offset用途\"><a href=\"#3-offset用途\" class=\"headerlink\" title=\"3 offset用途\"></a>3 offset用途</h3><p>消费者是如何从最开始持续消费消息的？消费者要消费的第一条消息的起始位置是用户自己通过consumer.setConsumeFromWhere()方法指定的。</p>\n<p>在Consumer启动后，其要消费的第一条消息的起始位置常用的有三种，这三种位置可以通过枚举类型常量设置。这个枚举类型为ConsumeFromWhere。</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208143837.png\" class title=\"输入图片说明\">\n\n<blockquote>\n<p>CONSUME_FROM_LAST_OFFSET：从queue的当前最后一条消息开始消费<br><br>CONSUME_FROM_FIRST_OFFSET：从queue的第一条消息开始消费<br><br>CONSUME_FROM_TIMESTAMP：从指定的具 体时间戳位置的消息开始消费。这个具体时间戳是通过另外一个语句指定的 。<br><br>consumer.setConsumeTimestamp(“20210701080000”) yyyyMMddHHmmss</p>\n</blockquote>\n<p>当消费完一批消息后，Consumer会提交其消费进度offset给Broker，Broker在收到消费进度后会将其更新到那个双层Map（ConsumerOffsetManager）及consumerOffset.json文件中，然后向该Consumer进行ACK，而ACK内容中包含三项数据：当前消费队列的最小offset（minOffset）、最大offset（maxOffset）、及下次消费的起始offset（nextBeginOffset）。</p>\n<h3 id=\"4-重试队列\"><a href=\"#4-重试队列\" class=\"headerlink\" title=\"4 重试队列\"></a>4 重试队列</h3><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208143940.png\" class title=\"输入图片说明\">\n\n<p>当rocketMQ对消息的消费出现异常时，会将发生异常的消息的offset提交到Broker中的重试队列。系统在发生消息消费异常时会为当前的topic@group创建一个重试队列，该队列以%RETRY%开头，到达重试时间后进行消费重试。</p>\n<h3 id=\"5-offset的同步提交与异步提交\"><a href=\"#5-offset的同步提交与异步提交\" class=\"headerlink\" title=\"5 offset的同步提交与异步提交\"></a>5 offset的同步提交与异步提交</h3><p>集群消费模式下，Consumer消费完消息后会向Broker提交消费进度offset，其提交方式分为两种：</p>\n<p><code>同步提交</code>：消费者在消费完一批消息后会向broker提交这些消息的offset，然后等待broker的成功响应。若在等待超时之前收到了成功响应，则继续读取下一批消息进行消费（从ACK中获取nextBeginOffset）。若没有收到响应，则会重新提交，直到获取到响应。而在这个等待过程中，消费者是阻塞的。其严重影响了消费者的吞吐量。</p>\n<p><code>异步提交</code>：消费者在消费完一批消息后向broker提交offset，但无需等待Broker的成功响应，可以继续读取并消费下一批消息。这种方式增加了消费者的吞吐量。但需要注意，broker在收到提交的offset后，还是会向消费者进行响应的。可能还没有收到ACK，此时Consumer会从Broker中直接获取nextBeginOffset。</p>\n<h2 id=\"七、消费幂等\"><a href=\"#七、消费幂等\" class=\"headerlink\" title=\"七、消费幂等\"></a>七、消费幂等</h2><h3 id=\"1-什么是消费幂等\"><a href=\"#1-什么是消费幂等\" class=\"headerlink\" title=\"1 什么是消费幂等\"></a>1 什么是消费幂等</h3><p>当出现消费者对某条消息重复消费的情况时，重复消费的结果与消费一次的结果是相同的，并且多次消费并未对业务系统产生任何负面影响，那么这个消费过程就是消费幂等的。</p>\n<blockquote>\n<p>幂等：若某操作执行多次与执行一次对系统产生的影响是相同的，则称该操作是幂等的。</p>\n</blockquote>\n<p>在互联网应用中，尤其在网络不稳定的情况下，消息很有可能会出现重复发送或重复消费。如果重复的消息可能会影响业务处理，那么就应该对消息做幂等处理。</p>\n<h3 id=\"2-消息重复的场景分析\"><a href=\"#2-消息重复的场景分析\" class=\"headerlink\" title=\"2 消息重复的场景分析\"></a>2 消息重复的场景分析</h3><p>什么情况下可能会出现消息被重复消费呢？最常见的有以下三种情况：</p>\n<h4 id=\"发送时消息重复\"><a href=\"#发送时消息重复\" class=\"headerlink\" title=\"发送时消息重复\"></a>发送时消息重复</h4><p>当一条消息已被成功发送到Broker并完成持久化，此时出现了网络闪断，从而导致Broker对Producer应答失败。 如果此时Producer意识到消息发送失败并尝试再次发送消息，此时Broker中就可能会出现两条内容相同并且Message ID也相同的消息，那么后续Consumer就一定会消费两次该消息。</p>\n<h4 id=\"消费时消息重复\"><a href=\"#消费时消息重复\" class=\"headerlink\" title=\"消费时消息重复\"></a>消费时消息重复</h4><p>消息已投递到Consumer并完成业务处理，当Consumer给Broker反馈应答时网络闪断，Broker没有接收到消费成功响应。为了保证消息<code>至少被消费一次</code>的原则，Broker将在网络恢复后再次尝试投递之前已被处理过的消息。此时消费者就会收到与之前处理过的内容相同、Message ID也相同的消息。</p>\n<h4 id=\"Rebalance时消息重复\"><a href=\"#Rebalance时消息重复\" class=\"headerlink\" title=\"Rebalance时消息重复\"></a>Rebalance时消息重复</h4><p>当Consumer Group中的Consumer数量发生变化时，或其订阅的Topic的Queue数量发生变化时，会触发Rebalance，此时Consumer可能会收到曾经被消费过的消息。</p>\n<h3 id=\"3-通用解决方案\"><a href=\"#3-通用解决方案\" class=\"headerlink\" title=\"3 通用解决方案\"></a>3 通用解决方案</h3><h4 id=\"两要素\"><a href=\"#两要素\" class=\"headerlink\" title=\"两要素\"></a>两要素</h4><p>幂等解决方案的设计中涉及到两项要素：幂等令牌，与唯一性处理。只要充分利用好这两要素，就可以设计出好的幂等解决方案。</p>\n<ul>\n<li>幂等令牌：是生产者和消费者两者中的既定协议，通常指具备唯一业务标识的字符串。例如，订单号、流水号。一般由Producer随着消息一同发送来的。</li>\n<li>唯一性处理：服务端通过采用一定的算法策略，保证同一个业务逻辑不会被重复执行成功多次。例如，对同一笔订单的多次支付操作，只会成功一次。</li>\n</ul>\n<h4 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><p>对于常见的系统，幂等性操作的通用性解决方案是：</p>\n<ul>\n<li><ol>\n<li>首先通过缓存去重。在缓存中如果已经存在了某幂等令牌，则说明本次操作是重复性操作；若缓存没有命中，则进入下一步。</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>在唯一性处理之前，先在数据库中查询幂等令牌作为索引的数据是否存在。若存在，则说明本次操作为重复性操作；若不存在，则进入下一步。</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>在同一事务中完成三项操作：唯一性处理后，将幂等令牌写入到缓存，并将幂等令牌作为唯一索引的数据写入到DB中。</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p>第 1 步已经判断过是否是重复性操作了，为什么第 2 步还要再次判断？能够进入第 2 步，说明已经不是重复操作了，第 2 次判断是否重复？<br><br><br>当然不重复。一般缓存中的数据是具有有效期的。缓存中数据的有效期一旦过期，就是发生缓存穿透，使请求直接就到达了DBMS。</p>\n</blockquote>\n<h4 id=\"解决方案举例\"><a href=\"#解决方案举例\" class=\"headerlink\" title=\"解决方案举例\"></a>解决方案举例</h4><h4 id=\"以支付场景为例：\"><a href=\"#以支付场景为例：\" class=\"headerlink\" title=\"以支付场景为例：\"></a>以支付场景为例：</h4><ul>\n<li><ol>\n<li>当支付请求到达后，首先在Redis缓存中却获取key为支付流水号的缓存value。若value不空，则说明本次支付是重复操作，业务系统直接返回调用侧重复支付标识；若value为空，则进入下一步操作</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>到DBMS中根据支付流水号查询是否存在相应实例。若存在，则说明本次支付是重复操作，业务系统直接返回调用侧重复支付标识；若不存在，则说明本次操作是首次操作，进入下一步完成唯一性处理</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>在分布式事务中完成三项操作：</li>\n</ol>\n<ul>\n<li>完成支付任务</li>\n<li>将当前支付流水号作为key，任意字符串作为value，通过set(key, value, expireTime)将数据写入到Redis缓存</li>\n<li>将当前支付流水号作为主键，与其它相关数据共同写入到DBMS</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-消费幂等的实现\"><a href=\"#4-消费幂等的实现\" class=\"headerlink\" title=\"4 消费幂等的实现\"></a>4 消费幂等的实现</h3><p>消费幂等的解决方案很简单：为消息指定不会重复的唯一标识。因为Message ID有可能出现重复的情况，所以真正安全的幂等处理，不建议以Message ID作为处理依据。最好的方式是以业务唯一标识作为幂等处理的关键依据，而业务的唯一标识可以通过消息Key设置。</p>\n<p>以支付场景为例，可以将消息的Key设置为订单号，作为幂等处理的依据。具体代码示例如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Message message = <span class=\"keyword\">new</span> Message();</span><br><span class=\"line\">message.setKey(<span class=\"string\">&quot;ORDERID_100&quot;</span>);</span><br><span class=\"line\">SendResult sendResult = producer.send(message);</span><br></pre></td></tr></table></figure>\n\n<p>消费者收到消息时可以根据消息的Key即订单号来实现消费幂等：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">consumer.registerMessageListener(<span class=\"keyword\">new</span> MessageListenerConcurrently() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ConsumeConcurrentlyStatus <span class=\"title\">consumeMessage</span><span class=\"params\">(List&lt;MessageExt&gt;msgs,ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(MessageExt msg:msgs)&#123;</span><br><span class=\"line\">            String key = msg.getKeys();</span><br><span class=\"line\">            <span class=\"comment\">// 根据业务唯一标识Key做幂等处理</span></span><br><span class=\"line\">            <span class=\"comment\">// ......</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>RocketMQ能够保证消息不丢失，但不能保证消息不重复。</p>\n</blockquote>\n<h2 id=\"八、消息堆积与消费延迟\"><a href=\"#八、消息堆积与消费延迟\" class=\"headerlink\" title=\"八、消息堆积与消费延迟\"></a>八、消息堆积与消费延迟</h2><h3 id=\"1-概念\"><a href=\"#1-概念\" class=\"headerlink\" title=\"1 概念\"></a>1 概念</h3><p>消息处理流程中，如果Consumer的消费速度跟不上Producer的发送速度，MQ中未处理的消息会越来越多（进的多出的少），这部分消息就被称为<code>堆积消息</code>。消息出现堆积进而会造成消息的<code>消费延迟</code>。<br><br>以下场景需要重点关注消息堆积和消费延迟问题：</p>\n<ul>\n<li>业务系统上下游能力不匹配造成的持续堆积，且无法自行恢复。</li>\n<li>业务系统对消息的消费实时性要求较高，即使是短暂的堆积造成的消费延迟也无法接受。</li>\n</ul>\n<h3 id=\"2-产生原因分析\"><a href=\"#2-产生原因分析\" class=\"headerlink\" title=\"2 产生原因分析\"></a>2 产生原因分析</h3><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208144842.png\" class title=\"输入图片说明\">\n\n<p>Consumer使用长轮询Pull模式消费消息时，分为以下两个阶段：</p>\n<h4 id=\"消息拉取-1\"><a href=\"#消息拉取-1\" class=\"headerlink\" title=\"消息拉取\"></a>消息拉取</h4><p>Consumer通过长轮询Pull模式批量拉取的方式从服务端获取消息，将拉取到的消息缓存到本地缓冲队列中。对于拉取式消费，在内网环境下会有很高的吞吐量，所以这一阶段一般不会成为消息堆积的瓶颈。</p>\n<blockquote>\n<p>一个单线程单分区的低规格主机(Consumer，4C8G)，其可达到几万的TPS。如果是多个分区多个线程，则可以轻松达到几十万的TPS。</p>\n</blockquote>\n<h4 id=\"消息消费\"><a href=\"#消息消费\" class=\"headerlink\" title=\"消息消费\"></a>消息消费</h4><p>Consumer将本地缓存的消息提交到消费线程中，使用业务消费逻辑对消息进行处理，处理完毕后获取到一个结果。这是真正的消息消费过程。此时Consumer的消费能力就完全依赖于消息的<code>消费耗时</code>和<code>消费并发度</code>了。如果由于业务处理逻辑复杂等原因，导致处理单条消息的耗时较长，则整体的消息吞吐量肯定不会高，此时就会导致Consumer本地缓冲队列达到上限，停止从服务端拉取消息。</p>\n<h4 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h4><p>消息堆积的主要瓶颈在于客户端的消费能力，而消费能力由<code>消费耗时</code>和<code>消费并发度</code>决定。注意，消费耗时的优先级要高于消费并发度。即在保证了消费耗时的合理性前提下，再考虑消费并发度问题。</p>\n<h3 id=\"3-消费耗时\"><a href=\"#3-消费耗时\" class=\"headerlink\" title=\"3 消费耗时\"></a>3 消费耗时</h3><p>影响消息处理时长的主要因素是代码逻辑。而代码逻辑中可能会影响处理时长代码主要有两种类型：<code>CPU内部计算型代码</code>和<code>外部I/O操作型代码</code>。</p>\n<p>通常情况下代码中如果没有复杂的递归和循环的话，内部计算耗时相对外部I/O操作来说几乎可以忽略。所以外部IO型代码是影响消息处理时长的主要症结所在。</p>\n<blockquote>\n<p>外部IO操作型代码举例：<br><br><br>1)读写外部数据库，例如对远程MySQL的访问<br><br>2)读写外部缓存系统，例如对远程Redis的访问<br><br>3)下游系统调用，例如Dubbo的RPC远程调用，Spring Cloud的对下游系统的Http接口调用<br><br><br>关于下游系统调用逻辑需要进行提前梳理，掌握每个调用操作预期的耗时，这样做是为了能够判断消费逻辑中IO操作的耗时是否合理。通常消息堆积是由于下游系统出现了<code>服务异常</code>或<code>达到了DBMS容量限制</code>，导致消费耗时增加。<br><br><br>服务异常，并不仅仅是系统中出现的类似 500 这样的代码错误，而可能是更加隐蔽的问题。例如，网络带宽问题。<br><br><br>达到了DBMS容量限制，其也会引发消息的消费耗时增加。</p>\n</blockquote>\n<h3 id=\"4-消费并发度\"><a href=\"#4-消费并发度\" class=\"headerlink\" title=\"4 消费并发度\"></a>4 消费并发度</h3><p>一般情况下，消费者端的消费并发度由单节点线程数和节点数量共同决定，其值为单节点线程数*节点数量。不过，通常需要优先调整单节点的线程数，若单机硬件资源达到了上限，则需要通过横向扩展来提高消费并发度。</p>\n<blockquote>\n<p>单节点线程数，即单个Consumer所包含的线程数量<br><br><br>节点数量，即Consumer Group所包含的Consumer数量<br><br><br>对于普通消息、延时消息及事务消息，并发度计算都是单节点线程数*节点数量。但对于顺序消息则是不同的。顺序消息的消费并发度等于Topic的Queue分区数量。<br><br><br>1 ）全局顺序消息：该类型消息的Topic只有一个Queue分区。其可以保证该Topic的所有消息被顺序消费。为了保证这个全局顺序性，Consumer Group中在同一时刻只能有一个Consumer的一个线程进行消费。所以其并发度为 1 。<br><br><br>2 ）分区顺序消息：该类型消息的Topic有多个Queue分区。其仅可以保证该Topic的每个Queue分区中的消息被顺序消费，不能保证整个Topic中消息的顺序消费。为了保证这个分区顺序性，每个Queue分区中的消息在Consumer Group中的同一时刻只能有一个Consumer的一个线程进行消费。即，在同一时刻最多会出现多个Queue分蘖有多个Consumer的多个线程并行消费。所以其并发度为Topic的分区数量。</p>\n</blockquote>\n<h3 id=\"5-单机线程数计算\"><a href=\"#5-单机线程数计算\" class=\"headerlink\" title=\"5 单机线程数计算\"></a>5 单机线程数计算</h3><p>对于一台主机中线程池中线程数的设置需要谨慎，不能盲目直接调大线程数，设置过大的线程数反而会带来大量的线程切换的开销。理想环境下单节点的最优线程数计算模型为：C *（T1 + T2）/ T1。</p>\n<ul>\n<li>C：CPU内核数</li>\n<li>T1：CPU内部逻辑计算耗时</li>\n<li>T2：外部IO操作耗时</li>\n</ul>\n<blockquote>\n<p>最优线程数 = C *（T1 + T2）/ T1 = C * T1/T1 + C * T2/T1 = C + C * T2/T1</p>\n</blockquote>\n<blockquote>\n<p>注意，该计算出的数值是理想状态下的理论数据，在生产环境中，不建议直接使用。而是根据当前环境，先设置一个比该值小的数值然后观察其压测效果，然后再根据效果逐步调大线程数，直至找到在该环境中性能最佳时的值。</p>\n</blockquote>\n<h3 id=\"6-如何避免\"><a href=\"#6-如何避免\" class=\"headerlink\" title=\"6 如何避免\"></a>6 如何避免</h3><p>为了避免在业务使用时出现非预期的消息堆积和消费延迟问题，需要在前期设计阶段对整个业务逻辑进行完善的排查和梳理。其中最重要的就是<code>梳理消息的消费耗时</code>和<code>设置消息消费的并发度</code>。</p>\n<h4 id=\"梳理消息的消费耗时\"><a href=\"#梳理消息的消费耗时\" class=\"headerlink\" title=\"梳理消息的消费耗时\"></a>梳理消息的消费耗时</h4><p>通过压测获取消息的消费耗时，并对耗时较高的操作的代码逻辑进行分析。梳理消息的消费耗时需要关注以下信息：</p>\n<ul>\n<li>消息消费逻辑的计算复杂度是否过高，代码是否存在无限循环和递归等缺陷。</li>\n<li>消息消费逻辑中的I/O操作是否是必须的，能否用本地缓存等方案规避。</li>\n<li>消费逻辑中的复杂耗时的操作是否可以做异步化处理。如果可以，是否会造成逻辑错乱。</li>\n</ul>\n<h4 id=\"设置消费并发度\"><a href=\"#设置消费并发度\" class=\"headerlink\" title=\"设置消费并发度\"></a>设置消费并发度</h4><p>对于消息消费并发度的计算，可以通过以下两步实施：</p>\n<ul>\n<li>逐步调大单个Consumer节点的线程数，并观测节点的系统指标，得到单个节点最优的消费线程数和消息吞吐量。</li>\n<li>根据上下游链路的流量峰值计算出需要设置的节点数</li>\n</ul>\n<blockquote>\n<p>节点数 = 流量峰值 / 单个节点消息吞吐量</p>\n</blockquote>\n<h2 id=\"九、消息的清理\"><a href=\"#九、消息的清理\" class=\"headerlink\" title=\"九、消息的清理\"></a>九、消息的清理</h2><p>消息被消费过后会被清理掉吗？不会的。</p>\n<p>消息是被顺序存储在commitlog文件的，且消息大小不定长，所以消息的清理是不可能以消息为单位进行清理的，而是以commitlog文件为单位进行清理的。否则会急剧下降清理效率，并实现逻辑复杂。</p>\n<p>commitlog文件存在一个过期时间，默认为 72 小时，即三天。除了用户手动清理外，在以下情况下也会被自动清理，无论文件中的消息是否被消费过：</p>\n<ul>\n<li>文件过期，且到达清理时间点（默认为凌晨 4 点）后，自动清理过期文件</li>\n<li>文件过期，且磁盘空间占用率已达过期清理警戒线（默认75%）后，无论是否达到清理时间点，都会自动清理过期文件</li>\n<li>磁盘占用率达到清理警戒线（默认85%）后，开始按照设定好的规则清理文件，无论是否过期。默认会从最老的文件开始清理</li>\n<li>磁盘占用率达到系统危险警戒线（默认90%）后，Broker将拒绝消息写入</li>\n</ul>\n<blockquote>\n<p>需要注意以下几点：<br><br>1 ）对于RocketMQ系统来说，删除一个1G大小的文件，是一个压力巨大的IO操作。在删除过程中，系统性能会骤然下降。所以，其默认清理时间点为凌晨 4 点，访问量最小的时间。也正因如果，我们要保障磁盘空间的空闲率，不要使系统出现在其它时间点删除commitlog文件的情况。<br><br>2 ）官方建议RocketMQ服务的Linux文件系统采用ext4。因为对于文件删除操作，ext4要比ext3性能更好</p>\n</blockquote>\n<h1 id=\"第-4-章-RocketMQ应用\"><a href=\"#第-4-章-RocketMQ应用\" class=\"headerlink\" title=\"第 4 章 RocketMQ应用\"></a>第 4 章 RocketMQ应用</h1><h2 id=\"一、普通消息\"><a href=\"#一、普通消息\" class=\"headerlink\" title=\"一、普通消息\"></a>一、普通消息</h2><h3 id=\"1-消息发送分类\"><a href=\"#1-消息发送分类\" class=\"headerlink\" title=\"1 消息发送分类\"></a>1 消息发送分类</h3><p>Producer对于消息的发送方式也有多种选择，不同的方式会产生不同的系统效果。</p>\n<h4 id=\"同步发送消息\"><a href=\"#同步发送消息\" class=\"headerlink\" title=\"同步发送消息\"></a>同步发送消息</h4><p>同步发送消息是指，Producer发出一条消息后，会在收到MQ返回的ACK之后才发下一条消息。该方式的消息可靠性最高，但消息发送效率太低。</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208145933.png\" class title=\"输入图片说明\">\n\n<h4 id=\"异步发送消息\"><a href=\"#异步发送消息\" class=\"headerlink\" title=\"异步发送消息\"></a>异步发送消息</h4><p>异步发送消息是指，Producer发出消息后无需等待MQ返回ACK，直接发送下一条消息。该方式的消息可靠性可以得到保障，消息发送效率也可以。</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208150004.png\" class title=\"输入图片说明\">\n\n<h4 id=\"单向发送消息\"><a href=\"#单向发送消息\" class=\"headerlink\" title=\"单向发送消息\"></a>单向发送消息</h4><p>单向发送消息是指，Producer仅负责发送消息，不等待、不处理MQ的ACK。该发送方式时MQ也不返回ACK。该方式的消息发送效率最高，但消息可靠性较差。</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208150023.png\" class title=\"输入图片说明\">\n\n<h3 id=\"2-代码举例\"><a href=\"#2-代码举例\" class=\"headerlink\" title=\"2 代码举例\"></a>2 代码举例</h3><h4 id=\"创建工程\"><a href=\"#创建工程\" class=\"headerlink\" title=\"创建工程\"></a>创建工程</h4><p>创建一个Maven的Java工程rocketmq-test。</p>\n<p>导入rocketmq的client依赖。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">project.build.sourceEncoding</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">maven.compiler.source</span>&gt;</span>1.8<span class=\"tag\">&lt;/<span class=\"name\">maven.compiler.source</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">maven.compiler.target</span>&gt;</span>1.8<span class=\"tag\">&lt;/<span class=\"name\">maven.compiler.target</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.rocketmq<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>rocketmq-client<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.8.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"定义同步消息发送生产者\"><a href=\"#定义同步消息发送生产者\" class=\"headerlink\" title=\"定义同步消息发送生产者\"></a>定义同步消息发送生产者</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SyncProducer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建一个producer，参数为Producer Group名称</span></span><br><span class=\"line\">        DefaultMQProducer producer = <span class=\"keyword\">new</span> DefaultMQProducer(<span class=\"string\">&quot;pg&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 指定nameServer地址</span></span><br><span class=\"line\">        producer.setNamesrvAddr(<span class=\"string\">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 设置当发送失败时重试发送的次数，默认为 2 次</span></span><br><span class=\"line\">        producer.setRetryTimesWhenSendFailed( <span class=\"number\">3</span> );</span><br><span class=\"line\">        <span class=\"comment\">// 设置发送超时时限为5s，默认3s</span></span><br><span class=\"line\">        producer.setSendMsgTimeout( <span class=\"number\">5000</span> );</span><br><span class=\"line\">        <span class=\"comment\">// 开启生产者</span></span><br><span class=\"line\">        producer.start();</span><br><span class=\"line\">        <span class=\"comment\">// 生产并发送 100 条消息</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">100</span> ; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] body = (<span class=\"string\">&quot;Hi,&quot;</span> + i).getBytes();</span><br><span class=\"line\">            Message msg = <span class=\"keyword\">new</span> Message(<span class=\"string\">&quot;someTopic&quot;</span>, <span class=\"string\">&quot;someTag&quot;</span>, body);</span><br><span class=\"line\">            <span class=\"comment\">// 为消息指定key</span></span><br><span class=\"line\">            msg.setKeys(<span class=\"string\">&quot;key-&quot;</span> + i);</span><br><span class=\"line\">            <span class=\"comment\">// 发送消息</span></span><br><span class=\"line\">            SendResult sendResult = producer.send(msg);</span><br><span class=\"line\">            System.out.println(sendResult);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 关闭producer</span></span><br><span class=\"line\">        producer.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 消息发送的状态</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">SendStatus</span> </span>&#123;</span><br><span class=\"line\">    SEND_OK, <span class=\"comment\">// 发送成功</span></span><br><span class=\"line\">    FLUSH_DISK_TIMEOUT,  <span class=\"comment\">// 刷盘超时。当Broker设置的刷盘策略为同步刷盘时才可能出现这种异常状态。异步刷盘不会出现</span></span><br><span class=\"line\">    FLUSH_SLAVE_TIMEOUT, <span class=\"comment\">// Slave同步超时。当Broker集群设置的Master-Slave的复制方式为同步复制时才可能出现这种异常状态。异步复制不会出现</span></span><br><span class=\"line\">    SLAVE_NOT_AVAILABLE, <span class=\"comment\">// 没有可用的Slave。当Broker集群设置为Master-Slave的复制方式为同步复制时才可能出现这种异常状态。异步复制不会出现</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"定义异步消息发送生产者\"><a href=\"#定义异步消息发送生产者\" class=\"headerlink\" title=\"定义异步消息发送生产者\"></a>定义异步消息发送生产者</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AsyncProducer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        DefaultMQProducer producer = <span class=\"keyword\">new</span> DefaultMQProducer(<span class=\"string\">&quot;pg&quot;</span>);</span><br><span class=\"line\">        producer.setNamesrvAddr(<span class=\"string\">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 指定异步发送失败后不进行重试发送</span></span><br><span class=\"line\">        producer.setRetryTimesWhenSendAsyncFailed( <span class=\"number\">0</span> );</span><br><span class=\"line\">        <span class=\"comment\">// 指定新创建的Topic的Queue数量为 2 ，默认为 4</span></span><br><span class=\"line\">        producer.setDefaultTopicQueueNums( <span class=\"number\">2</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">        producer.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">100</span> ; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] body = (<span class=\"string\">&quot;Hi,&quot;</span> + i).getBytes();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Message msg = <span class=\"keyword\">new</span> Message(<span class=\"string\">&quot;myTopicA&quot;</span>, <span class=\"string\">&quot;myTag&quot;</span>, body);</span><br><span class=\"line\">            <span class=\"comment\">// 异步发送。指定回调</span></span><br><span class=\"line\">            producer.send(msg, <span class=\"keyword\">new</span> SendCallback() &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 当producer接收到MQ发送来的ACK后就会触发该回调方法的执行</span></span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSuccess</span><span class=\"params\">(SendResult sendResult)</span> </span>&#123;</span><br><span class=\"line\">                    System.out.println(sendResult);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onException</span><span class=\"params\">(Throwable e)</span> </span>&#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"comment\">// end-for</span></span><br><span class=\"line\">        <span class=\"comment\">// sleep一会儿</span></span><br><span class=\"line\">        <span class=\"comment\">// 由于采用的是异步发送，所以若这里不sleep，</span></span><br><span class=\"line\">        <span class=\"comment\">// 则消息还未发送就会将producer给关闭，报错</span></span><br><span class=\"line\">        TimeUnit.SECONDS.sleep( <span class=\"number\">3</span> );</span><br><span class=\"line\">        producer.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"定义单向消息发送生产者\"><a href=\"#定义单向消息发送生产者\" class=\"headerlink\" title=\"定义单向消息发送生产者\"></a>定义单向消息发送生产者</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OnewayProducer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">        DefaultMQProducer producer = <span class=\"keyword\">new</span> DefaultMQProducer(<span class=\"string\">&quot;pg&quot;</span>);</span><br><span class=\"line\">        producer.setNamesrvAddr(<span class=\"string\">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class=\"line\">        producer.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">10</span> ; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] body = (<span class=\"string\">&quot;Hi,&quot;</span> + i).getBytes();</span><br><span class=\"line\">            Message msg = <span class=\"keyword\">new</span> Message(<span class=\"string\">&quot;single&quot;</span>, <span class=\"string\">&quot;someTag&quot;</span>, body);</span><br><span class=\"line\">            <span class=\"comment\">// 单向发送</span></span><br><span class=\"line\">            producer.sendOneway(msg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        producer.shutdown();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;producer shutdown&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"定义消息消费者\"><a href=\"#定义消息消费者\" class=\"headerlink\" title=\"定义消息消费者\"></a>定义消息消费者</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeConsumer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> MQClientException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 定义一个pull消费者</span></span><br><span class=\"line\">        <span class=\"comment\">// DefaultLitePullConsumer consumer = new</span></span><br><span class=\"line\">        DefaultLitePullConsumer(<span class=\"string\">&quot;cg&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 定义一个push消费者</span></span><br><span class=\"line\">        DefaultMQPushConsumer consumer = <span class=\"keyword\">new</span> DefaultMQPushConsumer(<span class=\"string\">&quot;cg&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 指定nameServer</span></span><br><span class=\"line\">        consumer.setNamesrvAddr(<span class=\"string\">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 指定从第一条消息开始消费</span></span><br><span class=\"line\">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class=\"line\">        <span class=\"comment\">// 指定消费topic与tag</span></span><br><span class=\"line\">        consumer.subscribe(<span class=\"string\">&quot;someTopic&quot;</span>, <span class=\"string\">&quot;*&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 指定采用“广播模式”进行消费，默认为“集群模式”</span></span><br><span class=\"line\">        <span class=\"comment\">// consumer.setMessageModel(MessageModel.BROADCASTING);</span></span><br><span class=\"line\">        <span class=\"comment\">// 注册消息监听器</span></span><br><span class=\"line\">        consumer.registerMessageListener(<span class=\"keyword\">new</span> MessageListenerConcurrently() &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 一旦broker中有了其订阅的消息就会触发该方法的执行，</span></span><br><span class=\"line\">            <span class=\"comment\">// 其返回值为当前consumer消费的状态</span></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> ConsumeConcurrentlyStatus <span class=\"title\">consumeMessage</span><span class=\"params\">(List&lt;MessageExt&gt; msgs,ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 逐条消费消息</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (MessageExt msg : msgs) &#123;</span><br><span class=\"line\">                    System.out.println(msg);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 返回消费状态：消费成功</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"comment\">// 开启消费者消费</span></span><br><span class=\"line\">        consumer.start();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Consumer Started&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二、顺序消息\"><a href=\"#二、顺序消息\" class=\"headerlink\" title=\"二、顺序消息\"></a>二、顺序消息</h2><h3 id=\"1-什么是顺序消息\"><a href=\"#1-什么是顺序消息\" class=\"headerlink\" title=\"1 什么是顺序消息\"></a>1 什么是顺序消息</h3><p>顺序消息指的是，严格按照消息的<code>发送顺序</code>进行<code>消费</code>的消息(FIFO)。</p>\n<p>默认情况下生产者会把消息以Round Robin轮询方式发送到不同的Queue分区队列；而消费消息时会从多个Queue上拉取消息，这种情况下的发送和消费是不能保证顺序的。如果将消息仅发送到同一个Queue中，消费时也只从这个Queue上拉取消息，就严格保证了消息的顺序性。</p>\n<h3 id=\"2-为什么需要顺序消息\"><a href=\"#2-为什么需要顺序消息\" class=\"headerlink\" title=\"2 为什么需要顺序消息\"></a>2 为什么需要顺序消息</h3><p>例如，现在有TOPIC <code>ORDER_STATUS</code>(订单状态)，其下有 4 个Queue队列，该Topic中的不同消息用于描述当前订单的不同状态。假设订单有状态：未支付、已支付、发货中、发货成功、发货失败。</p>\n<p>根据以上订单状态，生产者从时序上可以生成如下几个消息：</p>\n<p>`订单T0000001:未支付 –&gt; 订单T0000001:已支付 –&gt; 订单T0000001:发货中 –&gt; 订单T0000001:发货失败</p>\n<p>消息发送到MQ中之后，Queue的选择如果采用轮询策略，消息在MQ的存储可能如下：</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208152040.png\" class title=\"输入图片说明\">\n\n<p>这种情况下，我们希望Consumer消费消息的顺序和我们发送是一致的，然而上述MQ的投递和消费方式，我们无法保证顺序是正确的。对于顺序异常的消息，Consumer即使设置有一定的状态容错，也不能完全处理好这么多种随机出现组合情况。</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208152144.png\" class title=\"输入图片说明\">\n\n<p>基于上述的情况，可以设计如下方案：对于相同订单号的消息，通过一定的策略，将其放置在一个Queue中，然后消费者再采用一定的策略（例如，一个线程独立处理一个queue，保证处理消息的顺序性），能够保证消费的顺序性。</p>\n<h3 id=\"3-有序性分类\"><a href=\"#3-有序性分类\" class=\"headerlink\" title=\"3 有序性分类\"></a>3 有序性分类</h3><p>根据有序范围的不同，RocketMQ可以严格地保证两种消息的有序性：分区有序与全局有序。</p>\n<h4 id=\"全局有序\"><a href=\"#全局有序\" class=\"headerlink\" title=\"全局有序\"></a>全局有序</h4><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208152224.png\" class title=\"输入图片说明\">\n\n<p>当发送和消费参与的Queue只有一个时所保证的有序是整个Topic中消息的顺序， 称为<code>全局有序</code>。</p>\n<blockquote>\n<p>在创建Topic时指定Queue的数量。有三种指定方式：<br><br><br>1 ）在代码中创建Producer时，可以指定其自动创建的Topic的Queue数量<br><br><br>2 ）在RocketMQ可视化控制台中手动创建Topic时指定Queue数量<br><br><br>3 ）使用mqadmin命令手动创建Topic时指定Queue数量<br></p>\n</blockquote>\n<h4 id=\"分区有序\"><a href=\"#分区有序\" class=\"headerlink\" title=\"分区有序\"></a>分区有序</h4><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208152417.png\" class title=\"输入图片说明\">\n\n<p>如果有多个Queue参与，其仅可保证在该Queue分区队列上的消息顺序，则称为<code>分区有序</code>。</p>\n<blockquote>\n<p>如何实现Queue的选择？在定义Producer时我们可以指定消息队列选择器，而这个选择器是我们自己实现了MessageQueueSelector接口定义的。<br><br><br>在定义选择器的选择算法时，一般需要使用选择key。这个选择key可以是消息key也可以是其它数据。但无论谁做选择key，都不能重复，都是唯一的。<br><br><br>一般性的选择算法是，让选择key（或其hash值）与该Topic所包含的Queue的数量取模，其结果即为选择出的Queue的QueueId。<br><br><br>取模算法存在一个问题：不同选择key与Queue数量取模结果可能会是相同的，即不同选择key的消息可能会出现在相同的Queue，即同一个Consuemr可能会消费到不同选择key的消息。这个问题如何解决？一般性的作法是，从消息中获取到选择key，对其进行判断。若是当前Consumer需要消费的消息，则直接消费，否则，什么也不做。这种做法要求选择key要能够随着消息一起被Consumer获取到。此时使用消息key作为选择key是比较好的做法。<br><br><br>以上做法会不会出现如下新的问题呢？不属于那个Consumer的消息被拉取走了，那么应该消费该消息的Consumer是否还能再消费该消息呢？同一个Queue中的消息不可能被同一个Group中的不同Consumer同时消费。所以，消费现一个Queue的不同选择key的消息的Consumer一定属于不同的Group。而不同的Group中的Consumer间的消费是相互隔离的，互不影响的。</p>\n</blockquote>\n<h3 id=\"4-代码举例\"><a href=\"#4-代码举例\" class=\"headerlink\" title=\"4 代码举例\"></a>4 代码举例</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OrderedProducer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        DefaultMQProducer producer = <span class=\"keyword\">new</span> DefaultMQProducer(<span class=\"string\">&quot;pg&quot;</span>);</span><br><span class=\"line\">        producer.setNamesrvAddr(<span class=\"string\">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class=\"line\">        producer.start();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">100</span> ; i++) &#123;</span><br><span class=\"line\">            Integer orderId = i;</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] body = (<span class=\"string\">&quot;Hi,&quot;</span> + i).getBytes();</span><br><span class=\"line\">            Message msg = <span class=\"keyword\">new</span> Message(<span class=\"string\">&quot;TopicA&quot;</span>, <span class=\"string\">&quot;TagA&quot;</span>, body);</span><br><span class=\"line\">            SendResult sendResult = producer.send(msg, <span class=\"keyword\">new</span> MessageQueueSelector() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> MessageQueue <span class=\"title\">select</span><span class=\"params\">(List&lt;MessageQueue&gt; mqs,Message msg, Object arg)</span> </span>&#123;</span><br><span class=\"line\">                        Integer id = (Integer) arg;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> index = id % mqs.size();</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> mqs.get(index);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;, orderId);</span><br><span class=\"line\">            System.out.println(sendResult);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        producer.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"三、延时消息\"><a href=\"#三、延时消息\" class=\"headerlink\" title=\"三、延时消息\"></a>三、延时消息</h2><h3 id=\"1-什么是延时消息\"><a href=\"#1-什么是延时消息\" class=\"headerlink\" title=\"1 什么是延时消息\"></a>1 什么是延时消息</h3><p>当消息写入到Broker后，在指定的时长后才可被消费处理的消息，称为延时消息。</p>\n<p>采用RocketMQ的延时消息可以实现<code>定时任务</code>的功能，而无需使用定时器。典型的应用场景是，电商交易中超时未支付关闭订单的场景， 12306 平台订票超时未支付取消订票的场景。</p>\n<blockquote>\n<p>在电商平台中，订单创建时会发送一条延迟消息。这条消息将会在 30 分钟后投递给后台业务系统（Consumer），后台业务系统收到该消息后会判断对应的订单是否已经完成支付。如果未完成，则取消订单，将商品再次放回到库存；如果完成支付，则忽略。<br><br><br>在 12306 平台中，车票预订成功后就会发送一条延迟消息。这条消息将会在 45 分钟后投递给后台业务系统（Consumer），后台业务系统收到该消息后会判断对应的订单是否已经完成支付。如果未完成，则取消预订，将车票再次放回到票池；如果完成支付，则忽略。</p>\n</blockquote>\n<h3 id=\"2-延时等级\"><a href=\"#2-延时等级\" class=\"headerlink\" title=\"2 延时等级\"></a>2 延时等级</h3><p>延时消息的延迟时长<code>不支持随意时长</code>的延迟，是通过特定的延迟等级来指定的。延时等级定义在RocketMQ服务端的MessageStoreConfig类中的如下变量中：</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208153410.png\" class title=\"输入图片说明\">\n\n<p>即，若指定的延时等级为 3 ，则表示延迟时长为10s，即延迟等级是从 1 开始计数的。</p>\n<p>当然，如果需要自定义的延时等级，可以通过在broker加载的配置中新增如下配置（例如下面增加了 1天这个等级1d）。配置文件在RocketMQ安装目录下的conf目录中。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">messageDelayLevel = 1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h 1d</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-延时消息实现原理\"><a href=\"#3-延时消息实现原理\" class=\"headerlink\" title=\"3 延时消息实现原理\"></a>3 延时消息实现原理</h3><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208153523.png\" class title=\"输入图片说明\">\n\n<h4 id=\"具体实现方案是：\"><a href=\"#具体实现方案是：\" class=\"headerlink\" title=\"具体实现方案是：\"></a>具体实现方案是：</h4><h4 id=\"修改消息\"><a href=\"#修改消息\" class=\"headerlink\" title=\"修改消息\"></a>修改消息</h4><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208153545.png\" class title=\"输入图片说明\">\n\n<p>Producer将消息发送到Broker后，Broker会首先将消息写入到commitlog文件，然后需要将其分发到相应的consumequeue。不过，在分发之前，系统会先判断消息中是否带有延时等级。若没有，则直接正常分发；若有则需要经历一个复杂的过程：</p>\n<ul>\n<li>修改消息的Topic为SCHEDULE_TOPIC_XXXX</li>\n<li>根据延时等级，在consumequeue目录中SCHEDULE_TOPIC_XXXX主题下创建出相应的queueId目录与consumequeue文件（如果没有这些目录与文件的话）。</li>\n</ul>\n<blockquote>\n<p>延迟等级delayLevel与queueId的对应关系为queueId = delayLevel -1<br><br>需要注意，在创建queueId目录时，并不是一次性地将所有延迟等级对应的目录全部创建完毕，而是用到哪个延迟等级创建哪个目录</p>\n</blockquote>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208153635.png\" class title=\"输入图片说明\">\n\n<ul>\n<li>修改消息索引单元内容。索引单元中的Message Tag HashCode部分原本存放的是消息的Tag的Hash值。现修改为消息的<code>投递时间</code>。投递时间是指该消息被重新修改为原Topic后再次被写入到commitlog中的时间。<code>投递时间 = 消息存储时间 + 延时等级时间</code>。消息存储时间指的是消息被发送到Broker时的时间戳。</li>\n<li>将消息索引写入到SCHEDULE_TOPIC_XXXX主题下相应的consumequeue中</li>\n</ul>\n<blockquote>\n<p>SCHEDULE_TOPIC_XXXX目录中各个延时等级Queue中的消息是如何排序的？<br><br><br>是按照消息投递时间排序的。一个Broker中同一等级的所有延时消息会被写入到consumequeue目录中SCHEDULE_TOPIC_XXXX目录下相同Queue中。即一个Queue中消息投递时间的延迟等级时间是相同的。那么投递时间就取决于于<code>消息存储时间</code>了。即按照消息被发送到Broker的时间进行排序的。</p>\n</blockquote>\n<h4 id=\"投递延时消息\"><a href=\"#投递延时消息\" class=\"headerlink\" title=\"投递延时消息\"></a>投递延时消息</h4><p>Broker内部有一个延迟消息服务类ScheuleMessageService，其会消费SCHEDULE_TOPIC_XXXX中的消息，即按照每条消息的投递时间，将延时消息投递到目标Topic中。不过，在投递之前会从commitlog中将原来写入的消息再次读出，并将其原来的延时等级设置为 0 ，即原消息变为了一条不延迟的普通消息。然后再次将消息投递到目标Topic中。</p>\n<blockquote>\n<p>ScheuleMessageService在Broker启动时，会创建并启动一个定时器TImer，用于执行相应的定时任务。系统会根据延时等级的个数，定义相应数量的TimerTask，每个TimerTask负责一个延迟等级消息的消费与投递。每个TimerTask都会检 测相应Queue队列的第一条消息是否到期。若第一条消息未到期，则后面的所有消息更不会到期（消息是按照投递时间排序的）；若第一条消息到期了，则将该消息投递到目标Topic，即消费该消息。</p>\n</blockquote>\n<h4 id=\"将消息重新写入commitlog\"><a href=\"#将消息重新写入commitlog\" class=\"headerlink\" title=\"将消息重新写入commitlog\"></a>将消息重新写入commitlog</h4><p>延迟消息服务类ScheuleMessageService将延迟消息再次发送给了commitlog，并再次形成新的消息索引条目，分发到相应Queue。</p>\n<blockquote>\n<p>这其实就是一次普通消息发送。只不过这次的消息Producer是延迟消息服务类ScheuleMessageService。</p>\n</blockquote>\n<h3 id=\"4-代码举例-1\"><a href=\"#4-代码举例-1\" class=\"headerlink\" title=\"4 代码举例\"></a>4 代码举例</h3><p>定义DelayProducer类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DelayProducer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        DefaultMQProducer producer = <span class=\"keyword\">new</span> DefaultMQProducer(<span class=\"string\">&quot;pg&quot;</span>);</span><br><span class=\"line\">        producer.setNamesrvAddr(<span class=\"string\">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class=\"line\">        producer.start();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">10</span> ; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] body = (<span class=\"string\">&quot;Hi,&quot;</span> + i).getBytes();</span><br><span class=\"line\">            Message msg = <span class=\"keyword\">new</span> Message(<span class=\"string\">&quot;TopicB&quot;</span>, <span class=\"string\">&quot;someTag&quot;</span>, body);</span><br><span class=\"line\">            <span class=\"comment\">// 指定消息延迟等级为 3 级，即延迟10s</span></span><br><span class=\"line\">            <span class=\"comment\">// msg.setDelayTimeLevel(3);</span></span><br><span class=\"line\">            SendResult sendResult = producer.send(msg);</span><br><span class=\"line\">            <span class=\"comment\">// 输出消息被发送的时间</span></span><br><span class=\"line\">            System.out.print(<span class=\"keyword\">new</span> SimpleDateFormat(<span class=\"string\">&quot;mm:ss&quot;</span>).format(<span class=\"keyword\">new</span> Date()));</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot; ,&quot;</span> + sendResult);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        producer.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>定义OtherConsumer类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OtherConsumer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> MQClientException </span>&#123;</span><br><span class=\"line\">        DefaultMQPushConsumer consumer = <span class=\"keyword\">new</span> DefaultMQPushConsumer(<span class=\"string\">&quot;cg&quot;</span>);</span><br><span class=\"line\">        consumer.setNamesrvAddr(<span class=\"string\">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class=\"line\">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET );</span><br><span class=\"line\">        consumer.subscribe(<span class=\"string\">&quot;TopicB&quot;</span>, <span class=\"string\">&quot;*&quot;</span>);</span><br><span class=\"line\">        consumer.registerMessageListener(<span class=\"keyword\">new</span> MessageListenerConcurrently() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> ConsumeConcurrentlyStatus <span class=\"title\">consumeMessage</span><span class=\"params\">(List&lt;MessageExt&gt; msgs,ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (MessageExt msg : msgs) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 输出消息被消费的时间</span></span><br><span class=\"line\">                    System.out.print(<span class=\"keyword\">new</span> SimpleDateFormat(<span class=\"string\">&quot;mm:ss&quot;</span>).format(<span class=\"keyword\">new</span> Date()));</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot; ,&quot;</span> + msg);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        consumer.start();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Consumer Started&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、事务消息\"><a href=\"#四、事务消息\" class=\"headerlink\" title=\"四、事务消息\"></a>四、事务消息</h2><h3 id=\"1-问题引入\"><a href=\"#1-问题引入\" class=\"headerlink\" title=\"1 问题引入\"></a>1 问题引入</h3><p>这里的一个需求场景是：工行用户A向建行用户B转账 1 万元。</p>\n<p>我们可以使用同步消息来处理该需求场景：</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208154429.png\" class title=\"输入图片说明\">\n\n<ul>\n<li><ol>\n<li>工行系统发送一个给B增款 1 万元的同步消息M给Broker</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>消息被Broker成功接收后，向工行系统发送成功ACK</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>工行系统收到成功ACK后从用户A中扣款 1 万元</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>建行系统从Broker中获取到消息M</li>\n</ol>\n</li>\n<li><ol start=\"5\">\n<li>建行系统消费消息M，即向用户B中增加 1 万元</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p>这其中是有问题的：若第 3 步中的扣款操作失败，但消息已经成功发送到了Broker。对于MQ来说，只要消息写入成功，那么这个消息就可以被消费。此时建行系统中用户B增加了 1 万元。出现了数据不一致问题。</p>\n</blockquote>\n<h3 id=\"2-解决思路\"><a href=\"#2-解决思路\" class=\"headerlink\" title=\"2 解决思路\"></a>2 解决思路</h3><p>解决思路是，让第 1 、 2 、 3 步具有原子性，要么全部成功，要么全部失败。即消息发送成功后，必须要保证扣款成功。如果扣款失败，则回滚发送成功的消息。而该思路即使用<code>事务消息</code>。这里要使用<code>分布式事务</code>解决方案。</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208154545.png\" class title=\"输入图片说明\">\n\n<h4 id=\"使用事务消息来处理该需求场景：\"><a href=\"#使用事务消息来处理该需求场景：\" class=\"headerlink\" title=\"使用事务消息来处理该需求场景：\"></a>使用事务消息来处理该需求场景：</h4><ul>\n<li><ol>\n<li>事务管理器TM向事务协调器TC发起指令，开启全局事务</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>工行系统发一个给B增款 1 万元的事务消息M给TC</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>TC会向Broker发送半事务消息prepareHalf，将消息M预提交到Broker。此时的建行系统是看不到Broker中的消息M的</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>Broker会将预提交执行结果Report给TC。</li>\n</ol>\n</li>\n<li><ol start=\"5\">\n<li>如果预提交失败，则TC会向TM上报预提交失败的响应，全局事务结束；如果预提交成功，TC会调用工行系统的回调操作，去完成工行用户A的预扣款 1 万元的操作</li>\n</ol>\n</li>\n<li><ol start=\"6\">\n<li>工行系统会向TC发送预扣款执行结果，即本地事务的执行状态</li>\n</ol>\n</li>\n<li><ol start=\"7\">\n<li>TC收到预扣款执行结果后，会将结果上报给TM。</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p>预扣款执行结果存在三种可能性：<br></p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 描述本地事务执行状态</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">LocalTransactionState</span> </span>&#123;</span><br><span class=\"line\">    COMMIT_MESSAGE,  <span class=\"comment\">// 本地事务执行成功</span></span><br><span class=\"line\">    ROLLBACK_MESSAGE,  <span class=\"comment\">// 本地事务执行失败</span></span><br><span class=\"line\">    UNKNOW,  <span class=\"comment\">// 不确定，表示需要进行回查以确定本地事务的执行结果</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><ol start=\"8\">\n<li>TM会根据上报结果向TC发出不同的确认指令</li>\n</ol>\n<ul>\n<li>若预扣款成功（本地事务状态为COMMIT_MESSAGE），则TM向TC发送Global Commit指令</li>\n<li>若预扣款失败（本地事务状态为ROLLBACK_MESSAGE），则TM向TC发送Global Rollback指令</li>\n<li>若现未知状态（本地事务状态为UNKNOW），则会触发工行系统的本地事务状态<code>回查操作</code>。回查操作会将回查结果，即COMMIT_MESSAGE或ROLLBACK_MESSAGE Report给TC。TC将结果上报给TM，TM会再向TC发送最终确认指令Global Commit或Global Rollback</li>\n</ul>\n</li>\n<li><ol start=\"9\">\n<li>TC在接收到指令后会向Broker与工行系统发出确认指令</li>\n</ol>\n<ul>\n<li>TC接收的若是Global Commit指令，则向Broker与工行系统发送Branch Commit指令。此时Broker中的消息M才可被建行系统看到；此时的工行用户A中的扣款操作才真正被确认</li>\n<li>TC接收到的若是Global Rollback指令，则向Broker与工行系统发送Branch Rollback指令。此时Broker中的消息M将被撤销；工行用户A中的扣款操作将被回滚</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>以上方案就是为了确保<code>消息投递</code>与<code>扣款操作</code>能够在一个事务中，要成功都成功，有一个失败，则全部回滚。<br><br><br>以上方案并不是一个典型的XA模式。因为XA模式中的分支事务是异步的，而事务消息方案中的消息预提交与预扣款操作间是同步的。</p>\n</blockquote>\n<h3 id=\"3-基础\"><a href=\"#3-基础\" class=\"headerlink\" title=\"3 基础\"></a>3 基础</h3><h4 id=\"分布式事务\"><a href=\"#分布式事务\" class=\"headerlink\" title=\"分布式事务\"></a>分布式事务</h4><p>对于分布式事务，通俗地说就是，一次操作由若干分支操作组成，这些分支操作分属不同应用，分布在不同服务器上。分布式事务需要保证这些分支操作要么全部成功，要么全部失败。分布式事务与普通事务一样，就是为了保证操作结果的一致性。</p>\n<h4 id=\"事务消息\"><a href=\"#事务消息\" class=\"headerlink\" title=\"事务消息\"></a>事务消息</h4><p>RocketMQ提供了类似X/Open XA的分布式事务功能，通过事务消息能达到分布式事务的最终一致。XA是一种分布式事务解决方案，一种分布式事务处理模式。</p>\n<h4 id=\"半事务消息\"><a href=\"#半事务消息\" class=\"headerlink\" title=\"半事务消息\"></a>半事务消息</h4><p>暂不能投递的消息，发送方已经成功地将消息发送到了Broker，但是Broker未收到最终确认指令，此时该消息被标记成“暂不能投递”状态，即不能被消费者看到。处于该种状态下的消息即半事务消息。</p>\n<h4 id=\"本地事务状态\"><a href=\"#本地事务状态\" class=\"headerlink\" title=\"本地事务状态\"></a>本地事务状态</h4><p>Producer<code>回调操作</code>执行的结果为本地事务状态，其会发送给TC，而TC会再发送给TM。TM会根据TC发送来的本地事务状态来决定全局事务确认指令。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 描述本地事务执行状态</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">LocalTransactionState</span> </span>&#123;</span><br><span class=\"line\">    COMMIT_MESSAGE,  <span class=\"comment\">// 本地事务执行成功</span></span><br><span class=\"line\">    ROLLBACK_MESSAGE,  <span class=\"comment\">// 本地事务执行失败</span></span><br><span class=\"line\">    UNKNOW,  <span class=\"comment\">// 不确定，表示需要进行回查以确定本地事务的执行结果</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"消息回查\"><a href=\"#消息回查\" class=\"headerlink\" title=\"消息回查\"></a>消息回查</h4><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208155046.png\" class title=\"输入图片说明\">\n\n<p>消息回查，即重新查询本地事务的执行状态。本例就是重新到DB中查看预扣款操作是否执行成功。</p>\n<blockquote>\n<p>注意，消息回查不是重新执行回调操作。回调操作是进行预扣款操作，而消息回查则是查看预扣款操作执行的结果。<br><br><br>引发消息回查的原因最常见的有两个：<br><br>1)回调操作返回UNKNWON<br><br>2)TC没有接收到TM的最终全局事务确认指令<br></p>\n</blockquote>\n<h4 id=\"RocketMQ中的消息回查设置\"><a href=\"#RocketMQ中的消息回查设置\" class=\"headerlink\" title=\"RocketMQ中的消息回查设置\"></a>RocketMQ中的消息回查设置</h4><p>关于消息回查，有三个常见的属性设置。它们都在broker加载的配置文件中设置，例如：</p>\n<ul>\n<li>transactionTimeout=20，指定TM在 20 秒内应将最终确认状态发送给TC，否则引发消息回查。默认为 60 秒</li>\n<li>transactionCheckMax=5，指定最多回查 5 次，超过后将丢弃消息并记录错误日志。默认 15 次。</li>\n<li>transactionCheckInterval=10，指定设置的多次消息回查的时间间隔为 10 秒。默认为 60 秒。</li>\n</ul>\n<h3 id=\"4-XA模式三剑客\"><a href=\"#4-XA模式三剑客\" class=\"headerlink\" title=\"4 XA模式三剑客\"></a>4 XA模式三剑客</h3><h4 id=\"XA协议\"><a href=\"#XA协议\" class=\"headerlink\" title=\"XA协议\"></a>XA协议</h4><p>XA（Unix Transaction）是一种分布式事务解决方案，一种分布式事务处理模式，是基于XA协议的。<br><br>XA协议由Tuxedo（Transaction for Unix has been Extended for Distributed Operation，分布式操作扩展之后的Unix事务系统）首先提出的，并交给X/Open组织，作为资源管理器与事务管理器的接口标准。</p>\n<p><code>XA模式中有三个重要组件：TC、TM、RM。</code></p>\n<h4 id=\"TC\"><a href=\"#TC\" class=\"headerlink\" title=\"TC\"></a>TC</h4><p>Transaction Coordinator，事务协调者。维护全局和分支事务的状态，驱动全局事务提交或回滚。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">RocketMQ中Broker充当着TC。</span><br></pre></td></tr></table></figure>\n<h4 id=\"TM\"><a href=\"#TM\" class=\"headerlink\" title=\"TM\"></a>TM</h4><p>Transaction Manager，事务管理器。定义全局事务的范围：开始全局事务、提交或回滚全局事务。它实际是全局事务的发起者。</p>\n<blockquote>\n<p>RocketMQ中事务消息的Producer充当着TM。</p>\n</blockquote>\n<h4 id=\"RM\"><a href=\"#RM\" class=\"headerlink\" title=\"RM\"></a>RM</h4><p>Resource Manager，资源管理器。管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</p>\n<blockquote>\n<p>RocketMQ中事务消息的Producer及Broker均是RM。</p>\n</blockquote>\n<h3 id=\"5-XA模式架构\"><a href=\"#5-XA模式架构\" class=\"headerlink\" title=\"5 XA模式架构\"></a>5 XA模式架构</h3><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208155359.png\" class title=\"输入图片说明\">\n\n<p>XA模式是一个典型的2PC，其执行原理如下：</p>\n<ul>\n<li><ol>\n<li>TM向TC发起指令，开启一个全局事务。</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>根据业务要求，各个RM会逐个向TC注册分支事务，然后TC会逐个向RM发出预执行指令。</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>各个RM在接收到指令后会在进行本地事务预执行。</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>RM将预执行结果Report给TC。当然，这个结果可能是成功，也可能是失败。</li>\n</ol>\n</li>\n<li><ol start=\"5\">\n<li>TC在接收到各个RM的Report后会将汇总结果上报给TM，根据汇总结果TM会向TC发出确认指令。</li>\n</ol>\n<ul>\n<li>若所有结果都是成功响应，则向TC发送Global Commit指令。</li>\n<li>只要有结果是失败响应，则向TC发送Global Rollback指令。</li>\n</ul>\n</li>\n<li><ol start=\"6\">\n<li>TC在接收到指令后再次向RM发送确认指令。</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p>事务消息方案并不是一个典型的XA模式。因为XA模式中的分支事务是异步的，而事务消息方案中的消息预提交与预扣款操作间是同步的。</p>\n</blockquote>\n<h3 id=\"6-注意\"><a href=\"#6-注意\" class=\"headerlink\" title=\"6 注意\"></a>6 注意</h3><ul>\n<li>事务消息不支持延时消息</li>\n<li>对于事务消息要做好幂等性检查，因为事务消息可能不止一次被消费（因为存在回滚后再提交的情况）</li>\n</ul>\n<h3 id=\"7-代码举例\"><a href=\"#7-代码举例\" class=\"headerlink\" title=\"7 代码举例\"></a>7 代码举例</h3><h4 id=\"定义工行事务监听器\"><a href=\"#定义工行事务监听器\" class=\"headerlink\" title=\"定义工行事务监听器\"></a>定义工行事务监听器</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ICBCTransactionListener</span> <span class=\"keyword\">implements</span> <span class=\"title\">TransactionListener</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 回调操作方法</span></span><br><span class=\"line\">    <span class=\"comment\">// 消息预提交成功就会触发该方法的执行，用于完成本地事务</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> LocalTransactionState <span class=\"title\">executeLocalTransaction</span><span class=\"params\">(Message msg,Object arg)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;预提交消息成功：&quot;</span> + msg);</span><br><span class=\"line\">        <span class=\"comment\">// 假设接收到TAGA的消息就表示扣款操作成功，TAGB的消息表示扣款失败，</span></span><br><span class=\"line\">        <span class=\"comment\">// TAGC表示扣款结果不清楚，需要执行消息回查</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.equals(<span class=\"string\">&quot;TAGA&quot;</span>, msg.getTags())) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (StringUtils.equals(<span class=\"string\">&quot;TAGB&quot;</span>, msg.getTags())) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (StringUtils.equals(<span class=\"string\">&quot;TAGC&quot;</span>, msg.getTags())) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> LocalTransactionState.UNKNOW;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> LocalTransactionState.UNKNOW;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 消息回查方法</span></span><br><span class=\"line\">    <span class=\"comment\">// 引发消息回查的原因最常见的有两个：</span></span><br><span class=\"line\">    <span class=\"comment\">// 1)回调操作返回UNKNWON</span></span><br><span class=\"line\">    <span class=\"comment\">// 2)TC没有接收到TM的最终全局事务确认指令</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> LocalTransactionState <span class=\"title\">checkLocalTransaction</span><span class=\"params\">(MessageExt msg)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;执行消息回查&quot;</span> + msg.getTags());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"定义事物消息生产者\"><a href=\"#定义事物消息生产者\" class=\"headerlink\" title=\"定义事物消息生产者\"></a>定义事物消息生产者</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TransactionProducer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        TransactionMQProducer producer = <span class=\"keyword\">new</span> TransactionMQProducer(<span class=\"string\">&quot;tpg&quot;</span>);</span><br><span class=\"line\">        producer.setNamesrvAddr(<span class=\"string\">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">        * 定义一个线程池</span></span><br><span class=\"line\"><span class=\"comment\">        * <span class=\"doctag\">@param</span> corePoolSize 线程池中核心线程数量</span></span><br><span class=\"line\"><span class=\"comment\">        * <span class=\"doctag\">@param</span> maximumPoolSize 线程池中最多线程数</span></span><br><span class=\"line\"><span class=\"comment\">        * <span class=\"doctag\">@param</span> keepAliveTime 这是一个时间。当线程池中线程数量大于核心线程数量是，多余空闲线程的存活时长</span></span><br><span class=\"line\"><span class=\"comment\">        * <span class=\"doctag\">@param</span> unit 时间单位</span></span><br><span class=\"line\"><span class=\"comment\">        * <span class=\"doctag\">@param</span> workQueue 临时存放任务的队列，其参数就是队列的长度</span></span><br><span class=\"line\"><span class=\"comment\">        * <span class=\"doctag\">@param</span> threadFactory 线程工厂</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        ExecutorService executorService = <span class=\"keyword\">new</span> ThreadPoolExecutor( <span class=\"number\">2</span> , <span class=\"number\">5</span> ,<span class=\"number\">100</span> , TimeUnit.SECONDS,<span class=\"keyword\">new</span> ArrayBlockingQueue&lt;Runnable&gt;( <span class=\"number\">2000</span> ), <span class=\"keyword\">new</span> ThreadFactory() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> Thread <span class=\"title\">newThread</span><span class=\"params\">(Runnable r)</span> </span>&#123;</span><br><span class=\"line\">                Thread thread = <span class=\"keyword\">new</span> Thread(r);</span><br><span class=\"line\">                thread.setName(<span class=\"string\">&quot;client-transaction-msg-check-thread&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> thread;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"comment\">// 为生产者指定一个线程池</span></span><br><span class=\"line\">        producer.setExecutorService(executorService);</span><br><span class=\"line\">        <span class=\"comment\">// 为生产者添加事务监听器</span></span><br><span class=\"line\">        producer.setTransactionListener(<span class=\"keyword\">new</span> ICBCTransactionListener());</span><br><span class=\"line\">        producer.start();</span><br><span class=\"line\">        String[] tags = &#123;<span class=\"string\">&quot;TAGA&quot;</span>,<span class=\"string\">&quot;TAGB&quot;</span>,<span class=\"string\">&quot;TAGC&quot;</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">3</span> ; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] body = (<span class=\"string\">&quot;Hi,&quot;</span> + i).getBytes();</span><br><span class=\"line\">            Message msg = <span class=\"keyword\">new</span> Message(<span class=\"string\">&quot;TTopic&quot;</span>, tags[i], body);</span><br><span class=\"line\">            <span class=\"comment\">// 发送事务消息</span></span><br><span class=\"line\">            <span class=\"comment\">// 第二个参数用于指定在执行本地事务时要使用的业务参数</span></span><br><span class=\"line\">            SendResult sendResult =producer.sendMessageInTransaction(msg,<span class=\"keyword\">null</span>);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;发送结果为：&quot;</span> +sendResult.getSendStatus());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"定义消费者\"><a href=\"#定义消费者\" class=\"headerlink\" title=\"定义消费者\"></a>定义消费者</h4><p>直接使用普通消息的SomeConsumer作为消费者即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeConsumer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> MQClientException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// DefaultLitePullConsumer consumer = new DefaultLitePullConsumer(&quot;cg&quot;);</span></span><br><span class=\"line\">        <span class=\"comment\">// 定义一个push消费者</span></span><br><span class=\"line\">        DefaultMQPushConsumer consumer = <span class=\"keyword\">new</span> DefaultMQPushConsumer(<span class=\"string\">&quot;cg&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 指定nameServer</span></span><br><span class=\"line\">        consumer.setNamesrvAddr(<span class=\"string\">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 指定从第一条消息开始消费</span></span><br><span class=\"line\">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class=\"line\">        <span class=\"comment\">// 指定消费topic与tag</span></span><br><span class=\"line\">        consumer.subscribe(<span class=\"string\">&quot;TTopic&quot;</span>, <span class=\"string\">&quot;*&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 指定采用“广播模式”进行消费，默认为“集群模式”</span></span><br><span class=\"line\">        <span class=\"comment\">// consumer.setMessageModel(MessageModel.BROADCASTING);</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 注册消息监听器</span></span><br><span class=\"line\">        consumer.registerMessageListener(<span class=\"keyword\">new</span> MessageListenerConcurrently() &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 一旦broker中有了其订阅的消息就会触发该方法的执行，</span></span><br><span class=\"line\">            <span class=\"comment\">// 其返回值为当前consumer消费的状态</span></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> ConsumeConcurrentlyStatus <span class=\"title\">consumeMessage</span><span class=\"params\">(List&lt;MessageExt&gt; msgs,ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 逐条消费消息</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (MessageExt msg : msgs) &#123;</span><br><span class=\"line\">                    System.out.println(msg);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 返回消费状态：消费成功</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"comment\">// 开启消费者消费</span></span><br><span class=\"line\">        consumer.start();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Consumer Started&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"五、批量消息\"><a href=\"#五、批量消息\" class=\"headerlink\" title=\"五、批量消息\"></a>五、批量消息</h2><h3 id=\"1-批量发送消息\"><a href=\"#1-批量发送消息\" class=\"headerlink\" title=\"1 批量发送消息\"></a>1 批量发送消息</h3><h4 id=\"发送限制\"><a href=\"#发送限制\" class=\"headerlink\" title=\"发送限制\"></a>发送限制</h4><p>生产者进行消息发送时可以一次发送多条消息，这可以大大提升Producer的发送效率。不过需要注意以下几点：</p>\n<ul>\n<li>批量发送的消息必须具有相同的Topic</li>\n<li>批量发送的消息必须具有相同的刷盘策略</li>\n<li>批量发送的消息不能是延时消息与事务消息</li>\n</ul>\n<h4 id=\"批量发送大小\"><a href=\"#批量发送大小\" class=\"headerlink\" title=\"批量发送大小\"></a>批量发送大小</h4><p>默认情况下，一批发送的消息总大小不能超过4MB字节。如果想超出该值，有两种解决方案：</p>\n<ul>\n<li>方案一：将批量消息进行拆分，拆分为若干不大于4M的消息集合分多次批量发送</li>\n<li>方案二：在Producer端与Broker端修改属性</li>\n</ul>\n<p>** Producer端需要在发送之前设置Producer的maxMessageSize属性</p>\n<p>** Broker端需要修改其加载的配置文件中的maxMessageSize属性</p>\n<h4 id=\"生产者发送的消息大小\"><a href=\"#生产者发送的消息大小\" class=\"headerlink\" title=\"生产者发送的消息大小\"></a>生产者发送的消息大小</h4><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208160513.png\" class title=\"输入图片说明\">\n\n<p>生产者通过send()方法发送的Message，并不是直接将Message序列化后发送到网络上的，而是通过这个Message生成了一个字符串发送出去的。这个字符串由四部分构成：Topic、消息Body、消息日志（占 20 字节），及用于描述消息的一堆属性key-value。这些属性中包含例如生产者地址、生产时间、要发送的QueueId等。最终写入到Broker中消息单元中的数据都是来自于这些属性。</p>\n<h3 id=\"2-批量消费消息\"><a href=\"#2-批量消费消息\" class=\"headerlink\" title=\"2 批量消费消息\"></a>2 批量消费消息</h3><h4 id=\"修改批量属性\"><a href=\"#修改批量属性\" class=\"headerlink\" title=\"修改批量属性\"></a>修改批量属性</h4><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208160544.png\" class title=\"输入图片说明\">\n\n<p>Consumer的MessageListenerConcurrently监听接口的consumeMessage()方法的第一个参数为消息列表，但默认情况下每次只能消费一条消息。若要使其一次可以消费多条消息，则可以通过修改Consumer的consumeMessageBatchMaxSize属性来指定。不过，该值不能超过 32 。因为默认情况下消费者每次可以拉取的消息最多是 32 条。若要修改一次拉取的最大值，则可通过修改Consumer的pullBatchSize属性来指定。</p>\n<h4 id=\"存在的问题\"><a href=\"#存在的问题\" class=\"headerlink\" title=\"存在的问题\"></a>存在的问题</h4><p>Consumer的pullBatchSize属性与consumeMessageBatchMaxSize属性是否设置的越大越好？当然不是。</p>\n<ul>\n<li>pullBatchSize值设置的越大，Consumer每拉取一次需要的时间就会越长，且在网络上传输出现问题的可能性就越高。若在拉取过程中若出现了问题，那么本批次所有消息都需要全部重新拉取。</li>\n<li>consumeMessageBatchMaxSize值设置的越大，Consumer的消息并发消费能力越低，且这批被消费的消息具有相同的消费结果。因为consumeMessageBatchMaxSize指定的一批消息只会使用一个线程进行处理，且在处理过程中只要有一个消息处理异常，则这批消息需要全部重新再次消费处理。<h3 id=\"3-代码举例\"><a href=\"#3-代码举例\" class=\"headerlink\" title=\"3 代码举例\"></a>3 代码举例</h3>该批量发送的需求是，不修改最大发送4M的默认值，但要防止发送的批量消息超出4M的限制。</li>\n</ul>\n<h4 id=\"定义消息列表分割器\"><a href=\"#定义消息列表分割器\" class=\"headerlink\" title=\"定义消息列表分割器\"></a>定义消息列表分割器</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">    <span class=\"comment\">// 消息列表分割器：其只会处理每条消息的大小不超4M的情况。</span></span><br><span class=\"line\">    <span class=\"comment\">// 若存在某条消息，其本身大小大于4M，这个分割器无法处理，</span></span><br><span class=\"line\">    <span class=\"comment\">// 其直接将这条消息构成一个子列表返回。并没有再进行分割</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MessageListSplitter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">List</span>&lt;<span class=\"title\">Message</span>&gt;&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 指定极限值为4M</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SIZE_LIMIT =  <span class=\"number\">4</span> * <span class=\"number\">1024</span> * <span class=\"number\">1024</span> ;</span><br><span class=\"line\">    <span class=\"comment\">// 存放所有要发送的消息</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;Message&gt; messages;</span><br><span class=\"line\">    <span class=\"comment\">// 要进行批量发送消息的小集合起始索引</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> currIndex;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MessageListSplitter</span><span class=\"params\">(List&lt;Message&gt; messages)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.messages = messages;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断当前开始遍历的消息索引要小于消息总数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> currIndex &lt; messages.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Message&gt; <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nextIndex = currIndex;</span><br><span class=\"line\">        <span class=\"comment\">// 记录当前要发送的这一小批次消息列表的大小</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> totalSize = <span class=\"number\">0</span> ;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; nextIndex &lt; messages.size(); nextIndex++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获取当前遍历的消息</span></span><br><span class=\"line\">            Message message = messages.get(nextIndex);</span><br><span class=\"line\">            <span class=\"comment\">// 统计当前遍历的message的大小</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmpSize = message.getTopic().length() + message.getBody().length;</span><br><span class=\"line\">            Map&lt;String, String&gt; properties = message.getProperties();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Map.Entry&lt;String, String&gt; entry :properties.entrySet()) &#123;</span><br><span class=\"line\">                tmpSize += entry.getKey().length() +</span><br><span class=\"line\">                entry.getValue().length();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            tmpSize = tmpSize + <span class=\"number\">20</span> ;</span><br><span class=\"line\">            <span class=\"comment\">// 判断当前消息本身是否大于4M</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tmpSize &gt; SIZE_LIMIT) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (nextIndex - currIndex == <span class=\"number\">0</span> ) &#123;</span><br><span class=\"line\">                    nextIndex++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tmpSize + totalSize &gt; SIZE_LIMIT) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                totalSize += tmpSize;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"comment\">// end-for</span></span><br><span class=\"line\">        <span class=\"comment\">// 获取当前messages列表的子集合[currIndex, nextIndex)</span></span><br><span class=\"line\">        List&lt;Message&gt; subList = messages.subList(currIndex, nextIndex);</span><br><span class=\"line\">        <span class=\"comment\">// 下次遍历的开始索引</span></span><br><span class=\"line\">        currIndex = nextIndex;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> subList;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"定义批量消息生产者\"><a href=\"#定义批量消息生产者\" class=\"headerlink\" title=\"定义批量消息生产者\"></a>定义批量消息生产者</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BatchProducer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        DefaultMQProducer producer = <span class=\"keyword\">new</span> DefaultMQProducer(<span class=\"string\">&quot;pg&quot;</span>);</span><br><span class=\"line\">        producer.setNamesrvAddr(<span class=\"string\">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 指定要发送的消息的最大大小，默认是4M</span></span><br><span class=\"line\">        <span class=\"comment\">// 不过，仅修改该属性是不行的，还需要同时修改broker加载的配置文件中的</span></span><br><span class=\"line\">        <span class=\"comment\">// maxMessageSize属性</span></span><br><span class=\"line\">        <span class=\"comment\">// producer.setMaxMessageSize(8 * 1024 * 1024);</span></span><br><span class=\"line\">        producer.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 定义要发送的消息集合</span></span><br><span class=\"line\">        List&lt;Message&gt; messages = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">100</span> ; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] body = (<span class=\"string\">&quot;Hi,&quot;</span> + i).getBytes();</span><br><span class=\"line\">            Message msg = <span class=\"keyword\">new</span> Message(<span class=\"string\">&quot;someTopic&quot;</span>, <span class=\"string\">&quot;someTag&quot;</span>, body);</span><br><span class=\"line\">            messages.add(msg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 定义消息列表分割器，将消息列表分割为多个不超出4M大小的小列表</span></span><br><span class=\"line\">        MessageListSplitter splitter = <span class=\"keyword\">new</span> MessageListSplitter(messages);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (splitter.hasNext()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                List&lt;Message&gt; listItem = splitter.next();</span><br><span class=\"line\">                producer.send(listItem);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        producer.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"定义批量消息消费者\"><a href=\"#定义批量消息消费者\" class=\"headerlink\" title=\"定义批量消息消费者\"></a>定义批量消息消费者</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BatchConsumer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> MQClientException </span>&#123;</span><br><span class=\"line\">        DefaultMQPushConsumer consumer = <span class=\"keyword\">new</span> DefaultMQPushConsumer(<span class=\"string\">&quot;cg&quot;</span>);</span><br><span class=\"line\">        consumer.setNamesrvAddr(<span class=\"string\">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class=\"line\">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class=\"line\">        consumer.subscribe(<span class=\"string\">&quot;someTopicA&quot;</span>, <span class=\"string\">&quot;*&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 指定每次可以消费 10 条消息，默认为 1</span></span><br><span class=\"line\">        consumer.setConsumeMessageBatchMaxSize( <span class=\"number\">10</span> );</span><br><span class=\"line\">        <span class=\"comment\">// 指定每次可以从Broker拉取 40 条消息，默认为 32</span></span><br><span class=\"line\">        consumer.setPullBatchSize( <span class=\"number\">40</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">        consumer.registerMessageListener(<span class=\"keyword\">new</span> MessageListenerConcurrently() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> ConsumeConcurrentlyStatus <span class=\"title\">consumeMessage</span><span class=\"params\">(List&lt;MessageExt&gt; msgs,ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (MessageExt msg : msgs) &#123;</span><br><span class=\"line\">                    System.out.println(msg);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 消费成功的返回结果</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class=\"line\">                <span class=\"comment\">// 消费异常时的返回结果</span></span><br><span class=\"line\">                <span class=\"comment\">// return ConsumeConcurrentlyStatus.RECONSUME_LATER;</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        consumer.start();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Consumer Started&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"六、消息过滤\"><a href=\"#六、消息过滤\" class=\"headerlink\" title=\"六、消息过滤\"></a>六、消息过滤</h2><p>消息者在进行消息订阅时，除了可以指定要订阅消息的Topic外，还可以对指定Topic中的消息根据指定条件进行过滤，即可以订阅比Topic更加细粒度的消息类型。</p>\n<p>对于指定Topic消息的过滤有两种过滤方式：Tag过滤与SQL过滤。</p>\n<h3 id=\"1-Tag过滤\"><a href=\"#1-Tag过滤\" class=\"headerlink\" title=\"1 Tag过滤\"></a>1 Tag过滤</h3><p>通过consumer的subscribe()方法指定要订阅消息的Tag。如果订阅多个Tag的消息，Tag间使用或运算符(双竖线||)连接。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">DefaultMQPushConsumer consumer = <span class=\"keyword\">new</span> DefaultMQPushConsumer(<span class=\"string\">&quot;CID_EXAMPLE&quot;</span>);</span><br><span class=\"line\">consumer.subscribe(<span class=\"string\">&quot;TOPIC&quot;</span>, <span class=\"string\">&quot;TAGA || TAGB || TAGC&quot;</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-SQL过滤\"><a href=\"#2-SQL过滤\" class=\"headerlink\" title=\"2 SQL过滤\"></a>2 SQL过滤</h3><p>SQL过滤是一种通过特定表达式对事先埋入到消息中的<code>用户属性</code>进行筛选过滤的方式。通过SQL过滤，可以实现对消息的复杂过滤。不过，只有使用<code>PUSH模式</code>的消费者才能使用SQL过滤。</p>\n<p>SQL过滤表达式中支持多种常量类型与运算符。</p>\n<p>支持的常量类型：</p>\n<ul>\n<li>数值：比如： 123 ，3.1415</li>\n<li>字符：必须用单引号包裹起来，比如：’abc’</li>\n<li>布尔：TRUE 或 FALSE</li>\n<li>NULL：特殊的常量，表示空</li>\n</ul>\n<p>支持的运算符有：</p>\n<ul>\n<li>数值比较：&gt;，&gt;=，&lt;，&lt;=，BETWEEN，=</li>\n<li>字符比较：=，&lt;&gt;，IN</li>\n<li>逻辑运算 ：AND，OR，NOT</li>\n<li>NULL判断：IS NULL 或者 IS NOT NULL</li>\n</ul>\n<p>默认情况下Broker没有开启消息的SQL过滤功能，需要在Broker加载的配置文件中添加如下属性，以开启该功能：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">enablePropertyFilter = true</span><br></pre></td></tr></table></figure>\n\n<p>在启动Broker时需要指定这个修改过的配置文件。例如对于单机Broker的启动，其修改的配置文件是conf/broker.conf，启动时使用如下命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">sh bin/mqbroker -n localhost:9876 -c conf/broker.conf &amp;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-代码举例-1\"><a href=\"#3-代码举例-1\" class=\"headerlink\" title=\"3 代码举例\"></a>3 代码举例</h3><p>定义Tag过滤Producer</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FilterByTagProducer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        DefaultMQProducer producer = <span class=\"keyword\">new</span> DefaultMQProducer(<span class=\"string\">&quot;pg&quot;</span>);</span><br><span class=\"line\">        producer.setNamesrvAddr(<span class=\"string\">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class=\"line\">        producer.start();</span><br><span class=\"line\">        String[] tags = &#123;<span class=\"string\">&quot;myTagA&quot;</span>,<span class=\"string\">&quot;myTagB&quot;</span>,<span class=\"string\">&quot;myTagC&quot;</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">10</span> ; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] body = (<span class=\"string\">&quot;Hi,&quot;</span> + i).getBytes();</span><br><span class=\"line\">            String tag = tags[i%tags.length];</span><br><span class=\"line\">            Message msg = <span class=\"keyword\">new</span> Message(<span class=\"string\">&quot;myTopic&quot;</span>,tag,body);</span><br><span class=\"line\">            SendResult sendResult = producer.send(msg);</span><br><span class=\"line\">            System.out.println(sendResult);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        producer.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>定义Tag过滤Consumer</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FilterByTagConsumer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        DefaultMQPushConsumer consumer = <span class=\"keyword\">new</span> DefaultMQPushConsumer(<span class=\"string\">&quot;pg&quot;</span>);</span><br><span class=\"line\">        consumer.setNamesrvAddr(<span class=\"string\">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class=\"line\">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class=\"line\"></span><br><span class=\"line\">        consumer.subscribe(<span class=\"string\">&quot;myTopic&quot;</span>, <span class=\"string\">&quot;myTagA || myTagB&quot;</span>);</span><br><span class=\"line\">        consumer.registerMessageListener(<span class=\"keyword\">new</span> MessageListenerConcurrently() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> ConsumeConcurrentlyStatus <span class=\"title\">consumeMessage</span><span class=\"params\">(List&lt;MessageExt&gt; msgs,ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (MessageExt me:msgs)&#123;</span><br><span class=\"line\">                    System.out.println(me);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        consumer.start();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Consumer Started&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>定义SQL过滤Producer</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FilterBySQLProducer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        DefaultMQProducer producer = <span class=\"keyword\">new</span> DefaultMQProducer(<span class=\"string\">&quot;pg&quot;</span>);</span><br><span class=\"line\">        producer.setNamesrvAddr(<span class=\"string\">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class=\"line\">        producer.start();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">10</span> ; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">byte</span>[] body = (<span class=\"string\">&quot;Hi,&quot;</span> + i).getBytes();</span><br><span class=\"line\">                Message msg = <span class=\"keyword\">new</span> Message(<span class=\"string\">&quot;myTopic&quot;</span>, <span class=\"string\">&quot;myTag&quot;</span>, body);</span><br><span class=\"line\">                msg.putUserProperty(<span class=\"string\">&quot;age&quot;</span>, i + <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">                SendResult sendResult = producer.send(msg);</span><br><span class=\"line\">                System.out.println(sendResult);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        producer.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>定义SQL过滤Consumer</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FilterBySQLConsumer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        DefaultMQPushConsumer consumer = <span class=\"keyword\">new</span> DefaultMQPushConsumer(<span class=\"string\">&quot;pg&quot;</span>);</span><br><span class=\"line\">        consumer.setNamesrvAddr(<span class=\"string\">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class=\"line\">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class=\"line\">        consumer.subscribe(<span class=\"string\">&quot;myTopic&quot;</span>, MessageSelector.bySql(<span class=\"string\">&quot;age between 0 and 6&quot;</span>));</span><br><span class=\"line\">        consumer.registerMessageListener(<span class=\"keyword\">new</span> MessageListenerConcurrently() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> ConsumeConcurrentlyStatus <span class=\"title\">consumeMessage</span><span class=\"params\">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (MessageExt me:msgs)&#123;</span><br><span class=\"line\">                    System.out.println(me);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        consumer.start();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Consumer Started&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"七、消息发送重试机制\"><a href=\"#七、消息发送重试机制\" class=\"headerlink\" title=\"七、消息发送重试机制\"></a>七、消息发送重试机制</h2><h3 id=\"1-说明\"><a href=\"#1-说明\" class=\"headerlink\" title=\"1 说明\"></a>1 说明</h3><p>Producer对发送失败的消息进行重新发送的机制，称为消息发送重试机制，也称为消息重投机制。</p>\n<h4 id=\"对于消息重投，需要注意以下几点：\"><a href=\"#对于消息重投，需要注意以下几点：\" class=\"headerlink\" title=\"对于消息重投，需要注意以下几点：\"></a>对于消息重投，需要注意以下几点：</h4><ul>\n<li>生产者在发送消息时，若采用同步或异步发送方式，发送失败会重试，但oneway消息发送方式发送失败是没有重试机制的</li>\n<li>只有普通消息具有发送重试机制，顺序消息是没有的</li>\n<li>消息重投机制可以保证消息尽可能发送成功、不丢失，但可能会造成消息重复。消息重复在RocketMQ中是无法避免的问题</li>\n<li>消息重复在一般情况下不会发生，当出现消息量大、网络抖动，消息重复就会成为大概率事件</li>\n<li>producer主动重发、consumer负载变化（发生Rebalance，不会导致消息重复，但可能出现重复消费）也会导致重复消息</li>\n<li>消息重复无法避免，但要避免消息的重复消费。</li>\n<li>避免消息重复消费的解决方案是，为消息添加唯一标识（例如消息key），使消费者对消息进行消费判断来避免重复消费</li>\n<li>消息发送重试有三种策略可以选择：同步发送失败策略、异步发送失败策略、消息刷盘失败策略</li>\n</ul>\n<h3 id=\"2-同步发送失败策略\"><a href=\"#2-同步发送失败策略\" class=\"headerlink\" title=\"2 同步发送失败策略\"></a>2 同步发送失败策略</h3><p>对于普通消息，消息发送默认采用round-robin策略来选择所发送到的队列。如果发送失败，默认重试 2次。但在重试时是不会选择上次发送失败的Broker，而是选择其它Broker。当然，若只有一个Broker其也只能发送到该Broker，但其会尽量发送到该Broker上的其它Queue。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个producer，参数为Producer Group名称</span></span><br><span class=\"line\">DefaultMQProducer producer = <span class=\"keyword\">new</span> DefaultMQProducer(<span class=\"string\">&quot;pg&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 指定nameServer地址</span></span><br><span class=\"line\">producer.setNamesrvAddr(<span class=\"string\">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 设置同步发送失败时重试发送的次数，默认为 2 次</span></span><br><span class=\"line\">producer.setRetryTimesWhenSendFailed( <span class=\"number\">3</span> );</span><br><span class=\"line\"><span class=\"comment\">// 设置发送超时时限为5s，默认3s</span></span><br><span class=\"line\">producer.setSendMsgTimeout( <span class=\"number\">5000</span> );</span><br></pre></td></tr></table></figure>\n\n<p>同时，Broker还具有<code>失败隔离</code>功能，使Producer尽量选择未发生过发送失败的Broker作为目标Broker。其可以保证其它消息尽量不发送到问题Broker，为了提升消息发送效率，降低消息发送耗时。</p>\n<blockquote>\n<p>思考：让我们自己实现<code>失败隔离</code>功能，如何来做？<br><br><br>1 ）方案一：Producer中维护某JUC的Map集合，其key是发生失败的时间戳，value为Broker实例。Producer中还维护着一个Set集合，其中存放着所有未发生发送异常的Broker实例。选择目标Broker是从该Set集合中选择的。再定义一个定时任务，定期从Map集合中将长期未发生发送异常的Broker清理出去，并添加到Set集合。<br><br><br>2 ）方案二：为Producer中的Broker实例添加一个标识，例如是一个AtomicBoolean属性。只要该Broker上发生过发送异常，就将其置为true。选择目标Broker就是选择该属性值为false的Broker。再定义一个定时任务，定期将Broker的该属性置为false。<br><br><br>3 ）方案三：为Producer中的Broker实例添加一个标识，例如是一个AtomicLong属性。只要该Broker上发生过发送异常，就使其值增一。选择目标Broker就是选择该属性值最小的Broker。若该值相同，采用轮询方式选择。</p>\n</blockquote>\n<p>如果超过重试次数，则抛出异常，由Producer去保证消息不丢。当然当生产者出现RemotingException、MQClientException和MQBrokerException时，Producer会自动重投消息。</p>\n<h3 id=\"3-异步发送失败策略\"><a href=\"#3-异步发送失败策略\" class=\"headerlink\" title=\"3 异步发送失败策略\"></a>3 异步发送失败策略</h3><p>异步发送失败重试时，异步重试不会选择其他broker，仅在同一个broker上做重试，所以该策略无法保证消息不丢。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">DefaultMQProducer producer = <span class=\"keyword\">new</span> DefaultMQProducer(<span class=\"string\">&quot;pg&quot;</span>);</span><br><span class=\"line\">producer.setNamesrvAddr(<span class=\"string\">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 指定异步发送失败后不进行重试发送</span></span><br><span class=\"line\">producer.setRetryTimesWhenSendAsyncFailed( <span class=\"number\">0</span> );</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-消息刷盘失败策略\"><a href=\"#4-消息刷盘失败策略\" class=\"headerlink\" title=\"4 消息刷盘失败策略\"></a>4 消息刷盘失败策略</h3><p>消息刷盘超时（Master或Slave）或slave不可用（slave在做数据同步时向master返回状态不是SEND_OK）时，默认是不会将消息尝试发送到其他Broker的。不过，对于重要消息可以通过在Broker的配置文件设置retryAnotherBrokerWhenNotStoreOK属性为true来开启。</p>\n<h2 id=\"八、消息消费重试机制\"><a href=\"#八、消息消费重试机制\" class=\"headerlink\" title=\"八、消息消费重试机制\"></a>八、消息消费重试机制</h2><h3 id=\"1-顺序消息的消费重试\"><a href=\"#1-顺序消息的消费重试\" class=\"headerlink\" title=\"1 顺序消息的消费重试\"></a>1 顺序消息的消费重试</h3><p>对于顺序消息，当Consumer消费消息失败后，为了保证消息的顺序性，其会自动不断地进行消息重试，直到消费成功。消费重试默认间隔时间为 1000 毫秒。重试期间应用会出现消息消费被阻塞的情况。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">DefaultMQPushConsumer consumer = <span class=\"keyword\">new</span> DefaultMQPushConsumer(<span class=\"string\">&quot;cg&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 顺序消息消费失败的消费重试时间间隔，单位毫秒，默认为 1000 ，其取值范围为[10,30000]</span></span><br><span class=\"line\">consumer.setSuspendCurrentQueueTimeMillis( <span class=\"number\">100</span> );</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>由于对顺序消息的重试是无休止的，不间断的，直至消费成功，所以，对于顺序消息的消费，务必要保证应用能够及时监控并处理消费失败的情况，避免消费被永久性阻塞。<br><br><br>注意，顺序消息没有发送失败重试机制，但具有消费失败重试机制</p>\n</blockquote>\n<h3 id=\"2-无序消息的消费重试\"><a href=\"#2-无序消息的消费重试\" class=\"headerlink\" title=\"2 无序消息的消费重试\"></a>2 无序消息的消费重试</h3><p>对于无序消息（普通消息、延时消息、事务消息），当Consumer消费消息失败时，可以通过设置返回状态达到消息重试的效果。不过需要注意，无序消息的重试<code>只对集群消费方式生效</code>，广播消费方式不提供失败重试特性。即对于广播消费，消费失败后，失败消息不再重试，继续消费后续消息。</p>\n<h3 id=\"3-消费重试次数与间隔\"><a href=\"#3-消费重试次数与间隔\" class=\"headerlink\" title=\"3 消费重试次数与间隔\"></a>3 消费重试次数与间隔</h3><p>对于<code>无序消息集群</code>消费下的重试消费，每条消息默认最多重试 16 次，但每次重试的间隔时间是不同的，会逐渐变长。每次重试的间隔时间如下表。</p>\n<table>\n<thead>\n<tr>\n<th>重试次数</th>\n<th align=\"center\">与上次重试的间隔时间</th>\n<th align=\"right\">重试次数</th>\n<th align=\"right\">与上次重试的间隔时间</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td align=\"center\">10秒</td>\n<td align=\"right\">9</td>\n<td align=\"right\">7分钟</td>\n</tr>\n<tr>\n<td>2</td>\n<td align=\"center\">30</td>\n<td align=\"right\">10</td>\n<td align=\"right\">8 分钟</td>\n</tr>\n<tr>\n<td>3</td>\n<td align=\"center\">1分钟</td>\n<td align=\"right\">11</td>\n<td align=\"right\">9 分钟</td>\n</tr>\n<tr>\n<td>4</td>\n<td align=\"center\">2分钟</td>\n<td align=\"right\">12</td>\n<td align=\"right\">10分钟</td>\n</tr>\n<tr>\n<td>5</td>\n<td align=\"center\">3分钟</td>\n<td align=\"right\">13</td>\n<td align=\"right\">20分钟</td>\n</tr>\n<tr>\n<td>6</td>\n<td align=\"center\">4分钟</td>\n<td align=\"right\">14</td>\n<td align=\"right\">30分钟</td>\n</tr>\n<tr>\n<td>7</td>\n<td align=\"center\">5分钟</td>\n<td align=\"right\">15</td>\n<td align=\"right\">1小时</td>\n</tr>\n<tr>\n<td>8</td>\n<td align=\"center\">6分钟</td>\n<td align=\"right\">16</td>\n<td align=\"right\">2 小时</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>若一条消息在一直消费失败的前提下，将会在正常消费后的第 <code>4 小时 46 分</code>后进行第 16 次重试。<br><br>若仍然失败，则将消息投递到<code>死信队列</code><br><br><br>修改消费重试次数<br></p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(&quot;cg&quot;);</span><br><span class=\"line\">// 修改消费重试次数</span><br><span class=\"line\">consumer.setMaxReconsumeTimes( 10 );</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>对于修改过的重试次数，将按照以下策略执行：<br><br>1)若修改值小于 16 ，则按照指定间隔进行重试<br><br>2)若修改值大于 16 ，则超过 16 次的重试时间间隔均为 2 小时<br><br><br>对于Consumer Group，若仅修改了一个Consumer的消费重试次数，则会应用到该Group中所有其它Consumer实例。若出现多个Consumer均做了修改的情况，则采用覆盖方式生效。即最后被修改的值会覆盖前面设置的值。</p>\n</blockquote>\n<h3 id=\"4-重试队列-1\"><a href=\"#4-重试队列-1\" class=\"headerlink\" title=\"4 重试队列\"></a>4 重试队列</h3><p>对于需要重试消费的消息，并不是Consumer在等待了指定时长后再次去拉取原来的消息进行消费，而是将这些需要重试消费的消息放入到了一个特殊Topic的队列中，而后进行再次消费的。这个特殊的队列就是重试队列。</p>\n<p>当出现需要进行重试消费的消息时，Broker会为每个消费组都设置一个Topic名称为<code>%RETRY%consumerGroup@consumerGroup</code>的重试队列。</p>\n<blockquote>\n<p>1 ）这个重试队列是针对消息才组的，而不是针对每个Topic设置的（一个Topic的消息可以让多个消费者组进行消费，所以会为这些消费者组各创建一个重试队列）<br><br>2 ）只有当出现需要进行重试消费的消息时，才会为该消费者组创建重试队列</p>\n</blockquote>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208163646.png\" class title=\"输入图片说明\">\n\n<blockquote>\n<p>注意，消费重试的时间间隔与<code>延时消费</code>的<code>延时等级</code>十分相似，除了没有延时等级的前两个时间外，其它的时间都是相同的</p>\n</blockquote>\n<p>Broker对于重试消息的处理是通过<code>延时消息</code>实现的。先将消息保存到SCHEDULE_TOPIC_XXXX延迟队列中，延迟时间到后，会将消息投递到%RETRY%consumerGroup@consumerGroup重试队列中。</p>\n<h3 id=\"5-消费重试配置方式\"><a href=\"#5-消费重试配置方式\" class=\"headerlink\" title=\"5 消费重试配置方式\"></a>5 消费重试配置方式</h3><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208163740.png\" class title=\"输入图片说明\">\n\n<p>集群消费方式下，消息消费失败后若希望消费重试，则需要在消息监听器接口的实现中明确进行如下三种方式之一的配置：</p>\n<ul>\n<li>方式 1 ：返回ConsumeConcurrentlyStatus.RECONSUME_LATER（推荐）</li>\n<li>方式 2 ：返回Null</li>\n<li>方式 3 ：抛出异常</li>\n</ul>\n<h3 id=\"6-消费不重试配置方式\"><a href=\"#6-消费不重试配置方式\" class=\"headerlink\" title=\"6 消费不重试配置方式\"></a>6 消费不重试配置方式</h3><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208163826.png\" class title=\"输入图片说明\">\n\n<p>集群消费方式下，消息消费失败后若不希望消费重试，则在捕获到异常后同样也返回与消费成功后的相同的结果，即ConsumeConcurrentlyStatus.CONSUME_SUCCESS，则不进行消费重试。</p>\n<h2 id=\"九、死信队列\"><a href=\"#九、死信队列\" class=\"headerlink\" title=\"九、死信队列\"></a>九、死信队列</h2><h3 id=\"1-什么是死信队列\"><a href=\"#1-什么是死信队列\" class=\"headerlink\" title=\"1 什么是死信队列\"></a>1 什么是死信队列</h3><p>当一条消息初次消费失败，消息队列会自动进行消费重试；达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确地消费该消息，此时，消息队列不会立刻将消息丢弃，而是将其发送到该消费者对应的特殊队列中。这个队列就是死信队列（Dead-Letter Queue，DLQ），而其中的消息<br>则称为死信消息（Dead-Letter Message，DLM）。</p>\n<blockquote>\n<p>死信队列是用于处理无法被正常消费的消息的。</p>\n</blockquote>\n<h3 id=\"2-死信队列的特征\"><a href=\"#2-死信队列的特征\" class=\"headerlink\" title=\"2 死信队列的特征\"></a>2 死信队列的特征</h3><h4 id=\"死信队列具有如下特征：\"><a href=\"#死信队列具有如下特征：\" class=\"headerlink\" title=\"死信队列具有如下特征：\"></a>死信队列具有如下特征：</h4><ul>\n<li>死信队列中的消息不会再被消费者正常消费，即DLQ对于消费者是不可见的</li>\n<li>死信存储有效期与正常消息相同，均为 3 天（commitlog文件的过期时间）， 3 天后会被自动删除</li>\n<li>死信队列就是一个特殊的Topic，名称为%DLQ%consumerGroup@consumerGroup，即每个消费者组都有一个死信队列</li>\n<li>如果一个消费者组未产生死信消息，则不会为其创建相应的死信队列</li>\n</ul>\n<h3 id=\"3-死信消息的处理\"><a href=\"#3-死信消息的处理\" class=\"headerlink\" title=\"3 死信消息的处理\"></a>3 死信消息的处理</h3><p>实际上，当一条消息进入死信队列，就意味着系统中某些地方出现了问题，从而导致消费者无法正常消费该消息，比如代码中原本就存在Bug。因此，对于死信消息，通常需要开发人员进行特殊处理。最关键的步骤是要排查可疑因素，解决代码中可能存在的Bug，然后再将原来的死信消息再次进行投递消费。</p>\n","site":{"data":{"bangumis":{"wantWatch":[],"watching":[{"title":"凡人修仙传","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/70d11dfab23a3ee81ccf64f18efa139416a633ff.jpg@220w_280h.webp","totalCount":"未完结","id":28223043,"follow":"615.7 万","view":"8.9 亿","danmaku":"490.9 万","coin":"1186.9 万","score":9.7,"des":"看机智的凡人小子韩立如何稳健发展、步步为营，战魔道、夺至宝、驰骋星海、快意恩仇，成为纵横三界的强者。他日仙界重相逢，一声道友尽沧桑。..."},{"title":"恋爱游戏世界对路人角色很不友好","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/c9723d8c77d881a8debba2852d580e97826b43d0.png@220w_280h.webp","totalCount":"全12话","id":28237300,"follow":"151.2 万","view":"5120.4 万","danmaku":"40.6 万","coin":"24.5 万","score":9.1,"des":"从现代日本转生到“恋爱游戏”世界的里昂，发现这里女尊男卑，对男性很不友好。身为路人角色的他，为了摆脱自己因地位低下而被肆意决定的人生，决定活用从游戏中得到的知识，保持路人角色的身份，取得“失落物品”来..."},{"title":"魔法纪录 魔法少女小圆外传 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/9eef1df9ab157be52d2c4d70d3500442f00cafc3.png@220w_280h.webp","totalCount":"全12话","id":28234642,"follow":"237.1 万","view":"907.6 万","danmaku":"5.0 万","coin":"4.9 万","score":7.7,"des":"愿望的代价，究竟是希望还是绝望——。"},{"title":"小林家的龙女仆 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/847e9dbb6876fb37a30199a5c88910704976d45b.png@220w_280h.webp","totalCount":"全13话","id":28234613,"follow":"855.7 万","view":"1.1 亿","danmaku":"49.0 万","coin":"69.0 万","score":9.6,"des":"那位不可思议的龙女仆再度登场！\n因为各种奇妙的原因而作为小林家的女仆而工作中的龙·托尔。\n偶尔（胡说，是经常）给亲爱的小林添麻烦，总算是融入了人类社会，成为了一个完美的（骗人，也就还行）女仆。\n同样是..."},{"title":"国王排名","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/376d7e69a667bcb1c0b934a4e35e07e7fa23110b.png@220w_280h.webp","totalCount":"全23话","id":28235154,"follow":"927.7 万","view":"4.8 亿","danmaku":"250.1 万","coin":"260.9 万","score":7,"des":"国家的丰饶、麾下勇者的数量、\n以及国王本人如何像勇者一般强大，\n这些要素的综合排名，便是所谓的“国王排名”。\n主人公波吉是国王排名第七名的伯斯王治下王国的第一王子。\n但是波吉却生来又聋又哑，贫弱到挥不..."},{"title":"阿松 第三季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0212baa8898d0c819c7fb84015e95b8fca621435.png@220w_280h.webp","totalCount":"全25话","id":28229892,"follow":"67.6 万","view":"938.0 万","danmaku":"13.0 万","coin":"5.4 万","score":9.6,"des":"日本最有名的六胞胎的传说，第三次开幕！！这次会有怎样意想不到的新展开！？..."},{"title":"命运-冠位指定 冠位时间神殿所罗门","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0e094b798388da19a4feffa6a6dabc1dc1dc90cd.jpg@220w_280h.webp","totalCount":"全1话","id":28236225,"follow":"525.5 万","view":"1220.0 万","danmaku":"8.9 万","coin":"15.1 万","score":8.5,"des":"在经过七个特异点的大战后，\n人理存续保障机关迦勒底，终于到达了圣杯探索的最终地点——终局特异点 冠位时间神殿所罗门。\n他们要击败身为罪魁祸首的魔术王所罗门，夺回未来。\n在开战的前一刻，一行人各自度过了..."},{"title":"JOJO的奇妙冒险 星尘远征军","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/47c0108259355d6d2c517ed97f6b90fb777f844f.png@220w_280h.webp","totalCount":"全24话","id":28223481,"follow":"444.2 万","view":"1.5 亿","danmaku":"463.4 万","coin":"45.7 万","score":9.8,"des":"时为1987年，乔瑟夫·乔斯达与“柱之男”们之间的死战后过了50年……乔瑟夫为了为了帮助“被恶灵附身了”的外孙子·空条承太郎而来到了日本。原来那并不是恶灵而是幽波纹（替身）。替身突然出现的原因在于，从..."},{"title":"JOJO的奇妙冒险 星尘远征军 埃及篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f6709b76e88f50aa132d1e09e2d8de9663a09b3e.png@220w_280h.webp","totalCount":"全24话","id":28223483,"follow":"421.9 万","view":"1.3 亿","danmaku":"468.7 万","coin":"44.3 万","score":9.9,"des":"在乔斯达家的宿敌·迪奥（DIO）复活的影响下，一位年轻人——空条承太郎，得到了名为“幽波纹（替身）”的能力。为了拯救因迪奥的诅咒而倒下的母亲荷莉，空条承太郎与外祖父·乔瑟夫以及伙伴们，一起为了打倒迪奥..."},{"title":"JOJO的奇妙冒险 不灭钻石","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/6a04c87e990ab74cd8d555ef45a863de0993b161.png@220w_280h.webp","totalCount":"全39话","id":140552,"follow":"302.3 万","view":"2.1 亿","danmaku":"813.8 万","coin":"55.9 万","score":9.8,"des":"在埃及与宿敌DIO的死斗之后过了11年。1999年，空条承太郎为了与祖父乔瑟夫·乔斯达的私生子东方仗助见面，而来到了日本M县S市杜王町。但，仗助却持有与承太郎相同的特殊能力“替身”。之后，以承太郎的来..."},{"title":"命运-冠位嘉年华","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/c660976f4502a544d990a882ae62194b57753a71.png@220w_280h.webp","totalCount":"全2话","id":28234639,"follow":"479.8 万","view":"862.4 万","danmaku":"4.1 万","coin":"9.1 万","score":9.8,"des":"一起庆祝吧！为了这奇迹般的嘉年华！"},{"title":"伍六七","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/b69e26d9e50514f3fa99eac9ab5aabf2a6e28c88.jpg@220w_280h.webp","totalCount":"全13话","id":6360,"follow":"585.8 万","view":"3.3 亿","danmaku":"227.1 万","coin":"191.8 万","score":9.8,"des":"在某个小岛上，有一个可以伪装成任何东西的廉价刺客，名叫伍六七。平时看上去是个理发师，其实背地里却做着刺客生意。热爱理发事业，喜欢给人剪头发，善用剪刀——剪刀也是他的刺杀武器。由于初入刺客行当，行情十分..."},{"title":"命运-冠位指定 -月光／失落之室-","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3fa5fd2b7afae827b0bf150d7f0cbfc54eda1ff2.png@220w_280h.webp","totalCount":"全1话","id":28234950,"follow":"483.3 万","view":"551.2 万","danmaku":9696,"coin":"2.9 万","score":9.5,"des":"失落之室——。\n这是一个可以看到被夺去亦或是遗失之物的地方。\n这是位于迦勒底被遗忘的角落，不属于任何人的地方。..."},{"title":"致不灭的你","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/1ae94fbb35d8e23bb84926b694509f8b057f96e6.png@220w_280h.webp","totalCount":"全20话","id":28233896,"follow":"476.3 万","view":"1.3 亿","danmaku":"140.1 万","coin":"95.0 万","score":9.6,"des":"本剧讲述了一个情节跌宕、场面宏大的奇幻故事，通过拥有不灭之身的主人公“不死”来探索人生哲理。\n不死起初是一个被投放到人世间的“球”。\n\n它具有“幻化为刺激源形态的能力”和“死后重生的能力”。\n\n先后从..."},{"title":"来自新世界","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/aaa60f9cb17fb4a38df464f1064ca9623e0769cc.jpg@220w_280h.webp","totalCount":"全25话","id":1598,"follow":"115.9 万","view":"1540.9 万","danmaku":"76.3 万","coin":"5.7 万","score":9.5,"des":"1000年后的日本，孩子们不断地消失，只存在想象中的恐怖动物与人类展开殊死战争。反乌托邦式的未来超级社会“新世界”，是口吐真言凭藉“咒力”就能移动物体的人类，与有着等同于普通人智力的生物“妖鼠”共存的..."},{"title":"转生成蜘蛛又怎样！","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f0796e37abac25ba2aa9f23120646aaa9a3d5ea7.png@220w_280h.webp","totalCount":"全24话","id":28231809,"follow":"600.0 万","view":"3.7 亿","danmaku":"190.3 万","coin":"164.6 万","score":7.8,"des":"曾经是一名女高中生的“我”，突然转生变成了幻想世界中的蜘蛛魔物。\n而且，出生地点还是各种凶恶魔物所盘踞的大迷宫。\n“我”以人类的智慧和非同寻常的积极心态为武器，使用蜘蛛的丝网以及陷阱打倒比自己等级高得..."},{"title":"装甲重拳/MEGALOBOX 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/e14dc4a935397fc074c7a12d9520225615209025.png@220w_280h.webp","totalCount":"全13话","id":28233916,"follow":"244.9 万","view":"3435.4 万","danmaku":"19.7 万","coin":"53.1 万","score":9.9,"des":"再一次，为梦想而活——\n\n将肉体与“装甲技术”融合的究极格斗技“装甲拳击”。\n在决出其顶点之人的大会“重拳之巅”上，身穿装甲用自己肉身挑战一切的拳击手“JOE”。\n\n从最下层的比赛开始仅仅花了三个月就..."},{"title":"机动战士高达SEED HD","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/855c88677267d707ebfe4040403692ff2c0938f0.png@220w_280h.webp","totalCount":"全48话","id":497,"follow":"54.8 万","view":"4044.4 万","danmaku":"114.4 万","coin":"6.0 万","score":9.6,"des":"《机动战士高达SEED》是高达系列在2002年至2003年度放映的动画。续作为《机动战士高达SEED Destiny》在2004年播放。因各具魅力的角色，明星云集的声优阵容和高度商业化的宣传而受到较低..."},{"title":"夏目友人帐 唤石者与怪异的访客","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6cf43708b779cde84ad285ff4e3a080de98df0af.png@220w_280h.webp","totalCount":"全1话","id":28234316,"follow":"567.1 万","view":"1374.8 万","danmaku":"18.1 万","coin":"17.9 万","score":9.9,"des":"本作由【唤石者】与【怪异的访客】两个人气短篇集锦而成。讲述生来便能看见各种妖怪的夏目，与自称保镖的猫咪老师一同邂逅的一系列温暖故事。\n【唤石者】一天夏目在森林中遇到一只小妖怪——密实。密实称自己肩负「..."},{"title":"Fate/Grand Order ‐First Order‐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/b75c55d209d156c8631f5ceb21e5c52c834dbb60.jpg@220w_280h.webp","totalCount":"全1话","id":5747,"follow":"250.9 万","view":"3329.7 万","danmaku":"76.7 万","coin":"10.7 万","score":8.3,"des":"【2016年12月31日bilibili独播】2015年。示巴所观测到的未来领域毫无前兆地消失。根据计算，发现——不，是证明了人类将于2017年灭绝。人理延续保障机构·迦勒底将“无法观测的领域”假定为..."},{"title":"伍六七之玄武国篇","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/00843865ea13702eccc4efd64c313fd4c8029c6b.jpg@220w_280h.webp","totalCount":"全10话","id":28232253,"follow":"999.4 万","view":"4.0 亿","danmaku":"177.7 万","coin":"385.3 万","score":9.8,"des":"为了保护小鸡岛居民和这里平静的生活，伍六七和他的伙伴大保和小飞开启了去往玄武国的冒险旅程，去寻找身世的真相和解救小岛的办法，等待他们的又将是更多的未知与奇遇。..."},{"title":"堀与宫村","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/039c4e0b14e27c7a9e5cce2f20a6efd3c8909401.png@220w_280h.webp","totalCount":"全13话","id":28231840,"follow":"695.2 万","view":"2.2 亿","danmaku":"242.1 万","coin":"361.4 万","score":9.8,"des":"不论是谁，都会有不想被人知道的一面。\n\n在学校中漂亮大方、成绩优秀的人气女生堀，私下却打扮土气、忙于家务和照顾弟弟。\n在学校中是阴暗宅男形象的宫村，生活中却是打扮时尚、带耳钉的帅气男生。\n因为一次特别..."},{"title":"奇蛋物语 / WONDER EGG PRIORITY","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/10e0bbc1047b2c45f0f881de334a6f3bfb42a3b6.png@220w_280h.webp","totalCount":"全12话","id":28231851,"follow":"254.9 万","view":"4686.8 万","danmaku":"47.6 万","coin":"65.5 万","score":9.7,"des":"14岁少女·大户爱在深夜散步的途中，\n随着神秘声音的指引，获得了一枚「蛋」。\n\n「如果想要改变世界的话」\n「那么就在现在做出选择」\n「请相信自己——」\n「打破这枚蛋——」\n\n而在打破「蛋」之后，等待着..."},{"title":"Re：从零开始的异世界生活 第二季 后半","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/4f3edbede7fc0bdb52842075cf8faaa1c5953eaa.png@220w_280h.webp","totalCount":"全12话","id":28232073,"follow":"849.9 万","view":"9308.1 万","danmaku":"108.1 万","coin":"230.1 万","score":9.9,"des":"我一定会拯救你。\n在打倒了魔女教大罪司教「怠惰」担当——培提其乌斯·罗曼尼康帝之后，菜月昴和爱蜜莉雅又得以重新开始。\n克服了艰难的诀别，两人终于和解，然而这只是新一轮风波的序幕。\n超乎想象的绝境危机，..."},{"title":"灰与幻想的格林姆迦尔","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/7fb4945f864e9e988212b7d20f206df2677053f8.jpg@220w_280h.webp","totalCount":"全12话","id":106512,"follow":"172.0 万","view":"2343.4 万","danmaku":"63.8 万","coin":"18.3 万","score":9.8,"des":"电视动画《灰与幻想的格林姆迦尔》改编自日本轻小说家十文字青原作白井锐利插画的同名轻小说。\n我们为什么要这么做…？\n哈尔希洛回过神来，才发现自己身处在黑暗当中，他完全不知道自己人在何处，也不明白这个地方..."},{"title":"龙与虎","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/144910805f172d16c5f544f43939a05d8ca20576.jpg@220w_280h.webp","totalCount":"全26话","id":1672,"follow":"336.9 万","view":"6671.9 万","danmaku":"511.9 万","coin":"61.5 万","score":9.7,"des":"樱花飞舞的四月，全新的高中二年级，新的班级……\n眼神凶恶的普通男孩——高须龙儿，遇上了众人害怕、凶暴残忍的“掌中老虎”逢坂大河，还知道了她不欲为人知的秘密。这就是龙虎相争爱与战斗的序幕。\n再加上总是笑..."},{"title":"机动战士高达 铁血的奥尔芬斯 第一季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/f84a80d731d0431c00903d8951fd66623d8237f7.png@220w_280h.webp","totalCount":"全25话","id":4310042,"follow":"62.4 万","view":"2318.6 万","danmaku":"52.2 万","coin":"5.4 万","score":9.5,"des":"主人公三日月·奥古斯，从所属的民间警备公司克律塞安保公司（下称CGS）那里，接受了对少女库德莉亚·蓝那·伯恩斯坦的护卫任务。但CGS受到了摘取反叛之芽的武力组织加拉尔霍恩的袭击，于是在把三日月当做诱饵..."},{"title":"机动战士高达00 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1d7a969e8f1045739c596de89a963e30475aff0e.jpg@220w_280h.webp","totalCount":"全25话","id":1193,"follow":"37.2 万","view":"2458.1 万","danmaku":"61.4 万","coin":"4.1 万","score":9.8,"des":"天人与联合国军的最终决战后过了四年。建立地球联邦政府的人类，为了追求更进一步的国家间之统合，以及人类意识的统一，在联合正规军之外，设立了独立治安维持部队“A-Laws”，目的为对所有危害联合的势力与主..."},{"title":"机动战士高达00","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/35b11bf59eb3fd12f0387951510a5d722d7435e5.jpg@220w_280h.webp","totalCount":"全25话","id":1192,"follow":"62.1 万","view":"2465.5 万","danmaku":"53.6 万","coin":"4.6 万","score":9.7,"des":"在西历2307年，虽然化石燃料枯竭了，但是人类得到了截然不同的新型能源。三台巨大的轨道升降机以及伴随它们的大规模的太阳光发电系统。但是能得到这个系统恩惠的，只有一部分大国和其同盟国而已。\n拥有三台轨道..."},{"title":"Re：从零开始的异世界生活 第二季 前半","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f2425cbdb07cc93bd0d3ba1c0099bfe78f5dc58a.png@220w_280h.webp","totalCount":"全13话","id":28229233,"follow":"774.2 万","view":"1.3 亿","danmaku":"201.4 万","coin":"126.7 万","score":9.7,"des":"我一定会拯救你。\n在打倒了魔女教大罪司教「怠惰」担当——培提其乌斯·罗曼尼康帝之后，菜月昴和爱蜜莉雅又得以重新开始。\n克服了艰难的诀别，两人终于和解，然而这只是新一轮风波的序幕。\n超乎想象的绝境危机，..."},{"title":"超级小白","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3d3e8257d22596f5d3e4395ca759bd1e0fe9b873.jpg@220w_280h.webp","totalCount":"全48话","id":28222671,"follow":"27.4 万","view":"978.0 万","danmaku":"3.6 万","coin":"3.6 万","score":9.6,"des":"为了阻止企图霸占世界的黑暗势力，野原家的普通小狗——小白接肩负重大使命，变身成为了守护世界的“超级小白”。小白将要面对的不仅是发明狗，还有其他意想不到的对手。当然，面对邪恶势力，小白也有着令人惊讶的超..."},{"title":"Re：从零开始的异世界生活 新编集版","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3c125e1aad08643e3eff2fb7d45e740c1a052725.png@220w_280h.webp","totalCount":"全13话","id":28224394,"follow":"631.1 万","view":"7674.2 万","danmaku":"166.2 万","coin":"51.1 万","score":9.6,"des":"在从便利商店回家的路上，突然被异世界召唤的少年菜月昴。在无法依靠任何东西的异世界，无力的少年手唯一的力量……那是“死去然后重新开始”的力量。为了守护最重要的人们，为了取回确实存在着又无可替代的时间，少..."},{"title":"因为太怕痛就全点防御力了","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/8021d3f6b0df6dbba6d32f76eb9cfe2531e166c4.png@220w_280h.webp","totalCount":"全12话","id":28224137,"follow":"620.6 万","view":"2.3 亿","danmaku":"326.8 万","coin":"103.8 万","score":9,"des":"主角本条枫在好友白峰理沙推荐下开始游玩游戏“NewWorld Online”，创建了名为“梅普露”的角色。然而作为游戏初学者，梅普露选择了不受欢迎的大盾当武器，同时因为怕痛而把所有状态点加到防御力的极..."},{"title":"冰海战记","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/c30401817895e67399094b4e669785a104270cdf.jpg@220w_280h.webp","totalCount":"全24话","id":28220475,"follow":"174.4 万","view":"4893.8 万","danmaku":"48.7 万","coin":"36.7 万","score":9.8,"des":"公元10世纪末期，出现了在世界各地出没的最强民族。被讴歌为最强战士的托尔兹，其子托尔芬幼时便生活在战场上，并向往着梦幻大陆“文兰”。这是一个发生在激荡时代的，真正的英雄物语。..."},{"title":"齐木楠雄的灾难 始动篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ba59822eded39b5254fb01448a7f1502101d5624.png@220w_280h.webp","totalCount":"全6话","id":28223748,"follow":"372.4 万","view":"3054.5 万","danmaku":"20.0 万","coin":"17.8 万","score":9.8,"des":"在电视剧中堪称帅气的超能力，对于高中生齐木楠雄来说只是招致灾难的元凶。作为新动画系列展开的楠雄的日常又会如何！？..."},{"title":"OVERLORD Ⅱ","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/851f979c8ebcc7583a43abd4b786c4e2e66b746b.jpg@220w_280h.webp","totalCount":"全13话","id":8792,"follow":"539.3 万","view":"3.8 亿","danmaku":"413.9 万","coin":"114.1 万","score":9.6,"des":"时为2138年。曾卷起一大风潮的虚拟现实体感型网络游戏《YGGDRASIL》即将迎来停服。玩家飞鼠在曾经以同伴和荣华自傲的根据地纳萨力克地下大坟墓，独自一人安静等待着那一刻。但是，不料发生了结束时间已..."},{"title":"夏目友人帐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/99c549494d9425f6455bd45a151f4d26397d6151.png@220w_280h.webp","totalCount":"全13话","id":1660,"follow":"324.0 万","view":"4975.2 万","danmaku":"278.7 万","coin":"15.5 万","score":9.8,"des":"夏目贵志生来拥有强大的灵力，能感知平常人所无法接触的妖怪神明的存在。因父母双亡，他多年间辗转于互相推卸责任的亲戚之间，又受到同龄人的欺负，未曾与任何人深交，造成性格一定程度上的孤僻。夏目本性和善，对于..."}],"watched":[{"title":"装甲重拳/MEGALOBOX","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0c44785cb5d25cc9f648800d251f21a2e236bb8a.png@220w_280h.webp","totalCount":"全13话","id":79472,"follow":"221.9 万","view":"6162.0 万","danmaku":"48.6 万","coin":"32.9 万","score":9.8,"des":"将肉体与“装甲技术”融合的究极格斗技——“MEGALOBOX”，将自己的全部赌在上面的男人们的热血战斗开始！\n今天也立于未认可地区的赌博比赛赛场上的MEGALO拳击手“JNK DOG”。虽然具备实力，..."},{"title":"超能力女儿","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/152c536f8ecaad8f3d7d568d33da81c963a4a722.png@220w_280h.webp","totalCount":"全12话","id":78352,"follow":"293.8 万","view":"9252.2 万","danmaku":"98.5 万","coin":"35.4 万","score":9.6,"des":"支持着芦川组的年轻智力型黑道新田义史，过着被喜欢的壶所包围的悠然自得单身生活。但某一天，随着装在神秘物体里的少女雏来到他家，他的生活为之一变。他被能使用念动力的雏所胁迫，迫不得已开始和她同居！\n容易暴..."},{"title":"OVERLORD Ⅲ","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/dd7a9d0a0bee32b1f43c2656398d8463d12b3069.jpg@220w_280h.webp","totalCount":"全13话","id":102252,"follow":"551.6 万","view":"4.0 亿","danmaku":"399.7 万","coin":"129.2 万","score":9.4,"des":"时间为2138年。曾卷起一大风潮的虚拟现实体感型网络游戏《YGGDRASIL》即将迎来停服。玩家飞鼠在曾经以同伴和荣华自傲的根据地纳萨力克地下大坟墓，独自一人安静等待着那一刻。\n但是，不料发生了“过了..."},{"title":"路人超能100 第一次灵能咨询所员工旅游～舒缓心灵的疗愈之旅~（OVA2）","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/1271324d51634b68980704731987724a1afc60aa.jpg@220w_280h.webp","totalCount":"全1话","id":28222715,"follow":"318.8 万","view":"520.7 万","danmaku":"3.6 万","coin":"4.6 万","score":9.8,"des":"由原作ONE老师担任原案的完全新作OVA！「灵能咨询所」一行人，龙套与灵幻、小酒窝以及新同伴芹泽的目的地，正是缟马县深山中鲜为人知的温泉·疣神温泉。因为灵幻接受了旅馆老板娘的委托，「弄清温泉的恐怖传闻..."},{"title":"少女终末旅行","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1431ca5bb2f7143062e3df8f21b8448cf8cccc13.jpg@220w_280h.webp","totalCount":"全12话","id":6463,"follow":"239.8 万","view":"3714.7 万","danmaku":"100.7 万","coin":"37.2 万","score":9.8,"des":"本作舞台在人类繁华的文明迎来终结的很久以后，人类基本灭绝，甚至生物都不再存在的末日世界。复杂够高的都市成为迷宫般的废墟，得不到维护的机械渐渐停止运转。连何时终结了，何时开始终结的思考都不复存在的这个世..."},{"title":"齐木楠雄的灾难（日播&精选版）","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/eb4f17335f48951945fb9da47e6ee0bc65fa2fbb.jpg@220w_280h.webp","totalCount":"全120话","id":5070,"follow":"187.0 万","view":"2.3 亿","danmaku":"130.7 万","coin":"32.7 万","score":9.6,"des":"高中生·齐木楠雄是超能力者。心灵感应、念动力、透视、预知、瞬间移动、千里眼等，不论任何事情都自由自在。但这任谁都羡慕不已的最强能力，实际上对于本人而言是引来灾难的不幸元凶。因此，他在别人面前封印了超能..."},{"title":"比宇宙更远的地方","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/c9eca3cbc386c63b27461074b8b218898cb7440e.jpg@220w_280h.webp","totalCount":"全13话","id":13032,"follow":"156.0 万","view":"2298.0 万","danmaku":"45.9 万","coin":"23.9 万","score":9.8,"des":"无论何时，我们的第一步总是从好奇心开始。\n不曾看过的风景，不曾听过的声音，不曾闻过的味道，不曾摸过的质感，不曾尝过的食物，以及不曾感受过的澎湃。\n为了重拾不知何时忘却的记忆碎片和不知何时舍弃的感动的旅..."},{"title":"OVERLORD","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/b8e72ea69e57e0b7ac85d8b4d366554fd866df1a.jpg@220w_280h.webp","totalCount":"全13话","id":2576,"follow":"626.2 万","view":"4.1 亿","danmaku":"385.2 万","coin":"84.4 万","score":9.6,"des":"作品主要讲述了某天，一款曾经掀起过大热潮的VRMMORPG「YGGDRASIL」停止了运营。游戏原本会停止一切服务，但过了结束时间后，玩家们却发现不能退出，NPC也产生了各自的思想。现实世界中喜爱电玩..."},{"title":"路人超能100 II(灵能百分百 第二季)","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/216e1bdaf88244215a13b1154116805ee9adbe07.png@220w_280h.webp","totalCount":"全13话","id":4762734,"follow":"284.9 万","view":"1.0 亿","danmaku":"97.8 万","coin":"56.1 万","score":9.9,"des":"当有什么东西达到“100”的时候，就会爆发的少年·路人（龙套）。外表极其普通——不如说是不起眼。不擅长迎合气氛的他，实际上拥有着强力的超能力。盯上了这样的他的能力，而接连现身的伪灵能力者以及宗教团体、..."},{"title":"多罗罗","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3fc16a667502cbff226e585eb660a96a20c7458c.png@220w_280h.webp","totalCount":"全24话","id":4312482,"follow":"452.1 万","view":"1.8 亿","danmaku":"143.9 万","coin":"73.9 万","score":9.4,"des":"他们向着命运抗争，在那尽头等待他们的是人心，还是业障。\n时值乱世。\n名为景光的醍醐将军，向某个寺庙殿堂中的12尊魔神像祈求早日结束战乱。\n作为代价，他的嫡子在出生时就失去了身体的某些部位，被丢弃在河流..."},{"title":"魔法少女小圆","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/7fcaa0e98b561611538ae4deba7949cec4ca39a8.png@220w_280h.webp","totalCount":"全12话","id":2539,"follow":"218.7 万","view":"4199.0 万","danmaku":"201.5 万","coin":"20.0 万","score":9.8,"des":"就读初中二年级的鹿目圆，过着平凡幸福的生活。神秘转学生晓美焰的出现，开始让小圆的命运有了巨大转变。某日一只名为丘比的神秘生物，希望小圆能够与它签订魔法契约，成为“魔法少女”以对抗邪恶的魔女保护世界。正..."}]},"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h1 id=\"第1章-RocketMQ概述\"><a href=\"#第1章-RocketMQ概述\" class=\"headerlink\" title=\"第1章 RocketMQ概述\"></a>第1章 RocketMQ概述</h1><h2 id=\"一、MQ概述\"><a href=\"#一、MQ概述\" class=\"headerlink\" title=\"一、MQ概述\"></a>一、MQ概述</h2><h3 id=\"1-、MQ简介\"><a href=\"#1-、MQ简介\" class=\"headerlink\" title=\"1 、MQ简介\"></a>1 、MQ简介</h3><p>MQ，Message Queue，是一种提供消息队列服务的中间件，也称为消息中间件，是一套提供了消息生产、存储、消费全过程API的软件系统。消息即数据。一般消息的体量不会很大。</p>\n<h3 id=\"2-、MQ用途\"><a href=\"#2-、MQ用途\" class=\"headerlink\" title=\"2 、MQ用途\"></a>2 、MQ用途</h3><p>从网上可以查看到很多的关于MQ用途的叙述，但总结起来其实就以下三点。</p>\n<ul>\n<li><p>限流削峰</p>\n<ul>\n<li>MQ可以将系统的超量请求暂存其中，以便系统后期可以慢慢进行处理，从而避免了请求的丢失或系统被压垮。<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208101908.png\" class title=\"输入图片说明\"></li>\n</ul>\n</li>\n<li><p>异步解耦</p>\n<ul>\n<li>上游系统对下游系统的调用若为同步调用，则会大大降低系统的吞吐量与并发度，且系统耦合度太高。而异步调用则会解决这些问题。所以两层之间若要实现由同步到异步的转化，一般性做法就是，在这两层间添加一个MQ层。</li>\n</ul>\n</li>\n</ul>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208102000.png\" class title=\"输入图片说明\">\n\n<ul>\n<li><p>数据收集</p>\n<ul>\n<li>分布式系统会产生海量级数据流，如：业务日志、监控数据、用户行为等。针对这些数据流进行实时或批量采集汇总，然后对这些数据流进行大数据分析，这是当前互联网平台的必备技术。通过MQ完成此类数据收集是最好的选择。<h3 id=\"3-、常见MQ产品\"><a href=\"#3-、常见MQ产品\" class=\"headerlink\" title=\"3 、常见MQ产品\"></a>3 、常见MQ产品</h3></li>\n</ul>\n</li>\n<li><p>ActiveMQ</p>\n<ul>\n<li>ActiveMQ是使用Java语言开发一款MQ产品。早期很多公司与项目中都在使用。但现在的社区活跃度已经很低。现在的项目中已经很少使用了。</li>\n</ul>\n</li>\n<li><p>RabbitMQ</p>\n<ul>\n<li>RabbitMQ是使用ErLang语言开发的一款MQ产品。其吞吐量较Kafka与RocketMQ要低，且由于其不是Java语言开发，所以公司内部对其实现定制化开发难度较大。</li>\n</ul>\n</li>\n<li><p>Kafka</p>\n<ul>\n<li>Kafka是使用Scala/Java语言开发的一款MQ产品。其最大的特点就是高吞吐率，常用于大数据领域的实时计算、日志采集等场景。其没有遵循任何常见的MQ协议，而是使用自研协议。对于Spring CloudNetçix，其仅支持RabbitMQ与Kafka。</li>\n</ul>\n</li>\n<li><p>RocketMQ</p>\n<ul>\n<li>RocketMQ是使用Java语言开发的一款MQ产品。经过数年阿里双 11 的考验，性能与稳定性非常高。其没有遵循任何常见的MQ协议，而是使用自研协议。对于Spring Cloud Alibaba，其支持RabbitMQ、Kafka，但提倡使用RocketMQ。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"对比\"><a href=\"#对比\" class=\"headerlink\" title=\"对比\"></a>对比</h4><table>\n<thead>\n<tr>\n<th>关键词</th>\n<th align=\"center\">ACTIVEMQ</th>\n<th align=\"right\">RABBITMQ</th>\n<th align=\"right\">KAFKA</th>\n<th align=\"right\">ROCKETMQ</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>开发语言</td>\n<td align=\"center\">Java</td>\n<td align=\"right\">ErLang</td>\n<td align=\"right\">Java</td>\n<td align=\"right\">Java</td>\n</tr>\n<tr>\n<td>单机吞吐量</td>\n<td align=\"center\">万级</td>\n<td align=\"right\">万级</td>\n<td align=\"right\">十万级</td>\n<td align=\"right\">十万级</td>\n</tr>\n<tr>\n<td>Topic</td>\n<td align=\"center\">-</td>\n<td align=\"right\">-</td>\n<td align=\"right\">百级Topic时会影响系统吞吐量</td>\n<td align=\"right\">千级Topic时会影响系统吞吐</td>\n</tr>\n<tr>\n<td>社区活跃度</td>\n<td align=\"center\">低</td>\n<td align=\"right\">高</td>\n<td align=\"right\">高</td>\n<td align=\"right\">高</td>\n</tr>\n</tbody></table>\n<h3 id=\"4-、MQ常见协议\"><a href=\"#4-、MQ常见协议\" class=\"headerlink\" title=\"4 、MQ常见协议\"></a>4 、MQ常见协议</h3><h5 id=\"一般情况下MQ的实现是要遵循一些常规性协议的。常见的协议如下：\"><a href=\"#一般情况下MQ的实现是要遵循一些常规性协议的。常见的协议如下：\" class=\"headerlink\" title=\"一般情况下MQ的实现是要遵循一些常规性协议的。常见的协议如下：\"></a>一般情况下MQ的实现是要遵循一些常规性协议的。常见的协议如下：</h5><h6 id=\"JMS\"><a href=\"#JMS\" class=\"headerlink\" title=\"JMS\"></a>JMS</h6><blockquote>\n<p>JMS，Java Messaging Service（Java消息服务）。是Java平台上有关MOM（Message OrientedMiddleware，面向消息的中间件 PO/OO/AO）的技术规范，它便于消息系统中的Java应用程序进行消息交换，并且通过提供标准的产生、发送、接收消息的接口，简化企业应用的开发。ActiveMQ是该协议的典型实现。</p>\n</blockquote>\n<h6 id=\"STOMP\"><a href=\"#STOMP\" class=\"headerlink\" title=\"STOMP\"></a>STOMP</h6><blockquote>\n<p>STOMP，Streaming Text Orientated Message Protocol（面向流文本的消息协议），是一种MOM设计的简单文本协议。STOMP提供一个可互操作的连接格式，允许客户端与任意STOMP消息代理（Broker）进行交互。ActiveMQ是该协议的典型实现，RabbitMQ通过插件可以支持该协议。</p>\n</blockquote>\n<h6 id=\"AMQP\"><a href=\"#AMQP\" class=\"headerlink\" title=\"AMQP\"></a>AMQP</h6><blockquote>\n<p>AMQP，Advanced Message Queuing Protocol（高级消息队列协议），一个提供统一消息服务的应用层标准，是应用层协议的一个开放标准，是一种MOM设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同开发语言等条件的限制。 RabbitMQ是该协议的典型实现。</p>\n</blockquote>\n<h6 id=\"MQTT\"><a href=\"#MQTT\" class=\"headerlink\" title=\"MQTT\"></a>MQTT</h6><blockquote>\n<p>MQTT，Message Queuing Telemetry Transport（消息队列遥测传输），是IBM开发的一个即时通讯协议，是一种二进制协议，主要用于服务器和低功耗IoT（物联网）设备间的通信。该协议支持所有平台，几乎可以把所有联网物品和外部连接起来，被用来当做传感器和致动器的通信协议。 RabbitMQ通过插件可以支持该协议。</p>\n</blockquote>\n<h2 id=\"二、RocketMQ概述\"><a href=\"#二、RocketMQ概述\" class=\"headerlink\" title=\"二、RocketMQ概述\"></a>二、RocketMQ概述</h2><h3 id=\"1-、RocketMQ简介\"><a href=\"#1-、RocketMQ简介\" class=\"headerlink\" title=\"1 、RocketMQ简介\"></a>1 、RocketMQ简介</h3><blockquote>\n<p>RocketMQ是一个统一消息引擎、轻量级数据处理平台。RocketMQ是一款阿里巴巴开源的消息中间件。 2016 年 11 月 28 日，阿里巴巴向 Apache 软件基金会捐赠RocketMQ，成为 Apache 孵化项目。 2017 年 9 月 25 日，Apache 宣布 RocketMQ孵化成为 Apache 顶级项目（TLP ），成为国内首个互联网中间件在 Apache 上的顶级项目。</p>\n</blockquote>\n<p>官网地址：<a href=\"http://rocketmq.apache.org/\">http://rocketmq.apache.org</a></p>\n<h3 id=\"2-、RocketMQ发展历程\"><a href=\"#2-、RocketMQ发展历程\" class=\"headerlink\" title=\"2 、RocketMQ发展历程\"></a>2 、RocketMQ发展历程</h3><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208103522.png\" class title=\"输入图片说明\">\n<ul>\n<li>2007 年，阿里开始五彩石项目，Notify作为项目中交易核心消息流转系统，应运而生。Notify系统是RocketMQ的雏形。</li>\n<li>2010 年，B2B大规模使用ActiveMQ作为阿里的消息内核。阿里急需一个具有海量堆积能力的消息系统。</li>\n<li>2011 年初，Kafka开源。淘宝中间件团队在对Kafka进行了深入研究后，开发了一款新的MQ，MetaQ。</li>\n<li>2012 年，MetaQ发展到了v3.0版本，在它基础上进行了进一步的抽象，形成了RocketMQ，然后就将其进行了开源。</li>\n<li>2015 年，阿里在RocketMQ的基础上，又推出了一款专门针对阿里云上用户的消息系统Aliware MQ。</li>\n<li>2016 年双十一，RocketMQ承载了万亿级消息的流转，跨越了一个新的里程碑。 11 月 28 日，阿里巴巴向 Apache 软件基金会捐赠 RocketMQ，成为 Apache 孵化项目。</li>\n<li>2017 年 9 月 25 日，Apache 宣布 RocketMQ孵化成为 Apache 顶级项目（TLP ），成为国内首个互联网中间件在 Apache 上的顶级项目。</li>\n</ul>\n<h1 id=\"第-2-章-RocketMQ的安装与启动\"><a href=\"#第-2-章-RocketMQ的安装与启动\" class=\"headerlink\" title=\"第 2 章 RocketMQ的安装与启动\"></a>第 2 章 RocketMQ的安装与启动</h1><h2 id=\"一、基本概念\"><a href=\"#一、基本概念\" class=\"headerlink\" title=\"一、基本概念\"></a>一、基本概念</h2><h3 id=\"1-消息（Message）\"><a href=\"#1-消息（Message）\" class=\"headerlink\" title=\"1 消息（Message）\"></a>1 消息（Message）</h3><blockquote>\n<p>消息是指，消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题。</p>\n</blockquote>\n<h3 id=\"2-主题（Topic）\"><a href=\"#2-主题（Topic）\" class=\"headerlink\" title=\"2 主题（Topic）\"></a>2 主题（Topic）</h3><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208103828.png\" class title=\"输入图片说明\">\n\n<p>Topic表示一类消息的集合，每个主题包含若干条消息，每条消息只能属于一个主题，是RocketMQ进行消息订阅的基本单位。 topic:message 1:n message:topic 1:1</p>\n<p>一个生产者可以同时发送多种Topic的消息；而一个消费者只对某种特定的Topic感兴趣，即只可以订阅<br>和消费一种Topic的消息。 producer:topic 1:n consumer:topic 1:1</p>\n<h3 id=\"3-标签（Tag）\"><a href=\"#3-标签（Tag）\" class=\"headerlink\" title=\"3 标签（Tag）\"></a>3 标签（Tag）</h3><blockquote>\n<p>为消息设置的标签，用于同一主题下区分不同类型的消息。来自同一业务单元的消息，可以根据不同业务目的在同一主题下设置不同标签。标签能够有效地保持代码的清晰度和连贯性，并优化RocketMQ提供的查询系统。消费者可以根据Tag实现对不同子主题的不同消费逻辑，实现更好的扩展性。</p>\n</blockquote>\n<p>Topic是消息的一级分类，Tag是消息的二级分类。</p>\n<ul>\n<li>Topic：货物<ul>\n<li>tag=上海</li>\n<li>tag=江苏</li>\n<li>tag=浙江</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"——-消费者-—–\"><a href=\"#——-消费者-—–\" class=\"headerlink\" title=\"——- 消费者 —–\"></a>——- 消费者 —–</h4><ul>\n<li>topic=货物 tag = 上海</li>\n<li>topic=货物 tag = 上海|浙江</li>\n<li>topic=货物 tag = *</li>\n</ul>\n<h3 id=\"4-队列（Queue）\"><a href=\"#4-队列（Queue）\" class=\"headerlink\" title=\"4 队列（Queue）\"></a>4 队列（Queue）</h3><p>存储消息的物理实体。一个Topic中可以包含多个Queue，每个Queue中存放的就是该Topic的消息。一个Topic的Queue也被称为一个Topic中消息的分区（Partition）。</p>\n<p>一个Topic的Queue中的消息只能被一个消费者组中的一个消费者消费。一个Queue中的消息不允许同一个消费者组中的多个消费者同时消费。</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208104018.png\" class title=\"输入图片说明\">\n\n<p>在学习参考其它相关资料时，还会看到一个概念：分片（Sharding）。分片不同于分区。在RocketMQ中，分片指的是存放相应Topic的Broker。每个分片中会创建出相应数量的分区，即Queue，每个Queue的大小都是相同的。</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208104611.png\" class title=\"输入图片说明\">\n\n<h3 id=\"5-消息标识（MessageId-Key）\"><a href=\"#5-消息标识（MessageId-Key）\" class=\"headerlink\" title=\"5 消息标识（MessageId/Key）\"></a>5 消息标识（MessageId/Key）</h3><p>RocketMQ中每个消息拥有唯一的MessageId，且可以携带具有业务标识的Key，以方便对消息的查询。不过需要注意的是，MessageId有两个：在生产者send()消息时会自动生成一个MessageId（msgId)，当消息到达Broker后，Broker也会自动生成一个MessageId(offsetMsgId)。msgId、offsetMsgId与key都称为消息标识。</p>\n<ul>\n<li>msgId：由producer端生成，其生成规则为：producerIp + 进程pid + MessageClientIDSetter类的ClassLoader的hashCode +当前时间 + AutomicInteger自增计数器</li>\n<li>offsetMsgId：由broker端生成，其生成规则为：brokerIp + 物理分区的offset（Queue中的偏移量）</li>\n<li>key：由用户指定的业务相关的唯一标识</li>\n</ul>\n<h2 id=\"二、系统架构\"><a href=\"#二、系统架构\" class=\"headerlink\" title=\"二、系统架构\"></a>二、系统架构</h2><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208104741.png\" class title=\"输入图片说明\">\n\n<p>RocketMQ架构上主要分为四部分构成：</p>\n<h3 id=\"1-Producer\"><a href=\"#1-Producer\" class=\"headerlink\" title=\"1 Producer\"></a>1 Producer</h3><p>消息生产者，负责生产消息。Producer通过MQ的负载均衡模块选择相应的Broker集群队列进行消息投<br>递，投递的过程支持快速失败并且低延迟。</p>\n<blockquote>\n<p>例如，业务系统产生的日志写入到MQ的过程，就是消息生产的过程</p>\n</blockquote>\n<blockquote>\n<p>再如，电商平台中用户提交的秒杀请求写入到MQ的过程，就是消息生产的过程</p>\n</blockquote>\n<p>RocketMQ中的消息生产者都是以生产者组（Producer Group）的形式出现的。生产者组是同一类生产者的集合，这类Producer发送相同Topic类型的消息。一个生产者组可以同时发送多个主题的消息。</p>\n<h3 id=\"2-Consumer\"><a href=\"#2-Consumer\" class=\"headerlink\" title=\"2 Consumer\"></a>2 Consumer</h3><p>消息消费者，负责消费消息。一个消息消费者会从Broker服务器中获取到消息，并对消息进行相关业务处理。</p>\n<blockquote>\n<p>例如，QoS系统从MQ中读取日志，并对日志进行解析处理的过程就是消息消费的过程。</p>\n</blockquote>\n<blockquote>\n<p>再如，电商平台的业务系统从MQ中读取到秒杀请求，并对请求进行处理的过程就是消息消费的过程。</p>\n</blockquote>\n<p>RocketMQ中的消息消费者都是以消费者组（Consumer Group）的形式出现的。消费者组是同一类消费者的集合，这类Consumer消费的是同一个Topic类型的消息。消费者组使得在消息消费方面，实现负载均衡（将一个Topic中的不同的Queue平均分配给同一个Consumer Group的不同的Consumer，注意，并不是将消息负载均衡）和容错（一个Consmer挂了，该Consumer Group中的其它Consumer可以接着消费原Consumer消费的Queue）的目标变得非常容易。</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208105007.png\" class title=\"输入图片说明\">\n\n<p>消费者组中Consumer的数量应该小于等于订阅Topic的Queue数量。如果超出Queue数量，则多出的Consumer将不能消费消息。</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208105040.png\" class title=\"输入图片说明\">\n\n<p>不过，一个Topic类型的消息可以被多个消费者组同时消费。</p>\n<blockquote>\n<p>注意，</p>\n</blockquote>\n<ul>\n<li>1 ）消费者组只能消费一个Topic的消息，不能同时消费多个Topic消息</li>\n<li>2 ）一个消费者组中的消费者必须订阅完全相同的Topic</li>\n</ul>\n<h3 id=\"3-Name-Server\"><a href=\"#3-Name-Server\" class=\"headerlink\" title=\"3 Name Server\"></a>3 Name Server</h3><h4 id=\"功能介绍\"><a href=\"#功能介绍\" class=\"headerlink\" title=\"功能介绍\"></a>功能介绍</h4><p>NameServer是一个Broker与Topic路由的注册中心，支持Broker的动态注册与发现。</p>\n<p>RocketMQ的思想来自于Kafka，而Kafka是依赖了Zookeeper的。所以，在RocketMQ的早期版本，即在MetaQ v1.0与v2.0版本中，也是依赖于Zookeeper的。从MetaQ v3.0，即RocketMQ开始去掉了Zookeeper依赖，使用了自己的NameServer。</p>\n<h4 id=\"主要包括两个功能：\"><a href=\"#主要包括两个功能：\" class=\"headerlink\" title=\"主要包括两个功能：\"></a>主要包括两个功能：</h4><ul>\n<li><code>Broker管理：</code>接受Broker集群的注册信息并且保存下来作为路由信息的基本数据；提供心跳检测机制，检查Broker是否还存活。</li>\n<li><code>路由信息管理：</code>每个NameServer中都保存着Broker集群的整个路由信息和用于客户端查询的队列信息。Producer和Conumser通过NameServer可以获取整个Broker集群的路由信息，从而进行消息的投递和消费。</li>\n</ul>\n<h4 id=\"路由注册\"><a href=\"#路由注册\" class=\"headerlink\" title=\"路由注册\"></a>路由注册</h4><p>NameServer通常也是以集群的方式部署，不过，NameServer是无状态的，即NameServer集群中的各个节点间是无差异的，各节点间相互不进行信息通讯。那各节点中的数据是如何进行数据同步的呢？在Broker节点启动时，轮询NameServer列表，与每个NameServer节点建立长连接，发起注册请求。在NameServer内部维护着一个Broker列表，用来动态存储Broker的信息。</p>\n<blockquote>\n<p>注意，这是与其它像zk、Eureka、Nacos等注册中心不同的地方。<br><br>这种NameServer的无状态方式，有什么优缺点：<br><br>优点：NameServer集群搭建简单，扩容简单。<br><br>缺点：对于Broker，必须明确指出所有NameServer地址。否则未指出的将不会去注册。也正因为如此，NameServer并不能随便扩容。因为，若Broker不重新配置，新增的NameServer对于Broker来说是不可见的，其不会向这个NameServer进行注册。</p>\n</blockquote>\n<p>Broker节点为了证明自己是活着的，为了维护与NameServer间的长连接，会将最新的信息以心跳包的方式上报给NameServer，每 30 秒发送一次心跳。心跳包中包含 BrokerId、Broker地址(IP+Port)、Broker名称、Broker所属集群名称等等。NameServer在接收到心跳包后，会更新心跳时间戳，记录这个Broker的最新存活时间。</p>\n<h4 id=\"路由剔除\"><a href=\"#路由剔除\" class=\"headerlink\" title=\"路由剔除\"></a>路由剔除</h4><p>由于Broker关机、宕机或网络抖动等原因，NameServer没有收到Broker的心跳，NameServer可能会将其从Broker列表中剔除。</p>\n<p>NameServer中有一个定时任务，每隔 10 秒就会扫描一次Broker表，查看每一个Broker的最新心跳时间戳距离当前时间是否超过 120 秒，如果超过，则会判定Broker失效，然后将其从Broker列表中剔除。</p>\n<blockquote>\n<p>扩展：对于RocketMQ日常运维工作，例如Broker升级，需要停掉Broker的工作。OP需要怎么做？<br><br>OP需要将Broker的读写权限禁掉。一旦client(Consumer或Producer)向broker发送请求，都会收到broker的NO_PERMISSION响应，然后client会进行对其它Broker的重试。<br><br>当OP观察到这个Broker没有流量后，再关闭它，实现Broker从NameServer的移除。<br><br>OP：运维工程师<br><br>SRE：Site Reliability Engineer，现场可靠性工程师</p>\n</blockquote>\n<h4 id=\"路由发现\"><a href=\"#路由发现\" class=\"headerlink\" title=\"路由发现\"></a>路由发现</h4><p>RocketMQ的路由发现采用的是Pull模型。当Topic路由信息出现变化时，NameServer不会主动推送给客户端，而是客户端定时拉取主题最新的路由。默认客户端每 30 秒会拉取一次最新的路由。</p>\n<blockquote>\n<p>扩展：<br><br>1 ）Push模型：推送模型。其实时性较好，是一个“发布-订阅”模型，需要维护一个长连接。而长连接的维护是需要资源成本的。该模型适合于的场景：<br><br>    * 实时性要求较高<br><br>    * Client数量不多，Server数据变化较频繁<br><br>2 ）Pull模型：拉取模型。存在的问题是，实时性较差。<br><br><br>3 ）Long Polling模型：长轮询模型。其是对Push与Pull模型的整合，充分利用了这两种模型的优势，屏蔽了它们的劣势。</p>\n</blockquote>\n<h4 id=\"客户端NameServer选择策略\"><a href=\"#客户端NameServer选择策略\" class=\"headerlink\" title=\"客户端NameServer选择策略\"></a>客户端NameServer选择策略</h4><blockquote>\n<p>这里的客户端指的是Producer与Consumer</p>\n</blockquote>\n<p>客户端在配置时必须要写上NameServer集群的地址，那么客户端到底连接的是哪个NameServer节点呢？客户端首先会生产一个随机数，然后再与NameServer节点数量取模，此时得到的就是所要连接的节点索引，然后就会进行连接。如果连接失败，则会采用round-robin策略，逐个尝试着去连接其它节点。</p>\n<p>首先采用的是<code>随机策略</code>进行的选择，失败后采用的是<code>轮询策略</code>。</p>\n<blockquote>\n<p>扩展：Zookeeper Client是如何选择Zookeeper Server的？<br><br>简单来说就是，经过两次Shufæe，然后选择第一台Zookeeper Server。<br><br>详细说就是，将配置文件中的zk server地址进行第一次shufæe，然后随机选择一个。这个选择出的一般都是一个hostname。然后获取到该hostname对应的所有ip，再对这些ip进行第二次shufæe，从shufæe过的结果中取第一个server地址进行连接。</p>\n</blockquote>\n<h3 id=\"4-Broker\"><a href=\"#4-Broker\" class=\"headerlink\" title=\"4 Broker\"></a>4 Broker</h3><h4 id=\"功能介绍-1\"><a href=\"#功能介绍-1\" class=\"headerlink\" title=\"功能介绍\"></a>功能介绍</h4><p>Broker充当着消息中转角色，负责存储消息、转发消息。Broker在RocketMQ系统中负责接收并存储从生产者发送来的消息，同时为消费者的拉取请求作准备。Broker同时也存储着消息相关的元数据，包括消费者组消费进度偏移offset、主题、队列等。</p>\n<blockquote>\n<p>Kafka 0.8版本之后，offset是存放在Broker中的，之前版本是存放在Zookeeper中的。</p>\n</blockquote>\n<h4 id=\"模块构成\"><a href=\"#模块构成\" class=\"headerlink\" title=\"模块构成\"></a>模块构成</h4><p>下图为Broker Server的功能模块示意图。</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208110201.png\" class title=\"输入图片说明\">\n\n<p><code>Remoting Module</code>：整个Broker的实体，负责处理来自clients端的请求。而这个Broker实体则由以下模块构成。</p>\n<p><code>Client Manager：</code>客户端管理器。负责接收、解析客户端(Producer/Consumer)请求，管理客户端。例如，维护Consumer的Topic订阅信息</p>\n<p><code>Store Service：</code>存储服务。提供方便简单的API接口，处理消息存储到物理硬盘和消息查询功能。</p>\n<p><code>HA Service：</code>高可用服务，提供Master Broker 和 Slave Broker之间的数据同步功能。</p>\n<p><code>Index Service：</code>索引服务。根据特定的Message key，对投递到Broker的消息进行索引服务，同时也提供根据Message Key对消息进行快速查询的功能。</p>\n<h4 id=\"集群部署\"><a href=\"#集群部署\" class=\"headerlink\" title=\"集群部署\"></a>集群部署</h4><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208110311.png\" class title=\"输入图片说明\">\n\n<p>为了增强Broker性能与吞吐量，Broker一般都是以集群形式出现的。各集群节点中可能存放着相同Topic的不同Queue。不过，这里有个问题，如果某Broker节点宕机，如何保证数据不丢失呢？其解决方案是，将每个Broker集群节点进行横向扩展，即将Broker节点再建为一个HA集群，解决单点问题。</p>\n<p>Broker节点集群是一个主从集群，即集群中具有Master与Slave两种角色。Master负责处理读写操作请求，Slave负责对Master中的数据进行备份。当Master挂掉了，Slave则会自动切换为Master去工作。所以这个Broker集群是主备集群。一个Master可以包含多个Slave，但一个Slave只能隶属于一个Master。Master与Slave 的对应关系是通过指定相同的BrokerName、不同的BrokerId 来确定的。BrokerId为 0 表示Master，非 0 表示Slave。每个Broker与NameServer集群中的所有节点建立长连接，定时注册Topic信息到所有NameServer。</p>\n<h3 id=\"5-工作流程\"><a href=\"#5-工作流程\" class=\"headerlink\" title=\"5 工作流程\"></a>5 工作流程</h3><h4 id=\"具体流程\"><a href=\"#具体流程\" class=\"headerlink\" title=\"具体流程\"></a>具体流程</h4><ul>\n<li><p>1 ）启动NameServer，NameServer启动后开始监听端口，等待Broker、Producer、Consumer连接。</p>\n</li>\n<li><p>2 ）启动Broker时，Broker会与所有的NameServer建立并保持长连接，然后每 30 秒向NameServer定时发送心跳包。</p>\n</li>\n<li><p>3 ）发送消息前，可以先创建Topic，创建Topic时需要指定该Topic要存储在哪些Broker上，当然，在创建Topic时也会将Topic与Broker的关系写入到NameServer中。不过，这步是可选的，也可以在发送消息时自动创建Topic。</p>\n</li>\n<li><p>4 ）Producer发送消息，启动时先跟NameServer集群中的其中一台建立长连接，并从NameServer中获取路由信息，即当前发送的Topic消息的Queue与Broker的地址（IP+Port）的映射关系。然后根据算法策略从队选择一个Queue，与队列所在的Broker建立长连接从而向Broker发消息。当然，在获取到路由信息后，Producer会首先将路由信息缓存到本地，再每 30 秒从NameServer更新一次路由信息。</p>\n</li>\n<li><p>5 ）Consumer跟Producer类似，跟其中一台NameServer建立长连接，获取其所订阅Topic的路由信息，然后根据算法策略从路由信息中获取到其所要消费的Queue，然后直接跟Broker建立长连接，开始消费其中的消息。Consumer在获取到路由信息后，同样也会每 30 秒从NameServer更新一次路由信息。不过不同于Producer的是，Consumer还会向Broker发送心跳，以确保Broker的存活状态。</p>\n</li>\n</ul>\n<h4 id=\"Topic的创建模式\"><a href=\"#Topic的创建模式\" class=\"headerlink\" title=\"Topic的创建模式\"></a>Topic的创建模式</h4><p>手动创建Topic时，有两种模式：</p>\n<ul>\n<li>集群模式：该模式下创建的Topic在该集群中，所有Broker中的Queue数量是相同的。</li>\n<li>Broker模式：该模式下创建的Topic在该集群中，每个Broker中的Queue数量可以不同。</li>\n</ul>\n<p>自动创建Topic时，默认采用的是Broker模式，会为每个Broker默认创建 4 个Queue。</p>\n<h4 id=\"读-写队列\"><a href=\"#读-写队列\" class=\"headerlink\" title=\"读/写队列\"></a>读/写队列</h4><p>从物理上来讲，读/写队列是同一个队列。所以，不存在读/写队列数据同步问题。读/写队列是逻辑上进行区分的概念。一般情况下，读/写队列数量是相同的。</p>\n<p>例如，创建Topic时设置的写队列数量为 8 ，读队列数量为 4 ，此时系统会创建 8 个Queue，分别是0 1 2 3 4 5 6 7。Producer会将消息写入到这 8 个队列，但Consumer只会消费0 1 2 3这 4 个队列中的消息，4 5 6 7 中的消息是不会被消费到的。</p>\n<p>再如，创建Topic时设置的写队列数量为 4 ，读队列数量为 8 ，此时系统会创建 8 个Queue，分别是0 1 2 3 4 5 6 7。Producer会将消息写入到0 1 2 3 这 4 个队列，但Consumer只会消费0 1 2 3 4 5 6 7这 8 个队列中的消息，但是4 5 6 7中是没有消息的。此时假设Consumer Group中包含两个Consumer，Consumer1消费0 1 2 3，而Consumer2消费4 5 6 7。但实际情况是，Consumer2是没有消息可消费的。</p>\n<p>也就是说，当读/写队列数量设置不同时，总是有问题的。那么，为什么要这样设计呢？</p>\n<p>其这样设计的目的是为了，方便Topic的Queue的缩容。</p>\n<p>例如，原来创建的Topic中包含 16 个Queue，如何能够使其Queue缩容为 8 个，还不会丢失消息？可以动态修改写队列数量为 8 ，读队列数量不变。此时新的消息只能写入到前 8 个队列，而消费都消费的却是16 个队列中的数据。当发现后 8 个Queue中的消息消费完毕后，就可以再将读队列数量动态设置为 8 。整个缩容过程，没有丢失任何消息。</p>\n<p>perm用于设置对当前创建Topic的操作权限： 2 表示只写， 4 表示只读， 6 表示读写。</p>\n<h2 id=\"三、单机安装与启动\"><a href=\"#三、单机安装与启动\" class=\"headerlink\" title=\"三、单机安装与启动\"></a>三、单机安装与启动</h2><h3 id=\"1-准备工作\"><a href=\"#1-准备工作\" class=\"headerlink\" title=\"1 准备工作\"></a>1 准备工作</h3><h4 id=\"软硬件需求\"><a href=\"#软硬件需求\" class=\"headerlink\" title=\"软硬件需求\"></a>软硬件需求</h4><h4 id=\"系统要求是-64-位的，JDK要求是1-8及其以上版本的。\"><a href=\"#系统要求是-64-位的，JDK要求是1-8及其以上版本的。\" class=\"headerlink\" title=\"系统要求是 64 位的，JDK要求是1.8及其以上版本的。\"></a>系统要求是 64 位的，JDK要求是1.8及其以上版本的。</h4><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208110713.png\" class title=\"输入图片说明\">\n\n<p>下载RocketMQ安装包</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208110738.png\" class title=\"输入图片说明\">\n\n<p>将下载的安装包上传到Linux。</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208110807.png\" class title=\"输入图片说明\">\n\n<p>解压。</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208110821.png\" class title=\"输入图片说明\">\n\n<h3 id=\"2-、修改初始内存\"><a href=\"#2-、修改初始内存\" class=\"headerlink\" title=\"2 、修改初始内存\"></a>2 、修改初始内存</h3><p>修改runserver.sh</p>\n<p>使用vim命令打开bin/runserver.sh文件。现将这些值修改为如下：</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208110900.png\" class title=\"输入图片说明\">\n\n<p>修改runbroker.sh</p>\n<p>使用vim命令打开bin/runbroker.sh文件。现将这些值修改为如下：</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208110924.png\" class title=\"输入图片说明\">\n<h3 id=\"3-、启动\"><a href=\"#3-、启动\" class=\"headerlink\" title=\"3 、启动\"></a>3 、启动</h3><p>启动NameServer</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">nohup sh bin/mqnamesrv &amp;</span><br><span class=\"line\">tail -f ~/logs/rocketmqlogs/namesrv.log</span><br></pre></td></tr></table></figure>\n\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208111000.png\" class title=\"输入图片说明\">\n\n\n<p><code>如果出现mq启动报错ERROR: Please set the JAVA_HOME variable in your environment, We need java(x64)! !!</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">ln -s /usr/local/jdk1.8.0_191/bin/javac /usr/bin/javac</span><br><span class=\"line\">ln -s  /usr/local/jdk1.8.0_191/bin/jar /usr/bin/jar</span><br><span class=\"line\">ln -s /usr/local/jdk1.8.0_191/bin/java /bin/java</span><br></pre></td></tr></table></figure>\n\n<p>启动broker</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">nohup sh bin/mqbroker -n localhost:9876 &amp;</span><br><span class=\"line\">tail -f ~/logs/rocketmqlogs/broker.log</span><br></pre></td></tr></table></figure>\n\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208111020.png\" class title=\"输入图片说明\">\n\n<h3 id=\"4-、发送-接收消息测试\"><a href=\"#4-、发送-接收消息测试\" class=\"headerlink\" title=\"4 、发送/接收消息测试\"></a>4 、发送/接收消息测试</h3><h4 id=\"发送消息\"><a href=\"#发送消息\" class=\"headerlink\" title=\"发送消息\"></a>发送消息</h4><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">export NAMESRV_ADDR=localhost:9876</span><br><span class=\"line\">sh bin/tools.sh org.apache.rocketmq.example.quickstart.Producer</span><br></pre></td></tr></table></figure>\n<h4 id=\"接收消息\"><a href=\"#接收消息\" class=\"headerlink\" title=\"接收消息\"></a>接收消息</h4><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">sh bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-、关闭Server\"><a href=\"#5-、关闭Server\" class=\"headerlink\" title=\"5 、关闭Server\"></a>5 、关闭Server</h3><p>无论是关闭name server还是broker，都是使用bin/mqshutdown命令。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@mqOS rocketmq]# sh bin/mqshutdown broker</span><br><span class=\"line\">The mqbroker(1740) is running...</span><br><span class=\"line\">Send shutdown request to mqbroker(1740) OK</span><br><span class=\"line\"></span><br><span class=\"line\">[root@mqOS rocketmq]# sh bin/mqshutdown namesrv</span><br><span class=\"line\">The mqnamesrv(1692) is running...</span><br><span class=\"line\">Send shutdown request to mqnamesrv(1692) OK</span><br><span class=\"line\">[2]+ 退出 143 nohup sh bin/mqbroker -n localhost:9876</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、-控制台的安装与启动\"><a href=\"#四、-控制台的安装与启动\" class=\"headerlink\" title=\"四、 控制台的安装与启动\"></a>四、 控制台的安装与启动</h2><p>RocketMQ有一个可视化的dashboard，通过该控制台可以直观的查看到很多数据。</p>\n<h3 id=\"1-下载\"><a href=\"#1-下载\" class=\"headerlink\" title=\"1 下载\"></a>1 下载</h3><p>下载地址：<a href=\"https://github.com/apache/rocketmq-externals/releases\">https://github.com/apache/rocketmq-externals/releases</a></p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208111255.png\" class title=\"输入图片说明\">\n\n<h3 id=\"2-修改配置\"><a href=\"#2-修改配置\" class=\"headerlink\" title=\"2 修改配置\"></a>2 修改配置</h3><p>修改其src/main/resources中的application.properties配置文件。</p>\n<ul>\n<li>原来的端口号为 8080 ，修改为一个不常用的</li>\n<li>指定RocketMQ的name server地址</li>\n</ul>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208111351.png\" class title=\"输入图片说明\">\n\n<h3 id=\"3-添加依赖\"><a href=\"#3-添加依赖\" class=\"headerlink\" title=\"3 添加依赖\"></a>3 添加依赖</h3><p>在解压目录rocketmq-console的pom.xml中添加如下JAXB依赖。</p>\n<blockquote>\n<p>JAXB，Java Architechture for Xml Binding，用于XML绑定的Java技术，是一个业界标准，是一项可以根据XML Schema生成Java类的技术。</p>\n</blockquote>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>javax.xml.bind<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>jaxb-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.3.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.sun.xml.bind<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>jaxb-impl<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.3.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.sun.xml.bind<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>jaxb-core<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.3.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>javax.activation<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>activation<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.1.1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"4-打包\"><a href=\"#4-打包\" class=\"headerlink\" title=\"4 打包\"></a>4 打包</h3><p>在rocketmq-console目录下运行maven的打包命令。</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208111536.png\" class title=\"输入图片说明\">\n\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208111646.png\" class title=\"输入图片说明\">\n<h3 id=\"5-启动\"><a href=\"#5-启动\" class=\"headerlink\" title=\"5 启动\"></a>5 启动</h3><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208111700.png\" class title=\"输入图片说明\">\n<h3 id=\"6-访问\"><a href=\"#6-访问\" class=\"headerlink\" title=\"6 访问\"></a>6 访问</h3><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208111724.png\" class title=\"输入图片说明\">\n\n<h2 id=\"五、集群搭建理论\"><a href=\"#五、集群搭建理论\" class=\"headerlink\" title=\"五、集群搭建理论\"></a>五、集群搭建理论</h2><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208111755.png\" class title=\"输入图片说明\">\n\n<h3 id=\"1-数据复制与刷盘策略\"><a href=\"#1-数据复制与刷盘策略\" class=\"headerlink\" title=\"1 数据复制与刷盘策略\"></a>1 数据复制与刷盘策略</h3><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208111822.png\" class title=\"输入图片说明\">\n\n<h4 id=\"复制策略\"><a href=\"#复制策略\" class=\"headerlink\" title=\"复制策略\"></a>复制策略</h4><p>复制策略是Broker的Master与Slave间的数据同步方式。分为同步复制与异步复制：</p>\n<ul>\n<li>同步复制：消息写入master后，master会等待slave同步数据成功后才向producer返回成功ACK</li>\n<li>异步复制：消息写入master后，master立即向producer返回成功ACK，无需等待slave同步数据成功</li>\n</ul>\n<blockquote>\n<p>异步复制策略会降低系统的写入延迟，RT变小，提高了系统的吞吐量</p>\n</blockquote>\n<h4 id=\"刷盘策略\"><a href=\"#刷盘策略\" class=\"headerlink\" title=\"刷盘策略\"></a>刷盘策略</h4><p>刷盘策略指的是broker中消息的落盘方式，即消息发送到broker内存后消息持久化到磁盘的方式。分为同步刷盘与异步刷盘.</p>\n<ul>\n<li>同步刷盘：当消息持久化到broker的磁盘后才算是消息写入成功。</li>\n<li>异步刷盘：当消息写入到broker的内存后即表示消息写入成功，无需等待消息持久化到磁盘。</li>\n</ul>\n<blockquote>\n<p>1 ）异步刷盘策略会降低系统的写入延迟，RT变小，提高了系统的吞吐量<br><br>2 ）消息写入到Broker的内存，一般是写入到了PageCache<br><br>3 ）对于异步 刷盘策略，消息会写入到PageCache后立即返回成功ACK。但并不会立即做落盘操作，而是当PageCache到达一定量时会自动进行落盘。<br></p>\n</blockquote>\n<h3 id=\"2-Broker集群模式\"><a href=\"#2-Broker集群模式\" class=\"headerlink\" title=\"2 Broker集群模式\"></a>2 Broker集群模式</h3><p>根据Broker集群中各个节点间关系的不同，Broker集群可以分为以下几类：</p>\n<h4 id=\"单Master\"><a href=\"#单Master\" class=\"headerlink\" title=\"单Master\"></a>单Master</h4><p>只有一个broker（其本质上就不能称为集群）。这种方式也只能是在测试时使用，生产环境下不能使用，因为存在单点问题。</p>\n<h4 id=\"多Master\"><a href=\"#多Master\" class=\"headerlink\" title=\"多Master\"></a>多Master</h4><p>broker集群仅由多个master构成，不存在Slave。同一Topic的各个Queue会平均分布在各个master节点上。</p>\n<ul>\n<li>优点：配置简单，单个Master宕机或重启维护对应用无影响，在磁盘配置为RAID10时，即使机器宕机不可恢复情况下，由于RAID10磁盘非常可靠，消息也不会丢（异步刷盘丢失少量消息，同步刷盘一条不丢），性能最高；</li>\n<li>缺点：单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅（不可消费），消息实时性会受到影响。</li>\n</ul>\n<blockquote>\n<p>以上优点的前提是，这些Master都配置了RAID磁盘阵列。如果没有配置，一旦出现某Master宕机，则会发生大量消息丢失的情况。</p>\n</blockquote>\n<h4 id=\"多Master多Slave模式-异步复制\"><a href=\"#多Master多Slave模式-异步复制\" class=\"headerlink\" title=\"多Master多Slave模式-异步复制\"></a>多Master多Slave模式-异步复制</h4><p>broker集群由多个master构成，每个master又配置了多个slave（在配置了RAID磁盘阵列的情况下，一个master一般配置一个slave即可）。master与slave的关系是主备关系，即master负责处理消息的读写请求，而slave仅负责消息的备份与master宕机后的角色切换。</p>\n<p>异步复制即前面所讲的<code>复制策略</code>中的<code>异步复制策略</code>，即消息写入master成功后，master立即向producer返回成功ACK，无需等待slave同步数据成功。</p>\n<p>该模式的最大特点之一是，当master宕机后slave能够<code>自动切换</code>为master。不过由于slave从master的同步具有短暂的延迟（毫秒级），所以当master宕机后，这种异步复制方式可能会存在少量消息的丢失问题。</p>\n<blockquote>\n<p>Slave从Master同步的延迟越短，其可能丢失的消息就越少<br><br><br>对于Master的RAID磁盘阵列，若使用的也是异步复制策略，同样也存在延迟问题，同样也可能会丢失消息。但RAID阵列的秘诀是微秒级的（因为是由硬盘支持的），所以其丢失的数据量会更少。</p>\n</blockquote>\n<h4 id=\"多Master多Slave模式-同步双写\"><a href=\"#多Master多Slave模式-同步双写\" class=\"headerlink\" title=\"多Master多Slave模式-同步双写\"></a>多Master多Slave模式-同步双写</h4><p>该模式是<code>多Master多Slave模式</code>的<code>同步复制</code>实现。所谓<code>同步双写</code>，指的是消息写入master成功后，master会等待slave同步数据成功后才向producer返回成功ACK，即master与slave都要写入成功后才会返回成功ACK，也即<code>双写</code>。该模式与<code>异步复制模式相比</code>，优点是消息的安全性更高，不存在消息丢失的情况。但单个消息的RT略高，从而导致性能要略低（大约低10%）。</p>\n<p>该模式存在一个大的问题：对于目前的版本，Master宕机后，Slave<code>不会自动切换</code>到Master。</p>\n<h4 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h4><p>一般会为Master配置RAID10磁盘阵列，然后再为其配置一个Slave。即利用了RAID10磁盘阵列的高效、安全性，又解决了可能会影响订阅的问题。</p>\n<blockquote>\n<p>1 ）RAID磁盘阵列的效率要高于Master-Slave集群。因为RAID是硬件支持的。也正因为如此，所以RAID阵列的搭建成本较高。<br><br><br>2 ）多Master+RAID阵列，与多Master多Slave集群的区别是什么？<br><br>1.多Master+RAID阵列，其仅仅可以保证数据不丢失，即不影响消息写入，但其可能会影响到消息的订阅。但其执行效率要远高于<code>多Master多Slave集群</code><br><br>2.多Master多Slave集群，其不仅可以保证数据不丢失，也不会影响消息写入。其运行效率要低于<code>多Master+RAID阵列</code></p>\n</blockquote>\n<h2 id=\"六、磁盘阵列RAID（补充）\"><a href=\"#六、磁盘阵列RAID（补充）\" class=\"headerlink\" title=\"六、磁盘阵列RAID（补充）\"></a>六、磁盘阵列RAID（补充）</h2><h3 id=\"1-RAID历史\"><a href=\"#1-RAID历史\" class=\"headerlink\" title=\"1 RAID历史\"></a>1 RAID历史</h3><p>1988 年美国加州大学伯克利分校的 D. A. Patterson 教授等首次在论文 “A Case of Redundant Array of Inexpensive Disks” 中提出了 RAID 概念 ，即<code>廉价冗余磁盘阵列</code>（ Redundant Array of Inexpensive Disks ）。由于当时大容量磁盘比较昂贵， RAID 的基本思想是将多个容量较小、相对廉价的磁盘进行有机组合，从而以较低的成本获得与昂贵大容量磁盘相当的容量、性能、可靠性。随着磁盘成本和价格的不断降低， “廉价” 已经毫无意义。因此， RAID 咨询委员会（ RAID Advisory Board, RAB ）决定用“ 独立 ” 替代 “ 廉价 ” ，于时 RAID 变成了<code>独立磁盘冗余阵列</code>（ Redundant Array of Independent Disks ）。但这仅仅是名称的变化，实质内容没有改变。</p>\n<p>内存：32m 6.4G（IBM 10.1G）</p>\n<h3 id=\"2-RAID等级\"><a href=\"#2-RAID等级\" class=\"headerlink\" title=\"2 RAID等级\"></a>2 RAID等级</h3><p>RAID 这种设计思想很快被业界接纳， RAID 技术作为高性能、高可靠的存储技术，得到了非常广泛的应用。 RAID 主要利用镜像、数据条带和数据校验三种技术来获取高性能、可靠性、容错能力和扩展性，根据对这三种技术的使用策略和组合架构，可以把 RAID 分为不同的等级，以满足不同数据应用的需求。</p>\n<p>D. A. Patterson 等的论文中定义了 RAID0 ~ RAID6 原始 RAID 等级。随后存储厂商又不断推出 RAID7、 RAID10、RAID01 、 RAID50 、 RAID53 、 RAID100 等 RAID 等级，但这些并无统一的标准。目前业界与学术界公认的标准是 RAID0 ~ RAID6 ，而在实际应用领域中使用最多的 RAID 等级是 RAID0 、RAID1 、 RAID3 、 RAID5 、 RAID6 和 RAID10。</p>\n<p>RAID 每一个等级代表一种实现方法和技术，等级之间并无高低之分。在实际应用中，应当根据用户的数据应用特点，综合考虑可用性、性能和成本来选择合适的 RAID 等级，以及具体的实现方式。</p>\n<h3 id=\"3-关键技术\"><a href=\"#3-关键技术\" class=\"headerlink\" title=\"3 关键技术\"></a>3 关键技术</h3><h4 id=\"镜像技术\"><a href=\"#镜像技术\" class=\"headerlink\" title=\"镜像技术\"></a>镜像技术</h4><p>镜像技术是一种冗余技术，为磁盘提供数据备份功能，防止磁盘发生故障而造成数据丢失。对于 RAID而言，采用镜像技术最典型地的用法就是，同时在磁盘阵列中产生两个完全相同的数据副本，并且分布在两个不同的磁盘上。镜像提供了完全的数据冗余能力，当一个数据副本失效不可用时，外部系统仍可正常访问另一副本，不会对应用系统运行和性能产生影响。而且，镜像不需要额外的计算和校验，故障修复非常快，直接复制即可。镜像技术可以从多个副本进行并发读取数据，提供更高的读 I/O 性能，但不能并行写数据，写多个副本通常会导致一定的 I/O 性能下降。</p>\n<p>镜像技术提供了非常高的数据安全性，其代价也是非常昂贵的，需要至少双倍的存储空间。高成本限制了镜像的广泛应用，主要应用于至关重要的数据保护，这种场合下的数据丢失可能会造成非常巨大的损失。</p>\n<h4 id=\"数据条带技术\"><a href=\"#数据条带技术\" class=\"headerlink\" title=\"数据条带技术\"></a>数据条带技术</h4><p>数据条带化技术是一种自动将 I/O操作负载均衡到多个物理磁盘上的技术。更具体地说就是，将一块连续的数据分成很多小部分并把它们分别存储到不同磁盘上。这就能使多个进程可以并发访问数据的多个不同部分，从而获得最大程度上的 I/O 并行能力，极大地提升性能。</p>\n<h4 id=\"数据校验技术\"><a href=\"#数据校验技术\" class=\"headerlink\" title=\"数据校验技术\"></a>数据校验技术</h4><p>数据校验技术是指， RAID 要在写入数据的同时进行校验计算，并将得到的校验数据存储在 RAID 成员磁盘中。校验数据可以集中保存在某个磁盘或分散存储在多个不同磁盘中。当其中一部分数据出错时，就可以对剩余数据和校验数据进行反校验计算重建丢失的数据。</p>\n<p>数据校验技术相对于镜像技术的优势在于节省大量开销，但由于每次数据读写都要进行大量的校验运算，对计算机的运算速度要求很高，且必须使用硬件 RAID 控制器。在数据重建恢复方面，检验技术比镜像技术复杂得多且慢得多。</p>\n<h3 id=\"4-RAID分类\"><a href=\"#4-RAID分类\" class=\"headerlink\" title=\"4 RAID分类\"></a>4 RAID分类</h3><p>从实现角度看， RAID 主要分为软 RAID、硬 RAID 以及混合 RAID 三种。</p>\n<h4 id=\"软-RAID\"><a href=\"#软-RAID\" class=\"headerlink\" title=\"软 RAID\"></a>软 RAID</h4><p>所有功能均有操作系统和 CPU 来完成，没有独立的 RAID 控制处理芯片和 I/O 处理芯片，效率自然最低。</p>\n<h4 id=\"硬-RAID\"><a href=\"#硬-RAID\" class=\"headerlink\" title=\"硬 RAID\"></a>硬 RAID</h4><p>配备了专门的 RAID 控制处理芯片和 I/O 处理芯片以及阵列缓冲，不占用 CPU 资源。效率很高，但成本也很高。</p>\n<h4 id=\"混合-RAID\"><a href=\"#混合-RAID\" class=\"headerlink\" title=\"混合 RAID\"></a>混合 RAID</h4><p>具备 RAID 控制处理芯片，但没有专门的I/O 处理芯片，需要 CPU 和驱动程序来完成。性能和成本在软RAID 和硬 RAID 之间。</p>\n<h3 id=\"5-常见RAID等级详解\"><a href=\"#5-常见RAID等级详解\" class=\"headerlink\" title=\"5 常见RAID等级详解\"></a>5 常见RAID等级详解</h3><h4 id=\"JBOD\"><a href=\"#JBOD\" class=\"headerlink\" title=\"JBOD\"></a>JBOD</h4><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208113559.png\" class title=\"输入图片说明\">\n\n<p>JBOD ，Just a Bunch of Disks，磁盘簇。表示一个没有控制软件提供协调控制的磁盘集合，这是 RAID区别与 JBOD 的主要因素。 JBOD 将多个物理磁盘串联起来，提供一个巨大的逻辑磁盘。</p>\n<p>JBOD 的数据存放机制是由第一块磁盘开始按顺序往后存储，当前磁盘存储空间用完后，再依次往后面的磁盘存储数据。 JBOD 存储性能完全等同于单块磁盘，而且也不提供数据安全保护。</p>\n<blockquote>\n<p>其只是简单提供一种扩展存储空间的机制，JBOD可用存储容量等于所有成员磁盘的存储空间之和</p>\n</blockquote>\n<p>JBOD 常指磁盘柜，而不论其是否提供 RAID 功能。不过，JBOD并非官方术语，官方称为Spanning。</p>\n<h4 id=\"RAID0\"><a href=\"#RAID0\" class=\"headerlink\" title=\"RAID0\"></a>RAID0</h4><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208113758.png\" class title=\"输入图片说明\">\n\n<p>RAID0 是一种简单的、无数据校验的<code>数据条带化技术</code>。实际上不是一种真正的 RAID ，因为它并不提供任何形式的冗余策略。 RAID0 将所在磁盘条带化后组成大容量的存储空间，将数据分散存储在所有磁盘中，以独立访问方式实现多块磁盘的并读访问。</p>\n<p>理论上讲，一个由 n 块磁盘组成的 RAID0 ，它的读写性能是单个磁盘性能的 n 倍，但由于总线带宽等多种因素的限制，实际的性能提升低于理论值。由于可以并发执行 I/O 操作，总线带宽得到充分利用。再加上不需要进行数据校验，<code>RAID0 的性能在所有 RAID 等级中是最高的</code>。</p>\n<p>RAID0 具有低成本、高读写性能、 100% 的高存储空间利用率等优点，但是它不提供数据冗余保护，一旦数据损坏，将无法恢复。</p>\n<p>应用场景：对数据的顺序读写要求不高，对数据的安全性和可靠性要求不高，但对系统性能要求很高的场景。</p>\n<blockquote>\n<p>RAID0与JBOD相同点：<br><br>1 ）存储容量：都是成员磁盘容量总和<br><br>2 ）磁盘利用率，都是100%，即都没有做任何的数据冗余备份<br><br>RAID0与JBOD不同点：<br><br>1 ）JBOD：数据是顺序存放的，一个磁盘存满后才会开始存放到下一个磁盘<br><br>2 ）RAID：各个磁盘中的数据写入是并行的，是通过数据条带技术写入的。其读写性能是JBOD的n倍<br></p>\n</blockquote>\n<h4 id=\"RAID1\"><a href=\"#RAID1\" class=\"headerlink\" title=\"RAID1\"></a>RAID1</h4><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208121758.png\" class title=\"输入图片说明\">\n\n<p>RAID1 就是一种<code>镜像技术</code>，它将数据完全一致地分别写到工作磁盘和镜像磁盘，它的磁盘空间利用率为 50% 。 RAID1 在数据写入时，响应时间会有所影响，但是读数据的时候没有影响。 RAID1 提供了最佳的数据保护，一旦工作磁盘发生故障，系统将自动切换到镜像磁盘，不会影响使用。</p>\n<p>RAID1是为了增强数据安全性使两块磁盘数据呈现完全镜像，从而达到安全性好、技术简单、管理方便。 RAID1 拥有完全容错的能力，但实现成本高。</p>\n<p>应用场景：对顺序读写性能要求较高，或对数据安全性要求较高的场景。</p>\n<h4 id=\"RAID10\"><a href=\"#RAID10\" class=\"headerlink\" title=\"RAID10\"></a>RAID10</h4><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208122057.png\" class title=\"输入图片说明\">\n\n<p>RAID10是一个RAID1与RAID0的组合体，所以它继承了RAID0的快速和RAID1的安全。简单来说就是，先做条带，再做镜像。发即将进来的数据先分散到不同的磁盘，再将磁盘中的数据做镜像。</p>\n<h4 id=\"RAID01\"><a href=\"#RAID01\" class=\"headerlink\" title=\"RAID01\"></a>RAID01</h4><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208122113.png\" class title=\"输入图片说明\">\n\n<p>RAID01是一个RAID0与RAID1的组合体，所以它继承了RAID0的快速和RAID1的安全。简单来说就是，先做镜像再做条带。即将进来的数据先做镜像，再将镜像数据写入到与之前数据不同的磁盘，即再做条带。</p>\n<blockquote>\n<p>RAID10要比RAID01的容错率再高，所以生产环境下一般是不使用RAID01的。</p>\n</blockquote>\n<h4 id=\"序号-主机名-IP-IP-功能-BROKER角色\"><a href=\"#序号-主机名-IP-IP-功能-BROKER角色\" class=\"headerlink\" title=\"序号 主机名/IP IP 功能 BROKER角色\"></a>序号 主机名/IP IP 功能 BROKER角色</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1 rocketmqOS1 192.168.59.164 NameServer + Broker Master1 + Slave2</span><br><span class=\"line\">2 rocketmqOS2 192.168.59.165 NameServer + Broker Master2 + Slave1</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"七、集群搭建实践\"><a href=\"#七、集群搭建实践\" class=\"headerlink\" title=\"七、集群搭建实践\"></a>七、集群搭建实践</h2><h3 id=\"1-集群架构\"><a href=\"#1-集群架构\" class=\"headerlink\" title=\"1 集群架构\"></a>1 集群架构</h3><p>这里要搭建一个双主双从异步复制的Broker集群。为了方便，这里使用了两台主机来完成集群的搭建。这两台主机的功能与broker角色分配如下表。</p>\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th align=\"center\">主机名/IP</th>\n<th align=\"right\">IP</th>\n<th align=\"right\">功能</th>\n<th align=\"right\">BROKER角色</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td align=\"center\">rocketmqOS1</td>\n<td align=\"right\">192.168.59.164</td>\n<td align=\"right\">NameServer + Broker</td>\n<td align=\"right\">Master1 + Slave2</td>\n</tr>\n<tr>\n<td>2</td>\n<td align=\"center\">rocketmqOS1</td>\n<td align=\"right\">192.168.59.165</td>\n<td align=\"right\">NameServer + Broker</td>\n<td align=\"right\">Master2 + Slave1</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-克隆生成rocketmqOS1\"><a href=\"#2-克隆生成rocketmqOS1\" class=\"headerlink\" title=\"2 克隆生成rocketmqOS1\"></a>2 克隆生成rocketmqOS1</h3><p>克隆rocketmqOS主机，并修改配置。指定主机名为rocketmqOS1。</p>\n<h3 id=\"3-修改rocketmqOS1配置文件\"><a href=\"#3-修改rocketmqOS1配置文件\" class=\"headerlink\" title=\"3 修改rocketmqOS1配置文件\"></a>3 修改rocketmqOS1配置文件</h3><h4 id=\"配置文件位置\"><a href=\"#配置文件位置\" class=\"headerlink\" title=\"配置文件位置\"></a>配置文件位置</h4><p>要修改的配置文件在rocketMQ解压目录的conf/2m-2s-async目录中。</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208122608.png\" class title=\"输入图片说明\">\n\n\n<h4 id=\"修改broker-a-properties\"><a href=\"#修改broker-a-properties\" class=\"headerlink\" title=\"修改broker-a.properties\"></a>修改broker-a.properties</h4><p>将该配置文件内容修改为如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 指定整个broker集群的名称，或者说是RocketMQ集群的名称</span></span><br><span class=\"line\">brokerClusterName=  </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 指定master-slave集群的名称。一个RocketMQ集群可以包含多个master-slave集群</span></span><br><span class=\"line\">brokerName=broker-a</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> master的brokerId为 0</span></span><br><span class=\"line\">brokerId= 0</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 指定删除消息存储过期文件的时间为凌晨 4 点</span></span><br><span class=\"line\">deleteWhen= 04</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 指定未发生更新的消息存储文件的保留时长为 48 小时， 48 小时后过期，将会被删除</span></span><br><span class=\"line\">fileReservedTime= 48</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 指定当前broker为异步复制master</span></span><br><span class=\"line\">brokerRole=ASYNC_MASTER</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 指定刷盘策略为异步刷盘</span></span><br><span class=\"line\">flushDiskType=ASYNC_FLUSH</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 指定Name Server的地址</span></span><br><span class=\"line\">namesrvAddr=192.168.59.164:9876;192.168.59.165:9876</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"修改broker-b-s-properties\"><a href=\"#修改broker-b-s-properties\" class=\"headerlink\" title=\"修改broker-b-s.properties\"></a>修改broker-b-s.properties</h4><p>将该配置文件内容修改为如下：</p>\n<h4 id=\"其它配置\"><a href=\"#其它配置\" class=\"headerlink\" title=\"其它配置\"></a>其它配置</h4><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">brokerClusterName=DefaultCluster</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 指定这是另外一个master-slave集群</span></span><br><span class=\"line\">brokerName=broker-b</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> slave的brokerId为非 0</span></span><br><span class=\"line\">brokerId=1</span><br><span class=\"line\">deleteWhen=04</span><br><span class=\"line\">fileReservedTime=48</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 指定当前broker为slave</span></span><br><span class=\"line\">brokerRole=SLAVE</span><br><span class=\"line\">flushDiskType=ASYNC_FLUSH</span><br><span class=\"line\">namesrvAddr=192.168.59.164:9876;192.168.59.165:9876</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 指定Broker对外提供服务的端口，即Broker与producer与consumer通信的端口。默认10911 。由于当前主机同时充当着master1与slave2，而前面的master1使用的是默认端口。这里需要将这两个端口加以区分，以区分出master1与slave2</span></span><br><span class=\"line\">listenPort= 11911</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 指定消息存储相关的路径。默认路径为~/store目录。由于当前主机同时充当着master1与slave2，master1使用的是默认路径，这里就需要再指定一个不同路径</span></span><br><span class=\"line\">storePathRootDir=~/store-s</span><br><span class=\"line\">storePathCommitLog=~/store-s/commitlog</span><br><span class=\"line\">storePathConsumeQueue=~/store-s/consumequeue</span><br><span class=\"line\">storePathIndex=~/store-s/index</span><br><span class=\"line\">storeCheckpoint=~/store-s/checkpoint</span><br><span class=\"line\">abortFile=~/store-s/abort</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"除了以上配置外，这些配置文件中还可以设置其它属性。\"><a href=\"#除了以上配置外，这些配置文件中还可以设置其它属性。\" class=\"headerlink\" title=\"除了以上配置外，这些配置文件中还可以设置其它属性。\"></a>除了以上配置外，这些配置文件中还可以设置其它属性。</h4><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">指定整个broker集群的名称，或者说是RocketMQ集群的名称</span></span><br><span class=\"line\">brokerClusterName=rocket-MS</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">指定master-slave集群的名称。一个RocketMQ集群可以包含多个master-slave集群</span></span><br><span class=\"line\">brokerName=broker-a</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">0 表示 Master，&gt;0 表示 Slave</span></span><br><span class=\"line\">brokerId=0</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">nameServer地址，分号分割</span></span><br><span class=\"line\">namesrvAddr=nameserver1:9876;nameserver2:9876</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">默认为新建Topic所创建的队列数</span></span><br><span class=\"line\">defaultTopicQueueNums=4</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">是否允许 Broker 自动创建Topic，建议生产环境中关闭</span></span><br><span class=\"line\">autoCreateTopicEnable=true</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">是否允许 Broker 自动创建订阅组，建议生产环境中关闭</span></span><br><span class=\"line\">autoCreateSubscriptionGroup=true</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">Broker对外提供服务的端口，即Broker与producer与consumer通信的端口</span></span><br><span class=\"line\">listenPort=10911</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">HA高可用监听端口，即Master与Slave间通信的端口，默认值为listenPort+1</span></span><br><span class=\"line\">haListenPort=10912</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">指定删除消息存储过期文件的时间为凌晨 4 点</span></span><br><span class=\"line\">deleteWhen=04</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">指定未发生更新的消息存储文件的保留时长为 48 小时， 48 小时后过期，将会被删除</span></span><br><span class=\"line\">fileReservedTime=48</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">指定commitLog目录中每个文件的大小，默认1G</span></span><br><span class=\"line\">mapedFileSizeCommitLog=1073741824</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">指定ConsumeQueue的每个Topic的每个Queue文件中可以存放的消息数量，默认30w条</span></span><br><span class=\"line\">mapedFileSizeConsumeQueue=300000</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">在清除过期文件时，如果该文件被其他线程所占用（引用数大于 0 ，比如读取消息），此时会阻止此次删除任务，同时在第一次试图删除该文件时记录当前时间戳。该属性则表示从第一次拒绝删除后开始计时，该文件最多可以保留的时长。在此时间内若引用数仍不为 0 ，则删除仍会被拒绝。不过时间到后，文件将被强制删除</span></span><br><span class=\"line\">destroyMapedFileIntervalForcibly=120000</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">指定commitlog、consumequeue所在磁盘分区的最大使用率，超过该值，则需立即清除过期文件</span></span><br><span class=\"line\">diskMaxUsedSpaceRatio=88</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">指定store目录的路径，默认在当前用户主目录中</span></span><br><span class=\"line\">storePathRootDir=/usr/local/rocketmq-all-4.5.0/store</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">commitLog目录路径</span></span><br><span class=\"line\">storePathCommitLog=/usr/local/rocketmq-all-4.5.0/store/commitlog</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">consumeueue目录路径</span></span><br><span class=\"line\">storePathConsumeQueue=/usr/local/rocketmq-all-4.5.0/store/consumequeue</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">index目录路径</span></span><br><span class=\"line\">storePathIndex=/usr/local/rocketmq-all-4.5.0/store/index</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">checkpoint文件路径</span></span><br><span class=\"line\">storeCheckpoint=/usr/local/rocketmq-all-4.5.0/store/checkpoint</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">abort文件路径</span></span><br><span class=\"line\">abortFile=/usr/local/rocketmq-all-4.5.0/store/abort</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">指定消息的最大大小</span></span><br><span class=\"line\">maxMessageSize= 65536</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">Broker的角色</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> - ASYNC_MASTER 异步复制Master</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> - SYNC_MASTER 同步双写Master</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> - SLAVE</span></span><br><span class=\"line\">brokerRole=SYNC_MASTER</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">刷盘策略</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> - ASYNC_FLUSH 异步刷盘</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> - SYNC_FLUSH 同步刷盘</span></span><br><span class=\"line\">flushDiskType=SYNC_FLUSH</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">发消息线程池数量</span></span><br><span class=\"line\">sendMessageThreadPoolNums=128</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">拉消息线程池数量</span></span><br><span class=\"line\">pullMessageThreadPoolNums=128</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">强制指定本机IP，需要根据每台机器进行修改。官方介绍可为空，系统默认自动识别，但多网卡时IP地址可能读取错误</span></span><br><span class=\"line\">brokerIP1=192.168.3.105</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-克隆生成rocketmqOS2\"><a href=\"#4-克隆生成rocketmqOS2\" class=\"headerlink\" title=\"4 克隆生成rocketmqOS2\"></a>4 克隆生成rocketmqOS2</h3><p>克隆rocketmqOS1主机，并修改配置。指定主机名为rocketmqOS2。</p>\n<h3 id=\"5-修改rocketmqOS2配置文件\"><a href=\"#5-修改rocketmqOS2配置文件\" class=\"headerlink\" title=\"5 修改rocketmqOS2配置文件\"></a>5 修改rocketmqOS2配置文件</h3><p>对于rocketmqOS2主机，同样需要修改rocketMQ解压目录的conf目录的子目录2m-2s-async中的两个配置文件。</p>\n<h4 id=\"修改broker-b-properties\"><a href=\"#修改broker-b-properties\" class=\"headerlink\" title=\"修改broker-b.properties\"></a>修改broker-b.properties</h4><p>将该配置文件内容修改为如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">brokerClusterName=DefaultCluster</span><br><span class=\"line\">brokerName=broker-b</span><br><span class=\"line\">brokerId=0</span><br><span class=\"line\">deleteWhen=04</span><br><span class=\"line\">fileReservedTime=48</span><br><span class=\"line\">brokerRole=ASYNC_MASTER</span><br><span class=\"line\">flushDiskType=ASYNC_FLUSH</span><br><span class=\"line\">namesrvAddr=192.168.59.164:9876;192.168.59.165:9876</span><br></pre></td></tr></table></figure>\n\n<p>修改broker-a-s.properties</p>\n<h4 id=\"将该配置文件内容修改为如下：\"><a href=\"#将该配置文件内容修改为如下：\" class=\"headerlink\" title=\"将该配置文件内容修改为如下：\"></a>将该配置文件内容修改为如下：</h4><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">brokerClusterName=DefaultCluster</span><br><span class=\"line\">brokerName=broker-a</span><br><span class=\"line\">brokerId=1</span><br><span class=\"line\">deleteWhen=04</span><br><span class=\"line\">fileReservedTime=48</span><br><span class=\"line\">brokerRole=SLAVE</span><br><span class=\"line\">flushDiskType=ASYNC_FLUSH</span><br><span class=\"line\">namesrvAddr=192.168.59.164:9876;192.168.59.165:9876</span><br><span class=\"line\">listenPort=11911</span><br><span class=\"line\">storePathRootDir=~/store-s</span><br><span class=\"line\">storePathCommitLog=~/store-s/commitlog</span><br><span class=\"line\">storePathConsumeQueue=~/store-s/consumequeue</span><br><span class=\"line\">storePathIndex=~/store-s/index</span><br><span class=\"line\">storeCheckpoint=~/store-s/checkpoint</span><br><span class=\"line\">abortFile=~/store-s/abort</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-启动服务器\"><a href=\"#6-启动服务器\" class=\"headerlink\" title=\"6 启动服务器\"></a>6 启动服务器</h3><h4 id=\"启动NameServer集群\"><a href=\"#启动NameServer集群\" class=\"headerlink\" title=\"启动NameServer集群\"></a>启动NameServer集群</h4><p>分别启动rocketmqOS1与rocketmqOS2两个主机中的NameServer。启动命令完全相同。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">nohup sh bin/mqnamesrv &amp;</span><br><span class=\"line\">tail -f ~/logs/rocketmqlogs/namesrv.log</span><br></pre></td></tr></table></figure>\n<h4 id=\"启动两个Master\"><a href=\"#启动两个Master\" class=\"headerlink\" title=\"启动两个Master\"></a>启动两个Master</h4><p>分别启动rocketmqOS1与rocketmqOS2两个主机中的broker master。注意，它们指定所要加载的配置文件是不同的。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">nohup sh bin/mqbroker -c conf/2m-2s-async/broker-a.properties &amp;</span><br><span class=\"line\">tail -f ~/logs/rocketmqlogs/broker.log</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">nohup sh bin/mqbroker -c conf/2m-2s-async/broker-b.properties &amp;</span><br><span class=\"line\">tail -f ~/logs/rocketmqlogs/broker.log</span><br></pre></td></tr></table></figure>\n<h4 id=\"启动两个Slave\"><a href=\"#启动两个Slave\" class=\"headerlink\" title=\"启动两个Slave\"></a>启动两个Slave</h4><p>分别启动rocketmqOS1与rocketmqOS2两个主机中的broker slave。注意，它们指定所要加载的配置文件是不同的。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">nohup sh bin/mqbroker -c conf/2m-2s-async/broker-b-s.properties &amp;</span><br><span class=\"line\">tail -f ~/logs/rocketmqlogs/broker.log</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">nohup sh bin/mqbroker -c conf/2m-2s-async/broker-a-s.properties &amp;</span><br><span class=\"line\">tail -f ~/logs/rocketmqlogs/broker.log</span><br></pre></td></tr></table></figure>\n<h2 id=\"八、mqadmin命令\"><a href=\"#八、mqadmin命令\" class=\"headerlink\" title=\"八、mqadmin命令\"></a>八、mqadmin命令</h2><p>在mq解压目录的bin目录下有一个mqadmin命令，该命令是一个运维指令，用于对mq的主题，集群，broker 等信息进行管理。</p>\n<h3 id=\"1-修改bin-tools-sh\"><a href=\"#1-修改bin-tools-sh\" class=\"headerlink\" title=\"1 修改bin/tools.sh\"></a>1 修改bin/tools.sh</h3><p>在运行mqadmin命令之前，先要修改mq解压目录下bin/tools.sh配置的JDK的ext目录位置。本机的ext目录在<code>/usr/java/jdk1.8.0_161/jre/lib/ext</code>。</p>\n<p>使用vim命令打开tools.sh文件，并在JAVA_OPT配置的-Djava.ext.dirs这一行的后面添加ext的路径。</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208123848.png\" class title=\"输入图片说明\">\n\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms1g -Xmx1g -Xmn256m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=128m&quot;</span><br><span class=\"line\">JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -Djava.ext.dirs=$&#123;BASE_DIR&#125;/lib:$&#123;JAVA_HOME&#125;/jre/lib/ext:$&#123;JAVA_HOME&#125;/lib/ext:/usr/java/jdk1.8.0_161/jre/lib/ext&quot;</span><br><span class=\"line\">JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -cp $&#123;CLASSPATH&#125;&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-运行mqadmin\"><a href=\"#2-运行mqadmin\" class=\"headerlink\" title=\"2 运行mqadmin\"></a>2 运行mqadmin</h3><p>直接运行该命令，可以看到其可以添加的commands。通过这些commands可以完成很多的功能。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@mqOS rocketmq-all-4.8.0-bin-release]# ./bin/mqadmin</span><br><span class=\"line\">The most commonly used mqadmin commands are:</span><br><span class=\"line\">updateTopic Update or create topic</span><br><span class=\"line\">deleteTopic Delete topic from broker and NameServer.</span><br><span class=\"line\">updateSubGroup Update or create subscription group</span><br><span class=\"line\">deleteSubGroup Delete subscription group from broker.</span><br><span class=\"line\">updateBrokerConfig Update broker&#x27;s config</span><br><span class=\"line\">updateTopicPerm Update topic perm</span><br><span class=\"line\">topicRoute Examine topic route info</span><br><span class=\"line\">topicStatus Examine topic Status info</span><br><span class=\"line\">topicClusterList get cluster info for topic</span><br><span class=\"line\">brokerStatus Fetch broker runtime status data</span><br><span class=\"line\">queryMsgById Query Message by Id</span><br><span class=\"line\">queryMsgByKey Query Message by Key</span><br><span class=\"line\">queryMsgByUniqueKey Query Message by Unique key</span><br><span class=\"line\">queryMsgByOffset Query Message by offset</span><br><span class=\"line\">QueryMsgTraceById query a message trace</span><br><span class=\"line\">printMsg Print Message Detail</span><br><span class=\"line\">printMsgByQueue Print Message Detail</span><br><span class=\"line\">sendMsgStatus send msg to broker.</span><br><span class=\"line\">brokerConsumeStats Fetch broker consume stats data</span><br><span class=\"line\">producerConnection Query producer&#x27;s socket connection and clientversion</span><br><span class=\"line\">consumerConnection Query consumer&#x27;s socket connection, client version and subscription</span><br><span class=\"line\">consumerProgress Query consumers&#x27;s progress, speed</span><br><span class=\"line\">consumerStatus Query consumer&#x27;s internal data structure</span><br><span class=\"line\">cloneGroupOffset clone offset from other group.</span><br><span class=\"line\">clusterList List all of clusters</span><br><span class=\"line\">topicList Fetch all topic list from name server</span><br><span class=\"line\">updateKvConfig Create or update KV config.</span><br><span class=\"line\">deleteKvConfig Delete KV config.</span><br><span class=\"line\">wipeWritePerm Wipe write perm of broker in all name server</span><br><span class=\"line\">resetOffsetByTime Reset consumer offset by timestamp(without client restart).</span><br><span class=\"line\">updateOrderConf Create or update or delete order conf</span><br><span class=\"line\">cleanExpiredCQ Clean expired ConsumeQueue on broker.</span><br><span class=\"line\">cleanUnusedTopic Clean unused topic on broker.</span><br><span class=\"line\">startMonitoring Start Monitoring</span><br><span class=\"line\">statsAll Topic and Consumer tps stats</span><br><span class=\"line\">allocateMQ Allocate MQ</span><br><span class=\"line\">checkMsgSendRT check message send response time</span><br><span class=\"line\">clusterRT List All clusters Message Send RT</span><br><span class=\"line\">getNamesrvConfig Get configs of name server.</span><br><span class=\"line\">updateNamesrvConfig Update configs of name server.</span><br><span class=\"line\">getBrokerConfig Get broker config by cluster or special broker!</span><br><span class=\"line\">queryCq Query cq command.</span><br><span class=\"line\">sendMessage Send a message</span><br><span class=\"line\">consumeMessage Consume message</span><br><span class=\"line\">updateAclConfig Update acl config yaml file in broker</span><br><span class=\"line\">deleteAccessConfig Delete Acl Config Account in broker</span><br><span class=\"line\">clusterAclConfigVersion List all of acl config version information in cluster</span><br><span class=\"line\">updateGlobalWhiteAddr Update global white address for acl Config File in broker</span><br><span class=\"line\">getAccessConfigSubCommand List all of acl config information in cluster</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-该命令的官网详解\"><a href=\"#3-该命令的官网详解\" class=\"headerlink\" title=\"3 该命令的官网详解\"></a>3 该命令的官网详解</h3><h4 id=\"该命令在官网中有详细的用法解释。\"><a href=\"#该命令在官网中有详细的用法解释。\" class=\"headerlink\" title=\"该命令在官网中有详细的用法解释。\"></a>该命令在官网中有详细的用法解释。</h4><p><a href=\"https://github.com/apache/rocketmq/blob/master/docs/cn/operation.md\">https://github.com/apache/rocketmq/blob/master/docs/cn/operation.md</a></p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208124241.png\" class title=\"输入图片说明\">\n\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208124258.png\" class title=\"输入图片说明\">\n\n<h1 id=\"第-3-章-RocketMQ工作原理\"><a href=\"#第-3-章-RocketMQ工作原理\" class=\"headerlink\" title=\"第 3 章 RocketMQ工作原理\"></a>第 3 章 RocketMQ工作原理</h1><h2 id=\"一、消息的生产\"><a href=\"#一、消息的生产\" class=\"headerlink\" title=\"一、消息的生产\"></a>一、消息的生产</h2><h3 id=\"1-消息的生产过程\"><a href=\"#1-消息的生产过程\" class=\"headerlink\" title=\"1 消息的生产过程\"></a>1 消息的生产过程</h3><p>Producer可以将消息写入到某Broker中的某Queue中，其经历了如下过程：</p>\n<ul>\n<li>Producer发送消息之前，会先向NameServer发出获取消息Topic的路由信息的请求</li>\n<li>NameServer返回该Topic的路由表及Broker列表</li>\n<li>Producer根据代码中指定的Queue选择策略，从Queue列表中选出一个队列，用于后续存储消息</li>\n<li>Produer对消息做一些特殊处理，例如，消息本身超过4M，则会对其进行压缩</li>\n<li>Producer向选择出的Queue所在的Broker发出RPC请求，将消息发送到选择出的Queue</li>\n</ul>\n<blockquote>\n<p>路由表：实际是一个Map，key为Topic名称，value是一个QueueData实例列表。QueueData并不是一个Queue对应一个QueueData，而是一个Broker中该Topic的所有Queue对应一个QueueData。即，只要涉及到该Topic的Broker，一个Broker对应一个QueueData。QueueData中包含brokerName。简单来说，路由表的key为Topic名称，value则为所有涉及该Topic的BrokerName列表。</p>\n</blockquote>\n<blockquote>\n<p>Broker列表：其实际也是一个Map。key为brokerName，value为BrokerData。一个Broker对应一个BrokerData实例，对吗？不对。一套brokerName名称相同的Master-Slave小集群对应一个BrokerData。BrokerData中包含brokerName及一个map。该map的key为brokerId，value为该broker对应的地址。brokerId为 0 表示该broker为Master，非 0 表示Slave。</p>\n</blockquote>\n<h3 id=\"2-Queue选择算法\"><a href=\"#2-Queue选择算法\" class=\"headerlink\" title=\"2 Queue选择算法\"></a>2 Queue选择算法</h3><p>对于无序消息，其Queue选择算法，也称为消息投递算法，常见的有两种：</p>\n<h4 id=\"轮询算法\"><a href=\"#轮询算法\" class=\"headerlink\" title=\"轮询算法\"></a>轮询算法</h4><p>默认选择算法。该算法保证了每个Queue中可以均匀的获取到消息。</p>\n<blockquote>\n<p>该算法存在一个问题：由于某些原因，在某些Broker上的Queue可能投递延迟较严重。从而导致Producer的缓存队列中出现较大的消息积压，影响消息的投递性能。</p>\n</blockquote>\n<h4 id=\"最小投递延迟算法\"><a href=\"#最小投递延迟算法\" class=\"headerlink\" title=\"最小投递延迟算法\"></a>最小投递延迟算法</h4><p>该算法会统计每次消息投递的时间延迟，然后根据统计出的结果将消息投递到时间延迟最小的Queue。如果延迟相同，则采用轮询算法投递。该算法可以有效提升消息的投递性能。</p>\n<blockquote>\n<p>该算法也存在一个问题：消息在Queue上的分配不均匀。投递延迟小的Queue其可能会存在大量的消息。而对该Queue的消费者压力会增大，降低消息的消费能力，可能会导致MQ中消息的堆积。</p>\n</blockquote>\n<h2 id=\"二、消息的存储\"><a href=\"#二、消息的存储\" class=\"headerlink\" title=\"二、消息的存储\"></a>二、消息的存储</h2><p>RocketMQ中的消息存储在本地文件系统中，这些相关文件默认在当前用户主目录下的store目录中。</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208133814.png\" class title=\"输入图片说明\">\n\n<ul>\n<li>abort：该文件在Broker启动后会自动创建，正常关闭Broker，该文件会自动消失。若在没有启动Broker的情况下，发现这个文件是存在的，则说明之前Broker的关闭是非正常关闭。</li>\n<li>checkpoint：其中存储着commitlog、consumequeue、index文件的最后刷盘时间戳</li>\n<li>commitlog：其中存放着commitlog文件，而消息是写在commitlog文件中的</li>\n<li>conæg：存放着Broker运行期间的一些配置数据</li>\n<li>consumequeue：其中存放着consumequeue文件，队列就存放在这个目录中</li>\n<li>index：其中存放着消息索引文件indexFile</li>\n<li>lock：运行期间使用到的全局资源锁</li>\n</ul>\n<h3 id=\"1-commitlog文件\"><a href=\"#1-commitlog文件\" class=\"headerlink\" title=\"1 commitlog文件\"></a>1 commitlog文件</h3><blockquote>\n<p>说明：在很多资料中commitlog目录中的文件简单就称为commitlog文件。但在源码中，该文件被命名为mappedFile。</p>\n</blockquote>\n<h4 id=\"目录与文件\"><a href=\"#目录与文件\" class=\"headerlink\" title=\"目录与文件\"></a>目录与文件</h4><p>commitlog目录中存放着很多的mappedFile文件，当前Broker中的所有消息都是落盘到这些mappedFile文件中的。mappedFile文件大小为1G（小于等于1G），文件名由 20 位十进制数构成，表示当前文件的第一条消息的起始位移偏移量。</p>\n<blockquote>\n<p>第一个文件名一定是 20 位 0 构成的。因为第一个文件的第一条消息的偏移量commitlog offset为 0 <br><br><br>当第一个文件放满时，则会自动生成第二个文件继续存放消息。假设第一个文件大小是 1073741820 字节（1G = 1073741824字节），则第二个文件名就是 00000000001073741824 。<br><br><br>以此类推，第n个文件名应该是前n-1个文件大小之和。<br><br><br>一个Broker中所有mappedFile文件的commitlog offset是连续的</p>\n</blockquote>\n<p>需要注意的是，一个Broker中仅包含一个commitlog目录，所有的mappedFile文件都是存放在该目录中的。即无论当前Broker中存放着多少Topic的消息，这些消息都是被顺序写入到了mappedFile文件中的。也就是说，这些消息在Broker中存放时并没有被按照Topic进行分类存放。</p>\n<blockquote>\n<p>mappedFile文件是顺序读写的文件，所有其访问效率很高<br><br><br>无论是SSD磁盘还是SATA磁盘，通常情况下，顺序存取效率都会高于随机存取。</p>\n</blockquote>\n<h4 id=\"消息单元\"><a href=\"#消息单元\" class=\"headerlink\" title=\"消息单元\"></a>消息单元</h4><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208134157.png\" class title=\"输入图片说明\">\n\n<p>mappedFile文件内容由一个个的<code>消息单元</code>构成。每个消息单元中包含消息总长度MsgLen、消息的物理位置physicalOffset、消息体内容Body、消息体长度BodyLength、消息主题Topic、Topic长度 TopicLength、消息生产者BornHost、消息发送时间戳BornTimestamp、消息所在的队列QueueId、消息在Queue中存储的偏移量QueueOffset等近 20 余项消息相关属性。</p>\n<blockquote>\n<p>需要注意到，消息单元中是包含Queue相关属 性的。所以，我们在后续的学习中，就需要十分留意commitlog与queue间的关系是什么？<br><br><br>一个mappedFile文件中第m+1个消息单元的commitlog offset偏移量<br><br><br>L(m+1) = L(m) + MsgLen(m) (m &gt;= 0)</p>\n</blockquote>\n<h3 id=\"2-consumequeue\"><a href=\"#2-consumequeue\" class=\"headerlink\" title=\"2 consumequeue\"></a>2 consumequeue</h3><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208134355.png\" class title=\"输入图片说明\">\n<h4 id=\"目录与文件-1\"><a href=\"#目录与文件-1\" class=\"headerlink\" title=\"目录与文件\"></a>目录与文件</h4><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208134415.png\" class title=\"输入图片说明\">\n\n<p>为了提高效率，会为每个Topic在~/store/consumequeue中创建一个目录，目录名为Topic名称。在该Topic目录下，会再为每个该Topic的Queue建立一个目录，目录名为queueId。每个目录中存放着若干consumequeue文件，consumequeue文件是commitlog的索引文件，可以根据consumequeue定位到具体的消息。</p>\n<p>consumequeue文件名也由 20 位数字构成，表示当前文件的第一个索引条目的起始位移偏移量。与mappedFile文件名不同的是，其后续文件名是固定的。因为consumequeue文件大小是固定不变的。</p>\n<h4 id=\"索引条目\"><a href=\"#索引条目\" class=\"headerlink\" title=\"索引条目\"></a>索引条目</h4><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208134454.png\" class title=\"输入图片说明\">\n\n<p>每个consumequeue文件可以包含30w个索引条目，每个索引条目包含了三个消息重要属性：消息在mappedFile文件中的偏移量CommitLog Offset、消息长度、消息Tag的hashcode值。这三个属性占 20个字节，所以每个文件的大小是固定的30w * 20字节。</p>\n<blockquote>\n<p>一个consumequeue文件中所有消息的Topic一定是相同的。但每条消息的Tag可能是不同的。</p>\n</blockquote>\n<h3 id=\"3-对文件的读写\"><a href=\"#3-对文件的读写\" class=\"headerlink\" title=\"3 对文件的读写\"></a>3 对文件的读写</h3><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208134538.png\" class title=\"输入图片说明\">\n\n<h4 id=\"消息写入\"><a href=\"#消息写入\" class=\"headerlink\" title=\"消息写入\"></a>消息写入</h4><p>一条消息进入到Broker后经历了以下几个过程才最终被持久化。</p>\n<ul>\n<li>Broker根据queueId，获取到该消息对应索引条目要在consumequeue目录中的写入偏移量，即QueueOffset</li>\n<li>将queueId、queueOffset等数据，与消息一起封装为消息单元</li>\n<li>将消息单元写入到commitlog</li>\n<li>同时，形成消息索引条目</li>\n<li>将消息索引条目分发到相应的consumequeue</li>\n</ul>\n<h4 id=\"消息拉取\"><a href=\"#消息拉取\" class=\"headerlink\" title=\"消息拉取\"></a>消息拉取</h4><ul>\n<li><p>当Consumer来拉取消息时会经历以下几个步骤：</p>\n<ul>\n<li>Consumer获取到其要消费消息所在Queue的消费偏移量offset，计算出其要消费消息的消息offset<blockquote>\n<p>消费offset即消费进度，consumer对某个Queue的消费offset，即消费到了该Queue的第几条消息<br><br>消息offset = 消费offset + 1</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>Consumer向Broker发送拉取请求，其中会包含其要拉取消息的Queue、消息offset及消息Tag。</p>\n</li>\n<li><p>Broker计算在该consumequeue中的queueOffset。</p>\n<blockquote>\n<p>queueOffset = 消息offset * 20字节</p>\n</blockquote>\n</li>\n<li><p>从该queueOffset处开始向后查找第一个指定Tag的索引条目。</p>\n</li>\n<li><p>解析该索引条目的前 8 个字节，即可定位到该消息在commitlog中的commitlog offset</p>\n</li>\n<li><p>从对应commitlog offset中读取消息单元，并发送给Consumer</p>\n</li>\n</ul>\n<h4 id=\"性能提升\"><a href=\"#性能提升\" class=\"headerlink\" title=\"性能提升\"></a>性能提升</h4><p>RocketMQ中，无论是消息本身还是消息索引，都是存储在磁盘上的。其不会影响消息的消费吗？当然不会。其实RocketMQ的性能在目前的MQ产品中性能是非常高的。因为系统通过一系列相关机制大大提升了性能。</p>\n<p>首先，RocketMQ对文件的读写操作是通过<code>mmap零拷贝</code>进行的，将对文件的操作转化为直接对内存地址进行操作，从而极大地提高了文件的读写效率。</p>\n<p>其次，consumequeue中的数据是顺序存放的，还引入了<code>PageCache的预读取机制</code>，使得对consumequeue文件的读取几乎接近于内存读取，即使在有消息堆积情况下也不会影响性能。</p>\n<blockquote>\n<p>PageCache机制，页缓存机制，是OS对文件的缓存机制，用于加速对文件的读写操作。一般来说，程序对文件进行顺序读写的速度几乎接近于内存读写速度，主要原因是由于OS使用PageCache机制对读写访问操作进行性能优化，将一部分的内存用作PageCache。<br><br><br>1)写操作：OS会先将数据写入到PageCache中，随后会以异步方式由pdæush（page dirty æush)内核线程将Cache中的数据刷盘到物理磁盘<br><br>2)读操作：若用户要读取数据，其首先会从PageCache中读取，若没有命中，则OS在从物理磁盘上加载该数据到PageCache的同时，也会顺序 对其相邻数据块中的数据进行预读取。</p>\n</blockquote>\n<p>RocketMQ中可能会影响性能的是对commitlog文件的读取。因为对commitlog文件来说，读取消息时会产生大量的随机访问，而随机访问会严重影响性能。不过，如果选择合适的系统IO调度算法，比如设置调度算法为Deadline（采用SSD固态硬盘的话），随机读的性能也会有所提升。</p>\n<h3 id=\"4-与Kafka的对比\"><a href=\"#4-与Kafka的对比\" class=\"headerlink\" title=\"4 与Kafka的对比\"></a>4 与Kafka的对比</h3><p>RocketMQ的很多思想来源于Kafka，其中commitlog与consumequeue就是。</p>\n<p>RocketMQ中的commitlog目录与consumequeue的结合就类似于Kafka中的partition分区目录。mappedFile文件就类似于Kafka中的segment段。</p>\n<blockquote>\n<p>Kafka中的Topic的消息被分割为一个或多个partition。partition是一个物理概念，对应到系统上就是topic目录下的一个或多个目录。每个partition中包含的文件称为segment，是具体存放消息的文件。<br><br><br>Kafka中消息存放的目录结构是：topic目录下有partition目录，partition目录下有segment文件<br><br><br>Kafka中没有二级分类标签Tag这个概念<br><br><br>Kafka中无需索引文件。因为生产者是将消息直接写在了partition中的，消费者也是直接从partition中读取数据的</p>\n</blockquote>\n<h2 id=\"三、indexFile\"><a href=\"#三、indexFile\" class=\"headerlink\" title=\"三、indexFile\"></a>三、indexFile</h2><p>除了通过通常的指定Topic进行消息消费外，RocketMQ还提供了根据key进行消息查询的功能。该查询是通过store目录中的index子目录中的indexFile进行索引实现的快速查询。当然，这个indexFile中的索引数据是在<code>包含了key的消息</code>被发送到Broker时写入的。如果消息中没有包含key，则不会写入。</p>\n<h3 id=\"1-索引条目结构\"><a href=\"#1-索引条目结构\" class=\"headerlink\" title=\"1 索引条目结构\"></a>1 索引条目结构</h3><p>每个Broker中会包含一组indexFile，每个indexFile都是以一个<code>时间戳</code>命名的（这个indexFile被创建时的时间戳）。每个indexFile文件由三部分构成：indexHeader，slots槽位，indexes索引数据。每个<br>indexFile文件中包含500w个slot槽。而每个slot槽又可能会挂载很多的index索引单元。</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208135939.png\" class title=\"输入图片说明\">\n\n<p>indexHeader固定 40 个字节，其中存放着如下数据：</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208135949.png\" class title=\"输入图片说明\">\n\n<ul>\n<li>beginTimestamp：该indexFile中第一条消息的存储时间</li>\n<li>endTimestamp：该indexFile中最后一条消息存储时间</li>\n<li>beginPhyoffset：该indexFile中第一条消息在commitlog中的偏移量commitlog offset</li>\n<li>endPhyoffset：该indexFile中最后一条消息在commitlog中的偏移量commitlog offset</li>\n<li>hashSlotCount：已经填充有index的slot数量（并不是每个slot槽下都挂载有index索引单元，这里统计的是所有挂载了index索引单元的slot槽的数量）</li>\n<li>indexCount：该indexFile中包含的索引单元个数（统计出当前indexFile中所有slot槽下挂载的所有index索引单元的数量之和）</li>\n</ul>\n<p>indexFile中最复杂的是Slots与Indexes间的关系。在实际存储时，Indexes是在Slots后面的，但为了便于理解，将它们的关系展示为如下形式：</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208140054.png\" class title=\"输入图片说明\">\n\n<p><code>key的hash值 % 500w</code>的结果即为slot槽位，然后将该slot值修改为该index索引单元的indexNo，根据这个indexNo可以计算出该index单元在indexFile中的位置。不过，该取模结果的重复率是很高的，为了解决该问题，在每个index索引单元中增加了preIndexNo，用于指定该slot中当前index索引单元的前一个index索引单元。而slot中始终存放的是其下最新的index索引单元的indexNo，这样的话，只要找到了slot就可以找到其最新的index索引单元，而通过这个index索引单元就可以找到其之前的所有index索引单元。</p>\n<blockquote>\n<p>indexNo是一个在indexFile中的流水号，从 0 开始依次递增。即在一个indexFile中所有indexNo是以此递增的。indexNo在index索引单元中是没有体现的，其是通过indexes中依次数出来的。</p>\n</blockquote>\n<p>index索引单元默写 20 个字节，其中存放着以下四个属性：</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208140159.png\" class title=\"输入图片说明\">\n\n<ul>\n<li>keyHash：消息中指定的业务key的hash值</li>\n<li>phyOffset：当前key对应的消息在commitlog中的偏移量commitlog offset</li>\n<li>timeDiff：当前key对应消息的存储时间与当前indexFile创建时间的时间差</li>\n<li>preIndexNo：当前slot下当前index索引单元的前一个index索引单元的indexNo</li>\n</ul>\n<h3 id=\"2-indexFile的创建\"><a href=\"#2-indexFile的创建\" class=\"headerlink\" title=\"2 indexFile的创建\"></a>2 indexFile的创建</h3><p>indexFile的文件名为当前文件被创建时的时间戳。这个时间戳有什么用处呢？</p>\n<p>根据业务key进行查询时，查询条件除了key之外，还需要指定一个要查询的时间戳，表示要查询不大于该时间戳的最新的消息，即查询指定时间戳之前存储的最新消息。这个时间戳文件名可以简化查询，提高查询效率。具体后面会详细讲解。</p>\n<p>indexFile文件是何时创建的？其创建的条件（时机）有两个：</p>\n<ul>\n<li>当第一条带key的消息发送来后，系统发现没有indexFile，此时会创建第一个indexFile文件</li>\n<li>当一个indexFile中挂载的index索引单元数量超出2000w个时，会创建新的indexFile。当带key的消息发送到来后，系统会找到最新的indexFile，并从其indexHeader的最后 4 字节中读取到indexCount。若indexCount &gt;= 2000w时，会创建新的indexFile。</li>\n</ul>\n<blockquote>\n<p>由于可以推算出，一个indexFile的最大大小是：(40 + 500w * 4 + 2000w * 20)字节</p>\n</blockquote>\n<h3 id=\"3-查询流程\"><a href=\"#3-查询流程\" class=\"headerlink\" title=\"3 查询流程\"></a>3 查询流程</h3><p>当消费者通过业务key来查询相应的消息时，其需要经过一个相对较复杂的查询流程。不过，在分析查询流程之前，首先要清楚几个定位计算式子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">计算指定消息key的slot槽位序号：</span><br><span class=\"line\">slot槽位序号 = key的hash % 500w (式子1)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">计算槽位序号为n的slot在indexFile中的起始位置：</span><br><span class=\"line\">slot(n)位置 = 40 + (n - 1) * 4 (式子2)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">计算indexNo为m的index在indexFile中的位置：</span><br><span class=\"line\">index(m)位置 = 40 + 500w * 4 + (m - 1) * 20 (式子3)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>40 为indexFile中indexHeader的字节数<br><br>500w * 4 是所有slots所占的字节数</p>\n</blockquote>\n<h4 id=\"具体查询流程如下：\"><a href=\"#具体查询流程如下：\" class=\"headerlink\" title=\"具体查询流程如下：\"></a>具体查询流程如下：</h4><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208140740.png\" class title=\"输入图片说明\">\n<h2 id=\"四、消息的消费\"><a href=\"#四、消息的消费\" class=\"headerlink\" title=\"四、消息的消费\"></a>四、消息的消费</h2><p>消费者从Broker中获取消息的方式有两种：pull拉取方式和push推动方式。消费者组对于消息消费的模式又分为两种：集群消费Clustering和广播消费Broadcasting。</p>\n<h3 id=\"1-获取消费类型\"><a href=\"#1-获取消费类型\" class=\"headerlink\" title=\"1 获取消费类型\"></a>1 获取消费类型</h3><h4 id=\"拉取式消费\"><a href=\"#拉取式消费\" class=\"headerlink\" title=\"拉取式消费\"></a>拉取式消费</h4><p>Consumer主动从Broker中拉取消息，主动权由Consumer控制。一旦获取了批量消息，就会启动消费过程。不过，该方式的实时性较弱，即Broker中有了新的消息时消费者并不能及时发现并消费。</p>\n<blockquote>\n<p>由于拉取时间间隔是由用户指定的，所以在设置该间隔时需要注意平稳：间隔太短，空请求比例会增加；间隔太长，消息的实时性太差</p>\n</blockquote>\n<h4 id=\"推送式消费\"><a href=\"#推送式消费\" class=\"headerlink\" title=\"推送式消费\"></a>推送式消费</h4><p>该模式下Broker收到数据后会主动推送给Consumer。该获取方式一般实时性较高。</p>\n<p>该获取方式是典型的<code>发布-订阅</code>模式，即Consumer向其关联的Queue注册了监听器，一旦发现有新的消息到来就会触发回调的执行，回调方法是Consumer去Queue中拉取消息。而这些都是基于Consumer与Broker间的长连接的。长连接的维护是需要消耗系统资源的。</p>\n<h4 id=\"对比-1\"><a href=\"#对比-1\" class=\"headerlink\" title=\"对比\"></a>对比</h4><ul>\n<li>pull：需要应用去实现对关联Queue的遍历，实时性差；但便于应用控制消息的拉取</li>\n<li>push：封装了对关联Queue的遍历，实时性强，但会占用较多的系统资源</li>\n</ul>\n<h3 id=\"2-消费模式\"><a href=\"#2-消费模式\" class=\"headerlink\" title=\"2 消费模式\"></a>2 消费模式</h3><h4 id=\"广播消费\"><a href=\"#广播消费\" class=\"headerlink\" title=\"广播消费\"></a>广播消费</h4><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208141005.png\" class title=\"输入图片说明\">\n\n<p>广播消费模式下，相同Consumer Group的每个Consumer实例都接收同一个Topic的全量消息。即每条消息都会被发送到Consumer Group中的每个Consumer。</p>\n<h4 id=\"集群消费\"><a href=\"#集群消费\" class=\"headerlink\" title=\"集群消费\"></a>集群消费</h4><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208141053.png\" class title=\"输入图片说明\">\n\n<p>集群消费模式下，相同Consumer Group的每个Consumer实例<code>平均分摊</code>同一个Topic的消息。即每条消息只会被发送到Consumer Group中的<code>某个</code>Consumer。</p>\n<h4 id=\"消息进度保存\"><a href=\"#消息进度保存\" class=\"headerlink\" title=\"消息进度保存\"></a>消息进度保存</h4><ul>\n<li>广播模式：消费进度保存在consumer端。因为广播模式下consumer group中每个consumer都会消费所有消息，但它们的消费进度是不同。所以consumer各自保存各自的消费进度。</li>\n<li>集群模式：消费进度保存在broker中。consumer group中的所有consumer共同消费同一个Topic中的消息，同一条消息只会被消费一次。消费进度会参与到了消费的负载均衡中，故消费进度是需要共享的。下图是broker中存放的各个Topic的各个Queue的消费进度。</li>\n</ul>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208141202.png\" class title=\"输入图片说明\">\n\n<h3 id=\"3-Rebalance机制\"><a href=\"#3-Rebalance机制\" class=\"headerlink\" title=\"3 Rebalance机制\"></a>3 Rebalance机制</h3><p>Rebalance机制讨论的前提是：集群消费。</p>\n<h4 id=\"什么是Rebalance\"><a href=\"#什么是Rebalance\" class=\"headerlink\" title=\"什么是Rebalance\"></a>什么是Rebalance</h4><p>Rebalance即再均衡，指的是，将一个Topic下的多个Queue在同一个Consumer Group中的多个Consumer间进行重新分配的过程。</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208141304.png\" class title=\"输入图片说明\">\n\n<p>Rebalance机制的本意是为了提升消息的并行消费能力。例如，一个Topic下 5 个队列，在只有 1 个消费者的情况下，这个消费者将负责消费这 5 个队列的消息。如果此时我们增加一个消费者，那么就可以给其中一个消费者分配 2 个队列，给另一个分配 3 个队列，从而提升消息的并行消费能力。</p>\n<h4 id=\"Rebalance限制\"><a href=\"#Rebalance限制\" class=\"headerlink\" title=\"Rebalance限制\"></a>Rebalance限制</h4><p>由于一个队列最多分配给一个消费者，因此当某个消费者组下的消费者实例数量大于队列的数量时，多余的消费者实例将分配不到任何队列。</p>\n<h4 id=\"Rebalance危害\"><a href=\"#Rebalance危害\" class=\"headerlink\" title=\"Rebalance危害\"></a>Rebalance危害</h4><p>Rebalance的在提升消费能力的同时，也带来一些问题：</p>\n<p><code>消费暂停：</code>在只有一个Consumer时，其负责消费所有队列；在新增了一个Consumer后会触发Rebalance的发生。此时原Consumer就需要暂停部分队列的消费，等到这些队列分配给新的Consumer后，这些暂停消费的队列才能继续被消费。</p>\n<p><code>消费重复：</code>Consumer 在消费新分配给自己的队列时，必须接着之前Consumer 提交的消费进度的offset继续消费。然而默认情况下，offset是异步提交的，这个异步性导致提交到Broker的offset与Consumer实际消费的消息并不一致。这个不一致的差值就是可能会重复消费的消息。</p>\n<blockquote>\n<p>同步提交：consumer提交了其消费完毕的一批消息的offset给broker后，需要等待broker的成功ACK。当收到ACK后，consumer才会继续获取并消费下一批消息。在等待ACK期间，consumer是阻塞的。<br><br><br>异步提交：consumer提交了其消费完毕的一批消息的offset给broker后，不需要等待broker的成功ACK。consumer可以直接获取并消费下一批消息。<br><br><br>对于一次性读取消息的数量，需要根据具体业务场景选择一个相对均衡的是很有必要的。因为数量过大，系统性能提升了，但产生重复消费的消息数量可能会增加；数量过小，系统性能会下降，但被重复消费的消息数量可能会减少。</p>\n</blockquote>\n<p><code>消费突刺：</code>由于Rebalance可能导致重复消费，如果需要重复消费的消息过多，或者因为Rebalance暂停时间过长从而导致积压了部分消息。那么有可能会导致在Rebalance结束之后瞬间需要消费很多消息。</p>\n<h4 id=\"Rebalance产生的原因\"><a href=\"#Rebalance产生的原因\" class=\"headerlink\" title=\"Rebalance产生的原因\"></a>Rebalance产生的原因</h4><p>导致Rebalance产生的原因，无非就两个：消费者所订阅Topic的Queue数量发生变化，或消费者组中消费者的数量发生变化。</p>\n<blockquote>\n<p>1 ）Queue数量发生变化的场景：<br><br>Broker扩容或缩容<br><br>Broker升级运维<br><br>Broker与NameServer间的网络异常<br><br>Queue扩容或缩容<br><br>2 ）消费者数量发生变化的场景：<br><br>Consumer Group扩容或缩容<br><br>Consumer升级运维<br><br>Consumer与NameServer间网络异常<br></p>\n</blockquote>\n<h4 id=\"Rebalance过程\"><a href=\"#Rebalance过程\" class=\"headerlink\" title=\"Rebalance过程\"></a>Rebalance过程</h4><p>在Broker中维护着多个Map集合，这些集合中动态存放着当前Topic中Queue的信息、Consumer Group中Consumer实例的信息。一旦发现消费者所订阅的Queue数量发生变化，或消费者组中消费者的数量发生变化，立即向Consumer Group中的每个实例发出Rebalance通知。</p>\n<blockquote>\n<p>TopicConågManager：key是topic名称，value是TopicConåg。TopicConåg中维护着该Topic中所有Queue的数据。<br><br><br>ConsumerManager：key是Consumser Group Id，value是ConsumerGroupInfo。<br><br>ConsumerGroupInfo中维护着该Group中所有Consumer实例数据。<br><br><br>ConsumerOffsetManager：key为<code>Topic与订阅该Topic的Group的组合,即topic@group</code>，value是一个内层Map。内层Map的key为QueueId，内层Map的value为该Queue的消费进度offset。</p>\n</blockquote>\n<p>Consumer实例在接收到通知后会采用Queue分配算法自己获取到相应的Queue，即由Consumer实例自主进行Rebalance。</p>\n<h4 id=\"与Kafka对比\"><a href=\"#与Kafka对比\" class=\"headerlink\" title=\"与Kafka对比\"></a>与Kafka对比</h4><p>在Kafka中，一旦发现出现了Rebalance条件，Broker会调用Group Coordinator来完成Rebalance。Coordinator是Broker中的一个进程。Coordinator会在Consumer Group中选出一个Group Leader。由这个Leader根据自己本身组情况完成Partition分区的再分配。这个再分配结果会上报给Coordinator，并由Coordinator同步给Group中的所有Consumer实例。</p>\n<p>Kafka中的Rebalance是由Consumer Leader完成的。而RocketMQ中的Rebalance是由每个Consumer自身完成的，Group中不存在Leader。</p>\n<h3 id=\"4-Queue分配算法\"><a href=\"#4-Queue分配算法\" class=\"headerlink\" title=\"4 Queue分配算法\"></a>4 Queue分配算法</h3><p>一个Topic中的Queue只能由Consumer Group中的一个Consumer进行消费，而一个Consumer可以同时消费多个Queue中的消息。那么Queue与Consumer间的配对关系是如何确定的，即Queue要分配给哪个Consumer进行消费，也是有算法策略的。常见的有四种策略。这些策略是通过在创建Consumer时的构造器传进去的。</p>\n<h4 id=\"平均分配策略\"><a href=\"#平均分配策略\" class=\"headerlink\" title=\"平均分配策略\"></a>平均分配策略</h4><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208142527.png\" class title=\"输入图片说明\">\n\n<p>该算法是要根据<code>avg = QueueCount / ConsumerCount</code>的计算结果进行分配的。如果能够整除，则按顺序将avg个Queue逐个分配Consumer；如果不能整除，则将多余出的Queue按照Consumer顺序逐个分配。</p>\n<blockquote>\n<p>该算法即，先计算好每个Consumer应该分得几 个Queue，然后再依次将这些数量的Queue逐个分配个Consumer。</p>\n</blockquote>\n<h4 id=\"环形平均策略\"><a href=\"#环形平均策略\" class=\"headerlink\" title=\"环形平均策略\"></a>环形平均策略</h4><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208142630.png\" class title=\"输入图片说明\">\n\n<p>环形平均算法是指，根据消费者的顺序，依次在由queue队列组成的环形图中逐个分配。</p>\n<blockquote>\n<p>该算法不用事先计算每个Consumer需要分配几 个Queue，直接一个一个分即可。</p>\n</blockquote>\n<h4 id=\"一致性hash策略\"><a href=\"#一致性hash策略\" class=\"headerlink\" title=\"一致性hash策略\"></a>一致性hash策略</h4><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208142708.png\" class title=\"输入图片说明\">\n\n<p>该算法会将consumer的hash值作为Node节点存放到hash环上，然后将queue的hash值也放到hash环上，通过顺时针方向，距离queue最近的那个consumer就是该queue要分配的consumer。</p>\n<blockquote>\n<p>该算法存在的问题：分配不均。</p>\n</blockquote>\n<h4 id=\"同机房策略\"><a href=\"#同机房策略\" class=\"headerlink\" title=\"同机房策略\"></a>同机房策略</h4><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208142814.png\" class title=\"输入图片说明\">\n\n<p>该算法会根据queue的部署机房位置和consumer的位置，过滤出当前consumer相同机房的queue。然后按照平均分配策略或环形平均策略对同机房queue进行分配。如果没有同机房queue，则按照平均分配策略或环形平均策略对所有queue进行分配。</p>\n<h4 id=\"对比-2\"><a href=\"#对比-2\" class=\"headerlink\" title=\"对比\"></a>对比</h4><p>一致性hash算法存在的问题：</p>\n<p>两种平均分配策略的分配效率较高，一致性hash策略的较低。因为一致性hash算法较复杂。另外，一致性hash策略分配的结果也很大可能上存在不平均的情况。</p>\n<p>一致性hash算法存在的意义：</p>\n<p>其可以有效减少由于消费者组扩容或缩容所带来的大量的Rebalance。</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208142905.png\" class title=\"输入图片说明\">\n\n<p>一致性hash算法的应用场景：</p>\n<p>Consumer数量变化较频繁的场景。</p>\n<h3 id=\"5-至少一次原则\"><a href=\"#5-至少一次原则\" class=\"headerlink\" title=\"5 至少一次原则\"></a>5 至少一次原则</h3><p>RocketMQ有一个原则：每条消息必须要被<code>成功消费</code>一次。</p>\n<p>那么什么是成功消费呢？Consumer在消费完消息后会向其<code>消费进度记录器</code>提交其消费消息的offset，offset被成功记录到记录器中，那么这条消费就被成功消费了。</p>\n<blockquote>\n<p>什么是消费进度记录器？<br><br>对于广播消费模式来说，Consumer本身就是消费进度记录器。<br><br>对于集群消费模式来说，Broker是消费进度记录器。<br></p>\n</blockquote>\n<h2 id=\"五、订阅关系的一致性\"><a href=\"#五、订阅关系的一致性\" class=\"headerlink\" title=\"五、订阅关系的一致性\"></a>五、订阅关系的一致性</h2><p>订阅关系的一致性指的是，同一个消费者组（Group ID相同）下所有Consumer实例所订阅的Topic与Tag及对消息的处理逻辑必须完全一致。否则，消息消费的逻辑就会混乱，甚至导致消息丢失。</p>\n<h3 id=\"1-正确订阅关系\"><a href=\"#1-正确订阅关系\" class=\"headerlink\" title=\"1 正确订阅关系\"></a>1 正确订阅关系</h3><p>多个消费者组订阅了多个Topic，并且每个消费者组里的多个消费者实例的订阅关系保持了一致。</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208143050.png\" class title=\"输入图片说明\">\n\n<h3 id=\"2-错误订阅关系\"><a href=\"#2-错误订阅关系\" class=\"headerlink\" title=\"2 错误订阅关系\"></a>2 错误订阅关系</h3><p>一个消费者组订阅了多个Topic，但是该消费者组里的多个Consumer实例的订阅关系并没有保持一致。</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208143107.png\" class title=\"输入图片说明\">\n\n<h4 id=\"订阅了不同Topic\"><a href=\"#订阅了不同Topic\" class=\"headerlink\" title=\"订阅了不同Topic\"></a>订阅了不同Topic</h4><p>该例中的错误在于，同一个消费者组中的两个Consumer实例订阅了不同的Topic。</p>\n<p>Consumer实例1-1：（订阅了topic为jodie_test_A，tag为所有的消息）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Properties properties = <span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\">properties.put(PropertyKeyConst.GROUP_ID, <span class=\"string\">&quot;GID_jodie_test_1&quot;</span>);</span><br><span class=\"line\">Consumer consumer = ONSFactory.createConsumer(properties);</span><br><span class=\"line\">consumer.subscribe(<span class=\"string\">&quot;jodie_test_A&quot;</span>, <span class=\"string\">&quot;*&quot;</span>, <span class=\"keyword\">new</span> MessageListener() &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Action <span class=\"title\">consume</span><span class=\"params\">(Message message, ConsumeContext context)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(message.getMsgID());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Action.CommitMessage;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>Consumer实例1-2：（订阅了topic为jodie_test_B，tag为所有的消息）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Properties properties = <span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\">properties.put(PropertyKeyConst.GROUP_ID, <span class=\"string\">&quot;GID_jodie_test_1&quot;</span>);</span><br><span class=\"line\">Consumer consumer = ONSFactory.createConsumer(properties);</span><br><span class=\"line\">consumer.subscribe(<span class=\"string\">&quot;jodie_test_B&quot;</span>, <span class=\"string\">&quot;*&quot;</span>, <span class=\"keyword\">new</span> MessageListener() &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Action <span class=\"title\">consume</span><span class=\"params\">(Message message, ConsumeContext context)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(message.getMsgID());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Action.CommitMessage;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"订阅了不同Tag\"><a href=\"#订阅了不同Tag\" class=\"headerlink\" title=\"订阅了不同Tag\"></a>订阅了不同Tag</h4><p>该例中的错误在于，同一个消费者组中的两个Consumer订阅了相同Topic的不同Tag。</p>\n<p>Consumer实例2-1：（订阅了topic为jodie_test_A，tag为TagA的消息）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Properties properties = <span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\">properties.put(PropertyKeyConst.GROUP_ID, <span class=\"string\">&quot;GID_jodie_test_2&quot;</span>);</span><br><span class=\"line\">Consumer consumer = ONSFactory.createConsumer(properties);</span><br><span class=\"line\">consumer.subscribe(<span class=\"string\">&quot;jodie_test_A&quot;</span>, <span class=\"string\">&quot;TagA&quot;</span>, <span class=\"keyword\">new</span> MessageListener() &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Action <span class=\"title\">consume</span><span class=\"params\">(Message message, ConsumeContext context)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(message.getMsgID());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Action.CommitMessage;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>Consumer实例2-2：（订阅了topic为jodie_test_A，tag为所有的消息）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Properties properties = <span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\">properties.put(PropertyKeyConst.GROUP_ID, <span class=\"string\">&quot;GID_jodie_test_2&quot;</span>);</span><br><span class=\"line\">Consumer consumer = ONSFactory.createConsumer(properties);</span><br><span class=\"line\">consumer.subscribe(<span class=\"string\">&quot;jodie_test_A&quot;</span>, <span class=\"string\">&quot;*&quot;</span>, <span class=\"keyword\">new</span> MessageListener() &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Action <span class=\"title\">consume</span><span class=\"params\">(Message message, ConsumeContext context)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(message.getMsgID());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Action.CommitMessage;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"订阅了不同数量的Topic\"><a href=\"#订阅了不同数量的Topic\" class=\"headerlink\" title=\"订阅了不同数量的Topic\"></a>订阅了不同数量的Topic</h4><p>该例中的错误在于，同一个消费者组中的两个Consumer订阅了不同数量的Topic。</p>\n<p>Consumer实例3-1：（该Consumer订阅了两个Topic）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Properties properties = <span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\">properties.put(PropertyKeyConst.GROUP_ID, <span class=\"string\">&quot;GID_jodie_test_3&quot;</span>);</span><br><span class=\"line\">Consumer consumer = ONSFactory.createConsumer(properties);</span><br><span class=\"line\">consumer.subscribe(<span class=\"string\">&quot;jodie_test_A&quot;</span>, <span class=\"string\">&quot;TagA&quot;</span>, <span class=\"keyword\">new</span> MessageListener() &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Action <span class=\"title\">consume</span><span class=\"params\">(Message message, ConsumeContext context)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(message.getMsgID());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Action.CommitMessage;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">consumer.subscribe(<span class=\"string\">&quot;jodie_test_B&quot;</span>, <span class=\"string\">&quot;TagB&quot;</span>, <span class=\"keyword\">new</span> MessageListener() &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Action <span class=\"title\">consume</span><span class=\"params\">(Message message, ConsumeContext context)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(message.getMsgID());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Action.CommitMessage;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>Consumer实例3-2：（该Consumer订阅了一个Topic）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Properties properties = <span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\">properties.put(PropertyKeyConst.GROUP_ID, <span class=\"string\">&quot;GID_jodie_test_3&quot;</span>);</span><br><span class=\"line\">Consumer consumer = ONSFactory.createConsumer(properties);</span><br><span class=\"line\">consumer.subscribe(<span class=\"string\">&quot;jodie_test_A&quot;</span>, <span class=\"string\">&quot;TagB&quot;</span>, <span class=\"keyword\">new</span> MessageListener() &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Action <span class=\"title\">consume</span><span class=\"params\">(Message message, ConsumeContext context)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(message.getMsgID());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Action.CommitMessage;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"六、offset管理\"><a href=\"#六、offset管理\" class=\"headerlink\" title=\"六、offset管理\"></a>六、offset管理</h2><blockquote>\n<p>这里的offset指的是Consumer的消费进度offset。</p>\n</blockquote>\n<p>消费进度offset是用来记录每个Queue的不同消费组的消费进度的。根据消费进度记录器的不同，可以分为两种模式：本地模式和远程模式。</p>\n<h3 id=\"1-offset本地管理模式\"><a href=\"#1-offset本地管理模式\" class=\"headerlink\" title=\"1 offset本地管理模式\"></a>1 offset本地管理模式</h3><p>当消费模式为<code>广播消费</code>时，offset使用本地模式存储。因为每条消息会被所有的消费者消费，每个消费者管理自己的消费进度，各个消费者之间不存在消费进度的交集。</p>\n<p>Consumer在广播消费模式下offset相关数据以json的形式持久化到Consumer本地磁盘文件中，默认文件路径为当前用户主目录下的<code>.rocketmq_offsets/$&#123;clientId&#125;/$&#123;group&#125;/Offsets.json</code>。其中${clientId}为当前消费者id，默认为ip@DEFAULT；${group}为消费者组名称。</p>\n<h3 id=\"2-offset远程管理模式\"><a href=\"#2-offset远程管理模式\" class=\"headerlink\" title=\"2 offset远程管理模式\"></a>2 offset远程管理模式</h3><p>当消费模式为<code>集群消费</code>时，offset使用远程模式管理。因为所有Cosnumer实例对消息采用的是均衡消费，所有Consumer共享Queue的消费进度。</p>\n<p>Consumer在集群消费模式下offset相关数据以json的形式持久化到Broker磁盘文件中，文件路径为当前用户主目录下的<code>store/config/consumerOffset.json</code>。</p>\n<p>Broker启动时会加载这个文件，并写入到一个双层Map（ConsumerOffsetManager）。外层map的key为topic@group，value为内层map。内层map的key为queueId，value为offset。当发生Rebalance时，新的Consumer会从该Map中获取到相应的数据来继续消费。</p>\n<p>集群模式下offset采用远程管理模式，主要是为了保证Rebalance机制。</p>\n<h3 id=\"3-offset用途\"><a href=\"#3-offset用途\" class=\"headerlink\" title=\"3 offset用途\"></a>3 offset用途</h3><p>消费者是如何从最开始持续消费消息的？消费者要消费的第一条消息的起始位置是用户自己通过consumer.setConsumeFromWhere()方法指定的。</p>\n<p>在Consumer启动后，其要消费的第一条消息的起始位置常用的有三种，这三种位置可以通过枚举类型常量设置。这个枚举类型为ConsumeFromWhere。</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208143837.png\" class title=\"输入图片说明\">\n\n<blockquote>\n<p>CONSUME_FROM_LAST_OFFSET：从queue的当前最后一条消息开始消费<br><br>CONSUME_FROM_FIRST_OFFSET：从queue的第一条消息开始消费<br><br>CONSUME_FROM_TIMESTAMP：从指定的具 体时间戳位置的消息开始消费。这个具体时间戳是通过另外一个语句指定的 。<br><br>consumer.setConsumeTimestamp(“20210701080000”) yyyyMMddHHmmss</p>\n</blockquote>\n<p>当消费完一批消息后，Consumer会提交其消费进度offset给Broker，Broker在收到消费进度后会将其更新到那个双层Map（ConsumerOffsetManager）及consumerOffset.json文件中，然后向该Consumer进行ACK，而ACK内容中包含三项数据：当前消费队列的最小offset（minOffset）、最大offset（maxOffset）、及下次消费的起始offset（nextBeginOffset）。</p>\n<h3 id=\"4-重试队列\"><a href=\"#4-重试队列\" class=\"headerlink\" title=\"4 重试队列\"></a>4 重试队列</h3><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208143940.png\" class title=\"输入图片说明\">\n\n<p>当rocketMQ对消息的消费出现异常时，会将发生异常的消息的offset提交到Broker中的重试队列。系统在发生消息消费异常时会为当前的topic@group创建一个重试队列，该队列以%RETRY%开头，到达重试时间后进行消费重试。</p>\n<h3 id=\"5-offset的同步提交与异步提交\"><a href=\"#5-offset的同步提交与异步提交\" class=\"headerlink\" title=\"5 offset的同步提交与异步提交\"></a>5 offset的同步提交与异步提交</h3><p>集群消费模式下，Consumer消费完消息后会向Broker提交消费进度offset，其提交方式分为两种：</p>\n<p><code>同步提交</code>：消费者在消费完一批消息后会向broker提交这些消息的offset，然后等待broker的成功响应。若在等待超时之前收到了成功响应，则继续读取下一批消息进行消费（从ACK中获取nextBeginOffset）。若没有收到响应，则会重新提交，直到获取到响应。而在这个等待过程中，消费者是阻塞的。其严重影响了消费者的吞吐量。</p>\n<p><code>异步提交</code>：消费者在消费完一批消息后向broker提交offset，但无需等待Broker的成功响应，可以继续读取并消费下一批消息。这种方式增加了消费者的吞吐量。但需要注意，broker在收到提交的offset后，还是会向消费者进行响应的。可能还没有收到ACK，此时Consumer会从Broker中直接获取nextBeginOffset。</p>\n<h2 id=\"七、消费幂等\"><a href=\"#七、消费幂等\" class=\"headerlink\" title=\"七、消费幂等\"></a>七、消费幂等</h2><h3 id=\"1-什么是消费幂等\"><a href=\"#1-什么是消费幂等\" class=\"headerlink\" title=\"1 什么是消费幂等\"></a>1 什么是消费幂等</h3><p>当出现消费者对某条消息重复消费的情况时，重复消费的结果与消费一次的结果是相同的，并且多次消费并未对业务系统产生任何负面影响，那么这个消费过程就是消费幂等的。</p>\n<blockquote>\n<p>幂等：若某操作执行多次与执行一次对系统产生的影响是相同的，则称该操作是幂等的。</p>\n</blockquote>\n<p>在互联网应用中，尤其在网络不稳定的情况下，消息很有可能会出现重复发送或重复消费。如果重复的消息可能会影响业务处理，那么就应该对消息做幂等处理。</p>\n<h3 id=\"2-消息重复的场景分析\"><a href=\"#2-消息重复的场景分析\" class=\"headerlink\" title=\"2 消息重复的场景分析\"></a>2 消息重复的场景分析</h3><p>什么情况下可能会出现消息被重复消费呢？最常见的有以下三种情况：</p>\n<h4 id=\"发送时消息重复\"><a href=\"#发送时消息重复\" class=\"headerlink\" title=\"发送时消息重复\"></a>发送时消息重复</h4><p>当一条消息已被成功发送到Broker并完成持久化，此时出现了网络闪断，从而导致Broker对Producer应答失败。 如果此时Producer意识到消息发送失败并尝试再次发送消息，此时Broker中就可能会出现两条内容相同并且Message ID也相同的消息，那么后续Consumer就一定会消费两次该消息。</p>\n<h4 id=\"消费时消息重复\"><a href=\"#消费时消息重复\" class=\"headerlink\" title=\"消费时消息重复\"></a>消费时消息重复</h4><p>消息已投递到Consumer并完成业务处理，当Consumer给Broker反馈应答时网络闪断，Broker没有接收到消费成功响应。为了保证消息<code>至少被消费一次</code>的原则，Broker将在网络恢复后再次尝试投递之前已被处理过的消息。此时消费者就会收到与之前处理过的内容相同、Message ID也相同的消息。</p>\n<h4 id=\"Rebalance时消息重复\"><a href=\"#Rebalance时消息重复\" class=\"headerlink\" title=\"Rebalance时消息重复\"></a>Rebalance时消息重复</h4><p>当Consumer Group中的Consumer数量发生变化时，或其订阅的Topic的Queue数量发生变化时，会触发Rebalance，此时Consumer可能会收到曾经被消费过的消息。</p>\n<h3 id=\"3-通用解决方案\"><a href=\"#3-通用解决方案\" class=\"headerlink\" title=\"3 通用解决方案\"></a>3 通用解决方案</h3><h4 id=\"两要素\"><a href=\"#两要素\" class=\"headerlink\" title=\"两要素\"></a>两要素</h4><p>幂等解决方案的设计中涉及到两项要素：幂等令牌，与唯一性处理。只要充分利用好这两要素，就可以设计出好的幂等解决方案。</p>\n<ul>\n<li>幂等令牌：是生产者和消费者两者中的既定协议，通常指具备唯一业务标识的字符串。例如，订单号、流水号。一般由Producer随着消息一同发送来的。</li>\n<li>唯一性处理：服务端通过采用一定的算法策略，保证同一个业务逻辑不会被重复执行成功多次。例如，对同一笔订单的多次支付操作，只会成功一次。</li>\n</ul>\n<h4 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><p>对于常见的系统，幂等性操作的通用性解决方案是：</p>\n<ul>\n<li><ol>\n<li>首先通过缓存去重。在缓存中如果已经存在了某幂等令牌，则说明本次操作是重复性操作；若缓存没有命中，则进入下一步。</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>在唯一性处理之前，先在数据库中查询幂等令牌作为索引的数据是否存在。若存在，则说明本次操作为重复性操作；若不存在，则进入下一步。</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>在同一事务中完成三项操作：唯一性处理后，将幂等令牌写入到缓存，并将幂等令牌作为唯一索引的数据写入到DB中。</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p>第 1 步已经判断过是否是重复性操作了，为什么第 2 步还要再次判断？能够进入第 2 步，说明已经不是重复操作了，第 2 次判断是否重复？<br><br><br>当然不重复。一般缓存中的数据是具有有效期的。缓存中数据的有效期一旦过期，就是发生缓存穿透，使请求直接就到达了DBMS。</p>\n</blockquote>\n<h4 id=\"解决方案举例\"><a href=\"#解决方案举例\" class=\"headerlink\" title=\"解决方案举例\"></a>解决方案举例</h4><h4 id=\"以支付场景为例：\"><a href=\"#以支付场景为例：\" class=\"headerlink\" title=\"以支付场景为例：\"></a>以支付场景为例：</h4><ul>\n<li><ol>\n<li>当支付请求到达后，首先在Redis缓存中却获取key为支付流水号的缓存value。若value不空，则说明本次支付是重复操作，业务系统直接返回调用侧重复支付标识；若value为空，则进入下一步操作</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>到DBMS中根据支付流水号查询是否存在相应实例。若存在，则说明本次支付是重复操作，业务系统直接返回调用侧重复支付标识；若不存在，则说明本次操作是首次操作，进入下一步完成唯一性处理</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>在分布式事务中完成三项操作：</li>\n</ol>\n<ul>\n<li>完成支付任务</li>\n<li>将当前支付流水号作为key，任意字符串作为value，通过set(key, value, expireTime)将数据写入到Redis缓存</li>\n<li>将当前支付流水号作为主键，与其它相关数据共同写入到DBMS</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-消费幂等的实现\"><a href=\"#4-消费幂等的实现\" class=\"headerlink\" title=\"4 消费幂等的实现\"></a>4 消费幂等的实现</h3><p>消费幂等的解决方案很简单：为消息指定不会重复的唯一标识。因为Message ID有可能出现重复的情况，所以真正安全的幂等处理，不建议以Message ID作为处理依据。最好的方式是以业务唯一标识作为幂等处理的关键依据，而业务的唯一标识可以通过消息Key设置。</p>\n<p>以支付场景为例，可以将消息的Key设置为订单号，作为幂等处理的依据。具体代码示例如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Message message = <span class=\"keyword\">new</span> Message();</span><br><span class=\"line\">message.setKey(<span class=\"string\">&quot;ORDERID_100&quot;</span>);</span><br><span class=\"line\">SendResult sendResult = producer.send(message);</span><br></pre></td></tr></table></figure>\n\n<p>消费者收到消息时可以根据消息的Key即订单号来实现消费幂等：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">consumer.registerMessageListener(<span class=\"keyword\">new</span> MessageListenerConcurrently() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ConsumeConcurrentlyStatus <span class=\"title\">consumeMessage</span><span class=\"params\">(List&lt;MessageExt&gt;msgs,ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(MessageExt msg:msgs)&#123;</span><br><span class=\"line\">            String key = msg.getKeys();</span><br><span class=\"line\">            <span class=\"comment\">// 根据业务唯一标识Key做幂等处理</span></span><br><span class=\"line\">            <span class=\"comment\">// ......</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>RocketMQ能够保证消息不丢失，但不能保证消息不重复。</p>\n</blockquote>\n<h2 id=\"八、消息堆积与消费延迟\"><a href=\"#八、消息堆积与消费延迟\" class=\"headerlink\" title=\"八、消息堆积与消费延迟\"></a>八、消息堆积与消费延迟</h2><h3 id=\"1-概念\"><a href=\"#1-概念\" class=\"headerlink\" title=\"1 概念\"></a>1 概念</h3><p>消息处理流程中，如果Consumer的消费速度跟不上Producer的发送速度，MQ中未处理的消息会越来越多（进的多出的少），这部分消息就被称为<code>堆积消息</code>。消息出现堆积进而会造成消息的<code>消费延迟</code>。<br><br>以下场景需要重点关注消息堆积和消费延迟问题：</p>\n<ul>\n<li>业务系统上下游能力不匹配造成的持续堆积，且无法自行恢复。</li>\n<li>业务系统对消息的消费实时性要求较高，即使是短暂的堆积造成的消费延迟也无法接受。</li>\n</ul>\n<h3 id=\"2-产生原因分析\"><a href=\"#2-产生原因分析\" class=\"headerlink\" title=\"2 产生原因分析\"></a>2 产生原因分析</h3><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208144842.png\" class title=\"输入图片说明\">\n\n<p>Consumer使用长轮询Pull模式消费消息时，分为以下两个阶段：</p>\n<h4 id=\"消息拉取-1\"><a href=\"#消息拉取-1\" class=\"headerlink\" title=\"消息拉取\"></a>消息拉取</h4><p>Consumer通过长轮询Pull模式批量拉取的方式从服务端获取消息，将拉取到的消息缓存到本地缓冲队列中。对于拉取式消费，在内网环境下会有很高的吞吐量，所以这一阶段一般不会成为消息堆积的瓶颈。</p>\n<blockquote>\n<p>一个单线程单分区的低规格主机(Consumer，4C8G)，其可达到几万的TPS。如果是多个分区多个线程，则可以轻松达到几十万的TPS。</p>\n</blockquote>\n<h4 id=\"消息消费\"><a href=\"#消息消费\" class=\"headerlink\" title=\"消息消费\"></a>消息消费</h4><p>Consumer将本地缓存的消息提交到消费线程中，使用业务消费逻辑对消息进行处理，处理完毕后获取到一个结果。这是真正的消息消费过程。此时Consumer的消费能力就完全依赖于消息的<code>消费耗时</code>和<code>消费并发度</code>了。如果由于业务处理逻辑复杂等原因，导致处理单条消息的耗时较长，则整体的消息吞吐量肯定不会高，此时就会导致Consumer本地缓冲队列达到上限，停止从服务端拉取消息。</p>\n<h4 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h4><p>消息堆积的主要瓶颈在于客户端的消费能力，而消费能力由<code>消费耗时</code>和<code>消费并发度</code>决定。注意，消费耗时的优先级要高于消费并发度。即在保证了消费耗时的合理性前提下，再考虑消费并发度问题。</p>\n<h3 id=\"3-消费耗时\"><a href=\"#3-消费耗时\" class=\"headerlink\" title=\"3 消费耗时\"></a>3 消费耗时</h3><p>影响消息处理时长的主要因素是代码逻辑。而代码逻辑中可能会影响处理时长代码主要有两种类型：<code>CPU内部计算型代码</code>和<code>外部I/O操作型代码</code>。</p>\n<p>通常情况下代码中如果没有复杂的递归和循环的话，内部计算耗时相对外部I/O操作来说几乎可以忽略。所以外部IO型代码是影响消息处理时长的主要症结所在。</p>\n<blockquote>\n<p>外部IO操作型代码举例：<br><br><br>1)读写外部数据库，例如对远程MySQL的访问<br><br>2)读写外部缓存系统，例如对远程Redis的访问<br><br>3)下游系统调用，例如Dubbo的RPC远程调用，Spring Cloud的对下游系统的Http接口调用<br><br><br>关于下游系统调用逻辑需要进行提前梳理，掌握每个调用操作预期的耗时，这样做是为了能够判断消费逻辑中IO操作的耗时是否合理。通常消息堆积是由于下游系统出现了<code>服务异常</code>或<code>达到了DBMS容量限制</code>，导致消费耗时增加。<br><br><br>服务异常，并不仅仅是系统中出现的类似 500 这样的代码错误，而可能是更加隐蔽的问题。例如，网络带宽问题。<br><br><br>达到了DBMS容量限制，其也会引发消息的消费耗时增加。</p>\n</blockquote>\n<h3 id=\"4-消费并发度\"><a href=\"#4-消费并发度\" class=\"headerlink\" title=\"4 消费并发度\"></a>4 消费并发度</h3><p>一般情况下，消费者端的消费并发度由单节点线程数和节点数量共同决定，其值为单节点线程数*节点数量。不过，通常需要优先调整单节点的线程数，若单机硬件资源达到了上限，则需要通过横向扩展来提高消费并发度。</p>\n<blockquote>\n<p>单节点线程数，即单个Consumer所包含的线程数量<br><br><br>节点数量，即Consumer Group所包含的Consumer数量<br><br><br>对于普通消息、延时消息及事务消息，并发度计算都是单节点线程数*节点数量。但对于顺序消息则是不同的。顺序消息的消费并发度等于Topic的Queue分区数量。<br><br><br>1 ）全局顺序消息：该类型消息的Topic只有一个Queue分区。其可以保证该Topic的所有消息被顺序消费。为了保证这个全局顺序性，Consumer Group中在同一时刻只能有一个Consumer的一个线程进行消费。所以其并发度为 1 。<br><br><br>2 ）分区顺序消息：该类型消息的Topic有多个Queue分区。其仅可以保证该Topic的每个Queue分区中的消息被顺序消费，不能保证整个Topic中消息的顺序消费。为了保证这个分区顺序性，每个Queue分区中的消息在Consumer Group中的同一时刻只能有一个Consumer的一个线程进行消费。即，在同一时刻最多会出现多个Queue分蘖有多个Consumer的多个线程并行消费。所以其并发度为Topic的分区数量。</p>\n</blockquote>\n<h3 id=\"5-单机线程数计算\"><a href=\"#5-单机线程数计算\" class=\"headerlink\" title=\"5 单机线程数计算\"></a>5 单机线程数计算</h3><p>对于一台主机中线程池中线程数的设置需要谨慎，不能盲目直接调大线程数，设置过大的线程数反而会带来大量的线程切换的开销。理想环境下单节点的最优线程数计算模型为：C *（T1 + T2）/ T1。</p>\n<ul>\n<li>C：CPU内核数</li>\n<li>T1：CPU内部逻辑计算耗时</li>\n<li>T2：外部IO操作耗时</li>\n</ul>\n<blockquote>\n<p>最优线程数 = C *（T1 + T2）/ T1 = C * T1/T1 + C * T2/T1 = C + C * T2/T1</p>\n</blockquote>\n<blockquote>\n<p>注意，该计算出的数值是理想状态下的理论数据，在生产环境中，不建议直接使用。而是根据当前环境，先设置一个比该值小的数值然后观察其压测效果，然后再根据效果逐步调大线程数，直至找到在该环境中性能最佳时的值。</p>\n</blockquote>\n<h3 id=\"6-如何避免\"><a href=\"#6-如何避免\" class=\"headerlink\" title=\"6 如何避免\"></a>6 如何避免</h3><p>为了避免在业务使用时出现非预期的消息堆积和消费延迟问题，需要在前期设计阶段对整个业务逻辑进行完善的排查和梳理。其中最重要的就是<code>梳理消息的消费耗时</code>和<code>设置消息消费的并发度</code>。</p>\n<h4 id=\"梳理消息的消费耗时\"><a href=\"#梳理消息的消费耗时\" class=\"headerlink\" title=\"梳理消息的消费耗时\"></a>梳理消息的消费耗时</h4><p>通过压测获取消息的消费耗时，并对耗时较高的操作的代码逻辑进行分析。梳理消息的消费耗时需要关注以下信息：</p>\n<ul>\n<li>消息消费逻辑的计算复杂度是否过高，代码是否存在无限循环和递归等缺陷。</li>\n<li>消息消费逻辑中的I/O操作是否是必须的，能否用本地缓存等方案规避。</li>\n<li>消费逻辑中的复杂耗时的操作是否可以做异步化处理。如果可以，是否会造成逻辑错乱。</li>\n</ul>\n<h4 id=\"设置消费并发度\"><a href=\"#设置消费并发度\" class=\"headerlink\" title=\"设置消费并发度\"></a>设置消费并发度</h4><p>对于消息消费并发度的计算，可以通过以下两步实施：</p>\n<ul>\n<li>逐步调大单个Consumer节点的线程数，并观测节点的系统指标，得到单个节点最优的消费线程数和消息吞吐量。</li>\n<li>根据上下游链路的流量峰值计算出需要设置的节点数</li>\n</ul>\n<blockquote>\n<p>节点数 = 流量峰值 / 单个节点消息吞吐量</p>\n</blockquote>\n<h2 id=\"九、消息的清理\"><a href=\"#九、消息的清理\" class=\"headerlink\" title=\"九、消息的清理\"></a>九、消息的清理</h2><p>消息被消费过后会被清理掉吗？不会的。</p>\n<p>消息是被顺序存储在commitlog文件的，且消息大小不定长，所以消息的清理是不可能以消息为单位进行清理的，而是以commitlog文件为单位进行清理的。否则会急剧下降清理效率，并实现逻辑复杂。</p>\n<p>commitlog文件存在一个过期时间，默认为 72 小时，即三天。除了用户手动清理外，在以下情况下也会被自动清理，无论文件中的消息是否被消费过：</p>\n<ul>\n<li>文件过期，且到达清理时间点（默认为凌晨 4 点）后，自动清理过期文件</li>\n<li>文件过期，且磁盘空间占用率已达过期清理警戒线（默认75%）后，无论是否达到清理时间点，都会自动清理过期文件</li>\n<li>磁盘占用率达到清理警戒线（默认85%）后，开始按照设定好的规则清理文件，无论是否过期。默认会从最老的文件开始清理</li>\n<li>磁盘占用率达到系统危险警戒线（默认90%）后，Broker将拒绝消息写入</li>\n</ul>\n<blockquote>\n<p>需要注意以下几点：<br><br>1 ）对于RocketMQ系统来说，删除一个1G大小的文件，是一个压力巨大的IO操作。在删除过程中，系统性能会骤然下降。所以，其默认清理时间点为凌晨 4 点，访问量最小的时间。也正因如果，我们要保障磁盘空间的空闲率，不要使系统出现在其它时间点删除commitlog文件的情况。<br><br>2 ）官方建议RocketMQ服务的Linux文件系统采用ext4。因为对于文件删除操作，ext4要比ext3性能更好</p>\n</blockquote>\n<h1 id=\"第-4-章-RocketMQ应用\"><a href=\"#第-4-章-RocketMQ应用\" class=\"headerlink\" title=\"第 4 章 RocketMQ应用\"></a>第 4 章 RocketMQ应用</h1><h2 id=\"一、普通消息\"><a href=\"#一、普通消息\" class=\"headerlink\" title=\"一、普通消息\"></a>一、普通消息</h2><h3 id=\"1-消息发送分类\"><a href=\"#1-消息发送分类\" class=\"headerlink\" title=\"1 消息发送分类\"></a>1 消息发送分类</h3><p>Producer对于消息的发送方式也有多种选择，不同的方式会产生不同的系统效果。</p>\n<h4 id=\"同步发送消息\"><a href=\"#同步发送消息\" class=\"headerlink\" title=\"同步发送消息\"></a>同步发送消息</h4><p>同步发送消息是指，Producer发出一条消息后，会在收到MQ返回的ACK之后才发下一条消息。该方式的消息可靠性最高，但消息发送效率太低。</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208145933.png\" class title=\"输入图片说明\">\n\n<h4 id=\"异步发送消息\"><a href=\"#异步发送消息\" class=\"headerlink\" title=\"异步发送消息\"></a>异步发送消息</h4><p>异步发送消息是指，Producer发出消息后无需等待MQ返回ACK，直接发送下一条消息。该方式的消息可靠性可以得到保障，消息发送效率也可以。</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208150004.png\" class title=\"输入图片说明\">\n\n<h4 id=\"单向发送消息\"><a href=\"#单向发送消息\" class=\"headerlink\" title=\"单向发送消息\"></a>单向发送消息</h4><p>单向发送消息是指，Producer仅负责发送消息，不等待、不处理MQ的ACK。该发送方式时MQ也不返回ACK。该方式的消息发送效率最高，但消息可靠性较差。</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208150023.png\" class title=\"输入图片说明\">\n\n<h3 id=\"2-代码举例\"><a href=\"#2-代码举例\" class=\"headerlink\" title=\"2 代码举例\"></a>2 代码举例</h3><h4 id=\"创建工程\"><a href=\"#创建工程\" class=\"headerlink\" title=\"创建工程\"></a>创建工程</h4><p>创建一个Maven的Java工程rocketmq-test。</p>\n<p>导入rocketmq的client依赖。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">project.build.sourceEncoding</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">maven.compiler.source</span>&gt;</span>1.8<span class=\"tag\">&lt;/<span class=\"name\">maven.compiler.source</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">maven.compiler.target</span>&gt;</span>1.8<span class=\"tag\">&lt;/<span class=\"name\">maven.compiler.target</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.rocketmq<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>rocketmq-client<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.8.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"定义同步消息发送生产者\"><a href=\"#定义同步消息发送生产者\" class=\"headerlink\" title=\"定义同步消息发送生产者\"></a>定义同步消息发送生产者</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SyncProducer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建一个producer，参数为Producer Group名称</span></span><br><span class=\"line\">        DefaultMQProducer producer = <span class=\"keyword\">new</span> DefaultMQProducer(<span class=\"string\">&quot;pg&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 指定nameServer地址</span></span><br><span class=\"line\">        producer.setNamesrvAddr(<span class=\"string\">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 设置当发送失败时重试发送的次数，默认为 2 次</span></span><br><span class=\"line\">        producer.setRetryTimesWhenSendFailed( <span class=\"number\">3</span> );</span><br><span class=\"line\">        <span class=\"comment\">// 设置发送超时时限为5s，默认3s</span></span><br><span class=\"line\">        producer.setSendMsgTimeout( <span class=\"number\">5000</span> );</span><br><span class=\"line\">        <span class=\"comment\">// 开启生产者</span></span><br><span class=\"line\">        producer.start();</span><br><span class=\"line\">        <span class=\"comment\">// 生产并发送 100 条消息</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">100</span> ; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] body = (<span class=\"string\">&quot;Hi,&quot;</span> + i).getBytes();</span><br><span class=\"line\">            Message msg = <span class=\"keyword\">new</span> Message(<span class=\"string\">&quot;someTopic&quot;</span>, <span class=\"string\">&quot;someTag&quot;</span>, body);</span><br><span class=\"line\">            <span class=\"comment\">// 为消息指定key</span></span><br><span class=\"line\">            msg.setKeys(<span class=\"string\">&quot;key-&quot;</span> + i);</span><br><span class=\"line\">            <span class=\"comment\">// 发送消息</span></span><br><span class=\"line\">            SendResult sendResult = producer.send(msg);</span><br><span class=\"line\">            System.out.println(sendResult);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 关闭producer</span></span><br><span class=\"line\">        producer.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 消息发送的状态</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">SendStatus</span> </span>&#123;</span><br><span class=\"line\">    SEND_OK, <span class=\"comment\">// 发送成功</span></span><br><span class=\"line\">    FLUSH_DISK_TIMEOUT,  <span class=\"comment\">// 刷盘超时。当Broker设置的刷盘策略为同步刷盘时才可能出现这种异常状态。异步刷盘不会出现</span></span><br><span class=\"line\">    FLUSH_SLAVE_TIMEOUT, <span class=\"comment\">// Slave同步超时。当Broker集群设置的Master-Slave的复制方式为同步复制时才可能出现这种异常状态。异步复制不会出现</span></span><br><span class=\"line\">    SLAVE_NOT_AVAILABLE, <span class=\"comment\">// 没有可用的Slave。当Broker集群设置为Master-Slave的复制方式为同步复制时才可能出现这种异常状态。异步复制不会出现</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"定义异步消息发送生产者\"><a href=\"#定义异步消息发送生产者\" class=\"headerlink\" title=\"定义异步消息发送生产者\"></a>定义异步消息发送生产者</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AsyncProducer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        DefaultMQProducer producer = <span class=\"keyword\">new</span> DefaultMQProducer(<span class=\"string\">&quot;pg&quot;</span>);</span><br><span class=\"line\">        producer.setNamesrvAddr(<span class=\"string\">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 指定异步发送失败后不进行重试发送</span></span><br><span class=\"line\">        producer.setRetryTimesWhenSendAsyncFailed( <span class=\"number\">0</span> );</span><br><span class=\"line\">        <span class=\"comment\">// 指定新创建的Topic的Queue数量为 2 ，默认为 4</span></span><br><span class=\"line\">        producer.setDefaultTopicQueueNums( <span class=\"number\">2</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">        producer.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">100</span> ; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] body = (<span class=\"string\">&quot;Hi,&quot;</span> + i).getBytes();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Message msg = <span class=\"keyword\">new</span> Message(<span class=\"string\">&quot;myTopicA&quot;</span>, <span class=\"string\">&quot;myTag&quot;</span>, body);</span><br><span class=\"line\">            <span class=\"comment\">// 异步发送。指定回调</span></span><br><span class=\"line\">            producer.send(msg, <span class=\"keyword\">new</span> SendCallback() &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 当producer接收到MQ发送来的ACK后就会触发该回调方法的执行</span></span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSuccess</span><span class=\"params\">(SendResult sendResult)</span> </span>&#123;</span><br><span class=\"line\">                    System.out.println(sendResult);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onException</span><span class=\"params\">(Throwable e)</span> </span>&#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"comment\">// end-for</span></span><br><span class=\"line\">        <span class=\"comment\">// sleep一会儿</span></span><br><span class=\"line\">        <span class=\"comment\">// 由于采用的是异步发送，所以若这里不sleep，</span></span><br><span class=\"line\">        <span class=\"comment\">// 则消息还未发送就会将producer给关闭，报错</span></span><br><span class=\"line\">        TimeUnit.SECONDS.sleep( <span class=\"number\">3</span> );</span><br><span class=\"line\">        producer.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"定义单向消息发送生产者\"><a href=\"#定义单向消息发送生产者\" class=\"headerlink\" title=\"定义单向消息发送生产者\"></a>定义单向消息发送生产者</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OnewayProducer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">        DefaultMQProducer producer = <span class=\"keyword\">new</span> DefaultMQProducer(<span class=\"string\">&quot;pg&quot;</span>);</span><br><span class=\"line\">        producer.setNamesrvAddr(<span class=\"string\">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class=\"line\">        producer.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">10</span> ; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] body = (<span class=\"string\">&quot;Hi,&quot;</span> + i).getBytes();</span><br><span class=\"line\">            Message msg = <span class=\"keyword\">new</span> Message(<span class=\"string\">&quot;single&quot;</span>, <span class=\"string\">&quot;someTag&quot;</span>, body);</span><br><span class=\"line\">            <span class=\"comment\">// 单向发送</span></span><br><span class=\"line\">            producer.sendOneway(msg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        producer.shutdown();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;producer shutdown&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"定义消息消费者\"><a href=\"#定义消息消费者\" class=\"headerlink\" title=\"定义消息消费者\"></a>定义消息消费者</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeConsumer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> MQClientException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 定义一个pull消费者</span></span><br><span class=\"line\">        <span class=\"comment\">// DefaultLitePullConsumer consumer = new</span></span><br><span class=\"line\">        DefaultLitePullConsumer(<span class=\"string\">&quot;cg&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 定义一个push消费者</span></span><br><span class=\"line\">        DefaultMQPushConsumer consumer = <span class=\"keyword\">new</span> DefaultMQPushConsumer(<span class=\"string\">&quot;cg&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 指定nameServer</span></span><br><span class=\"line\">        consumer.setNamesrvAddr(<span class=\"string\">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 指定从第一条消息开始消费</span></span><br><span class=\"line\">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class=\"line\">        <span class=\"comment\">// 指定消费topic与tag</span></span><br><span class=\"line\">        consumer.subscribe(<span class=\"string\">&quot;someTopic&quot;</span>, <span class=\"string\">&quot;*&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 指定采用“广播模式”进行消费，默认为“集群模式”</span></span><br><span class=\"line\">        <span class=\"comment\">// consumer.setMessageModel(MessageModel.BROADCASTING);</span></span><br><span class=\"line\">        <span class=\"comment\">// 注册消息监听器</span></span><br><span class=\"line\">        consumer.registerMessageListener(<span class=\"keyword\">new</span> MessageListenerConcurrently() &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 一旦broker中有了其订阅的消息就会触发该方法的执行，</span></span><br><span class=\"line\">            <span class=\"comment\">// 其返回值为当前consumer消费的状态</span></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> ConsumeConcurrentlyStatus <span class=\"title\">consumeMessage</span><span class=\"params\">(List&lt;MessageExt&gt; msgs,ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 逐条消费消息</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (MessageExt msg : msgs) &#123;</span><br><span class=\"line\">                    System.out.println(msg);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 返回消费状态：消费成功</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"comment\">// 开启消费者消费</span></span><br><span class=\"line\">        consumer.start();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Consumer Started&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二、顺序消息\"><a href=\"#二、顺序消息\" class=\"headerlink\" title=\"二、顺序消息\"></a>二、顺序消息</h2><h3 id=\"1-什么是顺序消息\"><a href=\"#1-什么是顺序消息\" class=\"headerlink\" title=\"1 什么是顺序消息\"></a>1 什么是顺序消息</h3><p>顺序消息指的是，严格按照消息的<code>发送顺序</code>进行<code>消费</code>的消息(FIFO)。</p>\n<p>默认情况下生产者会把消息以Round Robin轮询方式发送到不同的Queue分区队列；而消费消息时会从多个Queue上拉取消息，这种情况下的发送和消费是不能保证顺序的。如果将消息仅发送到同一个Queue中，消费时也只从这个Queue上拉取消息，就严格保证了消息的顺序性。</p>\n<h3 id=\"2-为什么需要顺序消息\"><a href=\"#2-为什么需要顺序消息\" class=\"headerlink\" title=\"2 为什么需要顺序消息\"></a>2 为什么需要顺序消息</h3><p>例如，现在有TOPIC <code>ORDER_STATUS</code>(订单状态)，其下有 4 个Queue队列，该Topic中的不同消息用于描述当前订单的不同状态。假设订单有状态：未支付、已支付、发货中、发货成功、发货失败。</p>\n<p>根据以上订单状态，生产者从时序上可以生成如下几个消息：</p>\n<p>`订单T0000001:未支付 –&gt; 订单T0000001:已支付 –&gt; 订单T0000001:发货中 –&gt; 订单T0000001:发货失败</p>\n<p>消息发送到MQ中之后，Queue的选择如果采用轮询策略，消息在MQ的存储可能如下：</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208152040.png\" class title=\"输入图片说明\">\n\n<p>这种情况下，我们希望Consumer消费消息的顺序和我们发送是一致的，然而上述MQ的投递和消费方式，我们无法保证顺序是正确的。对于顺序异常的消息，Consumer即使设置有一定的状态容错，也不能完全处理好这么多种随机出现组合情况。</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208152144.png\" class title=\"输入图片说明\">\n\n<p>基于上述的情况，可以设计如下方案：对于相同订单号的消息，通过一定的策略，将其放置在一个Queue中，然后消费者再采用一定的策略（例如，一个线程独立处理一个queue，保证处理消息的顺序性），能够保证消费的顺序性。</p>\n<h3 id=\"3-有序性分类\"><a href=\"#3-有序性分类\" class=\"headerlink\" title=\"3 有序性分类\"></a>3 有序性分类</h3><p>根据有序范围的不同，RocketMQ可以严格地保证两种消息的有序性：分区有序与全局有序。</p>\n<h4 id=\"全局有序\"><a href=\"#全局有序\" class=\"headerlink\" title=\"全局有序\"></a>全局有序</h4><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208152224.png\" class title=\"输入图片说明\">\n\n<p>当发送和消费参与的Queue只有一个时所保证的有序是整个Topic中消息的顺序， 称为<code>全局有序</code>。</p>\n<blockquote>\n<p>在创建Topic时指定Queue的数量。有三种指定方式：<br><br><br>1 ）在代码中创建Producer时，可以指定其自动创建的Topic的Queue数量<br><br><br>2 ）在RocketMQ可视化控制台中手动创建Topic时指定Queue数量<br><br><br>3 ）使用mqadmin命令手动创建Topic时指定Queue数量<br></p>\n</blockquote>\n<h4 id=\"分区有序\"><a href=\"#分区有序\" class=\"headerlink\" title=\"分区有序\"></a>分区有序</h4><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208152417.png\" class title=\"输入图片说明\">\n\n<p>如果有多个Queue参与，其仅可保证在该Queue分区队列上的消息顺序，则称为<code>分区有序</code>。</p>\n<blockquote>\n<p>如何实现Queue的选择？在定义Producer时我们可以指定消息队列选择器，而这个选择器是我们自己实现了MessageQueueSelector接口定义的。<br><br><br>在定义选择器的选择算法时，一般需要使用选择key。这个选择key可以是消息key也可以是其它数据。但无论谁做选择key，都不能重复，都是唯一的。<br><br><br>一般性的选择算法是，让选择key（或其hash值）与该Topic所包含的Queue的数量取模，其结果即为选择出的Queue的QueueId。<br><br><br>取模算法存在一个问题：不同选择key与Queue数量取模结果可能会是相同的，即不同选择key的消息可能会出现在相同的Queue，即同一个Consuemr可能会消费到不同选择key的消息。这个问题如何解决？一般性的作法是，从消息中获取到选择key，对其进行判断。若是当前Consumer需要消费的消息，则直接消费，否则，什么也不做。这种做法要求选择key要能够随着消息一起被Consumer获取到。此时使用消息key作为选择key是比较好的做法。<br><br><br>以上做法会不会出现如下新的问题呢？不属于那个Consumer的消息被拉取走了，那么应该消费该消息的Consumer是否还能再消费该消息呢？同一个Queue中的消息不可能被同一个Group中的不同Consumer同时消费。所以，消费现一个Queue的不同选择key的消息的Consumer一定属于不同的Group。而不同的Group中的Consumer间的消费是相互隔离的，互不影响的。</p>\n</blockquote>\n<h3 id=\"4-代码举例\"><a href=\"#4-代码举例\" class=\"headerlink\" title=\"4 代码举例\"></a>4 代码举例</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OrderedProducer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        DefaultMQProducer producer = <span class=\"keyword\">new</span> DefaultMQProducer(<span class=\"string\">&quot;pg&quot;</span>);</span><br><span class=\"line\">        producer.setNamesrvAddr(<span class=\"string\">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class=\"line\">        producer.start();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">100</span> ; i++) &#123;</span><br><span class=\"line\">            Integer orderId = i;</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] body = (<span class=\"string\">&quot;Hi,&quot;</span> + i).getBytes();</span><br><span class=\"line\">            Message msg = <span class=\"keyword\">new</span> Message(<span class=\"string\">&quot;TopicA&quot;</span>, <span class=\"string\">&quot;TagA&quot;</span>, body);</span><br><span class=\"line\">            SendResult sendResult = producer.send(msg, <span class=\"keyword\">new</span> MessageQueueSelector() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> MessageQueue <span class=\"title\">select</span><span class=\"params\">(List&lt;MessageQueue&gt; mqs,Message msg, Object arg)</span> </span>&#123;</span><br><span class=\"line\">                        Integer id = (Integer) arg;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> index = id % mqs.size();</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> mqs.get(index);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;, orderId);</span><br><span class=\"line\">            System.out.println(sendResult);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        producer.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"三、延时消息\"><a href=\"#三、延时消息\" class=\"headerlink\" title=\"三、延时消息\"></a>三、延时消息</h2><h3 id=\"1-什么是延时消息\"><a href=\"#1-什么是延时消息\" class=\"headerlink\" title=\"1 什么是延时消息\"></a>1 什么是延时消息</h3><p>当消息写入到Broker后，在指定的时长后才可被消费处理的消息，称为延时消息。</p>\n<p>采用RocketMQ的延时消息可以实现<code>定时任务</code>的功能，而无需使用定时器。典型的应用场景是，电商交易中超时未支付关闭订单的场景， 12306 平台订票超时未支付取消订票的场景。</p>\n<blockquote>\n<p>在电商平台中，订单创建时会发送一条延迟消息。这条消息将会在 30 分钟后投递给后台业务系统（Consumer），后台业务系统收到该消息后会判断对应的订单是否已经完成支付。如果未完成，则取消订单，将商品再次放回到库存；如果完成支付，则忽略。<br><br><br>在 12306 平台中，车票预订成功后就会发送一条延迟消息。这条消息将会在 45 分钟后投递给后台业务系统（Consumer），后台业务系统收到该消息后会判断对应的订单是否已经完成支付。如果未完成，则取消预订，将车票再次放回到票池；如果完成支付，则忽略。</p>\n</blockquote>\n<h3 id=\"2-延时等级\"><a href=\"#2-延时等级\" class=\"headerlink\" title=\"2 延时等级\"></a>2 延时等级</h3><p>延时消息的延迟时长<code>不支持随意时长</code>的延迟，是通过特定的延迟等级来指定的。延时等级定义在RocketMQ服务端的MessageStoreConfig类中的如下变量中：</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208153410.png\" class title=\"输入图片说明\">\n\n<p>即，若指定的延时等级为 3 ，则表示延迟时长为10s，即延迟等级是从 1 开始计数的。</p>\n<p>当然，如果需要自定义的延时等级，可以通过在broker加载的配置中新增如下配置（例如下面增加了 1天这个等级1d）。配置文件在RocketMQ安装目录下的conf目录中。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">messageDelayLevel = 1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h 1d</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-延时消息实现原理\"><a href=\"#3-延时消息实现原理\" class=\"headerlink\" title=\"3 延时消息实现原理\"></a>3 延时消息实现原理</h3><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208153523.png\" class title=\"输入图片说明\">\n\n<h4 id=\"具体实现方案是：\"><a href=\"#具体实现方案是：\" class=\"headerlink\" title=\"具体实现方案是：\"></a>具体实现方案是：</h4><h4 id=\"修改消息\"><a href=\"#修改消息\" class=\"headerlink\" title=\"修改消息\"></a>修改消息</h4><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208153545.png\" class title=\"输入图片说明\">\n\n<p>Producer将消息发送到Broker后，Broker会首先将消息写入到commitlog文件，然后需要将其分发到相应的consumequeue。不过，在分发之前，系统会先判断消息中是否带有延时等级。若没有，则直接正常分发；若有则需要经历一个复杂的过程：</p>\n<ul>\n<li>修改消息的Topic为SCHEDULE_TOPIC_XXXX</li>\n<li>根据延时等级，在consumequeue目录中SCHEDULE_TOPIC_XXXX主题下创建出相应的queueId目录与consumequeue文件（如果没有这些目录与文件的话）。</li>\n</ul>\n<blockquote>\n<p>延迟等级delayLevel与queueId的对应关系为queueId = delayLevel -1<br><br>需要注意，在创建queueId目录时，并不是一次性地将所有延迟等级对应的目录全部创建完毕，而是用到哪个延迟等级创建哪个目录</p>\n</blockquote>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208153635.png\" class title=\"输入图片说明\">\n\n<ul>\n<li>修改消息索引单元内容。索引单元中的Message Tag HashCode部分原本存放的是消息的Tag的Hash值。现修改为消息的<code>投递时间</code>。投递时间是指该消息被重新修改为原Topic后再次被写入到commitlog中的时间。<code>投递时间 = 消息存储时间 + 延时等级时间</code>。消息存储时间指的是消息被发送到Broker时的时间戳。</li>\n<li>将消息索引写入到SCHEDULE_TOPIC_XXXX主题下相应的consumequeue中</li>\n</ul>\n<blockquote>\n<p>SCHEDULE_TOPIC_XXXX目录中各个延时等级Queue中的消息是如何排序的？<br><br><br>是按照消息投递时间排序的。一个Broker中同一等级的所有延时消息会被写入到consumequeue目录中SCHEDULE_TOPIC_XXXX目录下相同Queue中。即一个Queue中消息投递时间的延迟等级时间是相同的。那么投递时间就取决于于<code>消息存储时间</code>了。即按照消息被发送到Broker的时间进行排序的。</p>\n</blockquote>\n<h4 id=\"投递延时消息\"><a href=\"#投递延时消息\" class=\"headerlink\" title=\"投递延时消息\"></a>投递延时消息</h4><p>Broker内部有一个延迟消息服务类ScheuleMessageService，其会消费SCHEDULE_TOPIC_XXXX中的消息，即按照每条消息的投递时间，将延时消息投递到目标Topic中。不过，在投递之前会从commitlog中将原来写入的消息再次读出，并将其原来的延时等级设置为 0 ，即原消息变为了一条不延迟的普通消息。然后再次将消息投递到目标Topic中。</p>\n<blockquote>\n<p>ScheuleMessageService在Broker启动时，会创建并启动一个定时器TImer，用于执行相应的定时任务。系统会根据延时等级的个数，定义相应数量的TimerTask，每个TimerTask负责一个延迟等级消息的消费与投递。每个TimerTask都会检 测相应Queue队列的第一条消息是否到期。若第一条消息未到期，则后面的所有消息更不会到期（消息是按照投递时间排序的）；若第一条消息到期了，则将该消息投递到目标Topic，即消费该消息。</p>\n</blockquote>\n<h4 id=\"将消息重新写入commitlog\"><a href=\"#将消息重新写入commitlog\" class=\"headerlink\" title=\"将消息重新写入commitlog\"></a>将消息重新写入commitlog</h4><p>延迟消息服务类ScheuleMessageService将延迟消息再次发送给了commitlog，并再次形成新的消息索引条目，分发到相应Queue。</p>\n<blockquote>\n<p>这其实就是一次普通消息发送。只不过这次的消息Producer是延迟消息服务类ScheuleMessageService。</p>\n</blockquote>\n<h3 id=\"4-代码举例-1\"><a href=\"#4-代码举例-1\" class=\"headerlink\" title=\"4 代码举例\"></a>4 代码举例</h3><p>定义DelayProducer类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DelayProducer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        DefaultMQProducer producer = <span class=\"keyword\">new</span> DefaultMQProducer(<span class=\"string\">&quot;pg&quot;</span>);</span><br><span class=\"line\">        producer.setNamesrvAddr(<span class=\"string\">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class=\"line\">        producer.start();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">10</span> ; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] body = (<span class=\"string\">&quot;Hi,&quot;</span> + i).getBytes();</span><br><span class=\"line\">            Message msg = <span class=\"keyword\">new</span> Message(<span class=\"string\">&quot;TopicB&quot;</span>, <span class=\"string\">&quot;someTag&quot;</span>, body);</span><br><span class=\"line\">            <span class=\"comment\">// 指定消息延迟等级为 3 级，即延迟10s</span></span><br><span class=\"line\">            <span class=\"comment\">// msg.setDelayTimeLevel(3);</span></span><br><span class=\"line\">            SendResult sendResult = producer.send(msg);</span><br><span class=\"line\">            <span class=\"comment\">// 输出消息被发送的时间</span></span><br><span class=\"line\">            System.out.print(<span class=\"keyword\">new</span> SimpleDateFormat(<span class=\"string\">&quot;mm:ss&quot;</span>).format(<span class=\"keyword\">new</span> Date()));</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot; ,&quot;</span> + sendResult);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        producer.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>定义OtherConsumer类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OtherConsumer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> MQClientException </span>&#123;</span><br><span class=\"line\">        DefaultMQPushConsumer consumer = <span class=\"keyword\">new</span> DefaultMQPushConsumer(<span class=\"string\">&quot;cg&quot;</span>);</span><br><span class=\"line\">        consumer.setNamesrvAddr(<span class=\"string\">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class=\"line\">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET );</span><br><span class=\"line\">        consumer.subscribe(<span class=\"string\">&quot;TopicB&quot;</span>, <span class=\"string\">&quot;*&quot;</span>);</span><br><span class=\"line\">        consumer.registerMessageListener(<span class=\"keyword\">new</span> MessageListenerConcurrently() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> ConsumeConcurrentlyStatus <span class=\"title\">consumeMessage</span><span class=\"params\">(List&lt;MessageExt&gt; msgs,ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (MessageExt msg : msgs) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 输出消息被消费的时间</span></span><br><span class=\"line\">                    System.out.print(<span class=\"keyword\">new</span> SimpleDateFormat(<span class=\"string\">&quot;mm:ss&quot;</span>).format(<span class=\"keyword\">new</span> Date()));</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot; ,&quot;</span> + msg);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        consumer.start();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Consumer Started&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、事务消息\"><a href=\"#四、事务消息\" class=\"headerlink\" title=\"四、事务消息\"></a>四、事务消息</h2><h3 id=\"1-问题引入\"><a href=\"#1-问题引入\" class=\"headerlink\" title=\"1 问题引入\"></a>1 问题引入</h3><p>这里的一个需求场景是：工行用户A向建行用户B转账 1 万元。</p>\n<p>我们可以使用同步消息来处理该需求场景：</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208154429.png\" class title=\"输入图片说明\">\n\n<ul>\n<li><ol>\n<li>工行系统发送一个给B增款 1 万元的同步消息M给Broker</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>消息被Broker成功接收后，向工行系统发送成功ACK</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>工行系统收到成功ACK后从用户A中扣款 1 万元</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>建行系统从Broker中获取到消息M</li>\n</ol>\n</li>\n<li><ol start=\"5\">\n<li>建行系统消费消息M，即向用户B中增加 1 万元</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p>这其中是有问题的：若第 3 步中的扣款操作失败，但消息已经成功发送到了Broker。对于MQ来说，只要消息写入成功，那么这个消息就可以被消费。此时建行系统中用户B增加了 1 万元。出现了数据不一致问题。</p>\n</blockquote>\n<h3 id=\"2-解决思路\"><a href=\"#2-解决思路\" class=\"headerlink\" title=\"2 解决思路\"></a>2 解决思路</h3><p>解决思路是，让第 1 、 2 、 3 步具有原子性，要么全部成功，要么全部失败。即消息发送成功后，必须要保证扣款成功。如果扣款失败，则回滚发送成功的消息。而该思路即使用<code>事务消息</code>。这里要使用<code>分布式事务</code>解决方案。</p>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208154545.png\" class title=\"输入图片说明\">\n\n<h4 id=\"使用事务消息来处理该需求场景：\"><a href=\"#使用事务消息来处理该需求场景：\" class=\"headerlink\" title=\"使用事务消息来处理该需求场景：\"></a>使用事务消息来处理该需求场景：</h4><ul>\n<li><ol>\n<li>事务管理器TM向事务协调器TC发起指令，开启全局事务</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>工行系统发一个给B增款 1 万元的事务消息M给TC</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>TC会向Broker发送半事务消息prepareHalf，将消息M预提交到Broker。此时的建行系统是看不到Broker中的消息M的</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>Broker会将预提交执行结果Report给TC。</li>\n</ol>\n</li>\n<li><ol start=\"5\">\n<li>如果预提交失败，则TC会向TM上报预提交失败的响应，全局事务结束；如果预提交成功，TC会调用工行系统的回调操作，去完成工行用户A的预扣款 1 万元的操作</li>\n</ol>\n</li>\n<li><ol start=\"6\">\n<li>工行系统会向TC发送预扣款执行结果，即本地事务的执行状态</li>\n</ol>\n</li>\n<li><ol start=\"7\">\n<li>TC收到预扣款执行结果后，会将结果上报给TM。</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p>预扣款执行结果存在三种可能性：<br></p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 描述本地事务执行状态</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">LocalTransactionState</span> </span>&#123;</span><br><span class=\"line\">    COMMIT_MESSAGE,  <span class=\"comment\">// 本地事务执行成功</span></span><br><span class=\"line\">    ROLLBACK_MESSAGE,  <span class=\"comment\">// 本地事务执行失败</span></span><br><span class=\"line\">    UNKNOW,  <span class=\"comment\">// 不确定，表示需要进行回查以确定本地事务的执行结果</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><ol start=\"8\">\n<li>TM会根据上报结果向TC发出不同的确认指令</li>\n</ol>\n<ul>\n<li>若预扣款成功（本地事务状态为COMMIT_MESSAGE），则TM向TC发送Global Commit指令</li>\n<li>若预扣款失败（本地事务状态为ROLLBACK_MESSAGE），则TM向TC发送Global Rollback指令</li>\n<li>若现未知状态（本地事务状态为UNKNOW），则会触发工行系统的本地事务状态<code>回查操作</code>。回查操作会将回查结果，即COMMIT_MESSAGE或ROLLBACK_MESSAGE Report给TC。TC将结果上报给TM，TM会再向TC发送最终确认指令Global Commit或Global Rollback</li>\n</ul>\n</li>\n<li><ol start=\"9\">\n<li>TC在接收到指令后会向Broker与工行系统发出确认指令</li>\n</ol>\n<ul>\n<li>TC接收的若是Global Commit指令，则向Broker与工行系统发送Branch Commit指令。此时Broker中的消息M才可被建行系统看到；此时的工行用户A中的扣款操作才真正被确认</li>\n<li>TC接收到的若是Global Rollback指令，则向Broker与工行系统发送Branch Rollback指令。此时Broker中的消息M将被撤销；工行用户A中的扣款操作将被回滚</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>以上方案就是为了确保<code>消息投递</code>与<code>扣款操作</code>能够在一个事务中，要成功都成功，有一个失败，则全部回滚。<br><br><br>以上方案并不是一个典型的XA模式。因为XA模式中的分支事务是异步的，而事务消息方案中的消息预提交与预扣款操作间是同步的。</p>\n</blockquote>\n<h3 id=\"3-基础\"><a href=\"#3-基础\" class=\"headerlink\" title=\"3 基础\"></a>3 基础</h3><h4 id=\"分布式事务\"><a href=\"#分布式事务\" class=\"headerlink\" title=\"分布式事务\"></a>分布式事务</h4><p>对于分布式事务，通俗地说就是，一次操作由若干分支操作组成，这些分支操作分属不同应用，分布在不同服务器上。分布式事务需要保证这些分支操作要么全部成功，要么全部失败。分布式事务与普通事务一样，就是为了保证操作结果的一致性。</p>\n<h4 id=\"事务消息\"><a href=\"#事务消息\" class=\"headerlink\" title=\"事务消息\"></a>事务消息</h4><p>RocketMQ提供了类似X/Open XA的分布式事务功能，通过事务消息能达到分布式事务的最终一致。XA是一种分布式事务解决方案，一种分布式事务处理模式。</p>\n<h4 id=\"半事务消息\"><a href=\"#半事务消息\" class=\"headerlink\" title=\"半事务消息\"></a>半事务消息</h4><p>暂不能投递的消息，发送方已经成功地将消息发送到了Broker，但是Broker未收到最终确认指令，此时该消息被标记成“暂不能投递”状态，即不能被消费者看到。处于该种状态下的消息即半事务消息。</p>\n<h4 id=\"本地事务状态\"><a href=\"#本地事务状态\" class=\"headerlink\" title=\"本地事务状态\"></a>本地事务状态</h4><p>Producer<code>回调操作</code>执行的结果为本地事务状态，其会发送给TC，而TC会再发送给TM。TM会根据TC发送来的本地事务状态来决定全局事务确认指令。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 描述本地事务执行状态</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">LocalTransactionState</span> </span>&#123;</span><br><span class=\"line\">    COMMIT_MESSAGE,  <span class=\"comment\">// 本地事务执行成功</span></span><br><span class=\"line\">    ROLLBACK_MESSAGE,  <span class=\"comment\">// 本地事务执行失败</span></span><br><span class=\"line\">    UNKNOW,  <span class=\"comment\">// 不确定，表示需要进行回查以确定本地事务的执行结果</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"消息回查\"><a href=\"#消息回查\" class=\"headerlink\" title=\"消息回查\"></a>消息回查</h4><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208155046.png\" class title=\"输入图片说明\">\n\n<p>消息回查，即重新查询本地事务的执行状态。本例就是重新到DB中查看预扣款操作是否执行成功。</p>\n<blockquote>\n<p>注意，消息回查不是重新执行回调操作。回调操作是进行预扣款操作，而消息回查则是查看预扣款操作执行的结果。<br><br><br>引发消息回查的原因最常见的有两个：<br><br>1)回调操作返回UNKNWON<br><br>2)TC没有接收到TM的最终全局事务确认指令<br></p>\n</blockquote>\n<h4 id=\"RocketMQ中的消息回查设置\"><a href=\"#RocketMQ中的消息回查设置\" class=\"headerlink\" title=\"RocketMQ中的消息回查设置\"></a>RocketMQ中的消息回查设置</h4><p>关于消息回查，有三个常见的属性设置。它们都在broker加载的配置文件中设置，例如：</p>\n<ul>\n<li>transactionTimeout=20，指定TM在 20 秒内应将最终确认状态发送给TC，否则引发消息回查。默认为 60 秒</li>\n<li>transactionCheckMax=5，指定最多回查 5 次，超过后将丢弃消息并记录错误日志。默认 15 次。</li>\n<li>transactionCheckInterval=10，指定设置的多次消息回查的时间间隔为 10 秒。默认为 60 秒。</li>\n</ul>\n<h3 id=\"4-XA模式三剑客\"><a href=\"#4-XA模式三剑客\" class=\"headerlink\" title=\"4 XA模式三剑客\"></a>4 XA模式三剑客</h3><h4 id=\"XA协议\"><a href=\"#XA协议\" class=\"headerlink\" title=\"XA协议\"></a>XA协议</h4><p>XA（Unix Transaction）是一种分布式事务解决方案，一种分布式事务处理模式，是基于XA协议的。<br><br>XA协议由Tuxedo（Transaction for Unix has been Extended for Distributed Operation，分布式操作扩展之后的Unix事务系统）首先提出的，并交给X/Open组织，作为资源管理器与事务管理器的接口标准。</p>\n<p><code>XA模式中有三个重要组件：TC、TM、RM。</code></p>\n<h4 id=\"TC\"><a href=\"#TC\" class=\"headerlink\" title=\"TC\"></a>TC</h4><p>Transaction Coordinator，事务协调者。维护全局和分支事务的状态，驱动全局事务提交或回滚。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">RocketMQ中Broker充当着TC。</span><br></pre></td></tr></table></figure>\n<h4 id=\"TM\"><a href=\"#TM\" class=\"headerlink\" title=\"TM\"></a>TM</h4><p>Transaction Manager，事务管理器。定义全局事务的范围：开始全局事务、提交或回滚全局事务。它实际是全局事务的发起者。</p>\n<blockquote>\n<p>RocketMQ中事务消息的Producer充当着TM。</p>\n</blockquote>\n<h4 id=\"RM\"><a href=\"#RM\" class=\"headerlink\" title=\"RM\"></a>RM</h4><p>Resource Manager，资源管理器。管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</p>\n<blockquote>\n<p>RocketMQ中事务消息的Producer及Broker均是RM。</p>\n</blockquote>\n<h3 id=\"5-XA模式架构\"><a href=\"#5-XA模式架构\" class=\"headerlink\" title=\"5 XA模式架构\"></a>5 XA模式架构</h3><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208155359.png\" class title=\"输入图片说明\">\n\n<p>XA模式是一个典型的2PC，其执行原理如下：</p>\n<ul>\n<li><ol>\n<li>TM向TC发起指令，开启一个全局事务。</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>根据业务要求，各个RM会逐个向TC注册分支事务，然后TC会逐个向RM发出预执行指令。</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>各个RM在接收到指令后会在进行本地事务预执行。</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>RM将预执行结果Report给TC。当然，这个结果可能是成功，也可能是失败。</li>\n</ol>\n</li>\n<li><ol start=\"5\">\n<li>TC在接收到各个RM的Report后会将汇总结果上报给TM，根据汇总结果TM会向TC发出确认指令。</li>\n</ol>\n<ul>\n<li>若所有结果都是成功响应，则向TC发送Global Commit指令。</li>\n<li>只要有结果是失败响应，则向TC发送Global Rollback指令。</li>\n</ul>\n</li>\n<li><ol start=\"6\">\n<li>TC在接收到指令后再次向RM发送确认指令。</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p>事务消息方案并不是一个典型的XA模式。因为XA模式中的分支事务是异步的，而事务消息方案中的消息预提交与预扣款操作间是同步的。</p>\n</blockquote>\n<h3 id=\"6-注意\"><a href=\"#6-注意\" class=\"headerlink\" title=\"6 注意\"></a>6 注意</h3><ul>\n<li>事务消息不支持延时消息</li>\n<li>对于事务消息要做好幂等性检查，因为事务消息可能不止一次被消费（因为存在回滚后再提交的情况）</li>\n</ul>\n<h3 id=\"7-代码举例\"><a href=\"#7-代码举例\" class=\"headerlink\" title=\"7 代码举例\"></a>7 代码举例</h3><h4 id=\"定义工行事务监听器\"><a href=\"#定义工行事务监听器\" class=\"headerlink\" title=\"定义工行事务监听器\"></a>定义工行事务监听器</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ICBCTransactionListener</span> <span class=\"keyword\">implements</span> <span class=\"title\">TransactionListener</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 回调操作方法</span></span><br><span class=\"line\">    <span class=\"comment\">// 消息预提交成功就会触发该方法的执行，用于完成本地事务</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> LocalTransactionState <span class=\"title\">executeLocalTransaction</span><span class=\"params\">(Message msg,Object arg)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;预提交消息成功：&quot;</span> + msg);</span><br><span class=\"line\">        <span class=\"comment\">// 假设接收到TAGA的消息就表示扣款操作成功，TAGB的消息表示扣款失败，</span></span><br><span class=\"line\">        <span class=\"comment\">// TAGC表示扣款结果不清楚，需要执行消息回查</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.equals(<span class=\"string\">&quot;TAGA&quot;</span>, msg.getTags())) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (StringUtils.equals(<span class=\"string\">&quot;TAGB&quot;</span>, msg.getTags())) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (StringUtils.equals(<span class=\"string\">&quot;TAGC&quot;</span>, msg.getTags())) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> LocalTransactionState.UNKNOW;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> LocalTransactionState.UNKNOW;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 消息回查方法</span></span><br><span class=\"line\">    <span class=\"comment\">// 引发消息回查的原因最常见的有两个：</span></span><br><span class=\"line\">    <span class=\"comment\">// 1)回调操作返回UNKNWON</span></span><br><span class=\"line\">    <span class=\"comment\">// 2)TC没有接收到TM的最终全局事务确认指令</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> LocalTransactionState <span class=\"title\">checkLocalTransaction</span><span class=\"params\">(MessageExt msg)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;执行消息回查&quot;</span> + msg.getTags());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"定义事物消息生产者\"><a href=\"#定义事物消息生产者\" class=\"headerlink\" title=\"定义事物消息生产者\"></a>定义事物消息生产者</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TransactionProducer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        TransactionMQProducer producer = <span class=\"keyword\">new</span> TransactionMQProducer(<span class=\"string\">&quot;tpg&quot;</span>);</span><br><span class=\"line\">        producer.setNamesrvAddr(<span class=\"string\">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">        * 定义一个线程池</span></span><br><span class=\"line\"><span class=\"comment\">        * <span class=\"doctag\">@param</span> corePoolSize 线程池中核心线程数量</span></span><br><span class=\"line\"><span class=\"comment\">        * <span class=\"doctag\">@param</span> maximumPoolSize 线程池中最多线程数</span></span><br><span class=\"line\"><span class=\"comment\">        * <span class=\"doctag\">@param</span> keepAliveTime 这是一个时间。当线程池中线程数量大于核心线程数量是，多余空闲线程的存活时长</span></span><br><span class=\"line\"><span class=\"comment\">        * <span class=\"doctag\">@param</span> unit 时间单位</span></span><br><span class=\"line\"><span class=\"comment\">        * <span class=\"doctag\">@param</span> workQueue 临时存放任务的队列，其参数就是队列的长度</span></span><br><span class=\"line\"><span class=\"comment\">        * <span class=\"doctag\">@param</span> threadFactory 线程工厂</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        ExecutorService executorService = <span class=\"keyword\">new</span> ThreadPoolExecutor( <span class=\"number\">2</span> , <span class=\"number\">5</span> ,<span class=\"number\">100</span> , TimeUnit.SECONDS,<span class=\"keyword\">new</span> ArrayBlockingQueue&lt;Runnable&gt;( <span class=\"number\">2000</span> ), <span class=\"keyword\">new</span> ThreadFactory() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> Thread <span class=\"title\">newThread</span><span class=\"params\">(Runnable r)</span> </span>&#123;</span><br><span class=\"line\">                Thread thread = <span class=\"keyword\">new</span> Thread(r);</span><br><span class=\"line\">                thread.setName(<span class=\"string\">&quot;client-transaction-msg-check-thread&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> thread;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"comment\">// 为生产者指定一个线程池</span></span><br><span class=\"line\">        producer.setExecutorService(executorService);</span><br><span class=\"line\">        <span class=\"comment\">// 为生产者添加事务监听器</span></span><br><span class=\"line\">        producer.setTransactionListener(<span class=\"keyword\">new</span> ICBCTransactionListener());</span><br><span class=\"line\">        producer.start();</span><br><span class=\"line\">        String[] tags = &#123;<span class=\"string\">&quot;TAGA&quot;</span>,<span class=\"string\">&quot;TAGB&quot;</span>,<span class=\"string\">&quot;TAGC&quot;</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">3</span> ; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] body = (<span class=\"string\">&quot;Hi,&quot;</span> + i).getBytes();</span><br><span class=\"line\">            Message msg = <span class=\"keyword\">new</span> Message(<span class=\"string\">&quot;TTopic&quot;</span>, tags[i], body);</span><br><span class=\"line\">            <span class=\"comment\">// 发送事务消息</span></span><br><span class=\"line\">            <span class=\"comment\">// 第二个参数用于指定在执行本地事务时要使用的业务参数</span></span><br><span class=\"line\">            SendResult sendResult =producer.sendMessageInTransaction(msg,<span class=\"keyword\">null</span>);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;发送结果为：&quot;</span> +sendResult.getSendStatus());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"定义消费者\"><a href=\"#定义消费者\" class=\"headerlink\" title=\"定义消费者\"></a>定义消费者</h4><p>直接使用普通消息的SomeConsumer作为消费者即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeConsumer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> MQClientException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// DefaultLitePullConsumer consumer = new DefaultLitePullConsumer(&quot;cg&quot;);</span></span><br><span class=\"line\">        <span class=\"comment\">// 定义一个push消费者</span></span><br><span class=\"line\">        DefaultMQPushConsumer consumer = <span class=\"keyword\">new</span> DefaultMQPushConsumer(<span class=\"string\">&quot;cg&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 指定nameServer</span></span><br><span class=\"line\">        consumer.setNamesrvAddr(<span class=\"string\">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 指定从第一条消息开始消费</span></span><br><span class=\"line\">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class=\"line\">        <span class=\"comment\">// 指定消费topic与tag</span></span><br><span class=\"line\">        consumer.subscribe(<span class=\"string\">&quot;TTopic&quot;</span>, <span class=\"string\">&quot;*&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 指定采用“广播模式”进行消费，默认为“集群模式”</span></span><br><span class=\"line\">        <span class=\"comment\">// consumer.setMessageModel(MessageModel.BROADCASTING);</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 注册消息监听器</span></span><br><span class=\"line\">        consumer.registerMessageListener(<span class=\"keyword\">new</span> MessageListenerConcurrently() &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 一旦broker中有了其订阅的消息就会触发该方法的执行，</span></span><br><span class=\"line\">            <span class=\"comment\">// 其返回值为当前consumer消费的状态</span></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> ConsumeConcurrentlyStatus <span class=\"title\">consumeMessage</span><span class=\"params\">(List&lt;MessageExt&gt; msgs,ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 逐条消费消息</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (MessageExt msg : msgs) &#123;</span><br><span class=\"line\">                    System.out.println(msg);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 返回消费状态：消费成功</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"comment\">// 开启消费者消费</span></span><br><span class=\"line\">        consumer.start();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Consumer Started&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"五、批量消息\"><a href=\"#五、批量消息\" class=\"headerlink\" title=\"五、批量消息\"></a>五、批量消息</h2><h3 id=\"1-批量发送消息\"><a href=\"#1-批量发送消息\" class=\"headerlink\" title=\"1 批量发送消息\"></a>1 批量发送消息</h3><h4 id=\"发送限制\"><a href=\"#发送限制\" class=\"headerlink\" title=\"发送限制\"></a>发送限制</h4><p>生产者进行消息发送时可以一次发送多条消息，这可以大大提升Producer的发送效率。不过需要注意以下几点：</p>\n<ul>\n<li>批量发送的消息必须具有相同的Topic</li>\n<li>批量发送的消息必须具有相同的刷盘策略</li>\n<li>批量发送的消息不能是延时消息与事务消息</li>\n</ul>\n<h4 id=\"批量发送大小\"><a href=\"#批量发送大小\" class=\"headerlink\" title=\"批量发送大小\"></a>批量发送大小</h4><p>默认情况下，一批发送的消息总大小不能超过4MB字节。如果想超出该值，有两种解决方案：</p>\n<ul>\n<li>方案一：将批量消息进行拆分，拆分为若干不大于4M的消息集合分多次批量发送</li>\n<li>方案二：在Producer端与Broker端修改属性</li>\n</ul>\n<p>** Producer端需要在发送之前设置Producer的maxMessageSize属性</p>\n<p>** Broker端需要修改其加载的配置文件中的maxMessageSize属性</p>\n<h4 id=\"生产者发送的消息大小\"><a href=\"#生产者发送的消息大小\" class=\"headerlink\" title=\"生产者发送的消息大小\"></a>生产者发送的消息大小</h4><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208160513.png\" class title=\"输入图片说明\">\n\n<p>生产者通过send()方法发送的Message，并不是直接将Message序列化后发送到网络上的，而是通过这个Message生成了一个字符串发送出去的。这个字符串由四部分构成：Topic、消息Body、消息日志（占 20 字节），及用于描述消息的一堆属性key-value。这些属性中包含例如生产者地址、生产时间、要发送的QueueId等。最终写入到Broker中消息单元中的数据都是来自于这些属性。</p>\n<h3 id=\"2-批量消费消息\"><a href=\"#2-批量消费消息\" class=\"headerlink\" title=\"2 批量消费消息\"></a>2 批量消费消息</h3><h4 id=\"修改批量属性\"><a href=\"#修改批量属性\" class=\"headerlink\" title=\"修改批量属性\"></a>修改批量属性</h4><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208160544.png\" class title=\"输入图片说明\">\n\n<p>Consumer的MessageListenerConcurrently监听接口的consumeMessage()方法的第一个参数为消息列表，但默认情况下每次只能消费一条消息。若要使其一次可以消费多条消息，则可以通过修改Consumer的consumeMessageBatchMaxSize属性来指定。不过，该值不能超过 32 。因为默认情况下消费者每次可以拉取的消息最多是 32 条。若要修改一次拉取的最大值，则可通过修改Consumer的pullBatchSize属性来指定。</p>\n<h4 id=\"存在的问题\"><a href=\"#存在的问题\" class=\"headerlink\" title=\"存在的问题\"></a>存在的问题</h4><p>Consumer的pullBatchSize属性与consumeMessageBatchMaxSize属性是否设置的越大越好？当然不是。</p>\n<ul>\n<li>pullBatchSize值设置的越大，Consumer每拉取一次需要的时间就会越长，且在网络上传输出现问题的可能性就越高。若在拉取过程中若出现了问题，那么本批次所有消息都需要全部重新拉取。</li>\n<li>consumeMessageBatchMaxSize值设置的越大，Consumer的消息并发消费能力越低，且这批被消费的消息具有相同的消费结果。因为consumeMessageBatchMaxSize指定的一批消息只会使用一个线程进行处理，且在处理过程中只要有一个消息处理异常，则这批消息需要全部重新再次消费处理。<h3 id=\"3-代码举例\"><a href=\"#3-代码举例\" class=\"headerlink\" title=\"3 代码举例\"></a>3 代码举例</h3>该批量发送的需求是，不修改最大发送4M的默认值，但要防止发送的批量消息超出4M的限制。</li>\n</ul>\n<h4 id=\"定义消息列表分割器\"><a href=\"#定义消息列表分割器\" class=\"headerlink\" title=\"定义消息列表分割器\"></a>定义消息列表分割器</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">    <span class=\"comment\">// 消息列表分割器：其只会处理每条消息的大小不超4M的情况。</span></span><br><span class=\"line\">    <span class=\"comment\">// 若存在某条消息，其本身大小大于4M，这个分割器无法处理，</span></span><br><span class=\"line\">    <span class=\"comment\">// 其直接将这条消息构成一个子列表返回。并没有再进行分割</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MessageListSplitter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">List</span>&lt;<span class=\"title\">Message</span>&gt;&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 指定极限值为4M</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SIZE_LIMIT =  <span class=\"number\">4</span> * <span class=\"number\">1024</span> * <span class=\"number\">1024</span> ;</span><br><span class=\"line\">    <span class=\"comment\">// 存放所有要发送的消息</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;Message&gt; messages;</span><br><span class=\"line\">    <span class=\"comment\">// 要进行批量发送消息的小集合起始索引</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> currIndex;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MessageListSplitter</span><span class=\"params\">(List&lt;Message&gt; messages)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.messages = messages;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断当前开始遍历的消息索引要小于消息总数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> currIndex &lt; messages.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Message&gt; <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nextIndex = currIndex;</span><br><span class=\"line\">        <span class=\"comment\">// 记录当前要发送的这一小批次消息列表的大小</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> totalSize = <span class=\"number\">0</span> ;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; nextIndex &lt; messages.size(); nextIndex++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获取当前遍历的消息</span></span><br><span class=\"line\">            Message message = messages.get(nextIndex);</span><br><span class=\"line\">            <span class=\"comment\">// 统计当前遍历的message的大小</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmpSize = message.getTopic().length() + message.getBody().length;</span><br><span class=\"line\">            Map&lt;String, String&gt; properties = message.getProperties();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Map.Entry&lt;String, String&gt; entry :properties.entrySet()) &#123;</span><br><span class=\"line\">                tmpSize += entry.getKey().length() +</span><br><span class=\"line\">                entry.getValue().length();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            tmpSize = tmpSize + <span class=\"number\">20</span> ;</span><br><span class=\"line\">            <span class=\"comment\">// 判断当前消息本身是否大于4M</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tmpSize &gt; SIZE_LIMIT) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (nextIndex - currIndex == <span class=\"number\">0</span> ) &#123;</span><br><span class=\"line\">                    nextIndex++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tmpSize + totalSize &gt; SIZE_LIMIT) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                totalSize += tmpSize;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"comment\">// end-for</span></span><br><span class=\"line\">        <span class=\"comment\">// 获取当前messages列表的子集合[currIndex, nextIndex)</span></span><br><span class=\"line\">        List&lt;Message&gt; subList = messages.subList(currIndex, nextIndex);</span><br><span class=\"line\">        <span class=\"comment\">// 下次遍历的开始索引</span></span><br><span class=\"line\">        currIndex = nextIndex;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> subList;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"定义批量消息生产者\"><a href=\"#定义批量消息生产者\" class=\"headerlink\" title=\"定义批量消息生产者\"></a>定义批量消息生产者</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BatchProducer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        DefaultMQProducer producer = <span class=\"keyword\">new</span> DefaultMQProducer(<span class=\"string\">&quot;pg&quot;</span>);</span><br><span class=\"line\">        producer.setNamesrvAddr(<span class=\"string\">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 指定要发送的消息的最大大小，默认是4M</span></span><br><span class=\"line\">        <span class=\"comment\">// 不过，仅修改该属性是不行的，还需要同时修改broker加载的配置文件中的</span></span><br><span class=\"line\">        <span class=\"comment\">// maxMessageSize属性</span></span><br><span class=\"line\">        <span class=\"comment\">// producer.setMaxMessageSize(8 * 1024 * 1024);</span></span><br><span class=\"line\">        producer.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 定义要发送的消息集合</span></span><br><span class=\"line\">        List&lt;Message&gt; messages = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">100</span> ; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] body = (<span class=\"string\">&quot;Hi,&quot;</span> + i).getBytes();</span><br><span class=\"line\">            Message msg = <span class=\"keyword\">new</span> Message(<span class=\"string\">&quot;someTopic&quot;</span>, <span class=\"string\">&quot;someTag&quot;</span>, body);</span><br><span class=\"line\">            messages.add(msg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 定义消息列表分割器，将消息列表分割为多个不超出4M大小的小列表</span></span><br><span class=\"line\">        MessageListSplitter splitter = <span class=\"keyword\">new</span> MessageListSplitter(messages);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (splitter.hasNext()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                List&lt;Message&gt; listItem = splitter.next();</span><br><span class=\"line\">                producer.send(listItem);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        producer.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"定义批量消息消费者\"><a href=\"#定义批量消息消费者\" class=\"headerlink\" title=\"定义批量消息消费者\"></a>定义批量消息消费者</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BatchConsumer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> MQClientException </span>&#123;</span><br><span class=\"line\">        DefaultMQPushConsumer consumer = <span class=\"keyword\">new</span> DefaultMQPushConsumer(<span class=\"string\">&quot;cg&quot;</span>);</span><br><span class=\"line\">        consumer.setNamesrvAddr(<span class=\"string\">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class=\"line\">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class=\"line\">        consumer.subscribe(<span class=\"string\">&quot;someTopicA&quot;</span>, <span class=\"string\">&quot;*&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 指定每次可以消费 10 条消息，默认为 1</span></span><br><span class=\"line\">        consumer.setConsumeMessageBatchMaxSize( <span class=\"number\">10</span> );</span><br><span class=\"line\">        <span class=\"comment\">// 指定每次可以从Broker拉取 40 条消息，默认为 32</span></span><br><span class=\"line\">        consumer.setPullBatchSize( <span class=\"number\">40</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">        consumer.registerMessageListener(<span class=\"keyword\">new</span> MessageListenerConcurrently() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> ConsumeConcurrentlyStatus <span class=\"title\">consumeMessage</span><span class=\"params\">(List&lt;MessageExt&gt; msgs,ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (MessageExt msg : msgs) &#123;</span><br><span class=\"line\">                    System.out.println(msg);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 消费成功的返回结果</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class=\"line\">                <span class=\"comment\">// 消费异常时的返回结果</span></span><br><span class=\"line\">                <span class=\"comment\">// return ConsumeConcurrentlyStatus.RECONSUME_LATER;</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        consumer.start();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Consumer Started&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"六、消息过滤\"><a href=\"#六、消息过滤\" class=\"headerlink\" title=\"六、消息过滤\"></a>六、消息过滤</h2><p>消息者在进行消息订阅时，除了可以指定要订阅消息的Topic外，还可以对指定Topic中的消息根据指定条件进行过滤，即可以订阅比Topic更加细粒度的消息类型。</p>\n<p>对于指定Topic消息的过滤有两种过滤方式：Tag过滤与SQL过滤。</p>\n<h3 id=\"1-Tag过滤\"><a href=\"#1-Tag过滤\" class=\"headerlink\" title=\"1 Tag过滤\"></a>1 Tag过滤</h3><p>通过consumer的subscribe()方法指定要订阅消息的Tag。如果订阅多个Tag的消息，Tag间使用或运算符(双竖线||)连接。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">DefaultMQPushConsumer consumer = <span class=\"keyword\">new</span> DefaultMQPushConsumer(<span class=\"string\">&quot;CID_EXAMPLE&quot;</span>);</span><br><span class=\"line\">consumer.subscribe(<span class=\"string\">&quot;TOPIC&quot;</span>, <span class=\"string\">&quot;TAGA || TAGB || TAGC&quot;</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-SQL过滤\"><a href=\"#2-SQL过滤\" class=\"headerlink\" title=\"2 SQL过滤\"></a>2 SQL过滤</h3><p>SQL过滤是一种通过特定表达式对事先埋入到消息中的<code>用户属性</code>进行筛选过滤的方式。通过SQL过滤，可以实现对消息的复杂过滤。不过，只有使用<code>PUSH模式</code>的消费者才能使用SQL过滤。</p>\n<p>SQL过滤表达式中支持多种常量类型与运算符。</p>\n<p>支持的常量类型：</p>\n<ul>\n<li>数值：比如： 123 ，3.1415</li>\n<li>字符：必须用单引号包裹起来，比如：’abc’</li>\n<li>布尔：TRUE 或 FALSE</li>\n<li>NULL：特殊的常量，表示空</li>\n</ul>\n<p>支持的运算符有：</p>\n<ul>\n<li>数值比较：&gt;，&gt;=，&lt;，&lt;=，BETWEEN，=</li>\n<li>字符比较：=，&lt;&gt;，IN</li>\n<li>逻辑运算 ：AND，OR，NOT</li>\n<li>NULL判断：IS NULL 或者 IS NOT NULL</li>\n</ul>\n<p>默认情况下Broker没有开启消息的SQL过滤功能，需要在Broker加载的配置文件中添加如下属性，以开启该功能：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">enablePropertyFilter = true</span><br></pre></td></tr></table></figure>\n\n<p>在启动Broker时需要指定这个修改过的配置文件。例如对于单机Broker的启动，其修改的配置文件是conf/broker.conf，启动时使用如下命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">sh bin/mqbroker -n localhost:9876 -c conf/broker.conf &amp;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-代码举例-1\"><a href=\"#3-代码举例-1\" class=\"headerlink\" title=\"3 代码举例\"></a>3 代码举例</h3><p>定义Tag过滤Producer</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FilterByTagProducer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        DefaultMQProducer producer = <span class=\"keyword\">new</span> DefaultMQProducer(<span class=\"string\">&quot;pg&quot;</span>);</span><br><span class=\"line\">        producer.setNamesrvAddr(<span class=\"string\">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class=\"line\">        producer.start();</span><br><span class=\"line\">        String[] tags = &#123;<span class=\"string\">&quot;myTagA&quot;</span>,<span class=\"string\">&quot;myTagB&quot;</span>,<span class=\"string\">&quot;myTagC&quot;</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">10</span> ; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] body = (<span class=\"string\">&quot;Hi,&quot;</span> + i).getBytes();</span><br><span class=\"line\">            String tag = tags[i%tags.length];</span><br><span class=\"line\">            Message msg = <span class=\"keyword\">new</span> Message(<span class=\"string\">&quot;myTopic&quot;</span>,tag,body);</span><br><span class=\"line\">            SendResult sendResult = producer.send(msg);</span><br><span class=\"line\">            System.out.println(sendResult);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        producer.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>定义Tag过滤Consumer</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FilterByTagConsumer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        DefaultMQPushConsumer consumer = <span class=\"keyword\">new</span> DefaultMQPushConsumer(<span class=\"string\">&quot;pg&quot;</span>);</span><br><span class=\"line\">        consumer.setNamesrvAddr(<span class=\"string\">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class=\"line\">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class=\"line\"></span><br><span class=\"line\">        consumer.subscribe(<span class=\"string\">&quot;myTopic&quot;</span>, <span class=\"string\">&quot;myTagA || myTagB&quot;</span>);</span><br><span class=\"line\">        consumer.registerMessageListener(<span class=\"keyword\">new</span> MessageListenerConcurrently() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> ConsumeConcurrentlyStatus <span class=\"title\">consumeMessage</span><span class=\"params\">(List&lt;MessageExt&gt; msgs,ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (MessageExt me:msgs)&#123;</span><br><span class=\"line\">                    System.out.println(me);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        consumer.start();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Consumer Started&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>定义SQL过滤Producer</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FilterBySQLProducer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        DefaultMQProducer producer = <span class=\"keyword\">new</span> DefaultMQProducer(<span class=\"string\">&quot;pg&quot;</span>);</span><br><span class=\"line\">        producer.setNamesrvAddr(<span class=\"string\">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class=\"line\">        producer.start();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">10</span> ; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">byte</span>[] body = (<span class=\"string\">&quot;Hi,&quot;</span> + i).getBytes();</span><br><span class=\"line\">                Message msg = <span class=\"keyword\">new</span> Message(<span class=\"string\">&quot;myTopic&quot;</span>, <span class=\"string\">&quot;myTag&quot;</span>, body);</span><br><span class=\"line\">                msg.putUserProperty(<span class=\"string\">&quot;age&quot;</span>, i + <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">                SendResult sendResult = producer.send(msg);</span><br><span class=\"line\">                System.out.println(sendResult);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        producer.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>定义SQL过滤Consumer</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FilterBySQLConsumer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        DefaultMQPushConsumer consumer = <span class=\"keyword\">new</span> DefaultMQPushConsumer(<span class=\"string\">&quot;pg&quot;</span>);</span><br><span class=\"line\">        consumer.setNamesrvAddr(<span class=\"string\">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class=\"line\">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class=\"line\">        consumer.subscribe(<span class=\"string\">&quot;myTopic&quot;</span>, MessageSelector.bySql(<span class=\"string\">&quot;age between 0 and 6&quot;</span>));</span><br><span class=\"line\">        consumer.registerMessageListener(<span class=\"keyword\">new</span> MessageListenerConcurrently() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> ConsumeConcurrentlyStatus <span class=\"title\">consumeMessage</span><span class=\"params\">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (MessageExt me:msgs)&#123;</span><br><span class=\"line\">                    System.out.println(me);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        consumer.start();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Consumer Started&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"七、消息发送重试机制\"><a href=\"#七、消息发送重试机制\" class=\"headerlink\" title=\"七、消息发送重试机制\"></a>七、消息发送重试机制</h2><h3 id=\"1-说明\"><a href=\"#1-说明\" class=\"headerlink\" title=\"1 说明\"></a>1 说明</h3><p>Producer对发送失败的消息进行重新发送的机制，称为消息发送重试机制，也称为消息重投机制。</p>\n<h4 id=\"对于消息重投，需要注意以下几点：\"><a href=\"#对于消息重投，需要注意以下几点：\" class=\"headerlink\" title=\"对于消息重投，需要注意以下几点：\"></a>对于消息重投，需要注意以下几点：</h4><ul>\n<li>生产者在发送消息时，若采用同步或异步发送方式，发送失败会重试，但oneway消息发送方式发送失败是没有重试机制的</li>\n<li>只有普通消息具有发送重试机制，顺序消息是没有的</li>\n<li>消息重投机制可以保证消息尽可能发送成功、不丢失，但可能会造成消息重复。消息重复在RocketMQ中是无法避免的问题</li>\n<li>消息重复在一般情况下不会发生，当出现消息量大、网络抖动，消息重复就会成为大概率事件</li>\n<li>producer主动重发、consumer负载变化（发生Rebalance，不会导致消息重复，但可能出现重复消费）也会导致重复消息</li>\n<li>消息重复无法避免，但要避免消息的重复消费。</li>\n<li>避免消息重复消费的解决方案是，为消息添加唯一标识（例如消息key），使消费者对消息进行消费判断来避免重复消费</li>\n<li>消息发送重试有三种策略可以选择：同步发送失败策略、异步发送失败策略、消息刷盘失败策略</li>\n</ul>\n<h3 id=\"2-同步发送失败策略\"><a href=\"#2-同步发送失败策略\" class=\"headerlink\" title=\"2 同步发送失败策略\"></a>2 同步发送失败策略</h3><p>对于普通消息，消息发送默认采用round-robin策略来选择所发送到的队列。如果发送失败，默认重试 2次。但在重试时是不会选择上次发送失败的Broker，而是选择其它Broker。当然，若只有一个Broker其也只能发送到该Broker，但其会尽量发送到该Broker上的其它Queue。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个producer，参数为Producer Group名称</span></span><br><span class=\"line\">DefaultMQProducer producer = <span class=\"keyword\">new</span> DefaultMQProducer(<span class=\"string\">&quot;pg&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 指定nameServer地址</span></span><br><span class=\"line\">producer.setNamesrvAddr(<span class=\"string\">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 设置同步发送失败时重试发送的次数，默认为 2 次</span></span><br><span class=\"line\">producer.setRetryTimesWhenSendFailed( <span class=\"number\">3</span> );</span><br><span class=\"line\"><span class=\"comment\">// 设置发送超时时限为5s，默认3s</span></span><br><span class=\"line\">producer.setSendMsgTimeout( <span class=\"number\">5000</span> );</span><br></pre></td></tr></table></figure>\n\n<p>同时，Broker还具有<code>失败隔离</code>功能，使Producer尽量选择未发生过发送失败的Broker作为目标Broker。其可以保证其它消息尽量不发送到问题Broker，为了提升消息发送效率，降低消息发送耗时。</p>\n<blockquote>\n<p>思考：让我们自己实现<code>失败隔离</code>功能，如何来做？<br><br><br>1 ）方案一：Producer中维护某JUC的Map集合，其key是发生失败的时间戳，value为Broker实例。Producer中还维护着一个Set集合，其中存放着所有未发生发送异常的Broker实例。选择目标Broker是从该Set集合中选择的。再定义一个定时任务，定期从Map集合中将长期未发生发送异常的Broker清理出去，并添加到Set集合。<br><br><br>2 ）方案二：为Producer中的Broker实例添加一个标识，例如是一个AtomicBoolean属性。只要该Broker上发生过发送异常，就将其置为true。选择目标Broker就是选择该属性值为false的Broker。再定义一个定时任务，定期将Broker的该属性置为false。<br><br><br>3 ）方案三：为Producer中的Broker实例添加一个标识，例如是一个AtomicLong属性。只要该Broker上发生过发送异常，就使其值增一。选择目标Broker就是选择该属性值最小的Broker。若该值相同，采用轮询方式选择。</p>\n</blockquote>\n<p>如果超过重试次数，则抛出异常，由Producer去保证消息不丢。当然当生产者出现RemotingException、MQClientException和MQBrokerException时，Producer会自动重投消息。</p>\n<h3 id=\"3-异步发送失败策略\"><a href=\"#3-异步发送失败策略\" class=\"headerlink\" title=\"3 异步发送失败策略\"></a>3 异步发送失败策略</h3><p>异步发送失败重试时，异步重试不会选择其他broker，仅在同一个broker上做重试，所以该策略无法保证消息不丢。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">DefaultMQProducer producer = <span class=\"keyword\">new</span> DefaultMQProducer(<span class=\"string\">&quot;pg&quot;</span>);</span><br><span class=\"line\">producer.setNamesrvAddr(<span class=\"string\">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 指定异步发送失败后不进行重试发送</span></span><br><span class=\"line\">producer.setRetryTimesWhenSendAsyncFailed( <span class=\"number\">0</span> );</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-消息刷盘失败策略\"><a href=\"#4-消息刷盘失败策略\" class=\"headerlink\" title=\"4 消息刷盘失败策略\"></a>4 消息刷盘失败策略</h3><p>消息刷盘超时（Master或Slave）或slave不可用（slave在做数据同步时向master返回状态不是SEND_OK）时，默认是不会将消息尝试发送到其他Broker的。不过，对于重要消息可以通过在Broker的配置文件设置retryAnotherBrokerWhenNotStoreOK属性为true来开启。</p>\n<h2 id=\"八、消息消费重试机制\"><a href=\"#八、消息消费重试机制\" class=\"headerlink\" title=\"八、消息消费重试机制\"></a>八、消息消费重试机制</h2><h3 id=\"1-顺序消息的消费重试\"><a href=\"#1-顺序消息的消费重试\" class=\"headerlink\" title=\"1 顺序消息的消费重试\"></a>1 顺序消息的消费重试</h3><p>对于顺序消息，当Consumer消费消息失败后，为了保证消息的顺序性，其会自动不断地进行消息重试，直到消费成功。消费重试默认间隔时间为 1000 毫秒。重试期间应用会出现消息消费被阻塞的情况。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">DefaultMQPushConsumer consumer = <span class=\"keyword\">new</span> DefaultMQPushConsumer(<span class=\"string\">&quot;cg&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 顺序消息消费失败的消费重试时间间隔，单位毫秒，默认为 1000 ，其取值范围为[10,30000]</span></span><br><span class=\"line\">consumer.setSuspendCurrentQueueTimeMillis( <span class=\"number\">100</span> );</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>由于对顺序消息的重试是无休止的，不间断的，直至消费成功，所以，对于顺序消息的消费，务必要保证应用能够及时监控并处理消费失败的情况，避免消费被永久性阻塞。<br><br><br>注意，顺序消息没有发送失败重试机制，但具有消费失败重试机制</p>\n</blockquote>\n<h3 id=\"2-无序消息的消费重试\"><a href=\"#2-无序消息的消费重试\" class=\"headerlink\" title=\"2 无序消息的消费重试\"></a>2 无序消息的消费重试</h3><p>对于无序消息（普通消息、延时消息、事务消息），当Consumer消费消息失败时，可以通过设置返回状态达到消息重试的效果。不过需要注意，无序消息的重试<code>只对集群消费方式生效</code>，广播消费方式不提供失败重试特性。即对于广播消费，消费失败后，失败消息不再重试，继续消费后续消息。</p>\n<h3 id=\"3-消费重试次数与间隔\"><a href=\"#3-消费重试次数与间隔\" class=\"headerlink\" title=\"3 消费重试次数与间隔\"></a>3 消费重试次数与间隔</h3><p>对于<code>无序消息集群</code>消费下的重试消费，每条消息默认最多重试 16 次，但每次重试的间隔时间是不同的，会逐渐变长。每次重试的间隔时间如下表。</p>\n<table>\n<thead>\n<tr>\n<th>重试次数</th>\n<th align=\"center\">与上次重试的间隔时间</th>\n<th align=\"right\">重试次数</th>\n<th align=\"right\">与上次重试的间隔时间</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td align=\"center\">10秒</td>\n<td align=\"right\">9</td>\n<td align=\"right\">7分钟</td>\n</tr>\n<tr>\n<td>2</td>\n<td align=\"center\">30</td>\n<td align=\"right\">10</td>\n<td align=\"right\">8 分钟</td>\n</tr>\n<tr>\n<td>3</td>\n<td align=\"center\">1分钟</td>\n<td align=\"right\">11</td>\n<td align=\"right\">9 分钟</td>\n</tr>\n<tr>\n<td>4</td>\n<td align=\"center\">2分钟</td>\n<td align=\"right\">12</td>\n<td align=\"right\">10分钟</td>\n</tr>\n<tr>\n<td>5</td>\n<td align=\"center\">3分钟</td>\n<td align=\"right\">13</td>\n<td align=\"right\">20分钟</td>\n</tr>\n<tr>\n<td>6</td>\n<td align=\"center\">4分钟</td>\n<td align=\"right\">14</td>\n<td align=\"right\">30分钟</td>\n</tr>\n<tr>\n<td>7</td>\n<td align=\"center\">5分钟</td>\n<td align=\"right\">15</td>\n<td align=\"right\">1小时</td>\n</tr>\n<tr>\n<td>8</td>\n<td align=\"center\">6分钟</td>\n<td align=\"right\">16</td>\n<td align=\"right\">2 小时</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>若一条消息在一直消费失败的前提下，将会在正常消费后的第 <code>4 小时 46 分</code>后进行第 16 次重试。<br><br>若仍然失败，则将消息投递到<code>死信队列</code><br><br><br>修改消费重试次数<br></p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(&quot;cg&quot;);</span><br><span class=\"line\">// 修改消费重试次数</span><br><span class=\"line\">consumer.setMaxReconsumeTimes( 10 );</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>对于修改过的重试次数，将按照以下策略执行：<br><br>1)若修改值小于 16 ，则按照指定间隔进行重试<br><br>2)若修改值大于 16 ，则超过 16 次的重试时间间隔均为 2 小时<br><br><br>对于Consumer Group，若仅修改了一个Consumer的消费重试次数，则会应用到该Group中所有其它Consumer实例。若出现多个Consumer均做了修改的情况，则采用覆盖方式生效。即最后被修改的值会覆盖前面设置的值。</p>\n</blockquote>\n<h3 id=\"4-重试队列-1\"><a href=\"#4-重试队列-1\" class=\"headerlink\" title=\"4 重试队列\"></a>4 重试队列</h3><p>对于需要重试消费的消息，并不是Consumer在等待了指定时长后再次去拉取原来的消息进行消费，而是将这些需要重试消费的消息放入到了一个特殊Topic的队列中，而后进行再次消费的。这个特殊的队列就是重试队列。</p>\n<p>当出现需要进行重试消费的消息时，Broker会为每个消费组都设置一个Topic名称为<code>%RETRY%consumerGroup@consumerGroup</code>的重试队列。</p>\n<blockquote>\n<p>1 ）这个重试队列是针对消息才组的，而不是针对每个Topic设置的（一个Topic的消息可以让多个消费者组进行消费，所以会为这些消费者组各创建一个重试队列）<br><br>2 ）只有当出现需要进行重试消费的消息时，才会为该消费者组创建重试队列</p>\n</blockquote>\n<img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208163646.png\" class title=\"输入图片说明\">\n\n<blockquote>\n<p>注意，消费重试的时间间隔与<code>延时消费</code>的<code>延时等级</code>十分相似，除了没有延时等级的前两个时间外，其它的时间都是相同的</p>\n</blockquote>\n<p>Broker对于重试消息的处理是通过<code>延时消息</code>实现的。先将消息保存到SCHEDULE_TOPIC_XXXX延迟队列中，延迟时间到后，会将消息投递到%RETRY%consumerGroup@consumerGroup重试队列中。</p>\n<h3 id=\"5-消费重试配置方式\"><a href=\"#5-消费重试配置方式\" class=\"headerlink\" title=\"5 消费重试配置方式\"></a>5 消费重试配置方式</h3><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208163740.png\" class title=\"输入图片说明\">\n\n<p>集群消费方式下，消息消费失败后若希望消费重试，则需要在消息监听器接口的实现中明确进行如下三种方式之一的配置：</p>\n<ul>\n<li>方式 1 ：返回ConsumeConcurrentlyStatus.RECONSUME_LATER（推荐）</li>\n<li>方式 2 ：返回Null</li>\n<li>方式 3 ：抛出异常</li>\n</ul>\n<h3 id=\"6-消费不重试配置方式\"><a href=\"#6-消费不重试配置方式\" class=\"headerlink\" title=\"6 消费不重试配置方式\"></a>6 消费不重试配置方式</h3><img src=\"/2022/07/08/rocketmq/QQ%E6%88%AA%E5%9B%BE20220208163826.png\" class title=\"输入图片说明\">\n\n<p>集群消费方式下，消息消费失败后若不希望消费重试，则在捕获到异常后同样也返回与消费成功后的相同的结果，即ConsumeConcurrentlyStatus.CONSUME_SUCCESS，则不进行消费重试。</p>\n<h2 id=\"九、死信队列\"><a href=\"#九、死信队列\" class=\"headerlink\" title=\"九、死信队列\"></a>九、死信队列</h2><h3 id=\"1-什么是死信队列\"><a href=\"#1-什么是死信队列\" class=\"headerlink\" title=\"1 什么是死信队列\"></a>1 什么是死信队列</h3><p>当一条消息初次消费失败，消息队列会自动进行消费重试；达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确地消费该消息，此时，消息队列不会立刻将消息丢弃，而是将其发送到该消费者对应的特殊队列中。这个队列就是死信队列（Dead-Letter Queue，DLQ），而其中的消息<br>则称为死信消息（Dead-Letter Message，DLM）。</p>\n<blockquote>\n<p>死信队列是用于处理无法被正常消费的消息的。</p>\n</blockquote>\n<h3 id=\"2-死信队列的特征\"><a href=\"#2-死信队列的特征\" class=\"headerlink\" title=\"2 死信队列的特征\"></a>2 死信队列的特征</h3><h4 id=\"死信队列具有如下特征：\"><a href=\"#死信队列具有如下特征：\" class=\"headerlink\" title=\"死信队列具有如下特征：\"></a>死信队列具有如下特征：</h4><ul>\n<li>死信队列中的消息不会再被消费者正常消费，即DLQ对于消费者是不可见的</li>\n<li>死信存储有效期与正常消息相同，均为 3 天（commitlog文件的过期时间）， 3 天后会被自动删除</li>\n<li>死信队列就是一个特殊的Topic，名称为%DLQ%consumerGroup@consumerGroup，即每个消费者组都有一个死信队列</li>\n<li>如果一个消费者组未产生死信消息，则不会为其创建相应的死信队列</li>\n</ul>\n<h3 id=\"3-死信消息的处理\"><a href=\"#3-死信消息的处理\" class=\"headerlink\" title=\"3 死信消息的处理\"></a>3 死信消息的处理</h3><p>实际上，当一条消息进入死信队列，就意味着系统中某些地方出现了问题，从而导致消费者无法正常消费该消息，比如代码中原本就存在Bug。因此，对于死信消息，通常需要开发人员进行特殊处理。最关键的步骤是要排查可疑因素，解决代码中可能存在的Bug，然后再将原来的死信消息再次进行投递消费。</p>\n"},{"title":"重装云服务器之MySql整理","date":"2022-07-22T05:16:41.000Z","cover":"http://rebp38war.bkt.clouddn.com/img/v2-376062e6eaa322512fae11c68de08493_r.jpg","_content":"\n> 由于再下把服务器玩崩了（^-^），需要重装服务器系统，这次我选择LAMP ;因为我懒得再次安装MySQL之类的了。\n\n\n\n<img src=\"http://rebp38war.bkt.clouddn.com/img/20220722142934.png\" style=\"zoom:80%;\" />\n\n\n\n选择系统镜像，点击重置即可安装完毕，点击应用管理，可以看到应用安装完的应用信息；\n\n上面也写了密码放置的位置\n\n<img src=\"http://rebp38war.bkt.clouddn.com/img/20220722142216.png\" style=\"zoom:80%;\" />\n\n我们连接到服务器 \n\n~~~shell\n[root@ls_patrick ~]# cat /root/REAME\n~~~\n\n查看到我们初始的应用信息和密码；\n\n\n\n![](http://rebp38war.bkt.clouddn.com/img/20220722143415.png)\n\n复制密码进入我们的MySQL ；\n\n~~~shell\n[root@ls_patrick ~]# mysql -uroot -p\nEnter password:\n~~~\n\n在Enter password:后粘贴这段密码\n\n![](http://rebp38war.bkt.clouddn.com/img/20220722143711.png)\n\n看到欢迎信息就进入成功了；\n\n一般我们会使用客户端连接（Navicat等)。接下来，我们需要开启 远程连接并开放端口，这样客户端才能连接上\n\n命令行登入mysql后;\n\n~~~shell\nMySQL [(none)]> use mysql ;\nDatabase changed\n\n~~~\n\n查看root权限信息。\n~~~\nMySQL [mysql]> select host, user from user;\n+-----------+---------------+\n| host      | user          |\n+-----------+---------------+\n| 127.0.0.1 | root          |\n| localhost | mysql.session |\n| localhost | mysql.sys     |\n| localhost | root          |\n+-----------+---------------+\n4 rows in set (0.00 sec)\n\n~~~\n\n修改root用户的host\n\n```shell\nMySQL [mysql]> update user set host = '%' where user = 'root';\n```\n如果遇到以下发生错误，不理会\n```\nERROR 1062 (23000): Duplicate entry '%-root' for key 'PRIMARY'\n```\n更新权限\n```\nMySQL [mysql]> flush privileges;\n```\n\n再次查看root权限信息，可以看到修改成功了\n```\n\nMySQL [mysql]> select host, user from user;\n+-----------+---------------+\n| host      | user          |\n+-----------+---------------+\n| %         | root          |\n| 127.0.0.1 | root          |\n| localhost | mysql.session |\n| localhost | mysql.sys     |\n+-----------+---------------+\n4 rows in set (0.00 sec)\n\n```\n\n```shell\n# 为防火墙添加 3306 端口\nfirewall-cmd --zone=public --add-port=3306/tcp --permanent\n# 重启防火墙\nfirewall-cmd --reload\n```\n\n或者在百度云上配置\n\n<img src=\"http://rebp38war.bkt.clouddn.com/img/20220722144447.png\" style=\"zoom:80%;\" />\n\n<img src=\"http://rebp38war.bkt.clouddn.com/img/20220722144513.png\" style=\"zoom:67%;\" />\n\n~~~shell\n[root@ls_patrick ~]# service mysqld restart\nShutting down MySQL..                                      [  OK  ]\nStarting MySQL..                                           [  OK  ]\n~~~\n\n\n\n<img src=\"http://rebp38war.bkt.clouddn.com/img/20220722144304.png\" style=\"zoom:67%;\" />\n\n重置MySQL密码\n\n进入mysql（如果忘记密码可以 `mysqld_safe --skip-grant-tables &` 直接运行下面无密码命令进入mysql）\n1\n设置新密码\n\n~~~shell\n UPDATE mysql.user SET Password=PASSWORD('new-password') WHERE User='root';\n~~~\n\n\n在 mysql> 提示符下，键入以下命令刷新：\n\n~~~shell\nFLUSH PRIVILEGES;\n\nexit;\n~~~\n\n\n重启 MySQL 服务器。\n\n```shell\n[root@ls_patrick ~]# service mysqld restart\nShutting down MySQL..                                      [  OK  ]\nStarting MySQL..                                           [  OK  ]\n```\n\n\n\nMYSQL 就到此暂告一段落\n\n","source":"_posts/服务器重装.md","raw":"---\ntitle: 重装云服务器之MySql整理\ndate: 2022-07-22 13:16:41\ntags: \n - 云\n - MySql\ncategories: MySql\ncover: \n---\n\n> 由于再下把服务器玩崩了（^-^），需要重装服务器系统，这次我选择LAMP ;因为我懒得再次安装MySQL之类的了。\n\n\n\n<img src=\"http://rebp38war.bkt.clouddn.com/img/20220722142934.png\" style=\"zoom:80%;\" />\n\n\n\n选择系统镜像，点击重置即可安装完毕，点击应用管理，可以看到应用安装完的应用信息；\n\n上面也写了密码放置的位置\n\n<img src=\"http://rebp38war.bkt.clouddn.com/img/20220722142216.png\" style=\"zoom:80%;\" />\n\n我们连接到服务器 \n\n~~~shell\n[root@ls_patrick ~]# cat /root/REAME\n~~~\n\n查看到我们初始的应用信息和密码；\n\n\n\n![](http://rebp38war.bkt.clouddn.com/img/20220722143415.png)\n\n复制密码进入我们的MySQL ；\n\n~~~shell\n[root@ls_patrick ~]# mysql -uroot -p\nEnter password:\n~~~\n\n在Enter password:后粘贴这段密码\n\n![](http://rebp38war.bkt.clouddn.com/img/20220722143711.png)\n\n看到欢迎信息就进入成功了；\n\n一般我们会使用客户端连接（Navicat等)。接下来，我们需要开启 远程连接并开放端口，这样客户端才能连接上\n\n命令行登入mysql后;\n\n~~~shell\nMySQL [(none)]> use mysql ;\nDatabase changed\n\n~~~\n\n查看root权限信息。\n~~~\nMySQL [mysql]> select host, user from user;\n+-----------+---------------+\n| host      | user          |\n+-----------+---------------+\n| 127.0.0.1 | root          |\n| localhost | mysql.session |\n| localhost | mysql.sys     |\n| localhost | root          |\n+-----------+---------------+\n4 rows in set (0.00 sec)\n\n~~~\n\n修改root用户的host\n\n```shell\nMySQL [mysql]> update user set host = '%' where user = 'root';\n```\n如果遇到以下发生错误，不理会\n```\nERROR 1062 (23000): Duplicate entry '%-root' for key 'PRIMARY'\n```\n更新权限\n```\nMySQL [mysql]> flush privileges;\n```\n\n再次查看root权限信息，可以看到修改成功了\n```\n\nMySQL [mysql]> select host, user from user;\n+-----------+---------------+\n| host      | user          |\n+-----------+---------------+\n| %         | root          |\n| 127.0.0.1 | root          |\n| localhost | mysql.session |\n| localhost | mysql.sys     |\n+-----------+---------------+\n4 rows in set (0.00 sec)\n\n```\n\n```shell\n# 为防火墙添加 3306 端口\nfirewall-cmd --zone=public --add-port=3306/tcp --permanent\n# 重启防火墙\nfirewall-cmd --reload\n```\n\n或者在百度云上配置\n\n<img src=\"http://rebp38war.bkt.clouddn.com/img/20220722144447.png\" style=\"zoom:80%;\" />\n\n<img src=\"http://rebp38war.bkt.clouddn.com/img/20220722144513.png\" style=\"zoom:67%;\" />\n\n~~~shell\n[root@ls_patrick ~]# service mysqld restart\nShutting down MySQL..                                      [  OK  ]\nStarting MySQL..                                           [  OK  ]\n~~~\n\n\n\n<img src=\"http://rebp38war.bkt.clouddn.com/img/20220722144304.png\" style=\"zoom:67%;\" />\n\n重置MySQL密码\n\n进入mysql（如果忘记密码可以 `mysqld_safe --skip-grant-tables &` 直接运行下面无密码命令进入mysql）\n1\n设置新密码\n\n~~~shell\n UPDATE mysql.user SET Password=PASSWORD('new-password') WHERE User='root';\n~~~\n\n\n在 mysql> 提示符下，键入以下命令刷新：\n\n~~~shell\nFLUSH PRIVILEGES;\n\nexit;\n~~~\n\n\n重启 MySQL 服务器。\n\n```shell\n[root@ls_patrick ~]# service mysqld restart\nShutting down MySQL..                                      [  OK  ]\nStarting MySQL..                                           [  OK  ]\n```\n\n\n\nMYSQL 就到此暂告一段落\n\n","slug":"服务器重装","published":1,"updated":"2022-07-22T08:14:31.867Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5w7e745000kigvud9c77rwd","content":"<blockquote>\n<p>由于再下把服务器玩崩了（^-^），需要重装服务器系统，这次我选择LAMP ;因为我懒得再次安装MySQL之类的了。</p>\n</blockquote>\n<img src=\"http://rebp38war.bkt.clouddn.com/img/20220722142934.png\" style=\"zoom:80%;\">\n\n\n\n<p>选择系统镜像，点击重置即可安装完毕，点击应用管理，可以看到应用安装完的应用信息；</p>\n<p>上面也写了密码放置的位置</p>\n<img src=\"http://rebp38war.bkt.clouddn.com/img/20220722142216.png\" style=\"zoom:80%;\">\n\n<p>我们连接到服务器 </p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@ls_patrick ~]# cat /root/REAME</span><br></pre></td></tr></table></figure>\n\n<p>查看到我们初始的应用信息和密码；</p>\n<p><img src=\"http://rebp38war.bkt.clouddn.com/img/20220722143415.png\"></p>\n<p>复制密码进入我们的MySQL ；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@ls_patrick ~]# mysql -uroot -p</span><br><span class=\"line\">Enter password:</span><br></pre></td></tr></table></figure>\n\n<p>在Enter password:后粘贴这段密码</p>\n<p><img src=\"http://rebp38war.bkt.clouddn.com/img/20220722143711.png\"></p>\n<p>看到欢迎信息就进入成功了；</p>\n<p>一般我们会使用客户端连接（Navicat等)。接下来，我们需要开启 远程连接并开放端口，这样客户端才能连接上</p>\n<p>命令行登入mysql后;</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">MySQL [(none)]&gt; use mysql ;</span><br><span class=\"line\">Database changed</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>查看root权限信息。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">MySQL [mysql]&gt; select host, user from user;</span><br><span class=\"line\">+-----------+---------------+</span><br><span class=\"line\">| host      | user          |</span><br><span class=\"line\">+-----------+---------------+</span><br><span class=\"line\">| 127.0.0.1 | root          |</span><br><span class=\"line\">| localhost | mysql.session |</span><br><span class=\"line\">| localhost | mysql.sys     |</span><br><span class=\"line\">| localhost | root          |</span><br><span class=\"line\">+-----------+---------------+</span><br><span class=\"line\">4 rows in set (0.00 sec)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>修改root用户的host</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">MySQL [mysql]&gt; update user set host = &#x27;%&#x27; where user = &#x27;root&#x27;;</span><br></pre></td></tr></table></figure>\n<p>如果遇到以下发生错误，不理会</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ERROR 1062 (23000): Duplicate entry &#x27;%-root&#x27; for key &#x27;PRIMARY&#x27;</span><br></pre></td></tr></table></figure>\n<p>更新权限</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">MySQL [mysql]&gt; flush privileges;</span><br></pre></td></tr></table></figure>\n\n<p>再次查看root权限信息，可以看到修改成功了</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">MySQL [mysql]&gt; select host, user from user;</span><br><span class=\"line\">+-----------+---------------+</span><br><span class=\"line\">| host      | user          |</span><br><span class=\"line\">+-----------+---------------+</span><br><span class=\"line\">| %         | root          |</span><br><span class=\"line\">| 127.0.0.1 | root          |</span><br><span class=\"line\">| localhost | mysql.session |</span><br><span class=\"line\">| localhost | mysql.sys     |</span><br><span class=\"line\">+-----------+---------------+</span><br><span class=\"line\">4 rows in set (0.00 sec)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 为防火墙添加 3306 端口</span></span><br><span class=\"line\">firewall-cmd --zone=public --add-port=3306/tcp --permanent</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 重启防火墙</span></span><br><span class=\"line\">firewall-cmd --reload</span><br></pre></td></tr></table></figure>\n\n<p>或者在百度云上配置</p>\n<img src=\"http://rebp38war.bkt.clouddn.com/img/20220722144447.png\" style=\"zoom:80%;\">\n\n<img src=\"http://rebp38war.bkt.clouddn.com/img/20220722144513.png\" style=\"zoom:67%;\">\n\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@ls_patrick ~]# service mysqld restart</span><br><span class=\"line\">Shutting down MySQL..                                      [  OK  ]</span><br><span class=\"line\">Starting MySQL..                                           [  OK  ]</span><br></pre></td></tr></table></figure>\n\n\n\n<img src=\"http://rebp38war.bkt.clouddn.com/img/20220722144304.png\" style=\"zoom:67%;\">\n\n<p>重置MySQL密码</p>\n<p>进入mysql（如果忘记密码可以 <code>mysqld_safe --skip-grant-tables &amp;</code> 直接运行下面无密码命令进入mysql）<br>1<br>设置新密码</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">UPDATE mysql.user SET Password=PASSWORD(&#x27;new-password&#x27;) WHERE User=&#x27;root&#x27;;</span><br></pre></td></tr></table></figure>\n\n\n<p>在 mysql&gt; 提示符下，键入以下命令刷新：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">FLUSH PRIVILEGES;</span><br><span class=\"line\"></span><br><span class=\"line\">exit;</span><br></pre></td></tr></table></figure>\n\n\n<p>重启 MySQL 服务器。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@ls_patrick ~]# service mysqld restart</span><br><span class=\"line\">Shutting down MySQL..                                      [  OK  ]</span><br><span class=\"line\">Starting MySQL..                                           [  OK  ]</span><br></pre></td></tr></table></figure>\n\n\n\n<p>MYSQL 就到此暂告一段落</p>\n","site":{"data":{"bangumis":{"wantWatch":[],"watching":[{"title":"凡人修仙传","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/70d11dfab23a3ee81ccf64f18efa139416a633ff.jpg@220w_280h.webp","totalCount":"未完结","id":28223043,"follow":"615.7 万","view":"8.9 亿","danmaku":"490.9 万","coin":"1186.9 万","score":9.7,"des":"看机智的凡人小子韩立如何稳健发展、步步为营，战魔道、夺至宝、驰骋星海、快意恩仇，成为纵横三界的强者。他日仙界重相逢，一声道友尽沧桑。..."},{"title":"恋爱游戏世界对路人角色很不友好","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/c9723d8c77d881a8debba2852d580e97826b43d0.png@220w_280h.webp","totalCount":"全12话","id":28237300,"follow":"151.2 万","view":"5120.4 万","danmaku":"40.6 万","coin":"24.5 万","score":9.1,"des":"从现代日本转生到“恋爱游戏”世界的里昂，发现这里女尊男卑，对男性很不友好。身为路人角色的他，为了摆脱自己因地位低下而被肆意决定的人生，决定活用从游戏中得到的知识，保持路人角色的身份，取得“失落物品”来..."},{"title":"魔法纪录 魔法少女小圆外传 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/9eef1df9ab157be52d2c4d70d3500442f00cafc3.png@220w_280h.webp","totalCount":"全12话","id":28234642,"follow":"237.1 万","view":"907.6 万","danmaku":"5.0 万","coin":"4.9 万","score":7.7,"des":"愿望的代价，究竟是希望还是绝望——。"},{"title":"小林家的龙女仆 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/847e9dbb6876fb37a30199a5c88910704976d45b.png@220w_280h.webp","totalCount":"全13话","id":28234613,"follow":"855.7 万","view":"1.1 亿","danmaku":"49.0 万","coin":"69.0 万","score":9.6,"des":"那位不可思议的龙女仆再度登场！\n因为各种奇妙的原因而作为小林家的女仆而工作中的龙·托尔。\n偶尔（胡说，是经常）给亲爱的小林添麻烦，总算是融入了人类社会，成为了一个完美的（骗人，也就还行）女仆。\n同样是..."},{"title":"国王排名","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/376d7e69a667bcb1c0b934a4e35e07e7fa23110b.png@220w_280h.webp","totalCount":"全23话","id":28235154,"follow":"927.7 万","view":"4.8 亿","danmaku":"250.1 万","coin":"260.9 万","score":7,"des":"国家的丰饶、麾下勇者的数量、\n以及国王本人如何像勇者一般强大，\n这些要素的综合排名，便是所谓的“国王排名”。\n主人公波吉是国王排名第七名的伯斯王治下王国的第一王子。\n但是波吉却生来又聋又哑，贫弱到挥不..."},{"title":"阿松 第三季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0212baa8898d0c819c7fb84015e95b8fca621435.png@220w_280h.webp","totalCount":"全25话","id":28229892,"follow":"67.6 万","view":"938.0 万","danmaku":"13.0 万","coin":"5.4 万","score":9.6,"des":"日本最有名的六胞胎的传说，第三次开幕！！这次会有怎样意想不到的新展开！？..."},{"title":"命运-冠位指定 冠位时间神殿所罗门","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0e094b798388da19a4feffa6a6dabc1dc1dc90cd.jpg@220w_280h.webp","totalCount":"全1话","id":28236225,"follow":"525.5 万","view":"1220.0 万","danmaku":"8.9 万","coin":"15.1 万","score":8.5,"des":"在经过七个特异点的大战后，\n人理存续保障机关迦勒底，终于到达了圣杯探索的最终地点——终局特异点 冠位时间神殿所罗门。\n他们要击败身为罪魁祸首的魔术王所罗门，夺回未来。\n在开战的前一刻，一行人各自度过了..."},{"title":"JOJO的奇妙冒险 星尘远征军","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/47c0108259355d6d2c517ed97f6b90fb777f844f.png@220w_280h.webp","totalCount":"全24话","id":28223481,"follow":"444.2 万","view":"1.5 亿","danmaku":"463.4 万","coin":"45.7 万","score":9.8,"des":"时为1987年，乔瑟夫·乔斯达与“柱之男”们之间的死战后过了50年……乔瑟夫为了为了帮助“被恶灵附身了”的外孙子·空条承太郎而来到了日本。原来那并不是恶灵而是幽波纹（替身）。替身突然出现的原因在于，从..."},{"title":"JOJO的奇妙冒险 星尘远征军 埃及篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f6709b76e88f50aa132d1e09e2d8de9663a09b3e.png@220w_280h.webp","totalCount":"全24话","id":28223483,"follow":"421.9 万","view":"1.3 亿","danmaku":"468.7 万","coin":"44.3 万","score":9.9,"des":"在乔斯达家的宿敌·迪奥（DIO）复活的影响下，一位年轻人——空条承太郎，得到了名为“幽波纹（替身）”的能力。为了拯救因迪奥的诅咒而倒下的母亲荷莉，空条承太郎与外祖父·乔瑟夫以及伙伴们，一起为了打倒迪奥..."},{"title":"JOJO的奇妙冒险 不灭钻石","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/6a04c87e990ab74cd8d555ef45a863de0993b161.png@220w_280h.webp","totalCount":"全39话","id":140552,"follow":"302.3 万","view":"2.1 亿","danmaku":"813.8 万","coin":"55.9 万","score":9.8,"des":"在埃及与宿敌DIO的死斗之后过了11年。1999年，空条承太郎为了与祖父乔瑟夫·乔斯达的私生子东方仗助见面，而来到了日本M县S市杜王町。但，仗助却持有与承太郎相同的特殊能力“替身”。之后，以承太郎的来..."},{"title":"命运-冠位嘉年华","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/c660976f4502a544d990a882ae62194b57753a71.png@220w_280h.webp","totalCount":"全2话","id":28234639,"follow":"479.8 万","view":"862.4 万","danmaku":"4.1 万","coin":"9.1 万","score":9.8,"des":"一起庆祝吧！为了这奇迹般的嘉年华！"},{"title":"伍六七","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/b69e26d9e50514f3fa99eac9ab5aabf2a6e28c88.jpg@220w_280h.webp","totalCount":"全13话","id":6360,"follow":"585.8 万","view":"3.3 亿","danmaku":"227.1 万","coin":"191.8 万","score":9.8,"des":"在某个小岛上，有一个可以伪装成任何东西的廉价刺客，名叫伍六七。平时看上去是个理发师，其实背地里却做着刺客生意。热爱理发事业，喜欢给人剪头发，善用剪刀——剪刀也是他的刺杀武器。由于初入刺客行当，行情十分..."},{"title":"命运-冠位指定 -月光／失落之室-","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3fa5fd2b7afae827b0bf150d7f0cbfc54eda1ff2.png@220w_280h.webp","totalCount":"全1话","id":28234950,"follow":"483.3 万","view":"551.2 万","danmaku":9696,"coin":"2.9 万","score":9.5,"des":"失落之室——。\n这是一个可以看到被夺去亦或是遗失之物的地方。\n这是位于迦勒底被遗忘的角落，不属于任何人的地方。..."},{"title":"致不灭的你","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/1ae94fbb35d8e23bb84926b694509f8b057f96e6.png@220w_280h.webp","totalCount":"全20话","id":28233896,"follow":"476.3 万","view":"1.3 亿","danmaku":"140.1 万","coin":"95.0 万","score":9.6,"des":"本剧讲述了一个情节跌宕、场面宏大的奇幻故事，通过拥有不灭之身的主人公“不死”来探索人生哲理。\n不死起初是一个被投放到人世间的“球”。\n\n它具有“幻化为刺激源形态的能力”和“死后重生的能力”。\n\n先后从..."},{"title":"来自新世界","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/aaa60f9cb17fb4a38df464f1064ca9623e0769cc.jpg@220w_280h.webp","totalCount":"全25话","id":1598,"follow":"115.9 万","view":"1540.9 万","danmaku":"76.3 万","coin":"5.7 万","score":9.5,"des":"1000年后的日本，孩子们不断地消失，只存在想象中的恐怖动物与人类展开殊死战争。反乌托邦式的未来超级社会“新世界”，是口吐真言凭藉“咒力”就能移动物体的人类，与有着等同于普通人智力的生物“妖鼠”共存的..."},{"title":"转生成蜘蛛又怎样！","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f0796e37abac25ba2aa9f23120646aaa9a3d5ea7.png@220w_280h.webp","totalCount":"全24话","id":28231809,"follow":"600.0 万","view":"3.7 亿","danmaku":"190.3 万","coin":"164.6 万","score":7.8,"des":"曾经是一名女高中生的“我”，突然转生变成了幻想世界中的蜘蛛魔物。\n而且，出生地点还是各种凶恶魔物所盘踞的大迷宫。\n“我”以人类的智慧和非同寻常的积极心态为武器，使用蜘蛛的丝网以及陷阱打倒比自己等级高得..."},{"title":"装甲重拳/MEGALOBOX 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/e14dc4a935397fc074c7a12d9520225615209025.png@220w_280h.webp","totalCount":"全13话","id":28233916,"follow":"244.9 万","view":"3435.4 万","danmaku":"19.7 万","coin":"53.1 万","score":9.9,"des":"再一次，为梦想而活——\n\n将肉体与“装甲技术”融合的究极格斗技“装甲拳击”。\n在决出其顶点之人的大会“重拳之巅”上，身穿装甲用自己肉身挑战一切的拳击手“JOE”。\n\n从最下层的比赛开始仅仅花了三个月就..."},{"title":"机动战士高达SEED HD","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/855c88677267d707ebfe4040403692ff2c0938f0.png@220w_280h.webp","totalCount":"全48话","id":497,"follow":"54.8 万","view":"4044.4 万","danmaku":"114.4 万","coin":"6.0 万","score":9.6,"des":"《机动战士高达SEED》是高达系列在2002年至2003年度放映的动画。续作为《机动战士高达SEED Destiny》在2004年播放。因各具魅力的角色，明星云集的声优阵容和高度商业化的宣传而受到较低..."},{"title":"夏目友人帐 唤石者与怪异的访客","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6cf43708b779cde84ad285ff4e3a080de98df0af.png@220w_280h.webp","totalCount":"全1话","id":28234316,"follow":"567.1 万","view":"1374.8 万","danmaku":"18.1 万","coin":"17.9 万","score":9.9,"des":"本作由【唤石者】与【怪异的访客】两个人气短篇集锦而成。讲述生来便能看见各种妖怪的夏目，与自称保镖的猫咪老师一同邂逅的一系列温暖故事。\n【唤石者】一天夏目在森林中遇到一只小妖怪——密实。密实称自己肩负「..."},{"title":"Fate/Grand Order ‐First Order‐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/b75c55d209d156c8631f5ceb21e5c52c834dbb60.jpg@220w_280h.webp","totalCount":"全1话","id":5747,"follow":"250.9 万","view":"3329.7 万","danmaku":"76.7 万","coin":"10.7 万","score":8.3,"des":"【2016年12月31日bilibili独播】2015年。示巴所观测到的未来领域毫无前兆地消失。根据计算，发现——不，是证明了人类将于2017年灭绝。人理延续保障机构·迦勒底将“无法观测的领域”假定为..."},{"title":"伍六七之玄武国篇","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/00843865ea13702eccc4efd64c313fd4c8029c6b.jpg@220w_280h.webp","totalCount":"全10话","id":28232253,"follow":"999.4 万","view":"4.0 亿","danmaku":"177.7 万","coin":"385.3 万","score":9.8,"des":"为了保护小鸡岛居民和这里平静的生活，伍六七和他的伙伴大保和小飞开启了去往玄武国的冒险旅程，去寻找身世的真相和解救小岛的办法，等待他们的又将是更多的未知与奇遇。..."},{"title":"堀与宫村","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/039c4e0b14e27c7a9e5cce2f20a6efd3c8909401.png@220w_280h.webp","totalCount":"全13话","id":28231840,"follow":"695.2 万","view":"2.2 亿","danmaku":"242.1 万","coin":"361.4 万","score":9.8,"des":"不论是谁，都会有不想被人知道的一面。\n\n在学校中漂亮大方、成绩优秀的人气女生堀，私下却打扮土气、忙于家务和照顾弟弟。\n在学校中是阴暗宅男形象的宫村，生活中却是打扮时尚、带耳钉的帅气男生。\n因为一次特别..."},{"title":"奇蛋物语 / WONDER EGG PRIORITY","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/10e0bbc1047b2c45f0f881de334a6f3bfb42a3b6.png@220w_280h.webp","totalCount":"全12话","id":28231851,"follow":"254.9 万","view":"4686.8 万","danmaku":"47.6 万","coin":"65.5 万","score":9.7,"des":"14岁少女·大户爱在深夜散步的途中，\n随着神秘声音的指引，获得了一枚「蛋」。\n\n「如果想要改变世界的话」\n「那么就在现在做出选择」\n「请相信自己——」\n「打破这枚蛋——」\n\n而在打破「蛋」之后，等待着..."},{"title":"Re：从零开始的异世界生活 第二季 后半","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/4f3edbede7fc0bdb52842075cf8faaa1c5953eaa.png@220w_280h.webp","totalCount":"全12话","id":28232073,"follow":"849.9 万","view":"9308.1 万","danmaku":"108.1 万","coin":"230.1 万","score":9.9,"des":"我一定会拯救你。\n在打倒了魔女教大罪司教「怠惰」担当——培提其乌斯·罗曼尼康帝之后，菜月昴和爱蜜莉雅又得以重新开始。\n克服了艰难的诀别，两人终于和解，然而这只是新一轮风波的序幕。\n超乎想象的绝境危机，..."},{"title":"灰与幻想的格林姆迦尔","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/7fb4945f864e9e988212b7d20f206df2677053f8.jpg@220w_280h.webp","totalCount":"全12话","id":106512,"follow":"172.0 万","view":"2343.4 万","danmaku":"63.8 万","coin":"18.3 万","score":9.8,"des":"电视动画《灰与幻想的格林姆迦尔》改编自日本轻小说家十文字青原作白井锐利插画的同名轻小说。\n我们为什么要这么做…？\n哈尔希洛回过神来，才发现自己身处在黑暗当中，他完全不知道自己人在何处，也不明白这个地方..."},{"title":"龙与虎","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/144910805f172d16c5f544f43939a05d8ca20576.jpg@220w_280h.webp","totalCount":"全26话","id":1672,"follow":"336.9 万","view":"6671.9 万","danmaku":"511.9 万","coin":"61.5 万","score":9.7,"des":"樱花飞舞的四月，全新的高中二年级，新的班级……\n眼神凶恶的普通男孩——高须龙儿，遇上了众人害怕、凶暴残忍的“掌中老虎”逢坂大河，还知道了她不欲为人知的秘密。这就是龙虎相争爱与战斗的序幕。\n再加上总是笑..."},{"title":"机动战士高达 铁血的奥尔芬斯 第一季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/f84a80d731d0431c00903d8951fd66623d8237f7.png@220w_280h.webp","totalCount":"全25话","id":4310042,"follow":"62.4 万","view":"2318.6 万","danmaku":"52.2 万","coin":"5.4 万","score":9.5,"des":"主人公三日月·奥古斯，从所属的民间警备公司克律塞安保公司（下称CGS）那里，接受了对少女库德莉亚·蓝那·伯恩斯坦的护卫任务。但CGS受到了摘取反叛之芽的武力组织加拉尔霍恩的袭击，于是在把三日月当做诱饵..."},{"title":"机动战士高达00 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1d7a969e8f1045739c596de89a963e30475aff0e.jpg@220w_280h.webp","totalCount":"全25话","id":1193,"follow":"37.2 万","view":"2458.1 万","danmaku":"61.4 万","coin":"4.1 万","score":9.8,"des":"天人与联合国军的最终决战后过了四年。建立地球联邦政府的人类，为了追求更进一步的国家间之统合，以及人类意识的统一，在联合正规军之外，设立了独立治安维持部队“A-Laws”，目的为对所有危害联合的势力与主..."},{"title":"机动战士高达00","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/35b11bf59eb3fd12f0387951510a5d722d7435e5.jpg@220w_280h.webp","totalCount":"全25话","id":1192,"follow":"62.1 万","view":"2465.5 万","danmaku":"53.6 万","coin":"4.6 万","score":9.7,"des":"在西历2307年，虽然化石燃料枯竭了，但是人类得到了截然不同的新型能源。三台巨大的轨道升降机以及伴随它们的大规模的太阳光发电系统。但是能得到这个系统恩惠的，只有一部分大国和其同盟国而已。\n拥有三台轨道..."},{"title":"Re：从零开始的异世界生活 第二季 前半","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f2425cbdb07cc93bd0d3ba1c0099bfe78f5dc58a.png@220w_280h.webp","totalCount":"全13话","id":28229233,"follow":"774.2 万","view":"1.3 亿","danmaku":"201.4 万","coin":"126.7 万","score":9.7,"des":"我一定会拯救你。\n在打倒了魔女教大罪司教「怠惰」担当——培提其乌斯·罗曼尼康帝之后，菜月昴和爱蜜莉雅又得以重新开始。\n克服了艰难的诀别，两人终于和解，然而这只是新一轮风波的序幕。\n超乎想象的绝境危机，..."},{"title":"超级小白","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3d3e8257d22596f5d3e4395ca759bd1e0fe9b873.jpg@220w_280h.webp","totalCount":"全48话","id":28222671,"follow":"27.4 万","view":"978.0 万","danmaku":"3.6 万","coin":"3.6 万","score":9.6,"des":"为了阻止企图霸占世界的黑暗势力，野原家的普通小狗——小白接肩负重大使命，变身成为了守护世界的“超级小白”。小白将要面对的不仅是发明狗，还有其他意想不到的对手。当然，面对邪恶势力，小白也有着令人惊讶的超..."},{"title":"Re：从零开始的异世界生活 新编集版","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3c125e1aad08643e3eff2fb7d45e740c1a052725.png@220w_280h.webp","totalCount":"全13话","id":28224394,"follow":"631.1 万","view":"7674.2 万","danmaku":"166.2 万","coin":"51.1 万","score":9.6,"des":"在从便利商店回家的路上，突然被异世界召唤的少年菜月昴。在无法依靠任何东西的异世界，无力的少年手唯一的力量……那是“死去然后重新开始”的力量。为了守护最重要的人们，为了取回确实存在着又无可替代的时间，少..."},{"title":"因为太怕痛就全点防御力了","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/8021d3f6b0df6dbba6d32f76eb9cfe2531e166c4.png@220w_280h.webp","totalCount":"全12话","id":28224137,"follow":"620.6 万","view":"2.3 亿","danmaku":"326.8 万","coin":"103.8 万","score":9,"des":"主角本条枫在好友白峰理沙推荐下开始游玩游戏“NewWorld Online”，创建了名为“梅普露”的角色。然而作为游戏初学者，梅普露选择了不受欢迎的大盾当武器，同时因为怕痛而把所有状态点加到防御力的极..."},{"title":"冰海战记","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/c30401817895e67399094b4e669785a104270cdf.jpg@220w_280h.webp","totalCount":"全24话","id":28220475,"follow":"174.4 万","view":"4893.8 万","danmaku":"48.7 万","coin":"36.7 万","score":9.8,"des":"公元10世纪末期，出现了在世界各地出没的最强民族。被讴歌为最强战士的托尔兹，其子托尔芬幼时便生活在战场上，并向往着梦幻大陆“文兰”。这是一个发生在激荡时代的，真正的英雄物语。..."},{"title":"齐木楠雄的灾难 始动篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ba59822eded39b5254fb01448a7f1502101d5624.png@220w_280h.webp","totalCount":"全6话","id":28223748,"follow":"372.4 万","view":"3054.5 万","danmaku":"20.0 万","coin":"17.8 万","score":9.8,"des":"在电视剧中堪称帅气的超能力，对于高中生齐木楠雄来说只是招致灾难的元凶。作为新动画系列展开的楠雄的日常又会如何！？..."},{"title":"OVERLORD Ⅱ","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/851f979c8ebcc7583a43abd4b786c4e2e66b746b.jpg@220w_280h.webp","totalCount":"全13话","id":8792,"follow":"539.3 万","view":"3.8 亿","danmaku":"413.9 万","coin":"114.1 万","score":9.6,"des":"时为2138年。曾卷起一大风潮的虚拟现实体感型网络游戏《YGGDRASIL》即将迎来停服。玩家飞鼠在曾经以同伴和荣华自傲的根据地纳萨力克地下大坟墓，独自一人安静等待着那一刻。但是，不料发生了结束时间已..."},{"title":"夏目友人帐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/99c549494d9425f6455bd45a151f4d26397d6151.png@220w_280h.webp","totalCount":"全13话","id":1660,"follow":"324.0 万","view":"4975.2 万","danmaku":"278.7 万","coin":"15.5 万","score":9.8,"des":"夏目贵志生来拥有强大的灵力，能感知平常人所无法接触的妖怪神明的存在。因父母双亡，他多年间辗转于互相推卸责任的亲戚之间，又受到同龄人的欺负，未曾与任何人深交，造成性格一定程度上的孤僻。夏目本性和善，对于..."}],"watched":[{"title":"装甲重拳/MEGALOBOX","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0c44785cb5d25cc9f648800d251f21a2e236bb8a.png@220w_280h.webp","totalCount":"全13话","id":79472,"follow":"221.9 万","view":"6162.0 万","danmaku":"48.6 万","coin":"32.9 万","score":9.8,"des":"将肉体与“装甲技术”融合的究极格斗技——“MEGALOBOX”，将自己的全部赌在上面的男人们的热血战斗开始！\n今天也立于未认可地区的赌博比赛赛场上的MEGALO拳击手“JNK DOG”。虽然具备实力，..."},{"title":"超能力女儿","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/152c536f8ecaad8f3d7d568d33da81c963a4a722.png@220w_280h.webp","totalCount":"全12话","id":78352,"follow":"293.8 万","view":"9252.2 万","danmaku":"98.5 万","coin":"35.4 万","score":9.6,"des":"支持着芦川组的年轻智力型黑道新田义史，过着被喜欢的壶所包围的悠然自得单身生活。但某一天，随着装在神秘物体里的少女雏来到他家，他的生活为之一变。他被能使用念动力的雏所胁迫，迫不得已开始和她同居！\n容易暴..."},{"title":"OVERLORD Ⅲ","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/dd7a9d0a0bee32b1f43c2656398d8463d12b3069.jpg@220w_280h.webp","totalCount":"全13话","id":102252,"follow":"551.6 万","view":"4.0 亿","danmaku":"399.7 万","coin":"129.2 万","score":9.4,"des":"时间为2138年。曾卷起一大风潮的虚拟现实体感型网络游戏《YGGDRASIL》即将迎来停服。玩家飞鼠在曾经以同伴和荣华自傲的根据地纳萨力克地下大坟墓，独自一人安静等待着那一刻。\n但是，不料发生了“过了..."},{"title":"路人超能100 第一次灵能咨询所员工旅游～舒缓心灵的疗愈之旅~（OVA2）","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/1271324d51634b68980704731987724a1afc60aa.jpg@220w_280h.webp","totalCount":"全1话","id":28222715,"follow":"318.8 万","view":"520.7 万","danmaku":"3.6 万","coin":"4.6 万","score":9.8,"des":"由原作ONE老师担任原案的完全新作OVA！「灵能咨询所」一行人，龙套与灵幻、小酒窝以及新同伴芹泽的目的地，正是缟马县深山中鲜为人知的温泉·疣神温泉。因为灵幻接受了旅馆老板娘的委托，「弄清温泉的恐怖传闻..."},{"title":"少女终末旅行","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1431ca5bb2f7143062e3df8f21b8448cf8cccc13.jpg@220w_280h.webp","totalCount":"全12话","id":6463,"follow":"239.8 万","view":"3714.7 万","danmaku":"100.7 万","coin":"37.2 万","score":9.8,"des":"本作舞台在人类繁华的文明迎来终结的很久以后，人类基本灭绝，甚至生物都不再存在的末日世界。复杂够高的都市成为迷宫般的废墟，得不到维护的机械渐渐停止运转。连何时终结了，何时开始终结的思考都不复存在的这个世..."},{"title":"齐木楠雄的灾难（日播&精选版）","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/eb4f17335f48951945fb9da47e6ee0bc65fa2fbb.jpg@220w_280h.webp","totalCount":"全120话","id":5070,"follow":"187.0 万","view":"2.3 亿","danmaku":"130.7 万","coin":"32.7 万","score":9.6,"des":"高中生·齐木楠雄是超能力者。心灵感应、念动力、透视、预知、瞬间移动、千里眼等，不论任何事情都自由自在。但这任谁都羡慕不已的最强能力，实际上对于本人而言是引来灾难的不幸元凶。因此，他在别人面前封印了超能..."},{"title":"比宇宙更远的地方","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/c9eca3cbc386c63b27461074b8b218898cb7440e.jpg@220w_280h.webp","totalCount":"全13话","id":13032,"follow":"156.0 万","view":"2298.0 万","danmaku":"45.9 万","coin":"23.9 万","score":9.8,"des":"无论何时，我们的第一步总是从好奇心开始。\n不曾看过的风景，不曾听过的声音，不曾闻过的味道，不曾摸过的质感，不曾尝过的食物，以及不曾感受过的澎湃。\n为了重拾不知何时忘却的记忆碎片和不知何时舍弃的感动的旅..."},{"title":"OVERLORD","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/b8e72ea69e57e0b7ac85d8b4d366554fd866df1a.jpg@220w_280h.webp","totalCount":"全13话","id":2576,"follow":"626.2 万","view":"4.1 亿","danmaku":"385.2 万","coin":"84.4 万","score":9.6,"des":"作品主要讲述了某天，一款曾经掀起过大热潮的VRMMORPG「YGGDRASIL」停止了运营。游戏原本会停止一切服务，但过了结束时间后，玩家们却发现不能退出，NPC也产生了各自的思想。现实世界中喜爱电玩..."},{"title":"路人超能100 II(灵能百分百 第二季)","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/216e1bdaf88244215a13b1154116805ee9adbe07.png@220w_280h.webp","totalCount":"全13话","id":4762734,"follow":"284.9 万","view":"1.0 亿","danmaku":"97.8 万","coin":"56.1 万","score":9.9,"des":"当有什么东西达到“100”的时候，就会爆发的少年·路人（龙套）。外表极其普通——不如说是不起眼。不擅长迎合气氛的他，实际上拥有着强力的超能力。盯上了这样的他的能力，而接连现身的伪灵能力者以及宗教团体、..."},{"title":"多罗罗","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3fc16a667502cbff226e585eb660a96a20c7458c.png@220w_280h.webp","totalCount":"全24话","id":4312482,"follow":"452.1 万","view":"1.8 亿","danmaku":"143.9 万","coin":"73.9 万","score":9.4,"des":"他们向着命运抗争，在那尽头等待他们的是人心，还是业障。\n时值乱世。\n名为景光的醍醐将军，向某个寺庙殿堂中的12尊魔神像祈求早日结束战乱。\n作为代价，他的嫡子在出生时就失去了身体的某些部位，被丢弃在河流..."},{"title":"魔法少女小圆","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/7fcaa0e98b561611538ae4deba7949cec4ca39a8.png@220w_280h.webp","totalCount":"全12话","id":2539,"follow":"218.7 万","view":"4199.0 万","danmaku":"201.5 万","coin":"20.0 万","score":9.8,"des":"就读初中二年级的鹿目圆，过着平凡幸福的生活。神秘转学生晓美焰的出现，开始让小圆的命运有了巨大转变。某日一只名为丘比的神秘生物，希望小圆能够与它签订魔法契约，成为“魔法少女”以对抗邪恶的魔女保护世界。正..."}]},"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<blockquote>\n<p>由于再下把服务器玩崩了（^-^），需要重装服务器系统，这次我选择LAMP ;因为我懒得再次安装MySQL之类的了。</p>\n</blockquote>\n<img src=\"http://rebp38war.bkt.clouddn.com/img/20220722142934.png\" style=\"zoom:80%;\">\n\n\n\n<p>选择系统镜像，点击重置即可安装完毕，点击应用管理，可以看到应用安装完的应用信息；</p>\n<p>上面也写了密码放置的位置</p>\n<img src=\"http://rebp38war.bkt.clouddn.com/img/20220722142216.png\" style=\"zoom:80%;\">\n\n<p>我们连接到服务器 </p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@ls_patrick ~]# cat /root/REAME</span><br></pre></td></tr></table></figure>\n\n<p>查看到我们初始的应用信息和密码；</p>\n<p><img src=\"http://rebp38war.bkt.clouddn.com/img/20220722143415.png\"></p>\n<p>复制密码进入我们的MySQL ；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@ls_patrick ~]# mysql -uroot -p</span><br><span class=\"line\">Enter password:</span><br></pre></td></tr></table></figure>\n\n<p>在Enter password:后粘贴这段密码</p>\n<p><img src=\"http://rebp38war.bkt.clouddn.com/img/20220722143711.png\"></p>\n<p>看到欢迎信息就进入成功了；</p>\n<p>一般我们会使用客户端连接（Navicat等)。接下来，我们需要开启 远程连接并开放端口，这样客户端才能连接上</p>\n<p>命令行登入mysql后;</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">MySQL [(none)]&gt; use mysql ;</span><br><span class=\"line\">Database changed</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>查看root权限信息。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">MySQL [mysql]&gt; select host, user from user;</span><br><span class=\"line\">+-----------+---------------+</span><br><span class=\"line\">| host      | user          |</span><br><span class=\"line\">+-----------+---------------+</span><br><span class=\"line\">| 127.0.0.1 | root          |</span><br><span class=\"line\">| localhost | mysql.session |</span><br><span class=\"line\">| localhost | mysql.sys     |</span><br><span class=\"line\">| localhost | root          |</span><br><span class=\"line\">+-----------+---------------+</span><br><span class=\"line\">4 rows in set (0.00 sec)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>修改root用户的host</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">MySQL [mysql]&gt; update user set host = &#x27;%&#x27; where user = &#x27;root&#x27;;</span><br></pre></td></tr></table></figure>\n<p>如果遇到以下发生错误，不理会</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ERROR 1062 (23000): Duplicate entry &#x27;%-root&#x27; for key &#x27;PRIMARY&#x27;</span><br></pre></td></tr></table></figure>\n<p>更新权限</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">MySQL [mysql]&gt; flush privileges;</span><br></pre></td></tr></table></figure>\n\n<p>再次查看root权限信息，可以看到修改成功了</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">MySQL [mysql]&gt; select host, user from user;</span><br><span class=\"line\">+-----------+---------------+</span><br><span class=\"line\">| host      | user          |</span><br><span class=\"line\">+-----------+---------------+</span><br><span class=\"line\">| %         | root          |</span><br><span class=\"line\">| 127.0.0.1 | root          |</span><br><span class=\"line\">| localhost | mysql.session |</span><br><span class=\"line\">| localhost | mysql.sys     |</span><br><span class=\"line\">+-----------+---------------+</span><br><span class=\"line\">4 rows in set (0.00 sec)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 为防火墙添加 3306 端口</span></span><br><span class=\"line\">firewall-cmd --zone=public --add-port=3306/tcp --permanent</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 重启防火墙</span></span><br><span class=\"line\">firewall-cmd --reload</span><br></pre></td></tr></table></figure>\n\n<p>或者在百度云上配置</p>\n<img src=\"http://rebp38war.bkt.clouddn.com/img/20220722144447.png\" style=\"zoom:80%;\">\n\n<img src=\"http://rebp38war.bkt.clouddn.com/img/20220722144513.png\" style=\"zoom:67%;\">\n\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@ls_patrick ~]# service mysqld restart</span><br><span class=\"line\">Shutting down MySQL..                                      [  OK  ]</span><br><span class=\"line\">Starting MySQL..                                           [  OK  ]</span><br></pre></td></tr></table></figure>\n\n\n\n<img src=\"http://rebp38war.bkt.clouddn.com/img/20220722144304.png\" style=\"zoom:67%;\">\n\n<p>重置MySQL密码</p>\n<p>进入mysql（如果忘记密码可以 <code>mysqld_safe --skip-grant-tables &amp;</code> 直接运行下面无密码命令进入mysql）<br>1<br>设置新密码</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">UPDATE mysql.user SET Password=PASSWORD(&#x27;new-password&#x27;) WHERE User=&#x27;root&#x27;;</span><br></pre></td></tr></table></figure>\n\n\n<p>在 mysql&gt; 提示符下，键入以下命令刷新：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">FLUSH PRIVILEGES;</span><br><span class=\"line\"></span><br><span class=\"line\">exit;</span><br></pre></td></tr></table></figure>\n\n\n<p>重启 MySQL 服务器。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@ls_patrick ~]# service mysqld restart</span><br><span class=\"line\">Shutting down MySQL..                                      [  OK  ]</span><br><span class=\"line\">Starting MySQL..                                           [  OK  ]</span><br></pre></td></tr></table></figure>\n\n\n\n<p>MYSQL 就到此暂告一段落</p>\n"},{"title":"软件开发方法","date":"2022-06-30T06:40:44.000Z","_content":"> 开发方法是一种方法学，主要是针对系统开发阶段中的设计和编码进行实现。\n\n## 原型法 ##\n适用于**需求不明确**的场景,对用户的需求动态响应，逐步纳入<br>\n\n**按功能分类**\n1. 水平模型 （界面）\n2. 垂直模型 （复杂算法）\n\n**按最终结果分类**\n1. 抛弃型原型 （系统实现以后就放弃不用了：提裤子走人）\n2. 进化型原型 （从目标系统的一个或几个基本需求出发，通过修改和追加功能，逐渐丰富，演化成最终系统：迭代）\n\n## 结构化方法 ##\n![](http://rebp38war.bkt.clouddn.com/img/jiegou.png)\n\n\n特点：强调系统开发过程的**整体性**和**全局性**，系统开发过程**工程化**，文档**标准化**\n\n## 面向对象方法 ##\n\n![](http://rebp38war.bkt.clouddn.com/img/20220720105445.png)\n## 面向服务方法 ##\n\n以**粗粒度**、**松散耦合**的体统功能为核心，强调系统功能的**标准化**和**构件化**，加强了系统的**灵活性**、**可复用性**和**可演化性**<br>\n面向服务方法是在面向对象方法的基础上扩展的构建系统的思想和方法。面向服务方法关注的是企业业务，它直接映射到业务，强调IT与业务的对齐，以服务为核心元素来封装企业的业务流程和企业已有应用系统。服务的粒度更大，更加匹配企业级应用中的业务，可以实现更高级别的重用。但目前存在相关标准未统一、应用案例较少等一些问题。\n\n## 各类系统开发方法的比较 ##\n| 名称 | 概述 | 优点 | 缺点 |\n| :----: | :----: | :----: | :----: |\n| 原型法 | 对用户的需求动态响应，逐步纳入 | 系统开发循序渐进，反复修改，确保较好的用户满意度； | 不适合大规模系统的开发；开发过程管理要求高，整个开发过程要经过“修改—评价—再修改”的多次反复；用户过早看到系统原型，误认为系统就是这个模样，易使用户失去信心；开发人员易将原型取代系统分析；缺乏规范化的文档资料 |\n| 结构化方法 | 系统开发过程的整体性和全局性，系统开发过程工程化，文档标准化 | 体现了逐层分解、逐步求精的原则，有严格的规则 | 难于检验分析结果的正确与否；对需求变更的适应能力很差；系统设计人员对分析结果的理解存在障碍 |\n| 面向对象方法 | 以对象（对象=数据＋算法）为中心，实现了对数据和算法的封装和继承 | 加强了对应用领域的理解，改进了沟通和交流；适应需求变化的能力较强；支持分析和设计结果的复用 | 纯技术导向，存在与业务的鸿沟；复杂度高，抽象程度低，难以实现大规模和高层次的重用 |\n| 面向服务方法 | 以服务封装业务流程和应用系统 | 业务驱动技术，以开放标准实现应用系统之间服务的相互访问，乃至复合应用的组装，实现了更高级别重用 | 是一个较新的领域，许多研究和实践还有待进一步深入，相关标准尚未统一 |","source":"_posts/软件开发方法.md","raw":"---\ntitle: 软件开发方法\ndate: 2022-06-30 14:40:44\ntags:\ncategories:\n- [架构，学习笔记]\n---\n> 开发方法是一种方法学，主要是针对系统开发阶段中的设计和编码进行实现。\n\n## 原型法 ##\n适用于**需求不明确**的场景,对用户的需求动态响应，逐步纳入<br>\n\n**按功能分类**\n1. 水平模型 （界面）\n2. 垂直模型 （复杂算法）\n\n**按最终结果分类**\n1. 抛弃型原型 （系统实现以后就放弃不用了：提裤子走人）\n2. 进化型原型 （从目标系统的一个或几个基本需求出发，通过修改和追加功能，逐渐丰富，演化成最终系统：迭代）\n\n## 结构化方法 ##\n![](http://rebp38war.bkt.clouddn.com/img/jiegou.png)\n\n\n特点：强调系统开发过程的**整体性**和**全局性**，系统开发过程**工程化**，文档**标准化**\n\n## 面向对象方法 ##\n\n![](http://rebp38war.bkt.clouddn.com/img/20220720105445.png)\n## 面向服务方法 ##\n\n以**粗粒度**、**松散耦合**的体统功能为核心，强调系统功能的**标准化**和**构件化**，加强了系统的**灵活性**、**可复用性**和**可演化性**<br>\n面向服务方法是在面向对象方法的基础上扩展的构建系统的思想和方法。面向服务方法关注的是企业业务，它直接映射到业务，强调IT与业务的对齐，以服务为核心元素来封装企业的业务流程和企业已有应用系统。服务的粒度更大，更加匹配企业级应用中的业务，可以实现更高级别的重用。但目前存在相关标准未统一、应用案例较少等一些问题。\n\n## 各类系统开发方法的比较 ##\n| 名称 | 概述 | 优点 | 缺点 |\n| :----: | :----: | :----: | :----: |\n| 原型法 | 对用户的需求动态响应，逐步纳入 | 系统开发循序渐进，反复修改，确保较好的用户满意度； | 不适合大规模系统的开发；开发过程管理要求高，整个开发过程要经过“修改—评价—再修改”的多次反复；用户过早看到系统原型，误认为系统就是这个模样，易使用户失去信心；开发人员易将原型取代系统分析；缺乏规范化的文档资料 |\n| 结构化方法 | 系统开发过程的整体性和全局性，系统开发过程工程化，文档标准化 | 体现了逐层分解、逐步求精的原则，有严格的规则 | 难于检验分析结果的正确与否；对需求变更的适应能力很差；系统设计人员对分析结果的理解存在障碍 |\n| 面向对象方法 | 以对象（对象=数据＋算法）为中心，实现了对数据和算法的封装和继承 | 加强了对应用领域的理解，改进了沟通和交流；适应需求变化的能力较强；支持分析和设计结果的复用 | 纯技术导向，存在与业务的鸿沟；复杂度高，抽象程度低，难以实现大规模和高层次的重用 |\n| 面向服务方法 | 以服务封装业务流程和应用系统 | 业务驱动技术，以开放标准实现应用系统之间服务的相互访问，乃至复合应用的组装，实现了更高级别重用 | 是一个较新的领域，许多研究和实践还有待进一步深入，相关标准尚未统一 |","slug":"软件开发方法","published":1,"updated":"2022-07-20T03:46:55.411Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5w7e747000migvu3la8c3ur","content":"<blockquote>\n<p>开发方法是一种方法学，主要是针对系统开发阶段中的设计和编码进行实现。</p>\n</blockquote>\n<h2 id=\"原型法\"><a href=\"#原型法\" class=\"headerlink\" title=\"原型法\"></a>原型法</h2><p>适用于<strong>需求不明确</strong>的场景,对用户的需求动态响应，逐步纳入<br></p>\n<p><strong>按功能分类</strong></p>\n<ol>\n<li>水平模型 （界面）</li>\n<li>垂直模型 （复杂算法）</li>\n</ol>\n<p><strong>按最终结果分类</strong></p>\n<ol>\n<li>抛弃型原型 （系统实现以后就放弃不用了：提裤子走人）</li>\n<li>进化型原型 （从目标系统的一个或几个基本需求出发，通过修改和追加功能，逐渐丰富，演化成最终系统：迭代）</li>\n</ol>\n<h2 id=\"结构化方法\"><a href=\"#结构化方法\" class=\"headerlink\" title=\"结构化方法\"></a>结构化方法</h2><p><img src=\"http://rebp38war.bkt.clouddn.com/img/jiegou.png\"></p>\n<p>特点：强调系统开发过程的<strong>整体性</strong>和<strong>全局性</strong>，系统开发过程<strong>工程化</strong>，文档<strong>标准化</strong></p>\n<h2 id=\"面向对象方法\"><a href=\"#面向对象方法\" class=\"headerlink\" title=\"面向对象方法\"></a>面向对象方法</h2><p><img src=\"http://rebp38war.bkt.clouddn.com/img/20220720105445.png\"></p>\n<h2 id=\"面向服务方法\"><a href=\"#面向服务方法\" class=\"headerlink\" title=\"面向服务方法\"></a>面向服务方法</h2><p>以<strong>粗粒度</strong>、<strong>松散耦合</strong>的体统功能为核心，强调系统功能的<strong>标准化</strong>和<strong>构件化</strong>，加强了系统的<strong>灵活性</strong>、<strong>可复用性</strong>和<strong>可演化性</strong><br><br>面向服务方法是在面向对象方法的基础上扩展的构建系统的思想和方法。面向服务方法关注的是企业业务，它直接映射到业务，强调IT与业务的对齐，以服务为核心元素来封装企业的业务流程和企业已有应用系统。服务的粒度更大，更加匹配企业级应用中的业务，可以实现更高级别的重用。但目前存在相关标准未统一、应用案例较少等一些问题。</p>\n<h2 id=\"各类系统开发方法的比较\"><a href=\"#各类系统开发方法的比较\" class=\"headerlink\" title=\"各类系统开发方法的比较\"></a>各类系统开发方法的比较</h2><table>\n<thead>\n<tr>\n<th align=\"center\">名称</th>\n<th align=\"center\">概述</th>\n<th align=\"center\">优点</th>\n<th align=\"center\">缺点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">原型法</td>\n<td align=\"center\">对用户的需求动态响应，逐步纳入</td>\n<td align=\"center\">系统开发循序渐进，反复修改，确保较好的用户满意度；</td>\n<td align=\"center\">不适合大规模系统的开发；开发过程管理要求高，整个开发过程要经过“修改—评价—再修改”的多次反复；用户过早看到系统原型，误认为系统就是这个模样，易使用户失去信心；开发人员易将原型取代系统分析；缺乏规范化的文档资料</td>\n</tr>\n<tr>\n<td align=\"center\">结构化方法</td>\n<td align=\"center\">系统开发过程的整体性和全局性，系统开发过程工程化，文档标准化</td>\n<td align=\"center\">体现了逐层分解、逐步求精的原则，有严格的规则</td>\n<td align=\"center\">难于检验分析结果的正确与否；对需求变更的适应能力很差；系统设计人员对分析结果的理解存在障碍</td>\n</tr>\n<tr>\n<td align=\"center\">面向对象方法</td>\n<td align=\"center\">以对象（对象=数据＋算法）为中心，实现了对数据和算法的封装和继承</td>\n<td align=\"center\">加强了对应用领域的理解，改进了沟通和交流；适应需求变化的能力较强；支持分析和设计结果的复用</td>\n<td align=\"center\">纯技术导向，存在与业务的鸿沟；复杂度高，抽象程度低，难以实现大规模和高层次的重用</td>\n</tr>\n<tr>\n<td align=\"center\">面向服务方法</td>\n<td align=\"center\">以服务封装业务流程和应用系统</td>\n<td align=\"center\">业务驱动技术，以开放标准实现应用系统之间服务的相互访问，乃至复合应用的组装，实现了更高级别重用</td>\n<td align=\"center\">是一个较新的领域，许多研究和实践还有待进一步深入，相关标准尚未统一</td>\n</tr>\n</tbody></table>\n","site":{"data":{"bangumis":{"wantWatch":[],"watching":[{"title":"凡人修仙传","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/70d11dfab23a3ee81ccf64f18efa139416a633ff.jpg@220w_280h.webp","totalCount":"未完结","id":28223043,"follow":"615.7 万","view":"8.9 亿","danmaku":"490.9 万","coin":"1186.9 万","score":9.7,"des":"看机智的凡人小子韩立如何稳健发展、步步为营，战魔道、夺至宝、驰骋星海、快意恩仇，成为纵横三界的强者。他日仙界重相逢，一声道友尽沧桑。..."},{"title":"恋爱游戏世界对路人角色很不友好","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/c9723d8c77d881a8debba2852d580e97826b43d0.png@220w_280h.webp","totalCount":"全12话","id":28237300,"follow":"151.2 万","view":"5120.4 万","danmaku":"40.6 万","coin":"24.5 万","score":9.1,"des":"从现代日本转生到“恋爱游戏”世界的里昂，发现这里女尊男卑，对男性很不友好。身为路人角色的他，为了摆脱自己因地位低下而被肆意决定的人生，决定活用从游戏中得到的知识，保持路人角色的身份，取得“失落物品”来..."},{"title":"魔法纪录 魔法少女小圆外传 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/9eef1df9ab157be52d2c4d70d3500442f00cafc3.png@220w_280h.webp","totalCount":"全12话","id":28234642,"follow":"237.1 万","view":"907.6 万","danmaku":"5.0 万","coin":"4.9 万","score":7.7,"des":"愿望的代价，究竟是希望还是绝望——。"},{"title":"小林家的龙女仆 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/847e9dbb6876fb37a30199a5c88910704976d45b.png@220w_280h.webp","totalCount":"全13话","id":28234613,"follow":"855.7 万","view":"1.1 亿","danmaku":"49.0 万","coin":"69.0 万","score":9.6,"des":"那位不可思议的龙女仆再度登场！\n因为各种奇妙的原因而作为小林家的女仆而工作中的龙·托尔。\n偶尔（胡说，是经常）给亲爱的小林添麻烦，总算是融入了人类社会，成为了一个完美的（骗人，也就还行）女仆。\n同样是..."},{"title":"国王排名","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/376d7e69a667bcb1c0b934a4e35e07e7fa23110b.png@220w_280h.webp","totalCount":"全23话","id":28235154,"follow":"927.7 万","view":"4.8 亿","danmaku":"250.1 万","coin":"260.9 万","score":7,"des":"国家的丰饶、麾下勇者的数量、\n以及国王本人如何像勇者一般强大，\n这些要素的综合排名，便是所谓的“国王排名”。\n主人公波吉是国王排名第七名的伯斯王治下王国的第一王子。\n但是波吉却生来又聋又哑，贫弱到挥不..."},{"title":"阿松 第三季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0212baa8898d0c819c7fb84015e95b8fca621435.png@220w_280h.webp","totalCount":"全25话","id":28229892,"follow":"67.6 万","view":"938.0 万","danmaku":"13.0 万","coin":"5.4 万","score":9.6,"des":"日本最有名的六胞胎的传说，第三次开幕！！这次会有怎样意想不到的新展开！？..."},{"title":"命运-冠位指定 冠位时间神殿所罗门","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0e094b798388da19a4feffa6a6dabc1dc1dc90cd.jpg@220w_280h.webp","totalCount":"全1话","id":28236225,"follow":"525.5 万","view":"1220.0 万","danmaku":"8.9 万","coin":"15.1 万","score":8.5,"des":"在经过七个特异点的大战后，\n人理存续保障机关迦勒底，终于到达了圣杯探索的最终地点——终局特异点 冠位时间神殿所罗门。\n他们要击败身为罪魁祸首的魔术王所罗门，夺回未来。\n在开战的前一刻，一行人各自度过了..."},{"title":"JOJO的奇妙冒险 星尘远征军","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/47c0108259355d6d2c517ed97f6b90fb777f844f.png@220w_280h.webp","totalCount":"全24话","id":28223481,"follow":"444.2 万","view":"1.5 亿","danmaku":"463.4 万","coin":"45.7 万","score":9.8,"des":"时为1987年，乔瑟夫·乔斯达与“柱之男”们之间的死战后过了50年……乔瑟夫为了为了帮助“被恶灵附身了”的外孙子·空条承太郎而来到了日本。原来那并不是恶灵而是幽波纹（替身）。替身突然出现的原因在于，从..."},{"title":"JOJO的奇妙冒险 星尘远征军 埃及篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f6709b76e88f50aa132d1e09e2d8de9663a09b3e.png@220w_280h.webp","totalCount":"全24话","id":28223483,"follow":"421.9 万","view":"1.3 亿","danmaku":"468.7 万","coin":"44.3 万","score":9.9,"des":"在乔斯达家的宿敌·迪奥（DIO）复活的影响下，一位年轻人——空条承太郎，得到了名为“幽波纹（替身）”的能力。为了拯救因迪奥的诅咒而倒下的母亲荷莉，空条承太郎与外祖父·乔瑟夫以及伙伴们，一起为了打倒迪奥..."},{"title":"JOJO的奇妙冒险 不灭钻石","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/6a04c87e990ab74cd8d555ef45a863de0993b161.png@220w_280h.webp","totalCount":"全39话","id":140552,"follow":"302.3 万","view":"2.1 亿","danmaku":"813.8 万","coin":"55.9 万","score":9.8,"des":"在埃及与宿敌DIO的死斗之后过了11年。1999年，空条承太郎为了与祖父乔瑟夫·乔斯达的私生子东方仗助见面，而来到了日本M县S市杜王町。但，仗助却持有与承太郎相同的特殊能力“替身”。之后，以承太郎的来..."},{"title":"命运-冠位嘉年华","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/c660976f4502a544d990a882ae62194b57753a71.png@220w_280h.webp","totalCount":"全2话","id":28234639,"follow":"479.8 万","view":"862.4 万","danmaku":"4.1 万","coin":"9.1 万","score":9.8,"des":"一起庆祝吧！为了这奇迹般的嘉年华！"},{"title":"伍六七","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/b69e26d9e50514f3fa99eac9ab5aabf2a6e28c88.jpg@220w_280h.webp","totalCount":"全13话","id":6360,"follow":"585.8 万","view":"3.3 亿","danmaku":"227.1 万","coin":"191.8 万","score":9.8,"des":"在某个小岛上，有一个可以伪装成任何东西的廉价刺客，名叫伍六七。平时看上去是个理发师，其实背地里却做着刺客生意。热爱理发事业，喜欢给人剪头发，善用剪刀——剪刀也是他的刺杀武器。由于初入刺客行当，行情十分..."},{"title":"命运-冠位指定 -月光／失落之室-","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3fa5fd2b7afae827b0bf150d7f0cbfc54eda1ff2.png@220w_280h.webp","totalCount":"全1话","id":28234950,"follow":"483.3 万","view":"551.2 万","danmaku":9696,"coin":"2.9 万","score":9.5,"des":"失落之室——。\n这是一个可以看到被夺去亦或是遗失之物的地方。\n这是位于迦勒底被遗忘的角落，不属于任何人的地方。..."},{"title":"致不灭的你","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/1ae94fbb35d8e23bb84926b694509f8b057f96e6.png@220w_280h.webp","totalCount":"全20话","id":28233896,"follow":"476.3 万","view":"1.3 亿","danmaku":"140.1 万","coin":"95.0 万","score":9.6,"des":"本剧讲述了一个情节跌宕、场面宏大的奇幻故事，通过拥有不灭之身的主人公“不死”来探索人生哲理。\n不死起初是一个被投放到人世间的“球”。\n\n它具有“幻化为刺激源形态的能力”和“死后重生的能力”。\n\n先后从..."},{"title":"来自新世界","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/aaa60f9cb17fb4a38df464f1064ca9623e0769cc.jpg@220w_280h.webp","totalCount":"全25话","id":1598,"follow":"115.9 万","view":"1540.9 万","danmaku":"76.3 万","coin":"5.7 万","score":9.5,"des":"1000年后的日本，孩子们不断地消失，只存在想象中的恐怖动物与人类展开殊死战争。反乌托邦式的未来超级社会“新世界”，是口吐真言凭藉“咒力”就能移动物体的人类，与有着等同于普通人智力的生物“妖鼠”共存的..."},{"title":"转生成蜘蛛又怎样！","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f0796e37abac25ba2aa9f23120646aaa9a3d5ea7.png@220w_280h.webp","totalCount":"全24话","id":28231809,"follow":"600.0 万","view":"3.7 亿","danmaku":"190.3 万","coin":"164.6 万","score":7.8,"des":"曾经是一名女高中生的“我”，突然转生变成了幻想世界中的蜘蛛魔物。\n而且，出生地点还是各种凶恶魔物所盘踞的大迷宫。\n“我”以人类的智慧和非同寻常的积极心态为武器，使用蜘蛛的丝网以及陷阱打倒比自己等级高得..."},{"title":"装甲重拳/MEGALOBOX 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/e14dc4a935397fc074c7a12d9520225615209025.png@220w_280h.webp","totalCount":"全13话","id":28233916,"follow":"244.9 万","view":"3435.4 万","danmaku":"19.7 万","coin":"53.1 万","score":9.9,"des":"再一次，为梦想而活——\n\n将肉体与“装甲技术”融合的究极格斗技“装甲拳击”。\n在决出其顶点之人的大会“重拳之巅”上，身穿装甲用自己肉身挑战一切的拳击手“JOE”。\n\n从最下层的比赛开始仅仅花了三个月就..."},{"title":"机动战士高达SEED HD","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/855c88677267d707ebfe4040403692ff2c0938f0.png@220w_280h.webp","totalCount":"全48话","id":497,"follow":"54.8 万","view":"4044.4 万","danmaku":"114.4 万","coin":"6.0 万","score":9.6,"des":"《机动战士高达SEED》是高达系列在2002年至2003年度放映的动画。续作为《机动战士高达SEED Destiny》在2004年播放。因各具魅力的角色，明星云集的声优阵容和高度商业化的宣传而受到较低..."},{"title":"夏目友人帐 唤石者与怪异的访客","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6cf43708b779cde84ad285ff4e3a080de98df0af.png@220w_280h.webp","totalCount":"全1话","id":28234316,"follow":"567.1 万","view":"1374.8 万","danmaku":"18.1 万","coin":"17.9 万","score":9.9,"des":"本作由【唤石者】与【怪异的访客】两个人气短篇集锦而成。讲述生来便能看见各种妖怪的夏目，与自称保镖的猫咪老师一同邂逅的一系列温暖故事。\n【唤石者】一天夏目在森林中遇到一只小妖怪——密实。密实称自己肩负「..."},{"title":"Fate/Grand Order ‐First Order‐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/b75c55d209d156c8631f5ceb21e5c52c834dbb60.jpg@220w_280h.webp","totalCount":"全1话","id":5747,"follow":"250.9 万","view":"3329.7 万","danmaku":"76.7 万","coin":"10.7 万","score":8.3,"des":"【2016年12月31日bilibili独播】2015年。示巴所观测到的未来领域毫无前兆地消失。根据计算，发现——不，是证明了人类将于2017年灭绝。人理延续保障机构·迦勒底将“无法观测的领域”假定为..."},{"title":"伍六七之玄武国篇","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/00843865ea13702eccc4efd64c313fd4c8029c6b.jpg@220w_280h.webp","totalCount":"全10话","id":28232253,"follow":"999.4 万","view":"4.0 亿","danmaku":"177.7 万","coin":"385.3 万","score":9.8,"des":"为了保护小鸡岛居民和这里平静的生活，伍六七和他的伙伴大保和小飞开启了去往玄武国的冒险旅程，去寻找身世的真相和解救小岛的办法，等待他们的又将是更多的未知与奇遇。..."},{"title":"堀与宫村","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/039c4e0b14e27c7a9e5cce2f20a6efd3c8909401.png@220w_280h.webp","totalCount":"全13话","id":28231840,"follow":"695.2 万","view":"2.2 亿","danmaku":"242.1 万","coin":"361.4 万","score":9.8,"des":"不论是谁，都会有不想被人知道的一面。\n\n在学校中漂亮大方、成绩优秀的人气女生堀，私下却打扮土气、忙于家务和照顾弟弟。\n在学校中是阴暗宅男形象的宫村，生活中却是打扮时尚、带耳钉的帅气男生。\n因为一次特别..."},{"title":"奇蛋物语 / WONDER EGG PRIORITY","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/10e0bbc1047b2c45f0f881de334a6f3bfb42a3b6.png@220w_280h.webp","totalCount":"全12话","id":28231851,"follow":"254.9 万","view":"4686.8 万","danmaku":"47.6 万","coin":"65.5 万","score":9.7,"des":"14岁少女·大户爱在深夜散步的途中，\n随着神秘声音的指引，获得了一枚「蛋」。\n\n「如果想要改变世界的话」\n「那么就在现在做出选择」\n「请相信自己——」\n「打破这枚蛋——」\n\n而在打破「蛋」之后，等待着..."},{"title":"Re：从零开始的异世界生活 第二季 后半","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/4f3edbede7fc0bdb52842075cf8faaa1c5953eaa.png@220w_280h.webp","totalCount":"全12话","id":28232073,"follow":"849.9 万","view":"9308.1 万","danmaku":"108.1 万","coin":"230.1 万","score":9.9,"des":"我一定会拯救你。\n在打倒了魔女教大罪司教「怠惰」担当——培提其乌斯·罗曼尼康帝之后，菜月昴和爱蜜莉雅又得以重新开始。\n克服了艰难的诀别，两人终于和解，然而这只是新一轮风波的序幕。\n超乎想象的绝境危机，..."},{"title":"灰与幻想的格林姆迦尔","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/7fb4945f864e9e988212b7d20f206df2677053f8.jpg@220w_280h.webp","totalCount":"全12话","id":106512,"follow":"172.0 万","view":"2343.4 万","danmaku":"63.8 万","coin":"18.3 万","score":9.8,"des":"电视动画《灰与幻想的格林姆迦尔》改编自日本轻小说家十文字青原作白井锐利插画的同名轻小说。\n我们为什么要这么做…？\n哈尔希洛回过神来，才发现自己身处在黑暗当中，他完全不知道自己人在何处，也不明白这个地方..."},{"title":"龙与虎","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/144910805f172d16c5f544f43939a05d8ca20576.jpg@220w_280h.webp","totalCount":"全26话","id":1672,"follow":"336.9 万","view":"6671.9 万","danmaku":"511.9 万","coin":"61.5 万","score":9.7,"des":"樱花飞舞的四月，全新的高中二年级，新的班级……\n眼神凶恶的普通男孩——高须龙儿，遇上了众人害怕、凶暴残忍的“掌中老虎”逢坂大河，还知道了她不欲为人知的秘密。这就是龙虎相争爱与战斗的序幕。\n再加上总是笑..."},{"title":"机动战士高达 铁血的奥尔芬斯 第一季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/f84a80d731d0431c00903d8951fd66623d8237f7.png@220w_280h.webp","totalCount":"全25话","id":4310042,"follow":"62.4 万","view":"2318.6 万","danmaku":"52.2 万","coin":"5.4 万","score":9.5,"des":"主人公三日月·奥古斯，从所属的民间警备公司克律塞安保公司（下称CGS）那里，接受了对少女库德莉亚·蓝那·伯恩斯坦的护卫任务。但CGS受到了摘取反叛之芽的武力组织加拉尔霍恩的袭击，于是在把三日月当做诱饵..."},{"title":"机动战士高达00 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1d7a969e8f1045739c596de89a963e30475aff0e.jpg@220w_280h.webp","totalCount":"全25话","id":1193,"follow":"37.2 万","view":"2458.1 万","danmaku":"61.4 万","coin":"4.1 万","score":9.8,"des":"天人与联合国军的最终决战后过了四年。建立地球联邦政府的人类，为了追求更进一步的国家间之统合，以及人类意识的统一，在联合正规军之外，设立了独立治安维持部队“A-Laws”，目的为对所有危害联合的势力与主..."},{"title":"机动战士高达00","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/35b11bf59eb3fd12f0387951510a5d722d7435e5.jpg@220w_280h.webp","totalCount":"全25话","id":1192,"follow":"62.1 万","view":"2465.5 万","danmaku":"53.6 万","coin":"4.6 万","score":9.7,"des":"在西历2307年，虽然化石燃料枯竭了，但是人类得到了截然不同的新型能源。三台巨大的轨道升降机以及伴随它们的大规模的太阳光发电系统。但是能得到这个系统恩惠的，只有一部分大国和其同盟国而已。\n拥有三台轨道..."},{"title":"Re：从零开始的异世界生活 第二季 前半","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f2425cbdb07cc93bd0d3ba1c0099bfe78f5dc58a.png@220w_280h.webp","totalCount":"全13话","id":28229233,"follow":"774.2 万","view":"1.3 亿","danmaku":"201.4 万","coin":"126.7 万","score":9.7,"des":"我一定会拯救你。\n在打倒了魔女教大罪司教「怠惰」担当——培提其乌斯·罗曼尼康帝之后，菜月昴和爱蜜莉雅又得以重新开始。\n克服了艰难的诀别，两人终于和解，然而这只是新一轮风波的序幕。\n超乎想象的绝境危机，..."},{"title":"超级小白","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3d3e8257d22596f5d3e4395ca759bd1e0fe9b873.jpg@220w_280h.webp","totalCount":"全48话","id":28222671,"follow":"27.4 万","view":"978.0 万","danmaku":"3.6 万","coin":"3.6 万","score":9.6,"des":"为了阻止企图霸占世界的黑暗势力，野原家的普通小狗——小白接肩负重大使命，变身成为了守护世界的“超级小白”。小白将要面对的不仅是发明狗，还有其他意想不到的对手。当然，面对邪恶势力，小白也有着令人惊讶的超..."},{"title":"Re：从零开始的异世界生活 新编集版","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3c125e1aad08643e3eff2fb7d45e740c1a052725.png@220w_280h.webp","totalCount":"全13话","id":28224394,"follow":"631.1 万","view":"7674.2 万","danmaku":"166.2 万","coin":"51.1 万","score":9.6,"des":"在从便利商店回家的路上，突然被异世界召唤的少年菜月昴。在无法依靠任何东西的异世界，无力的少年手唯一的力量……那是“死去然后重新开始”的力量。为了守护最重要的人们，为了取回确实存在着又无可替代的时间，少..."},{"title":"因为太怕痛就全点防御力了","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/8021d3f6b0df6dbba6d32f76eb9cfe2531e166c4.png@220w_280h.webp","totalCount":"全12话","id":28224137,"follow":"620.6 万","view":"2.3 亿","danmaku":"326.8 万","coin":"103.8 万","score":9,"des":"主角本条枫在好友白峰理沙推荐下开始游玩游戏“NewWorld Online”，创建了名为“梅普露”的角色。然而作为游戏初学者，梅普露选择了不受欢迎的大盾当武器，同时因为怕痛而把所有状态点加到防御力的极..."},{"title":"冰海战记","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/c30401817895e67399094b4e669785a104270cdf.jpg@220w_280h.webp","totalCount":"全24话","id":28220475,"follow":"174.4 万","view":"4893.8 万","danmaku":"48.7 万","coin":"36.7 万","score":9.8,"des":"公元10世纪末期，出现了在世界各地出没的最强民族。被讴歌为最强战士的托尔兹，其子托尔芬幼时便生活在战场上，并向往着梦幻大陆“文兰”。这是一个发生在激荡时代的，真正的英雄物语。..."},{"title":"齐木楠雄的灾难 始动篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ba59822eded39b5254fb01448a7f1502101d5624.png@220w_280h.webp","totalCount":"全6话","id":28223748,"follow":"372.4 万","view":"3054.5 万","danmaku":"20.0 万","coin":"17.8 万","score":9.8,"des":"在电视剧中堪称帅气的超能力，对于高中生齐木楠雄来说只是招致灾难的元凶。作为新动画系列展开的楠雄的日常又会如何！？..."},{"title":"OVERLORD Ⅱ","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/851f979c8ebcc7583a43abd4b786c4e2e66b746b.jpg@220w_280h.webp","totalCount":"全13话","id":8792,"follow":"539.3 万","view":"3.8 亿","danmaku":"413.9 万","coin":"114.1 万","score":9.6,"des":"时为2138年。曾卷起一大风潮的虚拟现实体感型网络游戏《YGGDRASIL》即将迎来停服。玩家飞鼠在曾经以同伴和荣华自傲的根据地纳萨力克地下大坟墓，独自一人安静等待着那一刻。但是，不料发生了结束时间已..."},{"title":"夏目友人帐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/99c549494d9425f6455bd45a151f4d26397d6151.png@220w_280h.webp","totalCount":"全13话","id":1660,"follow":"324.0 万","view":"4975.2 万","danmaku":"278.7 万","coin":"15.5 万","score":9.8,"des":"夏目贵志生来拥有强大的灵力，能感知平常人所无法接触的妖怪神明的存在。因父母双亡，他多年间辗转于互相推卸责任的亲戚之间，又受到同龄人的欺负，未曾与任何人深交，造成性格一定程度上的孤僻。夏目本性和善，对于..."}],"watched":[{"title":"装甲重拳/MEGALOBOX","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0c44785cb5d25cc9f648800d251f21a2e236bb8a.png@220w_280h.webp","totalCount":"全13话","id":79472,"follow":"221.9 万","view":"6162.0 万","danmaku":"48.6 万","coin":"32.9 万","score":9.8,"des":"将肉体与“装甲技术”融合的究极格斗技——“MEGALOBOX”，将自己的全部赌在上面的男人们的热血战斗开始！\n今天也立于未认可地区的赌博比赛赛场上的MEGALO拳击手“JNK DOG”。虽然具备实力，..."},{"title":"超能力女儿","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/152c536f8ecaad8f3d7d568d33da81c963a4a722.png@220w_280h.webp","totalCount":"全12话","id":78352,"follow":"293.8 万","view":"9252.2 万","danmaku":"98.5 万","coin":"35.4 万","score":9.6,"des":"支持着芦川组的年轻智力型黑道新田义史，过着被喜欢的壶所包围的悠然自得单身生活。但某一天，随着装在神秘物体里的少女雏来到他家，他的生活为之一变。他被能使用念动力的雏所胁迫，迫不得已开始和她同居！\n容易暴..."},{"title":"OVERLORD Ⅲ","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/dd7a9d0a0bee32b1f43c2656398d8463d12b3069.jpg@220w_280h.webp","totalCount":"全13话","id":102252,"follow":"551.6 万","view":"4.0 亿","danmaku":"399.7 万","coin":"129.2 万","score":9.4,"des":"时间为2138年。曾卷起一大风潮的虚拟现实体感型网络游戏《YGGDRASIL》即将迎来停服。玩家飞鼠在曾经以同伴和荣华自傲的根据地纳萨力克地下大坟墓，独自一人安静等待着那一刻。\n但是，不料发生了“过了..."},{"title":"路人超能100 第一次灵能咨询所员工旅游～舒缓心灵的疗愈之旅~（OVA2）","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/1271324d51634b68980704731987724a1afc60aa.jpg@220w_280h.webp","totalCount":"全1话","id":28222715,"follow":"318.8 万","view":"520.7 万","danmaku":"3.6 万","coin":"4.6 万","score":9.8,"des":"由原作ONE老师担任原案的完全新作OVA！「灵能咨询所」一行人，龙套与灵幻、小酒窝以及新同伴芹泽的目的地，正是缟马县深山中鲜为人知的温泉·疣神温泉。因为灵幻接受了旅馆老板娘的委托，「弄清温泉的恐怖传闻..."},{"title":"少女终末旅行","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1431ca5bb2f7143062e3df8f21b8448cf8cccc13.jpg@220w_280h.webp","totalCount":"全12话","id":6463,"follow":"239.8 万","view":"3714.7 万","danmaku":"100.7 万","coin":"37.2 万","score":9.8,"des":"本作舞台在人类繁华的文明迎来终结的很久以后，人类基本灭绝，甚至生物都不再存在的末日世界。复杂够高的都市成为迷宫般的废墟，得不到维护的机械渐渐停止运转。连何时终结了，何时开始终结的思考都不复存在的这个世..."},{"title":"齐木楠雄的灾难（日播&精选版）","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/eb4f17335f48951945fb9da47e6ee0bc65fa2fbb.jpg@220w_280h.webp","totalCount":"全120话","id":5070,"follow":"187.0 万","view":"2.3 亿","danmaku":"130.7 万","coin":"32.7 万","score":9.6,"des":"高中生·齐木楠雄是超能力者。心灵感应、念动力、透视、预知、瞬间移动、千里眼等，不论任何事情都自由自在。但这任谁都羡慕不已的最强能力，实际上对于本人而言是引来灾难的不幸元凶。因此，他在别人面前封印了超能..."},{"title":"比宇宙更远的地方","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/c9eca3cbc386c63b27461074b8b218898cb7440e.jpg@220w_280h.webp","totalCount":"全13话","id":13032,"follow":"156.0 万","view":"2298.0 万","danmaku":"45.9 万","coin":"23.9 万","score":9.8,"des":"无论何时，我们的第一步总是从好奇心开始。\n不曾看过的风景，不曾听过的声音，不曾闻过的味道，不曾摸过的质感，不曾尝过的食物，以及不曾感受过的澎湃。\n为了重拾不知何时忘却的记忆碎片和不知何时舍弃的感动的旅..."},{"title":"OVERLORD","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/b8e72ea69e57e0b7ac85d8b4d366554fd866df1a.jpg@220w_280h.webp","totalCount":"全13话","id":2576,"follow":"626.2 万","view":"4.1 亿","danmaku":"385.2 万","coin":"84.4 万","score":9.6,"des":"作品主要讲述了某天，一款曾经掀起过大热潮的VRMMORPG「YGGDRASIL」停止了运营。游戏原本会停止一切服务，但过了结束时间后，玩家们却发现不能退出，NPC也产生了各自的思想。现实世界中喜爱电玩..."},{"title":"路人超能100 II(灵能百分百 第二季)","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/216e1bdaf88244215a13b1154116805ee9adbe07.png@220w_280h.webp","totalCount":"全13话","id":4762734,"follow":"284.9 万","view":"1.0 亿","danmaku":"97.8 万","coin":"56.1 万","score":9.9,"des":"当有什么东西达到“100”的时候，就会爆发的少年·路人（龙套）。外表极其普通——不如说是不起眼。不擅长迎合气氛的他，实际上拥有着强力的超能力。盯上了这样的他的能力，而接连现身的伪灵能力者以及宗教团体、..."},{"title":"多罗罗","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3fc16a667502cbff226e585eb660a96a20c7458c.png@220w_280h.webp","totalCount":"全24话","id":4312482,"follow":"452.1 万","view":"1.8 亿","danmaku":"143.9 万","coin":"73.9 万","score":9.4,"des":"他们向着命运抗争，在那尽头等待他们的是人心，还是业障。\n时值乱世。\n名为景光的醍醐将军，向某个寺庙殿堂中的12尊魔神像祈求早日结束战乱。\n作为代价，他的嫡子在出生时就失去了身体的某些部位，被丢弃在河流..."},{"title":"魔法少女小圆","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/7fcaa0e98b561611538ae4deba7949cec4ca39a8.png@220w_280h.webp","totalCount":"全12话","id":2539,"follow":"218.7 万","view":"4199.0 万","danmaku":"201.5 万","coin":"20.0 万","score":9.8,"des":"就读初中二年级的鹿目圆，过着平凡幸福的生活。神秘转学生晓美焰的出现，开始让小圆的命运有了巨大转变。某日一只名为丘比的神秘生物，希望小圆能够与它签订魔法契约，成为“魔法少女”以对抗邪恶的魔女保护世界。正..."}]},"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"http://rebp38war.bkt.clouddn.com/img/v2-e3059da37ed8f8f281476c133380e406_r.jpg","excerpt":"","more":"<blockquote>\n<p>开发方法是一种方法学，主要是针对系统开发阶段中的设计和编码进行实现。</p>\n</blockquote>\n<h2 id=\"原型法\"><a href=\"#原型法\" class=\"headerlink\" title=\"原型法\"></a>原型法</h2><p>适用于<strong>需求不明确</strong>的场景,对用户的需求动态响应，逐步纳入<br></p>\n<p><strong>按功能分类</strong></p>\n<ol>\n<li>水平模型 （界面）</li>\n<li>垂直模型 （复杂算法）</li>\n</ol>\n<p><strong>按最终结果分类</strong></p>\n<ol>\n<li>抛弃型原型 （系统实现以后就放弃不用了：提裤子走人）</li>\n<li>进化型原型 （从目标系统的一个或几个基本需求出发，通过修改和追加功能，逐渐丰富，演化成最终系统：迭代）</li>\n</ol>\n<h2 id=\"结构化方法\"><a href=\"#结构化方法\" class=\"headerlink\" title=\"结构化方法\"></a>结构化方法</h2><p><img src=\"http://rebp38war.bkt.clouddn.com/img/jiegou.png\"></p>\n<p>特点：强调系统开发过程的<strong>整体性</strong>和<strong>全局性</strong>，系统开发过程<strong>工程化</strong>，文档<strong>标准化</strong></p>\n<h2 id=\"面向对象方法\"><a href=\"#面向对象方法\" class=\"headerlink\" title=\"面向对象方法\"></a>面向对象方法</h2><p><img src=\"http://rebp38war.bkt.clouddn.com/img/20220720105445.png\"></p>\n<h2 id=\"面向服务方法\"><a href=\"#面向服务方法\" class=\"headerlink\" title=\"面向服务方法\"></a>面向服务方法</h2><p>以<strong>粗粒度</strong>、<strong>松散耦合</strong>的体统功能为核心，强调系统功能的<strong>标准化</strong>和<strong>构件化</strong>，加强了系统的<strong>灵活性</strong>、<strong>可复用性</strong>和<strong>可演化性</strong><br><br>面向服务方法是在面向对象方法的基础上扩展的构建系统的思想和方法。面向服务方法关注的是企业业务，它直接映射到业务，强调IT与业务的对齐，以服务为核心元素来封装企业的业务流程和企业已有应用系统。服务的粒度更大，更加匹配企业级应用中的业务，可以实现更高级别的重用。但目前存在相关标准未统一、应用案例较少等一些问题。</p>\n<h2 id=\"各类系统开发方法的比较\"><a href=\"#各类系统开发方法的比较\" class=\"headerlink\" title=\"各类系统开发方法的比较\"></a>各类系统开发方法的比较</h2><table>\n<thead>\n<tr>\n<th align=\"center\">名称</th>\n<th align=\"center\">概述</th>\n<th align=\"center\">优点</th>\n<th align=\"center\">缺点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">原型法</td>\n<td align=\"center\">对用户的需求动态响应，逐步纳入</td>\n<td align=\"center\">系统开发循序渐进，反复修改，确保较好的用户满意度；</td>\n<td align=\"center\">不适合大规模系统的开发；开发过程管理要求高，整个开发过程要经过“修改—评价—再修改”的多次反复；用户过早看到系统原型，误认为系统就是这个模样，易使用户失去信心；开发人员易将原型取代系统分析；缺乏规范化的文档资料</td>\n</tr>\n<tr>\n<td align=\"center\">结构化方法</td>\n<td align=\"center\">系统开发过程的整体性和全局性，系统开发过程工程化，文档标准化</td>\n<td align=\"center\">体现了逐层分解、逐步求精的原则，有严格的规则</td>\n<td align=\"center\">难于检验分析结果的正确与否；对需求变更的适应能力很差；系统设计人员对分析结果的理解存在障碍</td>\n</tr>\n<tr>\n<td align=\"center\">面向对象方法</td>\n<td align=\"center\">以对象（对象=数据＋算法）为中心，实现了对数据和算法的封装和继承</td>\n<td align=\"center\">加强了对应用领域的理解，改进了沟通和交流；适应需求变化的能力较强；支持分析和设计结果的复用</td>\n<td align=\"center\">纯技术导向，存在与业务的鸿沟；复杂度高，抽象程度低，难以实现大规模和高层次的重用</td>\n</tr>\n<tr>\n<td align=\"center\">面向服务方法</td>\n<td align=\"center\">以服务封装业务流程和应用系统</td>\n<td align=\"center\">业务驱动技术，以开放标准实现应用系统之间服务的相互访问，乃至复合应用的组装，实现了更高级别重用</td>\n<td align=\"center\">是一个较新的领域，许多研究和实践还有待进一步深入，相关标准尚未统一</td>\n</tr>\n</tbody></table>\n"},{"title":"重装云服务器之Hexo迁移","date":"2022-07-22T08:04:22.000Z","cover":"http://rebp38war.bkt.clouddn.com/img/v2-0ae647a31329c6851d322f313b75ffaf_r.jpg","_content":"\n\n\n\n>  接着上次MySql配置完毕，接下来把我们之前的hexo博客重新发布上来\n\n## 一、服务器环境搭建\n\n首先安装一些常用工具\n\n```shell\n[root@ls_patrick ~]# yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel\n```\n\n![](http://rebp38war.bkt.clouddn.com/img/20220722145908.png)\n\n刷刷刷.........一会就全部安装完成了，我们在安装git 安装的命令如下\n\n```shell\n[root@ls_patrick ~]# yum install -y git\n```\n\n安装完成后用git --version查看一下版本，能查到证明安装成功了。\n\n```shell\n[root@ls_patrick ~]# git --version\ngit version 1.8.3.1\n```\n\n接下来创建git使用的用户。\n\n```shell\n[root@ls_patrick ~]# useradd HelloWorldKing1\n[root@ls_patrick ~]# passwd HelloWorldKing1 // 设置密码\nChanging password for user HelloWorldKing1.\nNew password:\nRetype new password:\npasswd: all authentication tokens updated successfully.\n[root@ls_patrick ~]# chmod 740 /etc/sudoers // 设置权限\n```\n[root@ls_patrick ~]# vim /etc/sudoers // 修改root权限 按i直接进入编辑状态。找个风水宝地（新的一行就可以）输入下面的命令\n```\nHelloWorldKing1 ALL=(ALL)    ALL\n```\n\n紧接着。\n\n```shell\n[root@ls_patrick ~]# chmod 600 /etc/sudoers //改回权限\n[root@ls_patrick ~]# mkdir /home/hexo\n[root@ls_patrick ~]# chown HelloWorldKing1:HelloWorldKing1 -R /home/hexo\n```\n完成后正式开始安装Nginx\n```shell\n[root@ls_patrick ~]# yum install -y nginx  //安装nginx\n[root@ls_patrick ~]# systemctl start nginx.service  //启动Nginx服务\n```\n<font color=red>如果启动时，发生以下错误</font>\n\n```shell\nJob for nginx.service failed because the control process exited with error code. See \"systemctl status nginx.service\" and \"journalctl -xe\" for details.\n```\n分析：端口被占用了\n\n\n```shell\n[root@ls_patrick ~]# netstat -tnlp\nActive Internet connections (only servers)\nProto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name\ntcp        0      0 0.0.0.0:3306            0.0.0.0:*               LISTEN      18727/mysqld\ntcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1519/sshd\ntcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      1370/master\ntcp6       0      0 :::781                  :::*                    LISTEN      2477/./bcm-agent\ntcp6       0      0 :::80                   :::*                    LISTEN      950/httpd\ntcp6       0      0 :::22                   :::*                    LISTEN      1519/sshd\ntcp6       0      0 ::1:25                  :::*                    LISTEN      1370/master\n```\n\n想起了是服务器镜像是LAMP 。可能是apache的80端口和nginx的80端口冲突了\n\n进入apache的 conf目录修改端口\n\n```shell\n[root@ls_patrick conf]# vim httpd.conf\n```\n\n将80端口改为8080  :wq 保存退出\n\n```shell\n Listen 8080\n```\n\n进入bin目录 重启apache\n\n```shell\n[root@ls_patrick bin]# apachectl restart\n```\n\n 再次启动nginx\n\n```shell\n[root@ls_patrick conf]# systemctl start nginx.service\n```\n\n如果正常启动，没有任何报错，说明Nginx配置好了。 **建立git仓库**\n\n```shell\n[root@ls_patrick conf]# su root\n[root@ls_patrick conf]# cd /home/HelloWorldKing1\n[root@ls_patrick HelloWorldKing1]# git init --bare blog.git  //创建Git仓库\n[root@ls_patrick HelloWorldKing1]# chown HelloWorldKing1:HelloWorldKing1 -R blog.git  //授予Git仓库权限\n```\n\n同步网站根目录\n\n```shell\n[root@ls_patrick HelloWorldKing1]# cd blog.git/hooks/\n\n[root@ls_patrick hooks]# vim post-receive\n// 把下面的内容拷贝进去\n#!/bin/sh\ngit --work-tree=/home/hexo  --git-dir=/home/HelloWorldKing1/blog.git checkout -f\n```\n\n再次修改权限，\n\n```shell\nchmod +x post-receive\n```\n\n这样就已经把服务器端的环境基本配置好了。\n\n\n\n## 二、上传博客到服务器\n\n接下来把博客重新上传到云服务器\n\n有了文章我们就可以把博客上传到云服务器了。但是要想用Git把代码传到服务器，是需要密钥的。这就就直接创建一下密钥。在本地电脑打开`powerShell`，创建密钥。创建密钥的命令是 `ssh-keygen -t rsa` 如果你已经有了密钥就不用再次创建了，特别是公司已经有很多git管理的项目时，否则需要都进行重新配置。我这里是已经有密钥了。 到服务端创建一个存放密钥的文件夹。\n\n```\nsu HelloWorldKing1\nmkdir ~/.ssh   //创建存放密钥的文件夹\nvim ~/.ssh/authorized_keys  //写入密钥\n```\n\n来到自己的客户端，找到`C:\\Users\\Administrator\\.ssh` 打开`id_rsa`文件，直接复制全部，就可以完成了。 这样我们就可以通过HelloWorldKing1这个用户向服务器提交代码了，我们要测试一下，看看是否配置的可以连接上 **本地测试** 打开本地主机的`powerShell`，然后用ssh进行连接。\n\n```\nssh -v HelloWorldKing1@180.76.183.66 //服务器ip\n```\n\n<font color=red>发生错误WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!</font>\n\n\n\n<img src=\"http://rebp38war.bkt.clouddn.com/img/20220722155039.png\" style=\"zoom:67%;\" />\n\n是因为本地记录了上次连接信息；需要这这段删掉即可\n\n![](http://rebp38war.bkt.clouddn.com/img/20220722155006.png)\n\n\n\n修改本地的hexo配置文件`_config.yml`,打开文件后，拖动到最后边，输入下面的配置\n\n```\ndeploy:\n  type: git\n  repository: HelloWorldKing1@180.76.183.66:/home/HelloWorldKing1/blog.git\n  branch: master\nnpm install --save hexo-deployer-git\n```\n\n安装完成后，输入下面的命令\n\n```\nhexo clean\nhexo g -d\n```\n\n如果一切正常，就可以直接传到服务器上，然后输入网址`http://120.48.107.220/`就可以完成博客的浏览了，我这里没有使用域名，如果你有域名，只要把域名解析到这个网址就可以了。\n\n![](http://rebp38war.bkt.clouddn.com/img/20220722155619.png)\n","source":"_posts/重装云服务器之Hexo迁移.md","raw":"---\ntitle: 重装云服务器之Hexo迁移\ndate: 2022-07-22 16:04:22\ntags: \n - 云\n - Hexo\ncategories: Hexo\ncover: \n---\n\n\n\n\n>  接着上次MySql配置完毕，接下来把我们之前的hexo博客重新发布上来\n\n## 一、服务器环境搭建\n\n首先安装一些常用工具\n\n```shell\n[root@ls_patrick ~]# yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel\n```\n\n![](http://rebp38war.bkt.clouddn.com/img/20220722145908.png)\n\n刷刷刷.........一会就全部安装完成了，我们在安装git 安装的命令如下\n\n```shell\n[root@ls_patrick ~]# yum install -y git\n```\n\n安装完成后用git --version查看一下版本，能查到证明安装成功了。\n\n```shell\n[root@ls_patrick ~]# git --version\ngit version 1.8.3.1\n```\n\n接下来创建git使用的用户。\n\n```shell\n[root@ls_patrick ~]# useradd HelloWorldKing1\n[root@ls_patrick ~]# passwd HelloWorldKing1 // 设置密码\nChanging password for user HelloWorldKing1.\nNew password:\nRetype new password:\npasswd: all authentication tokens updated successfully.\n[root@ls_patrick ~]# chmod 740 /etc/sudoers // 设置权限\n```\n[root@ls_patrick ~]# vim /etc/sudoers // 修改root权限 按i直接进入编辑状态。找个风水宝地（新的一行就可以）输入下面的命令\n```\nHelloWorldKing1 ALL=(ALL)    ALL\n```\n\n紧接着。\n\n```shell\n[root@ls_patrick ~]# chmod 600 /etc/sudoers //改回权限\n[root@ls_patrick ~]# mkdir /home/hexo\n[root@ls_patrick ~]# chown HelloWorldKing1:HelloWorldKing1 -R /home/hexo\n```\n完成后正式开始安装Nginx\n```shell\n[root@ls_patrick ~]# yum install -y nginx  //安装nginx\n[root@ls_patrick ~]# systemctl start nginx.service  //启动Nginx服务\n```\n<font color=red>如果启动时，发生以下错误</font>\n\n```shell\nJob for nginx.service failed because the control process exited with error code. See \"systemctl status nginx.service\" and \"journalctl -xe\" for details.\n```\n分析：端口被占用了\n\n\n```shell\n[root@ls_patrick ~]# netstat -tnlp\nActive Internet connections (only servers)\nProto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name\ntcp        0      0 0.0.0.0:3306            0.0.0.0:*               LISTEN      18727/mysqld\ntcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1519/sshd\ntcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      1370/master\ntcp6       0      0 :::781                  :::*                    LISTEN      2477/./bcm-agent\ntcp6       0      0 :::80                   :::*                    LISTEN      950/httpd\ntcp6       0      0 :::22                   :::*                    LISTEN      1519/sshd\ntcp6       0      0 ::1:25                  :::*                    LISTEN      1370/master\n```\n\n想起了是服务器镜像是LAMP 。可能是apache的80端口和nginx的80端口冲突了\n\n进入apache的 conf目录修改端口\n\n```shell\n[root@ls_patrick conf]# vim httpd.conf\n```\n\n将80端口改为8080  :wq 保存退出\n\n```shell\n Listen 8080\n```\n\n进入bin目录 重启apache\n\n```shell\n[root@ls_patrick bin]# apachectl restart\n```\n\n 再次启动nginx\n\n```shell\n[root@ls_patrick conf]# systemctl start nginx.service\n```\n\n如果正常启动，没有任何报错，说明Nginx配置好了。 **建立git仓库**\n\n```shell\n[root@ls_patrick conf]# su root\n[root@ls_patrick conf]# cd /home/HelloWorldKing1\n[root@ls_patrick HelloWorldKing1]# git init --bare blog.git  //创建Git仓库\n[root@ls_patrick HelloWorldKing1]# chown HelloWorldKing1:HelloWorldKing1 -R blog.git  //授予Git仓库权限\n```\n\n同步网站根目录\n\n```shell\n[root@ls_patrick HelloWorldKing1]# cd blog.git/hooks/\n\n[root@ls_patrick hooks]# vim post-receive\n// 把下面的内容拷贝进去\n#!/bin/sh\ngit --work-tree=/home/hexo  --git-dir=/home/HelloWorldKing1/blog.git checkout -f\n```\n\n再次修改权限，\n\n```shell\nchmod +x post-receive\n```\n\n这样就已经把服务器端的环境基本配置好了。\n\n\n\n## 二、上传博客到服务器\n\n接下来把博客重新上传到云服务器\n\n有了文章我们就可以把博客上传到云服务器了。但是要想用Git把代码传到服务器，是需要密钥的。这就就直接创建一下密钥。在本地电脑打开`powerShell`，创建密钥。创建密钥的命令是 `ssh-keygen -t rsa` 如果你已经有了密钥就不用再次创建了，特别是公司已经有很多git管理的项目时，否则需要都进行重新配置。我这里是已经有密钥了。 到服务端创建一个存放密钥的文件夹。\n\n```\nsu HelloWorldKing1\nmkdir ~/.ssh   //创建存放密钥的文件夹\nvim ~/.ssh/authorized_keys  //写入密钥\n```\n\n来到自己的客户端，找到`C:\\Users\\Administrator\\.ssh` 打开`id_rsa`文件，直接复制全部，就可以完成了。 这样我们就可以通过HelloWorldKing1这个用户向服务器提交代码了，我们要测试一下，看看是否配置的可以连接上 **本地测试** 打开本地主机的`powerShell`，然后用ssh进行连接。\n\n```\nssh -v HelloWorldKing1@180.76.183.66 //服务器ip\n```\n\n<font color=red>发生错误WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!</font>\n\n\n\n<img src=\"http://rebp38war.bkt.clouddn.com/img/20220722155039.png\" style=\"zoom:67%;\" />\n\n是因为本地记录了上次连接信息；需要这这段删掉即可\n\n![](http://rebp38war.bkt.clouddn.com/img/20220722155006.png)\n\n\n\n修改本地的hexo配置文件`_config.yml`,打开文件后，拖动到最后边，输入下面的配置\n\n```\ndeploy:\n  type: git\n  repository: HelloWorldKing1@180.76.183.66:/home/HelloWorldKing1/blog.git\n  branch: master\nnpm install --save hexo-deployer-git\n```\n\n安装完成后，输入下面的命令\n\n```\nhexo clean\nhexo g -d\n```\n\n如果一切正常，就可以直接传到服务器上，然后输入网址`http://120.48.107.220/`就可以完成博客的浏览了，我这里没有使用域名，如果你有域名，只要把域名解析到这个网址就可以了。\n\n![](http://rebp38war.bkt.clouddn.com/img/20220722155619.png)\n","slug":"重装云服务器之Hexo迁移","published":1,"updated":"2022-07-22T08:31:12.792Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5w7e749000rigvu3ndv9wai","content":"<blockquote>\n<p> 接着上次MySql配置完毕，接下来把我们之前的hexo博客重新发布上来</p>\n</blockquote>\n<h2 id=\"一、服务器环境搭建\"><a href=\"#一、服务器环境搭建\" class=\"headerlink\" title=\"一、服务器环境搭建\"></a>一、服务器环境搭建</h2><p>首先安装一些常用工具</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@ls_patrick ~]# yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"http://rebp38war.bkt.clouddn.com/img/20220722145908.png\"></p>\n<p>刷刷刷………一会就全部安装完成了，我们在安装git 安装的命令如下</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@ls_patrick ~]# yum install -y git</span><br></pre></td></tr></table></figure>\n\n<p>安装完成后用git –version查看一下版本，能查到证明安装成功了。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@ls_patrick ~]# git --version</span><br><span class=\"line\">git version 1.8.3.1</span><br></pre></td></tr></table></figure>\n\n<p>接下来创建git使用的用户。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@ls_patrick ~]# useradd HelloWorldKing1</span><br><span class=\"line\">[root@ls_patrick ~]# passwd HelloWorldKing1 // 设置密码</span><br><span class=\"line\">Changing password for user HelloWorldKing1.</span><br><span class=\"line\">New password:</span><br><span class=\"line\">Retype new password:</span><br><span class=\"line\">passwd: all authentication tokens updated successfully.</span><br><span class=\"line\">[root@ls_patrick ~]# chmod 740 /etc/sudoers // 设置权限</span><br></pre></td></tr></table></figure>\n<p>[root@ls_patrick ~]# vim /etc/sudoers // 修改root权限 按i直接进入编辑状态。找个风水宝地（新的一行就可以）输入下面的命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">HelloWorldKing1 ALL=(ALL)    ALL</span><br></pre></td></tr></table></figure>\n\n<p>紧接着。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@ls_patrick ~]# chmod 600 /etc/sudoers //改回权限</span><br><span class=\"line\">[root@ls_patrick ~]# mkdir /home/hexo</span><br><span class=\"line\">[root@ls_patrick ~]# chown HelloWorldKing1:HelloWorldKing1 -R /home/hexo</span><br></pre></td></tr></table></figure>\n<p>完成后正式开始安装Nginx</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@ls_patrick ~]# yum install -y nginx  //安装nginx</span><br><span class=\"line\">[root@ls_patrick ~]# systemctl start nginx.service  //启动Nginx服务</span><br></pre></td></tr></table></figure>\n<p><font color=\"red\">如果启动时，发生以下错误</font></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">Job for nginx.service failed because the control process exited with error code. See &quot;systemctl status nginx.service&quot; and &quot;journalctl -xe&quot; for details.</span><br></pre></td></tr></table></figure>\n<p>分析：端口被占用了</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@ls_patrick ~]# netstat -tnlp</span><br><span class=\"line\">Active Internet connections (only servers)</span><br><span class=\"line\">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name</span><br><span class=\"line\">tcp        0      0 0.0.0.0:3306            0.0.0.0:*               LISTEN      18727/mysqld</span><br><span class=\"line\">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1519/sshd</span><br><span class=\"line\">tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      1370/master</span><br><span class=\"line\">tcp6       0      0 :::781                  :::*                    LISTEN      2477/./bcm-agent</span><br><span class=\"line\">tcp6       0      0 :::80                   :::*                    LISTEN      950/httpd</span><br><span class=\"line\">tcp6       0      0 :::22                   :::*                    LISTEN      1519/sshd</span><br><span class=\"line\">tcp6       0      0 ::1:25                  :::*                    LISTEN      1370/master</span><br></pre></td></tr></table></figure>\n\n<p>想起了是服务器镜像是LAMP 。可能是apache的80端口和nginx的80端口冲突了</p>\n<p>进入apache的 conf目录修改端口</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@ls_patrick conf]# vim httpd.conf</span><br></pre></td></tr></table></figure>\n\n<p>将80端口改为8080  :wq 保存退出</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">Listen 8080</span><br></pre></td></tr></table></figure>\n\n<p>进入bin目录 重启apache</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@ls_patrick bin]# apachectl restart</span><br></pre></td></tr></table></figure>\n\n<p> 再次启动nginx</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@ls_patrick conf]# systemctl start nginx.service</span><br></pre></td></tr></table></figure>\n\n<p>如果正常启动，没有任何报错，说明Nginx配置好了。 <strong>建立git仓库</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@ls_patrick conf]# su root</span><br><span class=\"line\">[root@ls_patrick conf]# cd /home/HelloWorldKing1</span><br><span class=\"line\">[root@ls_patrick HelloWorldKing1]# git init --bare blog.git  //创建Git仓库</span><br><span class=\"line\">[root@ls_patrick HelloWorldKing1]# chown HelloWorldKing1:HelloWorldKing1 -R blog.git  //授予Git仓库权限</span><br></pre></td></tr></table></figure>\n\n<p>同步网站根目录</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@ls_patrick HelloWorldKing1]# cd blog.git/hooks/</span><br><span class=\"line\"></span><br><span class=\"line\">[root@ls_patrick hooks]# vim post-receive</span><br><span class=\"line\">// 把下面的内容拷贝进去</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/sh</span></span><br><span class=\"line\">git --work-tree=/home/hexo  --git-dir=/home/HelloWorldKing1/blog.git checkout -f</span><br></pre></td></tr></table></figure>\n\n<p>再次修改权限，</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">chmod +x post-receive</span><br></pre></td></tr></table></figure>\n\n<p>这样就已经把服务器端的环境基本配置好了。</p>\n<h2 id=\"二、上传博客到服务器\"><a href=\"#二、上传博客到服务器\" class=\"headerlink\" title=\"二、上传博客到服务器\"></a>二、上传博客到服务器</h2><p>接下来把博客重新上传到云服务器</p>\n<p>有了文章我们就可以把博客上传到云服务器了。但是要想用Git把代码传到服务器，是需要密钥的。这就就直接创建一下密钥。在本地电脑打开<code>powerShell</code>，创建密钥。创建密钥的命令是 <code>ssh-keygen -t rsa</code> 如果你已经有了密钥就不用再次创建了，特别是公司已经有很多git管理的项目时，否则需要都进行重新配置。我这里是已经有密钥了。 到服务端创建一个存放密钥的文件夹。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">su HelloWorldKing1</span><br><span class=\"line\">mkdir ~/.ssh   //创建存放密钥的文件夹</span><br><span class=\"line\">vim ~/.ssh/authorized_keys  //写入密钥</span><br></pre></td></tr></table></figure>\n\n<p>来到自己的客户端，找到<code>C:\\Users\\Administrator\\.ssh</code> 打开<code>id_rsa</code>文件，直接复制全部，就可以完成了。 这样我们就可以通过HelloWorldKing1这个用户向服务器提交代码了，我们要测试一下，看看是否配置的可以连接上 <strong>本地测试</strong> 打开本地主机的<code>powerShell</code>，然后用ssh进行连接。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh -v HelloWorldKing1@180.76.183.66 //服务器ip</span><br></pre></td></tr></table></figure>\n\n<p><font color=\"red\">发生错误WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!</font></p>\n<img src=\"http://rebp38war.bkt.clouddn.com/img/20220722155039.png\" style=\"zoom:67%;\">\n\n<p>是因为本地记录了上次连接信息；需要这这段删掉即可</p>\n<p><img src=\"http://rebp38war.bkt.clouddn.com/img/20220722155006.png\"></p>\n<p>修改本地的hexo配置文件<code>_config.yml</code>,打开文件后，拖动到最后边，输入下面的配置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repository: HelloWorldKing1@180.76.183.66:/home/HelloWorldKing1/blog.git</span><br><span class=\"line\">  branch: master</span><br><span class=\"line\">npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure>\n\n<p>安装完成后，输入下面的命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br><span class=\"line\">hexo g -d</span><br></pre></td></tr></table></figure>\n\n<p>如果一切正常，就可以直接传到服务器上，然后输入网址<code>http://120.48.107.220/</code>就可以完成博客的浏览了，我这里没有使用域名，如果你有域名，只要把域名解析到这个网址就可以了。</p>\n<p><img src=\"http://rebp38war.bkt.clouddn.com/img/20220722155619.png\"></p>\n","site":{"data":{"bangumis":{"wantWatch":[],"watching":[{"title":"凡人修仙传","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/70d11dfab23a3ee81ccf64f18efa139416a633ff.jpg@220w_280h.webp","totalCount":"未完结","id":28223043,"follow":"615.7 万","view":"8.9 亿","danmaku":"490.9 万","coin":"1186.9 万","score":9.7,"des":"看机智的凡人小子韩立如何稳健发展、步步为营，战魔道、夺至宝、驰骋星海、快意恩仇，成为纵横三界的强者。他日仙界重相逢，一声道友尽沧桑。..."},{"title":"恋爱游戏世界对路人角色很不友好","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/c9723d8c77d881a8debba2852d580e97826b43d0.png@220w_280h.webp","totalCount":"全12话","id":28237300,"follow":"151.2 万","view":"5120.4 万","danmaku":"40.6 万","coin":"24.5 万","score":9.1,"des":"从现代日本转生到“恋爱游戏”世界的里昂，发现这里女尊男卑，对男性很不友好。身为路人角色的他，为了摆脱自己因地位低下而被肆意决定的人生，决定活用从游戏中得到的知识，保持路人角色的身份，取得“失落物品”来..."},{"title":"魔法纪录 魔法少女小圆外传 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/9eef1df9ab157be52d2c4d70d3500442f00cafc3.png@220w_280h.webp","totalCount":"全12话","id":28234642,"follow":"237.1 万","view":"907.6 万","danmaku":"5.0 万","coin":"4.9 万","score":7.7,"des":"愿望的代价，究竟是希望还是绝望——。"},{"title":"小林家的龙女仆 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/847e9dbb6876fb37a30199a5c88910704976d45b.png@220w_280h.webp","totalCount":"全13话","id":28234613,"follow":"855.7 万","view":"1.1 亿","danmaku":"49.0 万","coin":"69.0 万","score":9.6,"des":"那位不可思议的龙女仆再度登场！\n因为各种奇妙的原因而作为小林家的女仆而工作中的龙·托尔。\n偶尔（胡说，是经常）给亲爱的小林添麻烦，总算是融入了人类社会，成为了一个完美的（骗人，也就还行）女仆。\n同样是..."},{"title":"国王排名","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/376d7e69a667bcb1c0b934a4e35e07e7fa23110b.png@220w_280h.webp","totalCount":"全23话","id":28235154,"follow":"927.7 万","view":"4.8 亿","danmaku":"250.1 万","coin":"260.9 万","score":7,"des":"国家的丰饶、麾下勇者的数量、\n以及国王本人如何像勇者一般强大，\n这些要素的综合排名，便是所谓的“国王排名”。\n主人公波吉是国王排名第七名的伯斯王治下王国的第一王子。\n但是波吉却生来又聋又哑，贫弱到挥不..."},{"title":"阿松 第三季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0212baa8898d0c819c7fb84015e95b8fca621435.png@220w_280h.webp","totalCount":"全25话","id":28229892,"follow":"67.6 万","view":"938.0 万","danmaku":"13.0 万","coin":"5.4 万","score":9.6,"des":"日本最有名的六胞胎的传说，第三次开幕！！这次会有怎样意想不到的新展开！？..."},{"title":"命运-冠位指定 冠位时间神殿所罗门","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0e094b798388da19a4feffa6a6dabc1dc1dc90cd.jpg@220w_280h.webp","totalCount":"全1话","id":28236225,"follow":"525.5 万","view":"1220.0 万","danmaku":"8.9 万","coin":"15.1 万","score":8.5,"des":"在经过七个特异点的大战后，\n人理存续保障机关迦勒底，终于到达了圣杯探索的最终地点——终局特异点 冠位时间神殿所罗门。\n他们要击败身为罪魁祸首的魔术王所罗门，夺回未来。\n在开战的前一刻，一行人各自度过了..."},{"title":"JOJO的奇妙冒险 星尘远征军","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/47c0108259355d6d2c517ed97f6b90fb777f844f.png@220w_280h.webp","totalCount":"全24话","id":28223481,"follow":"444.2 万","view":"1.5 亿","danmaku":"463.4 万","coin":"45.7 万","score":9.8,"des":"时为1987年，乔瑟夫·乔斯达与“柱之男”们之间的死战后过了50年……乔瑟夫为了为了帮助“被恶灵附身了”的外孙子·空条承太郎而来到了日本。原来那并不是恶灵而是幽波纹（替身）。替身突然出现的原因在于，从..."},{"title":"JOJO的奇妙冒险 星尘远征军 埃及篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f6709b76e88f50aa132d1e09e2d8de9663a09b3e.png@220w_280h.webp","totalCount":"全24话","id":28223483,"follow":"421.9 万","view":"1.3 亿","danmaku":"468.7 万","coin":"44.3 万","score":9.9,"des":"在乔斯达家的宿敌·迪奥（DIO）复活的影响下，一位年轻人——空条承太郎，得到了名为“幽波纹（替身）”的能力。为了拯救因迪奥的诅咒而倒下的母亲荷莉，空条承太郎与外祖父·乔瑟夫以及伙伴们，一起为了打倒迪奥..."},{"title":"JOJO的奇妙冒险 不灭钻石","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/6a04c87e990ab74cd8d555ef45a863de0993b161.png@220w_280h.webp","totalCount":"全39话","id":140552,"follow":"302.3 万","view":"2.1 亿","danmaku":"813.8 万","coin":"55.9 万","score":9.8,"des":"在埃及与宿敌DIO的死斗之后过了11年。1999年，空条承太郎为了与祖父乔瑟夫·乔斯达的私生子东方仗助见面，而来到了日本M县S市杜王町。但，仗助却持有与承太郎相同的特殊能力“替身”。之后，以承太郎的来..."},{"title":"命运-冠位嘉年华","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/c660976f4502a544d990a882ae62194b57753a71.png@220w_280h.webp","totalCount":"全2话","id":28234639,"follow":"479.8 万","view":"862.4 万","danmaku":"4.1 万","coin":"9.1 万","score":9.8,"des":"一起庆祝吧！为了这奇迹般的嘉年华！"},{"title":"伍六七","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/b69e26d9e50514f3fa99eac9ab5aabf2a6e28c88.jpg@220w_280h.webp","totalCount":"全13话","id":6360,"follow":"585.8 万","view":"3.3 亿","danmaku":"227.1 万","coin":"191.8 万","score":9.8,"des":"在某个小岛上，有一个可以伪装成任何东西的廉价刺客，名叫伍六七。平时看上去是个理发师，其实背地里却做着刺客生意。热爱理发事业，喜欢给人剪头发，善用剪刀——剪刀也是他的刺杀武器。由于初入刺客行当，行情十分..."},{"title":"命运-冠位指定 -月光／失落之室-","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3fa5fd2b7afae827b0bf150d7f0cbfc54eda1ff2.png@220w_280h.webp","totalCount":"全1话","id":28234950,"follow":"483.3 万","view":"551.2 万","danmaku":9696,"coin":"2.9 万","score":9.5,"des":"失落之室——。\n这是一个可以看到被夺去亦或是遗失之物的地方。\n这是位于迦勒底被遗忘的角落，不属于任何人的地方。..."},{"title":"致不灭的你","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/1ae94fbb35d8e23bb84926b694509f8b057f96e6.png@220w_280h.webp","totalCount":"全20话","id":28233896,"follow":"476.3 万","view":"1.3 亿","danmaku":"140.1 万","coin":"95.0 万","score":9.6,"des":"本剧讲述了一个情节跌宕、场面宏大的奇幻故事，通过拥有不灭之身的主人公“不死”来探索人生哲理。\n不死起初是一个被投放到人世间的“球”。\n\n它具有“幻化为刺激源形态的能力”和“死后重生的能力”。\n\n先后从..."},{"title":"来自新世界","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/aaa60f9cb17fb4a38df464f1064ca9623e0769cc.jpg@220w_280h.webp","totalCount":"全25话","id":1598,"follow":"115.9 万","view":"1540.9 万","danmaku":"76.3 万","coin":"5.7 万","score":9.5,"des":"1000年后的日本，孩子们不断地消失，只存在想象中的恐怖动物与人类展开殊死战争。反乌托邦式的未来超级社会“新世界”，是口吐真言凭藉“咒力”就能移动物体的人类，与有着等同于普通人智力的生物“妖鼠”共存的..."},{"title":"转生成蜘蛛又怎样！","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f0796e37abac25ba2aa9f23120646aaa9a3d5ea7.png@220w_280h.webp","totalCount":"全24话","id":28231809,"follow":"600.0 万","view":"3.7 亿","danmaku":"190.3 万","coin":"164.6 万","score":7.8,"des":"曾经是一名女高中生的“我”，突然转生变成了幻想世界中的蜘蛛魔物。\n而且，出生地点还是各种凶恶魔物所盘踞的大迷宫。\n“我”以人类的智慧和非同寻常的积极心态为武器，使用蜘蛛的丝网以及陷阱打倒比自己等级高得..."},{"title":"装甲重拳/MEGALOBOX 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/e14dc4a935397fc074c7a12d9520225615209025.png@220w_280h.webp","totalCount":"全13话","id":28233916,"follow":"244.9 万","view":"3435.4 万","danmaku":"19.7 万","coin":"53.1 万","score":9.9,"des":"再一次，为梦想而活——\n\n将肉体与“装甲技术”融合的究极格斗技“装甲拳击”。\n在决出其顶点之人的大会“重拳之巅”上，身穿装甲用自己肉身挑战一切的拳击手“JOE”。\n\n从最下层的比赛开始仅仅花了三个月就..."},{"title":"机动战士高达SEED HD","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/855c88677267d707ebfe4040403692ff2c0938f0.png@220w_280h.webp","totalCount":"全48话","id":497,"follow":"54.8 万","view":"4044.4 万","danmaku":"114.4 万","coin":"6.0 万","score":9.6,"des":"《机动战士高达SEED》是高达系列在2002年至2003年度放映的动画。续作为《机动战士高达SEED Destiny》在2004年播放。因各具魅力的角色，明星云集的声优阵容和高度商业化的宣传而受到较低..."},{"title":"夏目友人帐 唤石者与怪异的访客","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6cf43708b779cde84ad285ff4e3a080de98df0af.png@220w_280h.webp","totalCount":"全1话","id":28234316,"follow":"567.1 万","view":"1374.8 万","danmaku":"18.1 万","coin":"17.9 万","score":9.9,"des":"本作由【唤石者】与【怪异的访客】两个人气短篇集锦而成。讲述生来便能看见各种妖怪的夏目，与自称保镖的猫咪老师一同邂逅的一系列温暖故事。\n【唤石者】一天夏目在森林中遇到一只小妖怪——密实。密实称自己肩负「..."},{"title":"Fate/Grand Order ‐First Order‐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/b75c55d209d156c8631f5ceb21e5c52c834dbb60.jpg@220w_280h.webp","totalCount":"全1话","id":5747,"follow":"250.9 万","view":"3329.7 万","danmaku":"76.7 万","coin":"10.7 万","score":8.3,"des":"【2016年12月31日bilibili独播】2015年。示巴所观测到的未来领域毫无前兆地消失。根据计算，发现——不，是证明了人类将于2017年灭绝。人理延续保障机构·迦勒底将“无法观测的领域”假定为..."},{"title":"伍六七之玄武国篇","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/00843865ea13702eccc4efd64c313fd4c8029c6b.jpg@220w_280h.webp","totalCount":"全10话","id":28232253,"follow":"999.4 万","view":"4.0 亿","danmaku":"177.7 万","coin":"385.3 万","score":9.8,"des":"为了保护小鸡岛居民和这里平静的生活，伍六七和他的伙伴大保和小飞开启了去往玄武国的冒险旅程，去寻找身世的真相和解救小岛的办法，等待他们的又将是更多的未知与奇遇。..."},{"title":"堀与宫村","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/039c4e0b14e27c7a9e5cce2f20a6efd3c8909401.png@220w_280h.webp","totalCount":"全13话","id":28231840,"follow":"695.2 万","view":"2.2 亿","danmaku":"242.1 万","coin":"361.4 万","score":9.8,"des":"不论是谁，都会有不想被人知道的一面。\n\n在学校中漂亮大方、成绩优秀的人气女生堀，私下却打扮土气、忙于家务和照顾弟弟。\n在学校中是阴暗宅男形象的宫村，生活中却是打扮时尚、带耳钉的帅气男生。\n因为一次特别..."},{"title":"奇蛋物语 / WONDER EGG PRIORITY","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/10e0bbc1047b2c45f0f881de334a6f3bfb42a3b6.png@220w_280h.webp","totalCount":"全12话","id":28231851,"follow":"254.9 万","view":"4686.8 万","danmaku":"47.6 万","coin":"65.5 万","score":9.7,"des":"14岁少女·大户爱在深夜散步的途中，\n随着神秘声音的指引，获得了一枚「蛋」。\n\n「如果想要改变世界的话」\n「那么就在现在做出选择」\n「请相信自己——」\n「打破这枚蛋——」\n\n而在打破「蛋」之后，等待着..."},{"title":"Re：从零开始的异世界生活 第二季 后半","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/4f3edbede7fc0bdb52842075cf8faaa1c5953eaa.png@220w_280h.webp","totalCount":"全12话","id":28232073,"follow":"849.9 万","view":"9308.1 万","danmaku":"108.1 万","coin":"230.1 万","score":9.9,"des":"我一定会拯救你。\n在打倒了魔女教大罪司教「怠惰」担当——培提其乌斯·罗曼尼康帝之后，菜月昴和爱蜜莉雅又得以重新开始。\n克服了艰难的诀别，两人终于和解，然而这只是新一轮风波的序幕。\n超乎想象的绝境危机，..."},{"title":"灰与幻想的格林姆迦尔","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/7fb4945f864e9e988212b7d20f206df2677053f8.jpg@220w_280h.webp","totalCount":"全12话","id":106512,"follow":"172.0 万","view":"2343.4 万","danmaku":"63.8 万","coin":"18.3 万","score":9.8,"des":"电视动画《灰与幻想的格林姆迦尔》改编自日本轻小说家十文字青原作白井锐利插画的同名轻小说。\n我们为什么要这么做…？\n哈尔希洛回过神来，才发现自己身处在黑暗当中，他完全不知道自己人在何处，也不明白这个地方..."},{"title":"龙与虎","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/144910805f172d16c5f544f43939a05d8ca20576.jpg@220w_280h.webp","totalCount":"全26话","id":1672,"follow":"336.9 万","view":"6671.9 万","danmaku":"511.9 万","coin":"61.5 万","score":9.7,"des":"樱花飞舞的四月，全新的高中二年级，新的班级……\n眼神凶恶的普通男孩——高须龙儿，遇上了众人害怕、凶暴残忍的“掌中老虎”逢坂大河，还知道了她不欲为人知的秘密。这就是龙虎相争爱与战斗的序幕。\n再加上总是笑..."},{"title":"机动战士高达 铁血的奥尔芬斯 第一季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/f84a80d731d0431c00903d8951fd66623d8237f7.png@220w_280h.webp","totalCount":"全25话","id":4310042,"follow":"62.4 万","view":"2318.6 万","danmaku":"52.2 万","coin":"5.4 万","score":9.5,"des":"主人公三日月·奥古斯，从所属的民间警备公司克律塞安保公司（下称CGS）那里，接受了对少女库德莉亚·蓝那·伯恩斯坦的护卫任务。但CGS受到了摘取反叛之芽的武力组织加拉尔霍恩的袭击，于是在把三日月当做诱饵..."},{"title":"机动战士高达00 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1d7a969e8f1045739c596de89a963e30475aff0e.jpg@220w_280h.webp","totalCount":"全25话","id":1193,"follow":"37.2 万","view":"2458.1 万","danmaku":"61.4 万","coin":"4.1 万","score":9.8,"des":"天人与联合国军的最终决战后过了四年。建立地球联邦政府的人类，为了追求更进一步的国家间之统合，以及人类意识的统一，在联合正规军之外，设立了独立治安维持部队“A-Laws”，目的为对所有危害联合的势力与主..."},{"title":"机动战士高达00","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/35b11bf59eb3fd12f0387951510a5d722d7435e5.jpg@220w_280h.webp","totalCount":"全25话","id":1192,"follow":"62.1 万","view":"2465.5 万","danmaku":"53.6 万","coin":"4.6 万","score":9.7,"des":"在西历2307年，虽然化石燃料枯竭了，但是人类得到了截然不同的新型能源。三台巨大的轨道升降机以及伴随它们的大规模的太阳光发电系统。但是能得到这个系统恩惠的，只有一部分大国和其同盟国而已。\n拥有三台轨道..."},{"title":"Re：从零开始的异世界生活 第二季 前半","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f2425cbdb07cc93bd0d3ba1c0099bfe78f5dc58a.png@220w_280h.webp","totalCount":"全13话","id":28229233,"follow":"774.2 万","view":"1.3 亿","danmaku":"201.4 万","coin":"126.7 万","score":9.7,"des":"我一定会拯救你。\n在打倒了魔女教大罪司教「怠惰」担当——培提其乌斯·罗曼尼康帝之后，菜月昴和爱蜜莉雅又得以重新开始。\n克服了艰难的诀别，两人终于和解，然而这只是新一轮风波的序幕。\n超乎想象的绝境危机，..."},{"title":"超级小白","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3d3e8257d22596f5d3e4395ca759bd1e0fe9b873.jpg@220w_280h.webp","totalCount":"全48话","id":28222671,"follow":"27.4 万","view":"978.0 万","danmaku":"3.6 万","coin":"3.6 万","score":9.6,"des":"为了阻止企图霸占世界的黑暗势力，野原家的普通小狗——小白接肩负重大使命，变身成为了守护世界的“超级小白”。小白将要面对的不仅是发明狗，还有其他意想不到的对手。当然，面对邪恶势力，小白也有着令人惊讶的超..."},{"title":"Re：从零开始的异世界生活 新编集版","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3c125e1aad08643e3eff2fb7d45e740c1a052725.png@220w_280h.webp","totalCount":"全13话","id":28224394,"follow":"631.1 万","view":"7674.2 万","danmaku":"166.2 万","coin":"51.1 万","score":9.6,"des":"在从便利商店回家的路上，突然被异世界召唤的少年菜月昴。在无法依靠任何东西的异世界，无力的少年手唯一的力量……那是“死去然后重新开始”的力量。为了守护最重要的人们，为了取回确实存在着又无可替代的时间，少..."},{"title":"因为太怕痛就全点防御力了","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/8021d3f6b0df6dbba6d32f76eb9cfe2531e166c4.png@220w_280h.webp","totalCount":"全12话","id":28224137,"follow":"620.6 万","view":"2.3 亿","danmaku":"326.8 万","coin":"103.8 万","score":9,"des":"主角本条枫在好友白峰理沙推荐下开始游玩游戏“NewWorld Online”，创建了名为“梅普露”的角色。然而作为游戏初学者，梅普露选择了不受欢迎的大盾当武器，同时因为怕痛而把所有状态点加到防御力的极..."},{"title":"冰海战记","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/c30401817895e67399094b4e669785a104270cdf.jpg@220w_280h.webp","totalCount":"全24话","id":28220475,"follow":"174.4 万","view":"4893.8 万","danmaku":"48.7 万","coin":"36.7 万","score":9.8,"des":"公元10世纪末期，出现了在世界各地出没的最强民族。被讴歌为最强战士的托尔兹，其子托尔芬幼时便生活在战场上，并向往着梦幻大陆“文兰”。这是一个发生在激荡时代的，真正的英雄物语。..."},{"title":"齐木楠雄的灾难 始动篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ba59822eded39b5254fb01448a7f1502101d5624.png@220w_280h.webp","totalCount":"全6话","id":28223748,"follow":"372.4 万","view":"3054.5 万","danmaku":"20.0 万","coin":"17.8 万","score":9.8,"des":"在电视剧中堪称帅气的超能力，对于高中生齐木楠雄来说只是招致灾难的元凶。作为新动画系列展开的楠雄的日常又会如何！？..."},{"title":"OVERLORD Ⅱ","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/851f979c8ebcc7583a43abd4b786c4e2e66b746b.jpg@220w_280h.webp","totalCount":"全13话","id":8792,"follow":"539.3 万","view":"3.8 亿","danmaku":"413.9 万","coin":"114.1 万","score":9.6,"des":"时为2138年。曾卷起一大风潮的虚拟现实体感型网络游戏《YGGDRASIL》即将迎来停服。玩家飞鼠在曾经以同伴和荣华自傲的根据地纳萨力克地下大坟墓，独自一人安静等待着那一刻。但是，不料发生了结束时间已..."},{"title":"夏目友人帐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/99c549494d9425f6455bd45a151f4d26397d6151.png@220w_280h.webp","totalCount":"全13话","id":1660,"follow":"324.0 万","view":"4975.2 万","danmaku":"278.7 万","coin":"15.5 万","score":9.8,"des":"夏目贵志生来拥有强大的灵力，能感知平常人所无法接触的妖怪神明的存在。因父母双亡，他多年间辗转于互相推卸责任的亲戚之间，又受到同龄人的欺负，未曾与任何人深交，造成性格一定程度上的孤僻。夏目本性和善，对于..."}],"watched":[{"title":"装甲重拳/MEGALOBOX","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0c44785cb5d25cc9f648800d251f21a2e236bb8a.png@220w_280h.webp","totalCount":"全13话","id":79472,"follow":"221.9 万","view":"6162.0 万","danmaku":"48.6 万","coin":"32.9 万","score":9.8,"des":"将肉体与“装甲技术”融合的究极格斗技——“MEGALOBOX”，将自己的全部赌在上面的男人们的热血战斗开始！\n今天也立于未认可地区的赌博比赛赛场上的MEGALO拳击手“JNK DOG”。虽然具备实力，..."},{"title":"超能力女儿","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/152c536f8ecaad8f3d7d568d33da81c963a4a722.png@220w_280h.webp","totalCount":"全12话","id":78352,"follow":"293.8 万","view":"9252.2 万","danmaku":"98.5 万","coin":"35.4 万","score":9.6,"des":"支持着芦川组的年轻智力型黑道新田义史，过着被喜欢的壶所包围的悠然自得单身生活。但某一天，随着装在神秘物体里的少女雏来到他家，他的生活为之一变。他被能使用念动力的雏所胁迫，迫不得已开始和她同居！\n容易暴..."},{"title":"OVERLORD Ⅲ","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/dd7a9d0a0bee32b1f43c2656398d8463d12b3069.jpg@220w_280h.webp","totalCount":"全13话","id":102252,"follow":"551.6 万","view":"4.0 亿","danmaku":"399.7 万","coin":"129.2 万","score":9.4,"des":"时间为2138年。曾卷起一大风潮的虚拟现实体感型网络游戏《YGGDRASIL》即将迎来停服。玩家飞鼠在曾经以同伴和荣华自傲的根据地纳萨力克地下大坟墓，独自一人安静等待着那一刻。\n但是，不料发生了“过了..."},{"title":"路人超能100 第一次灵能咨询所员工旅游～舒缓心灵的疗愈之旅~（OVA2）","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/1271324d51634b68980704731987724a1afc60aa.jpg@220w_280h.webp","totalCount":"全1话","id":28222715,"follow":"318.8 万","view":"520.7 万","danmaku":"3.6 万","coin":"4.6 万","score":9.8,"des":"由原作ONE老师担任原案的完全新作OVA！「灵能咨询所」一行人，龙套与灵幻、小酒窝以及新同伴芹泽的目的地，正是缟马县深山中鲜为人知的温泉·疣神温泉。因为灵幻接受了旅馆老板娘的委托，「弄清温泉的恐怖传闻..."},{"title":"少女终末旅行","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1431ca5bb2f7143062e3df8f21b8448cf8cccc13.jpg@220w_280h.webp","totalCount":"全12话","id":6463,"follow":"239.8 万","view":"3714.7 万","danmaku":"100.7 万","coin":"37.2 万","score":9.8,"des":"本作舞台在人类繁华的文明迎来终结的很久以后，人类基本灭绝，甚至生物都不再存在的末日世界。复杂够高的都市成为迷宫般的废墟，得不到维护的机械渐渐停止运转。连何时终结了，何时开始终结的思考都不复存在的这个世..."},{"title":"齐木楠雄的灾难（日播&精选版）","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/eb4f17335f48951945fb9da47e6ee0bc65fa2fbb.jpg@220w_280h.webp","totalCount":"全120话","id":5070,"follow":"187.0 万","view":"2.3 亿","danmaku":"130.7 万","coin":"32.7 万","score":9.6,"des":"高中生·齐木楠雄是超能力者。心灵感应、念动力、透视、预知、瞬间移动、千里眼等，不论任何事情都自由自在。但这任谁都羡慕不已的最强能力，实际上对于本人而言是引来灾难的不幸元凶。因此，他在别人面前封印了超能..."},{"title":"比宇宙更远的地方","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/c9eca3cbc386c63b27461074b8b218898cb7440e.jpg@220w_280h.webp","totalCount":"全13话","id":13032,"follow":"156.0 万","view":"2298.0 万","danmaku":"45.9 万","coin":"23.9 万","score":9.8,"des":"无论何时，我们的第一步总是从好奇心开始。\n不曾看过的风景，不曾听过的声音，不曾闻过的味道，不曾摸过的质感，不曾尝过的食物，以及不曾感受过的澎湃。\n为了重拾不知何时忘却的记忆碎片和不知何时舍弃的感动的旅..."},{"title":"OVERLORD","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/b8e72ea69e57e0b7ac85d8b4d366554fd866df1a.jpg@220w_280h.webp","totalCount":"全13话","id":2576,"follow":"626.2 万","view":"4.1 亿","danmaku":"385.2 万","coin":"84.4 万","score":9.6,"des":"作品主要讲述了某天，一款曾经掀起过大热潮的VRMMORPG「YGGDRASIL」停止了运营。游戏原本会停止一切服务，但过了结束时间后，玩家们却发现不能退出，NPC也产生了各自的思想。现实世界中喜爱电玩..."},{"title":"路人超能100 II(灵能百分百 第二季)","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/216e1bdaf88244215a13b1154116805ee9adbe07.png@220w_280h.webp","totalCount":"全13话","id":4762734,"follow":"284.9 万","view":"1.0 亿","danmaku":"97.8 万","coin":"56.1 万","score":9.9,"des":"当有什么东西达到“100”的时候，就会爆发的少年·路人（龙套）。外表极其普通——不如说是不起眼。不擅长迎合气氛的他，实际上拥有着强力的超能力。盯上了这样的他的能力，而接连现身的伪灵能力者以及宗教团体、..."},{"title":"多罗罗","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3fc16a667502cbff226e585eb660a96a20c7458c.png@220w_280h.webp","totalCount":"全24话","id":4312482,"follow":"452.1 万","view":"1.8 亿","danmaku":"143.9 万","coin":"73.9 万","score":9.4,"des":"他们向着命运抗争，在那尽头等待他们的是人心，还是业障。\n时值乱世。\n名为景光的醍醐将军，向某个寺庙殿堂中的12尊魔神像祈求早日结束战乱。\n作为代价，他的嫡子在出生时就失去了身体的某些部位，被丢弃在河流..."},{"title":"魔法少女小圆","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/7fcaa0e98b561611538ae4deba7949cec4ca39a8.png@220w_280h.webp","totalCount":"全12话","id":2539,"follow":"218.7 万","view":"4199.0 万","danmaku":"201.5 万","coin":"20.0 万","score":9.8,"des":"就读初中二年级的鹿目圆，过着平凡幸福的生活。神秘转学生晓美焰的出现，开始让小圆的命运有了巨大转变。某日一只名为丘比的神秘生物，希望小圆能够与它签订魔法契约，成为“魔法少女”以对抗邪恶的魔女保护世界。正..."}]},"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<blockquote>\n<p> 接着上次MySql配置完毕，接下来把我们之前的hexo博客重新发布上来</p>\n</blockquote>\n<h2 id=\"一、服务器环境搭建\"><a href=\"#一、服务器环境搭建\" class=\"headerlink\" title=\"一、服务器环境搭建\"></a>一、服务器环境搭建</h2><p>首先安装一些常用工具</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@ls_patrick ~]# yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"http://rebp38war.bkt.clouddn.com/img/20220722145908.png\"></p>\n<p>刷刷刷………一会就全部安装完成了，我们在安装git 安装的命令如下</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@ls_patrick ~]# yum install -y git</span><br></pre></td></tr></table></figure>\n\n<p>安装完成后用git –version查看一下版本，能查到证明安装成功了。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@ls_patrick ~]# git --version</span><br><span class=\"line\">git version 1.8.3.1</span><br></pre></td></tr></table></figure>\n\n<p>接下来创建git使用的用户。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@ls_patrick ~]# useradd HelloWorldKing1</span><br><span class=\"line\">[root@ls_patrick ~]# passwd HelloWorldKing1 // 设置密码</span><br><span class=\"line\">Changing password for user HelloWorldKing1.</span><br><span class=\"line\">New password:</span><br><span class=\"line\">Retype new password:</span><br><span class=\"line\">passwd: all authentication tokens updated successfully.</span><br><span class=\"line\">[root@ls_patrick ~]# chmod 740 /etc/sudoers // 设置权限</span><br></pre></td></tr></table></figure>\n<p>[root@ls_patrick ~]# vim /etc/sudoers // 修改root权限 按i直接进入编辑状态。找个风水宝地（新的一行就可以）输入下面的命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">HelloWorldKing1 ALL=(ALL)    ALL</span><br></pre></td></tr></table></figure>\n\n<p>紧接着。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@ls_patrick ~]# chmod 600 /etc/sudoers //改回权限</span><br><span class=\"line\">[root@ls_patrick ~]# mkdir /home/hexo</span><br><span class=\"line\">[root@ls_patrick ~]# chown HelloWorldKing1:HelloWorldKing1 -R /home/hexo</span><br></pre></td></tr></table></figure>\n<p>完成后正式开始安装Nginx</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@ls_patrick ~]# yum install -y nginx  //安装nginx</span><br><span class=\"line\">[root@ls_patrick ~]# systemctl start nginx.service  //启动Nginx服务</span><br></pre></td></tr></table></figure>\n<p><font color=\"red\">如果启动时，发生以下错误</font></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">Job for nginx.service failed because the control process exited with error code. See &quot;systemctl status nginx.service&quot; and &quot;journalctl -xe&quot; for details.</span><br></pre></td></tr></table></figure>\n<p>分析：端口被占用了</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@ls_patrick ~]# netstat -tnlp</span><br><span class=\"line\">Active Internet connections (only servers)</span><br><span class=\"line\">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name</span><br><span class=\"line\">tcp        0      0 0.0.0.0:3306            0.0.0.0:*               LISTEN      18727/mysqld</span><br><span class=\"line\">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1519/sshd</span><br><span class=\"line\">tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      1370/master</span><br><span class=\"line\">tcp6       0      0 :::781                  :::*                    LISTEN      2477/./bcm-agent</span><br><span class=\"line\">tcp6       0      0 :::80                   :::*                    LISTEN      950/httpd</span><br><span class=\"line\">tcp6       0      0 :::22                   :::*                    LISTEN      1519/sshd</span><br><span class=\"line\">tcp6       0      0 ::1:25                  :::*                    LISTEN      1370/master</span><br></pre></td></tr></table></figure>\n\n<p>想起了是服务器镜像是LAMP 。可能是apache的80端口和nginx的80端口冲突了</p>\n<p>进入apache的 conf目录修改端口</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@ls_patrick conf]# vim httpd.conf</span><br></pre></td></tr></table></figure>\n\n<p>将80端口改为8080  :wq 保存退出</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">Listen 8080</span><br></pre></td></tr></table></figure>\n\n<p>进入bin目录 重启apache</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@ls_patrick bin]# apachectl restart</span><br></pre></td></tr></table></figure>\n\n<p> 再次启动nginx</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@ls_patrick conf]# systemctl start nginx.service</span><br></pre></td></tr></table></figure>\n\n<p>如果正常启动，没有任何报错，说明Nginx配置好了。 <strong>建立git仓库</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@ls_patrick conf]# su root</span><br><span class=\"line\">[root@ls_patrick conf]# cd /home/HelloWorldKing1</span><br><span class=\"line\">[root@ls_patrick HelloWorldKing1]# git init --bare blog.git  //创建Git仓库</span><br><span class=\"line\">[root@ls_patrick HelloWorldKing1]# chown HelloWorldKing1:HelloWorldKing1 -R blog.git  //授予Git仓库权限</span><br></pre></td></tr></table></figure>\n\n<p>同步网站根目录</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@ls_patrick HelloWorldKing1]# cd blog.git/hooks/</span><br><span class=\"line\"></span><br><span class=\"line\">[root@ls_patrick hooks]# vim post-receive</span><br><span class=\"line\">// 把下面的内容拷贝进去</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/sh</span></span><br><span class=\"line\">git --work-tree=/home/hexo  --git-dir=/home/HelloWorldKing1/blog.git checkout -f</span><br></pre></td></tr></table></figure>\n\n<p>再次修改权限，</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">chmod +x post-receive</span><br></pre></td></tr></table></figure>\n\n<p>这样就已经把服务器端的环境基本配置好了。</p>\n<h2 id=\"二、上传博客到服务器\"><a href=\"#二、上传博客到服务器\" class=\"headerlink\" title=\"二、上传博客到服务器\"></a>二、上传博客到服务器</h2><p>接下来把博客重新上传到云服务器</p>\n<p>有了文章我们就可以把博客上传到云服务器了。但是要想用Git把代码传到服务器，是需要密钥的。这就就直接创建一下密钥。在本地电脑打开<code>powerShell</code>，创建密钥。创建密钥的命令是 <code>ssh-keygen -t rsa</code> 如果你已经有了密钥就不用再次创建了，特别是公司已经有很多git管理的项目时，否则需要都进行重新配置。我这里是已经有密钥了。 到服务端创建一个存放密钥的文件夹。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">su HelloWorldKing1</span><br><span class=\"line\">mkdir ~/.ssh   //创建存放密钥的文件夹</span><br><span class=\"line\">vim ~/.ssh/authorized_keys  //写入密钥</span><br></pre></td></tr></table></figure>\n\n<p>来到自己的客户端，找到<code>C:\\Users\\Administrator\\.ssh</code> 打开<code>id_rsa</code>文件，直接复制全部，就可以完成了。 这样我们就可以通过HelloWorldKing1这个用户向服务器提交代码了，我们要测试一下，看看是否配置的可以连接上 <strong>本地测试</strong> 打开本地主机的<code>powerShell</code>，然后用ssh进行连接。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh -v HelloWorldKing1@180.76.183.66 //服务器ip</span><br></pre></td></tr></table></figure>\n\n<p><font color=\"red\">发生错误WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!</font></p>\n<img src=\"http://rebp38war.bkt.clouddn.com/img/20220722155039.png\" style=\"zoom:67%;\">\n\n<p>是因为本地记录了上次连接信息；需要这这段删掉即可</p>\n<p><img src=\"http://rebp38war.bkt.clouddn.com/img/20220722155006.png\"></p>\n<p>修改本地的hexo配置文件<code>_config.yml</code>,打开文件后，拖动到最后边，输入下面的配置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repository: HelloWorldKing1@180.76.183.66:/home/HelloWorldKing1/blog.git</span><br><span class=\"line\">  branch: master</span><br><span class=\"line\">npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure>\n\n<p>安装完成后，输入下面的命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br><span class=\"line\">hexo g -d</span><br></pre></td></tr></table></figure>\n\n<p>如果一切正常，就可以直接传到服务器上，然后输入网址<code>http://120.48.107.220/</code>就可以完成博客的浏览了，我这里没有使用域名，如果你有域名，只要把域名解析到这个网址就可以了。</p>\n<p><img src=\"http://rebp38war.bkt.clouddn.com/img/20220722155619.png\"></p>\n"},{"title":"Shell脚本","urlname":"sq2vqv","date":"2022-07-05T02:04:46.000Z","_content":"\n> 💡 本质是一个文件，文件里面存放的是 特定格式的指令，系统可以使用脚本解析器 翻译或解析指令并执行\n\n- shell 脚本就是说我们把原来 linux 命令或语句放在一个文件中，然后通过这个程序文件去执行时，我们就说这个程序为 shell 脚本或 shell 程序；我们可以在脚本中输入一系统的命令以及相关的语法语句组合，比如变量，流程控制语句等，把他们有机结合起来就形成了一个功能强大的 shell 脚本\n\n# 记录下 linux 下 shell 脚本的基本使用\n\n贴一段项目部署中写的一段 sell 代码：\n\n```shell\n#!/bin/bash\napp=hsmj-cpa-app-1.0.0-SNAPSHOT.jar\nport=9086\npath=/usr/local/hsmj/project\ndeploy_path=/usr/local/hsmj/project/deploy\nlog_path=/data/log/hsmj/\necho this is app : $app\necho port : $port\n#若项目已启动，杀死旧进程\nappId=`ps -ef | grep \"$app\" | grep -v grep | awk '{print $2}'`\necho appId = $appId\nif [ \"$appId\" != \"\" ]; then\necho kill $appId\nkill -9 $appId\necho sleep 3s\nsleep 1\necho sleep 2s\nsleep 1\necho sleep 1s\nsleep 1\nfi\n#将jar包从jenkins工作空间中移动到指定路径下\nrm -rf $deploy_path/$app\nmv $path/$app $deploy_path/$app\ncd $deploy_path\n#防止进程被杀死\n#BUILD_ID=dontKillMe\n#后台进程形式启动项目\nJAVA_HOME=/usr/local/java\necho \"java环境\"+$JAVA_HOME\nnohup $JAVA_HOME/bin/java -jar -Dserver.port=$port -Dspring.profiles.active=test -Xmx256m -Xms128m  $deploy_path/$app  >/dev/null  2>&1 &\necho $app start success\n#jps -l\nexit 0\n\n```\n\n## 接下逐段解析代码\n\n```shell\n#!/bin/bash\n```\n\n**#!用来声明脚本由什么 shell 解释，否则使用默认 shell**\n\n> 有不少时候不规范的写法能够忽略掉这一句，执行起来好像也是 ok，结果没什么不同,linux 系统上默认都是执行/bin/bash 来执行 shell 脚本若是有些用户使用的是 csh，那么缺乏第一行的“#！/bin/bash 的 shell 脚本执行结果就可能存在语法不兼容的问题，致使结果异常或者根本不能执行。linux\n\n### shell 脚本也支持变量赋值\n\n```shell\napp=hsmj-cpa-app-1.0.0-SNAPSHOT.jar\nport=9086\npath=/usr/local/hsmj/project\ndeploy_path=/usr/local/hsmj/project/deploy\nlog_path=/data/log/hsmj/\n```\n\n#### echo 输出控制台信息\n\n> Shell 的 echo 指令与 PHP 的 echo 指令类似，都是用于字符串的输出。\n\n```shell\necho this is app : $app\necho port : $port\n```\n\n##### 1.显示普通字符串:\n\n`echo \"It is a test\"`\n这里的双引号完全可以省略，以下命令与上面实例效果一致：\n`echo It is a test`\n\n##### 2.显示转义字符\n\n`echo \"\\\"It is a test\\\"\"`\n结果将是:\n`\"It is a test\"`\n同样，双引号也可以省略\n\n##### 3.显示变量\n\nread 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量\n`#!/bin/sh read name echo \"$name It is a test\"`\n以上代码保存为 test.sh，name 接收标准输入的变量，结果将是:\n`[root@www ~]# sh test.sh OK #标准输入 OK It is a test #输出`\n\n##### 4.显示换行\n\n`echo -e \"OK! \\n\" # -e 开启转义 echo \"It is a test\"`\n输出结果：\n`OK! It is a test`\n\n##### 5.显示不换行\n\n`#!/bin/sh echo -e \"OK! \\c\" # -e 开启转义 \\c 不换行 echo \"It is a test\"`\n输出结果：\n`OK! It is a test`\n\n##### 6.显示结果定向至文件\n\n`echo \"It is a test\" > myfile`\n\n##### 7.原样输出字符串，不进行转义或取变量(用单引号)\n\n`echo '$name\\\"'`\n输出结果：\n`$name\\\"`\n\n##### 8.显示命令执行结果\n\n`echo `date`` **注意：** 这里使用的是反引号 **`**, 而不是单引号 **'\\*\\*。\n结果将显示当前日期\n`Thu Jul 24 10:08:46 CST 2014`\n\n#### 加下来这段代码表示 如果项目已经启动了，可以杀死旧的进程\n\n```shell\n#若项目已启动，杀死旧进程\nappId=`ps -ef | grep \"$app\" | grep -v grep | awk '{print $2}'`\necho appId = $appId\nif [ \"$appId\" != \"\" ]; then\necho kill $appId\nkill -9 $appId\necho sleep 3s\nsleep 1\necho sleep 2s\nsleep 1\necho sleep 1s\nsleep 1\nfi\n```\n\n##### shell 的变量可以定义一长串的代码\n\n`appId=`ps -ef | grep \"$app\" | grep -v grep | awk '{print $2}'``\n\n##### 判断语句(`if[]; then fi`)\n\n```shell\nif [ \"$appId\" != \"\" ]; then\nxxx\nfi\n```\n\n##### 并且使用 $xxx 来调用变量\n\n```shell\necho appId = $appId\nif [ \"$appId\" != \"\" ]; then\necho kill $appId\nkill -9 $appId\n```\n\n#### `sleep 1`表示休眠 1 秒\n\n#### shell 当然也可以使用 linux 中的命令，并使用调用变量的形式，让代码更加灵活\n\n```shell\n#将jar包从jenkins工作空间中移动到指定路径下\nrm -rf $deploy_path/$app\nmv $path/$app $deploy_path/$app\ncd $deploy_path\n#防止进程被杀死\n#BUILD_ID=dontKillMe\n#后台进程形式启动项目\nJAVA_HOME=/usr/local/java\necho \"java环境\"+$JAVA_HOME\nnohup $JAVA_HOME/bin/java -jar -Dserver.port=$port -Dspring.profiles.active=test -Xmx256m -Xms128m  $deploy_path/$app  >/dev/null  2>&1 &\necho $app start success\n```\n\n#### 最后`exit `退出程序\n\n```shell\nexit  0：正常运行程序并退出程序；\n\nexit  1：非正常运行导致退出程序；\n\nexit 0 可以告知你的程序的使用者：你的程序是正常结束的。如果 exit 非 0 值，那么你的程序的使用者通常会认为\n你的程序产生了一个错误。\n在 shell 中调用完你的程序之后，用 echo $? 命令就可以看到你的程序的 exit 值。在 shell 脚本中，通常会根据\n上一个命令的 $? 值来进行一些流程控制。0代表程序正确的执行，如下图例子所示：\n```\n\n### Shell 批量处理\n\n> 如果有多个项目需要脚本来启动，每个都写脚本比较繁杂，可以考虑用 for 循环来批量处理\n\n```shell\n#!/bin/bash\npath=/usr/local/hsmj/project\ndeploy_path=/usr/local/hsmj/project/deploy\narray=([1]=hsmj-desk-app.sh [2]=hsmj-flow-app.sh [3]=hsmj-sys-app.sh [4]=hsmj-spt-app.sh  [5]=hsmj-auth.sh [6]=hsmj-autho.sh [7]=hsmj-gateway.sh [8]=hsmj-cpa-app.sh [9]=hsmj-comp-app.sh  [10]=hsmj-cust-app.sh [11]=hsmj-ctm-app.sh [12]=hsmj-ctm-api.sh [13]=hsmj-cto-app.sh [14]=hsmj-cto-job.sh )\n\nfor file in `ls $deploy_path`\n\ndo\n\nif [[ $file == hsmj-*.jar ]]; then\n\tmv $deploy_path/$file $path/$file\n\techo \"move \"$file\" success\"\nfi\n\ndone\n\nfor b in ${array[*]}\n\ndo\n\nsh $path/$b\n\necho \"run \"$path/$b\" success\"\n\ndone\n。、\n```\n\n#### 这里 表示定义的数组，存入需要操作的项目\n\n```shell\narray=([1]=hsmj-desk-app.sh [2]=hsmj-flow-app.sh [3]=hsmj-sys-app.sh [4]=hsmj-spt-app.sh  [5]=hsmj-auth.sh [6]=hsmj-autho.sh [7]=hsmj-gateway.sh [8]=hsmj-cpa-app.sh [9]=hsmj-comp-app.sh  [10]=hsmj-cust-app.sh [11]=hsmj-ctm-app.sh [12]=hsmj-ctm-api.sh [13]=hsmj-cto-app.sh [14]=hsmj-cto-job.sh )\n```\n\n#### `for in do done`进行循环操作\n\n```shell\nfor file in `ls $deploy_path`\n\ndo\n\nif [[ $file == hsmj-*.jar ]]; then\n\tmv $deploy_path/$file $path/$file\n\techo \"move \"$file\" success\"\nfi\n\ndone\n```\n\n`for file in `ls $deploy_path``可以在循环目录下的所有文件 `if [[$file == hsmj-*.jar]]; `\\*模糊匹配文件名\n\n## 记录下 shell 使用中遇到的问题\n\n```shell\n[root@localhost project]# ./ctm-all.sh\n-bash: ./ctm-all.sh: 权限不够\n```\n\n#### 刚创建的脚本权限不足导致的错误；需要我们先给这个脚本赋权限；\n\n解决方法：\n使用`chmod +x ctm-all.sh` 即可解决；\n\n```shell\n[root@localhost project]# ./ctm-all.sh\n-bash: ./ctm-all.sh: /bin/bash^M: 坏的解释器: 没有那个文件或目录\n```\n\n#### 接着遇到的这个问题是，我的脚本在 Windows 中编写，导入 Linux 中运行的，因为在 Windows 中换行符为 \\r\\n，linux 下换行符为 \\n；所导致的问题\n\n解决方法：\n只需要去掉多余的 \\r 回车符 即可。操作办法可以用 sed 命令进行全局替换\n`sed 's/\\r//' -i ctm-all.sh`\n","source":"_posts/yuque/Shell脚本.md","raw":"---\ntitle: Shell脚本\nurlname: sq2vqv\ndate: '2022-07-05 10:04:46 +0800'\ntags: []\ncategories: []\n---\n\n> 💡 本质是一个文件，文件里面存放的是 特定格式的指令，系统可以使用脚本解析器 翻译或解析指令并执行\n\n- shell 脚本就是说我们把原来 linux 命令或语句放在一个文件中，然后通过这个程序文件去执行时，我们就说这个程序为 shell 脚本或 shell 程序；我们可以在脚本中输入一系统的命令以及相关的语法语句组合，比如变量，流程控制语句等，把他们有机结合起来就形成了一个功能强大的 shell 脚本\n\n# 记录下 linux 下 shell 脚本的基本使用\n\n贴一段项目部署中写的一段 sell 代码：\n\n```shell\n#!/bin/bash\napp=hsmj-cpa-app-1.0.0-SNAPSHOT.jar\nport=9086\npath=/usr/local/hsmj/project\ndeploy_path=/usr/local/hsmj/project/deploy\nlog_path=/data/log/hsmj/\necho this is app : $app\necho port : $port\n#若项目已启动，杀死旧进程\nappId=`ps -ef | grep \"$app\" | grep -v grep | awk '{print $2}'`\necho appId = $appId\nif [ \"$appId\" != \"\" ]; then\necho kill $appId\nkill -9 $appId\necho sleep 3s\nsleep 1\necho sleep 2s\nsleep 1\necho sleep 1s\nsleep 1\nfi\n#将jar包从jenkins工作空间中移动到指定路径下\nrm -rf $deploy_path/$app\nmv $path/$app $deploy_path/$app\ncd $deploy_path\n#防止进程被杀死\n#BUILD_ID=dontKillMe\n#后台进程形式启动项目\nJAVA_HOME=/usr/local/java\necho \"java环境\"+$JAVA_HOME\nnohup $JAVA_HOME/bin/java -jar -Dserver.port=$port -Dspring.profiles.active=test -Xmx256m -Xms128m  $deploy_path/$app  >/dev/null  2>&1 &\necho $app start success\n#jps -l\nexit 0\n\n```\n\n## 接下逐段解析代码\n\n```shell\n#!/bin/bash\n```\n\n**#!用来声明脚本由什么 shell 解释，否则使用默认 shell**\n\n> 有不少时候不规范的写法能够忽略掉这一句，执行起来好像也是 ok，结果没什么不同,linux 系统上默认都是执行/bin/bash 来执行 shell 脚本若是有些用户使用的是 csh，那么缺乏第一行的“#！/bin/bash 的 shell 脚本执行结果就可能存在语法不兼容的问题，致使结果异常或者根本不能执行。linux\n\n### shell 脚本也支持变量赋值\n\n```shell\napp=hsmj-cpa-app-1.0.0-SNAPSHOT.jar\nport=9086\npath=/usr/local/hsmj/project\ndeploy_path=/usr/local/hsmj/project/deploy\nlog_path=/data/log/hsmj/\n```\n\n#### echo 输出控制台信息\n\n> Shell 的 echo 指令与 PHP 的 echo 指令类似，都是用于字符串的输出。\n\n```shell\necho this is app : $app\necho port : $port\n```\n\n##### 1.显示普通字符串:\n\n`echo \"It is a test\"`\n这里的双引号完全可以省略，以下命令与上面实例效果一致：\n`echo It is a test`\n\n##### 2.显示转义字符\n\n`echo \"\\\"It is a test\\\"\"`\n结果将是:\n`\"It is a test\"`\n同样，双引号也可以省略\n\n##### 3.显示变量\n\nread 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量\n`#!/bin/sh read name echo \"$name It is a test\"`\n以上代码保存为 test.sh，name 接收标准输入的变量，结果将是:\n`[root@www ~]# sh test.sh OK #标准输入 OK It is a test #输出`\n\n##### 4.显示换行\n\n`echo -e \"OK! \\n\" # -e 开启转义 echo \"It is a test\"`\n输出结果：\n`OK! It is a test`\n\n##### 5.显示不换行\n\n`#!/bin/sh echo -e \"OK! \\c\" # -e 开启转义 \\c 不换行 echo \"It is a test\"`\n输出结果：\n`OK! It is a test`\n\n##### 6.显示结果定向至文件\n\n`echo \"It is a test\" > myfile`\n\n##### 7.原样输出字符串，不进行转义或取变量(用单引号)\n\n`echo '$name\\\"'`\n输出结果：\n`$name\\\"`\n\n##### 8.显示命令执行结果\n\n`echo `date`` **注意：** 这里使用的是反引号 **`**, 而不是单引号 **'\\*\\*。\n结果将显示当前日期\n`Thu Jul 24 10:08:46 CST 2014`\n\n#### 加下来这段代码表示 如果项目已经启动了，可以杀死旧的进程\n\n```shell\n#若项目已启动，杀死旧进程\nappId=`ps -ef | grep \"$app\" | grep -v grep | awk '{print $2}'`\necho appId = $appId\nif [ \"$appId\" != \"\" ]; then\necho kill $appId\nkill -9 $appId\necho sleep 3s\nsleep 1\necho sleep 2s\nsleep 1\necho sleep 1s\nsleep 1\nfi\n```\n\n##### shell 的变量可以定义一长串的代码\n\n`appId=`ps -ef | grep \"$app\" | grep -v grep | awk '{print $2}'``\n\n##### 判断语句(`if[]; then fi`)\n\n```shell\nif [ \"$appId\" != \"\" ]; then\nxxx\nfi\n```\n\n##### 并且使用 $xxx 来调用变量\n\n```shell\necho appId = $appId\nif [ \"$appId\" != \"\" ]; then\necho kill $appId\nkill -9 $appId\n```\n\n#### `sleep 1`表示休眠 1 秒\n\n#### shell 当然也可以使用 linux 中的命令，并使用调用变量的形式，让代码更加灵活\n\n```shell\n#将jar包从jenkins工作空间中移动到指定路径下\nrm -rf $deploy_path/$app\nmv $path/$app $deploy_path/$app\ncd $deploy_path\n#防止进程被杀死\n#BUILD_ID=dontKillMe\n#后台进程形式启动项目\nJAVA_HOME=/usr/local/java\necho \"java环境\"+$JAVA_HOME\nnohup $JAVA_HOME/bin/java -jar -Dserver.port=$port -Dspring.profiles.active=test -Xmx256m -Xms128m  $deploy_path/$app  >/dev/null  2>&1 &\necho $app start success\n```\n\n#### 最后`exit `退出程序\n\n```shell\nexit  0：正常运行程序并退出程序；\n\nexit  1：非正常运行导致退出程序；\n\nexit 0 可以告知你的程序的使用者：你的程序是正常结束的。如果 exit 非 0 值，那么你的程序的使用者通常会认为\n你的程序产生了一个错误。\n在 shell 中调用完你的程序之后，用 echo $? 命令就可以看到你的程序的 exit 值。在 shell 脚本中，通常会根据\n上一个命令的 $? 值来进行一些流程控制。0代表程序正确的执行，如下图例子所示：\n```\n\n### Shell 批量处理\n\n> 如果有多个项目需要脚本来启动，每个都写脚本比较繁杂，可以考虑用 for 循环来批量处理\n\n```shell\n#!/bin/bash\npath=/usr/local/hsmj/project\ndeploy_path=/usr/local/hsmj/project/deploy\narray=([1]=hsmj-desk-app.sh [2]=hsmj-flow-app.sh [3]=hsmj-sys-app.sh [4]=hsmj-spt-app.sh  [5]=hsmj-auth.sh [6]=hsmj-autho.sh [7]=hsmj-gateway.sh [8]=hsmj-cpa-app.sh [9]=hsmj-comp-app.sh  [10]=hsmj-cust-app.sh [11]=hsmj-ctm-app.sh [12]=hsmj-ctm-api.sh [13]=hsmj-cto-app.sh [14]=hsmj-cto-job.sh )\n\nfor file in `ls $deploy_path`\n\ndo\n\nif [[ $file == hsmj-*.jar ]]; then\n\tmv $deploy_path/$file $path/$file\n\techo \"move \"$file\" success\"\nfi\n\ndone\n\nfor b in ${array[*]}\n\ndo\n\nsh $path/$b\n\necho \"run \"$path/$b\" success\"\n\ndone\n。、\n```\n\n#### 这里 表示定义的数组，存入需要操作的项目\n\n```shell\narray=([1]=hsmj-desk-app.sh [2]=hsmj-flow-app.sh [3]=hsmj-sys-app.sh [4]=hsmj-spt-app.sh  [5]=hsmj-auth.sh [6]=hsmj-autho.sh [7]=hsmj-gateway.sh [8]=hsmj-cpa-app.sh [9]=hsmj-comp-app.sh  [10]=hsmj-cust-app.sh [11]=hsmj-ctm-app.sh [12]=hsmj-ctm-api.sh [13]=hsmj-cto-app.sh [14]=hsmj-cto-job.sh )\n```\n\n#### `for in do done`进行循环操作\n\n```shell\nfor file in `ls $deploy_path`\n\ndo\n\nif [[ $file == hsmj-*.jar ]]; then\n\tmv $deploy_path/$file $path/$file\n\techo \"move \"$file\" success\"\nfi\n\ndone\n```\n\n`for file in `ls $deploy_path``可以在循环目录下的所有文件 `if [[$file == hsmj-*.jar]]; `\\*模糊匹配文件名\n\n## 记录下 shell 使用中遇到的问题\n\n```shell\n[root@localhost project]# ./ctm-all.sh\n-bash: ./ctm-all.sh: 权限不够\n```\n\n#### 刚创建的脚本权限不足导致的错误；需要我们先给这个脚本赋权限；\n\n解决方法：\n使用`chmod +x ctm-all.sh` 即可解决；\n\n```shell\n[root@localhost project]# ./ctm-all.sh\n-bash: ./ctm-all.sh: /bin/bash^M: 坏的解释器: 没有那个文件或目录\n```\n\n#### 接着遇到的这个问题是，我的脚本在 Windows 中编写，导入 Linux 中运行的，因为在 Windows 中换行符为 \\r\\n，linux 下换行符为 \\n；所导致的问题\n\n解决方法：\n只需要去掉多余的 \\r 回车符 即可。操作办法可以用 sed 命令进行全局替换\n`sed 's/\\r//' -i ctm-all.sh`\n","slug":"yuque/Shell脚本","published":1,"updated":"2022-07-05T05:51:05.112Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5w7e74a000uigvu6nowaz6x","content":"<blockquote>\n<p>💡 本质是一个文件，文件里面存放的是 特定格式的指令，系统可以使用脚本解析器 翻译或解析指令并执行</p>\n</blockquote>\n<ul>\n<li>shell 脚本就是说我们把原来 linux 命令或语句放在一个文件中，然后通过这个程序文件去执行时，我们就说这个程序为 shell 脚本或 shell 程序；我们可以在脚本中输入一系统的命令以及相关的语法语句组合，比如变量，流程控制语句等，把他们有机结合起来就形成了一个功能强大的 shell 脚本</li>\n</ul>\n<h1 id=\"记录下-linux-下-shell-脚本的基本使用\"><a href=\"#记录下-linux-下-shell-脚本的基本使用\" class=\"headerlink\" title=\"记录下 linux 下 shell 脚本的基本使用\"></a>记录下 linux 下 shell 脚本的基本使用</h1><p>贴一段项目部署中写的一段 sell 代码：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\">app=hsmj-cpa-app-1.0.0-SNAPSHOT.jar</span><br><span class=\"line\">port=9086</span><br><span class=\"line\">path=/usr/local/hsmj/project</span><br><span class=\"line\">deploy_path=/usr/local/hsmj/project/deploy</span><br><span class=\"line\">log_path=/data/log/hsmj/</span><br><span class=\"line\">echo this is app : $app</span><br><span class=\"line\">echo port : $port</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">若项目已启动，杀死旧进程</span></span><br><span class=\"line\">appId=`ps -ef | grep &quot;$app&quot; | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class=\"line\">echo appId = $appId</span><br><span class=\"line\">if [ &quot;$appId&quot; != &quot;&quot; ]; then</span><br><span class=\"line\">echo kill $appId</span><br><span class=\"line\">kill -9 $appId</span><br><span class=\"line\">echo sleep 3s</span><br><span class=\"line\">sleep 1</span><br><span class=\"line\">echo sleep 2s</span><br><span class=\"line\">sleep 1</span><br><span class=\"line\">echo sleep 1s</span><br><span class=\"line\">sleep 1</span><br><span class=\"line\">fi</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">将jar包从jenkins工作空间中移动到指定路径下</span></span><br><span class=\"line\">rm -rf $deploy_path/$app</span><br><span class=\"line\">mv $path/$app $deploy_path/$app</span><br><span class=\"line\">cd $deploy_path</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">防止进程被杀死</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">BUILD_ID=dontKillMe</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">后台进程形式启动项目</span></span><br><span class=\"line\">JAVA_HOME=/usr/local/java</span><br><span class=\"line\">echo &quot;java环境&quot;+$JAVA_HOME</span><br><span class=\"line\">nohup $JAVA_HOME/bin/java -jar -Dserver.port=$port -Dspring.profiles.active=test -Xmx256m -Xms128m  $deploy_path/$app  &gt;/dev/null  2&gt;&amp;1 &amp;</span><br><span class=\"line\">echo $app start success</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">jps -l</span></span><br><span class=\"line\">exit 0</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"接下逐段解析代码\"><a href=\"#接下逐段解析代码\" class=\"headerlink\" title=\"接下逐段解析代码\"></a>接下逐段解析代码</h2><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>#!用来声明脚本由什么 shell 解释，否则使用默认 shell</strong></p>\n<blockquote>\n<p>有不少时候不规范的写法能够忽略掉这一句，执行起来好像也是 ok，结果没什么不同,linux 系统上默认都是执行/bin/bash 来执行 shell 脚本若是有些用户使用的是 csh，那么缺乏第一行的“#！/bin/bash 的 shell 脚本执行结果就可能存在语法不兼容的问题，致使结果异常或者根本不能执行。linux</p>\n</blockquote>\n<h3 id=\"shell-脚本也支持变量赋值\"><a href=\"#shell-脚本也支持变量赋值\" class=\"headerlink\" title=\"shell 脚本也支持变量赋值\"></a>shell 脚本也支持变量赋值</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">app=hsmj-cpa-app-1.0.0-SNAPSHOT.jar</span><br><span class=\"line\">port=9086</span><br><span class=\"line\">path=/usr/local/hsmj/project</span><br><span class=\"line\">deploy_path=/usr/local/hsmj/project/deploy</span><br><span class=\"line\">log_path=/data/log/hsmj/</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"echo-输出控制台信息\"><a href=\"#echo-输出控制台信息\" class=\"headerlink\" title=\"echo 输出控制台信息\"></a>echo 输出控制台信息</h4><blockquote>\n<p>Shell 的 echo 指令与 PHP 的 echo 指令类似，都是用于字符串的输出。</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">echo this is app : $app</span><br><span class=\"line\">echo port : $port</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"1-显示普通字符串\"><a href=\"#1-显示普通字符串\" class=\"headerlink\" title=\"1.显示普通字符串:\"></a>1.显示普通字符串:</h5><p><code>echo &quot;It is a test&quot;</code><br>这里的双引号完全可以省略，以下命令与上面实例效果一致：<br><code>echo It is a test</code></p>\n<h5 id=\"2-显示转义字符\"><a href=\"#2-显示转义字符\" class=\"headerlink\" title=\"2.显示转义字符\"></a>2.显示转义字符</h5><p><code>echo &quot;\\&quot;It is a test\\&quot;&quot;</code><br>结果将是:<br><code>&quot;It is a test&quot;</code><br>同样，双引号也可以省略</p>\n<h5 id=\"3-显示变量\"><a href=\"#3-显示变量\" class=\"headerlink\" title=\"3.显示变量\"></a>3.显示变量</h5><p>read 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量<br><code>#!/bin/sh read name echo &quot;$name It is a test&quot;</code><br>以上代码保存为 test.sh，name 接收标准输入的变量，结果将是:<br><code>[root@www ~]# sh test.sh OK #标准输入 OK It is a test #输出</code></p>\n<h5 id=\"4-显示换行\"><a href=\"#4-显示换行\" class=\"headerlink\" title=\"4.显示换行\"></a>4.显示换行</h5><p><code>echo -e &quot;OK! \\n&quot; # -e 开启转义 echo &quot;It is a test&quot;</code><br>输出结果：<br><code>OK! It is a test</code></p>\n<h5 id=\"5-显示不换行\"><a href=\"#5-显示不换行\" class=\"headerlink\" title=\"5.显示不换行\"></a>5.显示不换行</h5><p><code>#!/bin/sh echo -e &quot;OK! \\c&quot; # -e 开启转义 \\c 不换行 echo &quot;It is a test&quot;</code><br>输出结果：<br><code>OK! It is a test</code></p>\n<h5 id=\"6-显示结果定向至文件\"><a href=\"#6-显示结果定向至文件\" class=\"headerlink\" title=\"6.显示结果定向至文件\"></a>6.显示结果定向至文件</h5><p><code>echo &quot;It is a test&quot; &gt; myfile</code></p>\n<h5 id=\"7-原样输出字符串，不进行转义或取变量-用单引号\"><a href=\"#7-原样输出字符串，不进行转义或取变量-用单引号\" class=\"headerlink\" title=\"7.原样输出字符串，不进行转义或取变量(用单引号)\"></a>7.原样输出字符串，不进行转义或取变量(用单引号)</h5><p><code>echo &#39;$name\\&quot;&#39;</code><br>输出结果：<br><code>$name\\&quot;</code></p>\n<h5 id=\"8-显示命令执行结果\"><a href=\"#8-显示命令执行结果\" class=\"headerlink\" title=\"8.显示命令执行结果\"></a>8.显示命令执行结果</h5><p><code>echo </code>date`` <strong>注意：</strong> 这里使用的是反引号 **<code>**, 而不是单引号 **&#39;\\*\\*。 结果将显示当前日期 </code>Thu Jul 24 10:08:46 CST 2014`</p>\n<h4 id=\"加下来这段代码表示-如果项目已经启动了，可以杀死旧的进程\"><a href=\"#加下来这段代码表示-如果项目已经启动了，可以杀死旧的进程\" class=\"headerlink\" title=\"加下来这段代码表示 如果项目已经启动了，可以杀死旧的进程\"></a>加下来这段代码表示 如果项目已经启动了，可以杀死旧的进程</h4><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">若项目已启动，杀死旧进程</span></span><br><span class=\"line\">appId=`ps -ef | grep &quot;$app&quot; | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class=\"line\">echo appId = $appId</span><br><span class=\"line\">if [ &quot;$appId&quot; != &quot;&quot; ]; then</span><br><span class=\"line\">echo kill $appId</span><br><span class=\"line\">kill -9 $appId</span><br><span class=\"line\">echo sleep 3s</span><br><span class=\"line\">sleep 1</span><br><span class=\"line\">echo sleep 2s</span><br><span class=\"line\">sleep 1</span><br><span class=\"line\">echo sleep 1s</span><br><span class=\"line\">sleep 1</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"shell-的变量可以定义一长串的代码\"><a href=\"#shell-的变量可以定义一长串的代码\" class=\"headerlink\" title=\"shell 的变量可以定义一长串的代码\"></a>shell 的变量可以定义一长串的代码</h5><p><code>appId=</code>ps -ef | grep “$app” | grep -v grep | awk ‘{print $2}’``</p>\n<h5 id=\"判断语句-if-then-fi\"><a href=\"#判断语句-if-then-fi\" class=\"headerlink\" title=\"判断语句(if[]; then fi)\"></a>判断语句(<code>if[]; then fi</code>)</h5><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">if [ &quot;$appId&quot; != &quot;&quot; ]; then</span><br><span class=\"line\">xxx</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"并且使用-xxx-来调用变量\"><a href=\"#并且使用-xxx-来调用变量\" class=\"headerlink\" title=\"并且使用 $xxx 来调用变量\"></a>并且使用 $xxx 来调用变量</h5><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">echo appId = $appId</span><br><span class=\"line\">if [ &quot;$appId&quot; != &quot;&quot; ]; then</span><br><span class=\"line\">echo kill $appId</span><br><span class=\"line\">kill -9 $appId</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"sleep-1表示休眠-1-秒\"><a href=\"#sleep-1表示休眠-1-秒\" class=\"headerlink\" title=\"sleep 1表示休眠 1 秒\"></a><code>sleep 1</code>表示休眠 1 秒</h4><h4 id=\"shell-当然也可以使用-linux-中的命令，并使用调用变量的形式，让代码更加灵活\"><a href=\"#shell-当然也可以使用-linux-中的命令，并使用调用变量的形式，让代码更加灵活\" class=\"headerlink\" title=\"shell 当然也可以使用 linux 中的命令，并使用调用变量的形式，让代码更加灵活\"></a>shell 当然也可以使用 linux 中的命令，并使用调用变量的形式，让代码更加灵活</h4><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">将jar包从jenkins工作空间中移动到指定路径下</span></span><br><span class=\"line\">rm -rf $deploy_path/$app</span><br><span class=\"line\">mv $path/$app $deploy_path/$app</span><br><span class=\"line\">cd $deploy_path</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">防止进程被杀死</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">BUILD_ID=dontKillMe</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">后台进程形式启动项目</span></span><br><span class=\"line\">JAVA_HOME=/usr/local/java</span><br><span class=\"line\">echo &quot;java环境&quot;+$JAVA_HOME</span><br><span class=\"line\">nohup $JAVA_HOME/bin/java -jar -Dserver.port=$port -Dspring.profiles.active=test -Xmx256m -Xms128m  $deploy_path/$app  &gt;/dev/null  2&gt;&amp;1 &amp;</span><br><span class=\"line\">echo $app start success</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"最后exit-退出程序\"><a href=\"#最后exit-退出程序\" class=\"headerlink\" title=\"最后exit 退出程序\"></a>最后<code>exit </code>退出程序</h4><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">exit  0：正常运行程序并退出程序；</span><br><span class=\"line\"></span><br><span class=\"line\">exit  1：非正常运行导致退出程序；</span><br><span class=\"line\"></span><br><span class=\"line\">exit 0 可以告知你的程序的使用者：你的程序是正常结束的。如果 exit 非 0 值，那么你的程序的使用者通常会认为</span><br><span class=\"line\">你的程序产生了一个错误。</span><br><span class=\"line\">在 shell 中调用完你的程序之后，用 echo $? 命令就可以看到你的程序的 exit 值。在 shell 脚本中，通常会根据</span><br><span class=\"line\">上一个命令的 $? 值来进行一些流程控制。0代表程序正确的执行，如下图例子所示：</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Shell-批量处理\"><a href=\"#Shell-批量处理\" class=\"headerlink\" title=\"Shell 批量处理\"></a>Shell 批量处理</h3><blockquote>\n<p>如果有多个项目需要脚本来启动，每个都写脚本比较繁杂，可以考虑用 for 循环来批量处理</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\">path=/usr/local/hsmj/project</span><br><span class=\"line\">deploy_path=/usr/local/hsmj/project/deploy</span><br><span class=\"line\">array=([1]=hsmj-desk-app.sh [2]=hsmj-flow-app.sh [3]=hsmj-sys-app.sh [4]=hsmj-spt-app.sh  [5]=hsmj-auth.sh [6]=hsmj-autho.sh [7]=hsmj-gateway.sh [8]=hsmj-cpa-app.sh [9]=hsmj-comp-app.sh  [10]=hsmj-cust-app.sh [11]=hsmj-ctm-app.sh [12]=hsmj-ctm-api.sh [13]=hsmj-cto-app.sh [14]=hsmj-cto-job.sh )</span><br><span class=\"line\"></span><br><span class=\"line\">for file in `ls $deploy_path`</span><br><span class=\"line\"></span><br><span class=\"line\">do</span><br><span class=\"line\"></span><br><span class=\"line\">if [[ $file == hsmj-*.jar ]]; then</span><br><span class=\"line\">\tmv $deploy_path/$file $path/$file</span><br><span class=\"line\">\techo &quot;move &quot;$file&quot; success&quot;</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\">for b in $&#123;array[*]&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">do</span><br><span class=\"line\"></span><br><span class=\"line\">sh $path/$b</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;run &quot;$path/$b&quot; success&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">done</span><br><span class=\"line\">。、</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"这里-表示定义的数组，存入需要操作的项目\"><a href=\"#这里-表示定义的数组，存入需要操作的项目\" class=\"headerlink\" title=\"这里 表示定义的数组，存入需要操作的项目\"></a>这里 表示定义的数组，存入需要操作的项目</h4><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">array=([1]=hsmj-desk-app.sh [2]=hsmj-flow-app.sh [3]=hsmj-sys-app.sh [4]=hsmj-spt-app.sh  [5]=hsmj-auth.sh [6]=hsmj-autho.sh [7]=hsmj-gateway.sh [8]=hsmj-cpa-app.sh [9]=hsmj-comp-app.sh  [10]=hsmj-cust-app.sh [11]=hsmj-ctm-app.sh [12]=hsmj-ctm-api.sh [13]=hsmj-cto-app.sh [14]=hsmj-cto-job.sh )</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"for-in-do-done进行循环操作\"><a href=\"#for-in-do-done进行循环操作\" class=\"headerlink\" title=\"for in do done进行循环操作\"></a><code>for in do done</code>进行循环操作</h4><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">for file in `ls $deploy_path`</span><br><span class=\"line\"></span><br><span class=\"line\">do</span><br><span class=\"line\"></span><br><span class=\"line\">if [[ $file == hsmj-*.jar ]]; then</span><br><span class=\"line\">\tmv $deploy_path/$file $path/$file</span><br><span class=\"line\">\techo &quot;move &quot;$file&quot; success&quot;</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n\n<p><code>for file in </code>ls $deploy_path``可以在循环目录下的所有文件 <code>if [[$file == hsmj-*.jar]]; </code>*模糊匹配文件名</p>\n<h2 id=\"记录下-shell-使用中遇到的问题\"><a href=\"#记录下-shell-使用中遇到的问题\" class=\"headerlink\" title=\"记录下 shell 使用中遇到的问题\"></a>记录下 shell 使用中遇到的问题</h2><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost project]# ./ctm-all.sh</span><br><span class=\"line\">-bash: ./ctm-all.sh: 权限不够</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"刚创建的脚本权限不足导致的错误；需要我们先给这个脚本赋权限；\"><a href=\"#刚创建的脚本权限不足导致的错误；需要我们先给这个脚本赋权限；\" class=\"headerlink\" title=\"刚创建的脚本权限不足导致的错误；需要我们先给这个脚本赋权限；\"></a>刚创建的脚本权限不足导致的错误；需要我们先给这个脚本赋权限；</h4><p>解决方法：<br>使用<code>chmod +x ctm-all.sh</code> 即可解决；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost project]# ./ctm-all.sh</span><br><span class=\"line\">-bash: ./ctm-all.sh: /bin/bash^M: 坏的解释器: 没有那个文件或目录</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"接着遇到的这个问题是，我的脚本在-Windows-中编写，导入-Linux-中运行的，因为在-Windows-中换行符为-r-n，linux-下换行符为-n；所导致的问题\"><a href=\"#接着遇到的这个问题是，我的脚本在-Windows-中编写，导入-Linux-中运行的，因为在-Windows-中换行符为-r-n，linux-下换行符为-n；所导致的问题\" class=\"headerlink\" title=\"接着遇到的这个问题是，我的脚本在 Windows 中编写，导入 Linux 中运行的，因为在 Windows 中换行符为 \\r\\n，linux 下换行符为 \\n；所导致的问题\"></a>接着遇到的这个问题是，我的脚本在 Windows 中编写，导入 Linux 中运行的，因为在 Windows 中换行符为 \\r\\n，linux 下换行符为 \\n；所导致的问题</h4><p>解决方法：<br>只需要去掉多余的 \\r 回车符 即可。操作办法可以用 sed 命令进行全局替换<br><code>sed &#39;s/\\r//&#39; -i ctm-all.sh</code></p>\n","site":{"data":{"bangumis":{"wantWatch":[],"watching":[{"title":"凡人修仙传","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/70d11dfab23a3ee81ccf64f18efa139416a633ff.jpg@220w_280h.webp","totalCount":"未完结","id":28223043,"follow":"615.7 万","view":"8.9 亿","danmaku":"490.9 万","coin":"1186.9 万","score":9.7,"des":"看机智的凡人小子韩立如何稳健发展、步步为营，战魔道、夺至宝、驰骋星海、快意恩仇，成为纵横三界的强者。他日仙界重相逢，一声道友尽沧桑。..."},{"title":"恋爱游戏世界对路人角色很不友好","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/c9723d8c77d881a8debba2852d580e97826b43d0.png@220w_280h.webp","totalCount":"全12话","id":28237300,"follow":"151.2 万","view":"5120.4 万","danmaku":"40.6 万","coin":"24.5 万","score":9.1,"des":"从现代日本转生到“恋爱游戏”世界的里昂，发现这里女尊男卑，对男性很不友好。身为路人角色的他，为了摆脱自己因地位低下而被肆意决定的人生，决定活用从游戏中得到的知识，保持路人角色的身份，取得“失落物品”来..."},{"title":"魔法纪录 魔法少女小圆外传 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/9eef1df9ab157be52d2c4d70d3500442f00cafc3.png@220w_280h.webp","totalCount":"全12话","id":28234642,"follow":"237.1 万","view":"907.6 万","danmaku":"5.0 万","coin":"4.9 万","score":7.7,"des":"愿望的代价，究竟是希望还是绝望——。"},{"title":"小林家的龙女仆 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/847e9dbb6876fb37a30199a5c88910704976d45b.png@220w_280h.webp","totalCount":"全13话","id":28234613,"follow":"855.7 万","view":"1.1 亿","danmaku":"49.0 万","coin":"69.0 万","score":9.6,"des":"那位不可思议的龙女仆再度登场！\n因为各种奇妙的原因而作为小林家的女仆而工作中的龙·托尔。\n偶尔（胡说，是经常）给亲爱的小林添麻烦，总算是融入了人类社会，成为了一个完美的（骗人，也就还行）女仆。\n同样是..."},{"title":"国王排名","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/376d7e69a667bcb1c0b934a4e35e07e7fa23110b.png@220w_280h.webp","totalCount":"全23话","id":28235154,"follow":"927.7 万","view":"4.8 亿","danmaku":"250.1 万","coin":"260.9 万","score":7,"des":"国家的丰饶、麾下勇者的数量、\n以及国王本人如何像勇者一般强大，\n这些要素的综合排名，便是所谓的“国王排名”。\n主人公波吉是国王排名第七名的伯斯王治下王国的第一王子。\n但是波吉却生来又聋又哑，贫弱到挥不..."},{"title":"阿松 第三季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0212baa8898d0c819c7fb84015e95b8fca621435.png@220w_280h.webp","totalCount":"全25话","id":28229892,"follow":"67.6 万","view":"938.0 万","danmaku":"13.0 万","coin":"5.4 万","score":9.6,"des":"日本最有名的六胞胎的传说，第三次开幕！！这次会有怎样意想不到的新展开！？..."},{"title":"命运-冠位指定 冠位时间神殿所罗门","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0e094b798388da19a4feffa6a6dabc1dc1dc90cd.jpg@220w_280h.webp","totalCount":"全1话","id":28236225,"follow":"525.5 万","view":"1220.0 万","danmaku":"8.9 万","coin":"15.1 万","score":8.5,"des":"在经过七个特异点的大战后，\n人理存续保障机关迦勒底，终于到达了圣杯探索的最终地点——终局特异点 冠位时间神殿所罗门。\n他们要击败身为罪魁祸首的魔术王所罗门，夺回未来。\n在开战的前一刻，一行人各自度过了..."},{"title":"JOJO的奇妙冒险 星尘远征军","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/47c0108259355d6d2c517ed97f6b90fb777f844f.png@220w_280h.webp","totalCount":"全24话","id":28223481,"follow":"444.2 万","view":"1.5 亿","danmaku":"463.4 万","coin":"45.7 万","score":9.8,"des":"时为1987年，乔瑟夫·乔斯达与“柱之男”们之间的死战后过了50年……乔瑟夫为了为了帮助“被恶灵附身了”的外孙子·空条承太郎而来到了日本。原来那并不是恶灵而是幽波纹（替身）。替身突然出现的原因在于，从..."},{"title":"JOJO的奇妙冒险 星尘远征军 埃及篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f6709b76e88f50aa132d1e09e2d8de9663a09b3e.png@220w_280h.webp","totalCount":"全24话","id":28223483,"follow":"421.9 万","view":"1.3 亿","danmaku":"468.7 万","coin":"44.3 万","score":9.9,"des":"在乔斯达家的宿敌·迪奥（DIO）复活的影响下，一位年轻人——空条承太郎，得到了名为“幽波纹（替身）”的能力。为了拯救因迪奥的诅咒而倒下的母亲荷莉，空条承太郎与外祖父·乔瑟夫以及伙伴们，一起为了打倒迪奥..."},{"title":"JOJO的奇妙冒险 不灭钻石","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/6a04c87e990ab74cd8d555ef45a863de0993b161.png@220w_280h.webp","totalCount":"全39话","id":140552,"follow":"302.3 万","view":"2.1 亿","danmaku":"813.8 万","coin":"55.9 万","score":9.8,"des":"在埃及与宿敌DIO的死斗之后过了11年。1999年，空条承太郎为了与祖父乔瑟夫·乔斯达的私生子东方仗助见面，而来到了日本M县S市杜王町。但，仗助却持有与承太郎相同的特殊能力“替身”。之后，以承太郎的来..."},{"title":"命运-冠位嘉年华","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/c660976f4502a544d990a882ae62194b57753a71.png@220w_280h.webp","totalCount":"全2话","id":28234639,"follow":"479.8 万","view":"862.4 万","danmaku":"4.1 万","coin":"9.1 万","score":9.8,"des":"一起庆祝吧！为了这奇迹般的嘉年华！"},{"title":"伍六七","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/b69e26d9e50514f3fa99eac9ab5aabf2a6e28c88.jpg@220w_280h.webp","totalCount":"全13话","id":6360,"follow":"585.8 万","view":"3.3 亿","danmaku":"227.1 万","coin":"191.8 万","score":9.8,"des":"在某个小岛上，有一个可以伪装成任何东西的廉价刺客，名叫伍六七。平时看上去是个理发师，其实背地里却做着刺客生意。热爱理发事业，喜欢给人剪头发，善用剪刀——剪刀也是他的刺杀武器。由于初入刺客行当，行情十分..."},{"title":"命运-冠位指定 -月光／失落之室-","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3fa5fd2b7afae827b0bf150d7f0cbfc54eda1ff2.png@220w_280h.webp","totalCount":"全1话","id":28234950,"follow":"483.3 万","view":"551.2 万","danmaku":9696,"coin":"2.9 万","score":9.5,"des":"失落之室——。\n这是一个可以看到被夺去亦或是遗失之物的地方。\n这是位于迦勒底被遗忘的角落，不属于任何人的地方。..."},{"title":"致不灭的你","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/1ae94fbb35d8e23bb84926b694509f8b057f96e6.png@220w_280h.webp","totalCount":"全20话","id":28233896,"follow":"476.3 万","view":"1.3 亿","danmaku":"140.1 万","coin":"95.0 万","score":9.6,"des":"本剧讲述了一个情节跌宕、场面宏大的奇幻故事，通过拥有不灭之身的主人公“不死”来探索人生哲理。\n不死起初是一个被投放到人世间的“球”。\n\n它具有“幻化为刺激源形态的能力”和“死后重生的能力”。\n\n先后从..."},{"title":"来自新世界","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/aaa60f9cb17fb4a38df464f1064ca9623e0769cc.jpg@220w_280h.webp","totalCount":"全25话","id":1598,"follow":"115.9 万","view":"1540.9 万","danmaku":"76.3 万","coin":"5.7 万","score":9.5,"des":"1000年后的日本，孩子们不断地消失，只存在想象中的恐怖动物与人类展开殊死战争。反乌托邦式的未来超级社会“新世界”，是口吐真言凭藉“咒力”就能移动物体的人类，与有着等同于普通人智力的生物“妖鼠”共存的..."},{"title":"转生成蜘蛛又怎样！","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f0796e37abac25ba2aa9f23120646aaa9a3d5ea7.png@220w_280h.webp","totalCount":"全24话","id":28231809,"follow":"600.0 万","view":"3.7 亿","danmaku":"190.3 万","coin":"164.6 万","score":7.8,"des":"曾经是一名女高中生的“我”，突然转生变成了幻想世界中的蜘蛛魔物。\n而且，出生地点还是各种凶恶魔物所盘踞的大迷宫。\n“我”以人类的智慧和非同寻常的积极心态为武器，使用蜘蛛的丝网以及陷阱打倒比自己等级高得..."},{"title":"装甲重拳/MEGALOBOX 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/e14dc4a935397fc074c7a12d9520225615209025.png@220w_280h.webp","totalCount":"全13话","id":28233916,"follow":"244.9 万","view":"3435.4 万","danmaku":"19.7 万","coin":"53.1 万","score":9.9,"des":"再一次，为梦想而活——\n\n将肉体与“装甲技术”融合的究极格斗技“装甲拳击”。\n在决出其顶点之人的大会“重拳之巅”上，身穿装甲用自己肉身挑战一切的拳击手“JOE”。\n\n从最下层的比赛开始仅仅花了三个月就..."},{"title":"机动战士高达SEED HD","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/855c88677267d707ebfe4040403692ff2c0938f0.png@220w_280h.webp","totalCount":"全48话","id":497,"follow":"54.8 万","view":"4044.4 万","danmaku":"114.4 万","coin":"6.0 万","score":9.6,"des":"《机动战士高达SEED》是高达系列在2002年至2003年度放映的动画。续作为《机动战士高达SEED Destiny》在2004年播放。因各具魅力的角色，明星云集的声优阵容和高度商业化的宣传而受到较低..."},{"title":"夏目友人帐 唤石者与怪异的访客","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6cf43708b779cde84ad285ff4e3a080de98df0af.png@220w_280h.webp","totalCount":"全1话","id":28234316,"follow":"567.1 万","view":"1374.8 万","danmaku":"18.1 万","coin":"17.9 万","score":9.9,"des":"本作由【唤石者】与【怪异的访客】两个人气短篇集锦而成。讲述生来便能看见各种妖怪的夏目，与自称保镖的猫咪老师一同邂逅的一系列温暖故事。\n【唤石者】一天夏目在森林中遇到一只小妖怪——密实。密实称自己肩负「..."},{"title":"Fate/Grand Order ‐First Order‐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/b75c55d209d156c8631f5ceb21e5c52c834dbb60.jpg@220w_280h.webp","totalCount":"全1话","id":5747,"follow":"250.9 万","view":"3329.7 万","danmaku":"76.7 万","coin":"10.7 万","score":8.3,"des":"【2016年12月31日bilibili独播】2015年。示巴所观测到的未来领域毫无前兆地消失。根据计算，发现——不，是证明了人类将于2017年灭绝。人理延续保障机构·迦勒底将“无法观测的领域”假定为..."},{"title":"伍六七之玄武国篇","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/00843865ea13702eccc4efd64c313fd4c8029c6b.jpg@220w_280h.webp","totalCount":"全10话","id":28232253,"follow":"999.4 万","view":"4.0 亿","danmaku":"177.7 万","coin":"385.3 万","score":9.8,"des":"为了保护小鸡岛居民和这里平静的生活，伍六七和他的伙伴大保和小飞开启了去往玄武国的冒险旅程，去寻找身世的真相和解救小岛的办法，等待他们的又将是更多的未知与奇遇。..."},{"title":"堀与宫村","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/039c4e0b14e27c7a9e5cce2f20a6efd3c8909401.png@220w_280h.webp","totalCount":"全13话","id":28231840,"follow":"695.2 万","view":"2.2 亿","danmaku":"242.1 万","coin":"361.4 万","score":9.8,"des":"不论是谁，都会有不想被人知道的一面。\n\n在学校中漂亮大方、成绩优秀的人气女生堀，私下却打扮土气、忙于家务和照顾弟弟。\n在学校中是阴暗宅男形象的宫村，生活中却是打扮时尚、带耳钉的帅气男生。\n因为一次特别..."},{"title":"奇蛋物语 / WONDER EGG PRIORITY","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/10e0bbc1047b2c45f0f881de334a6f3bfb42a3b6.png@220w_280h.webp","totalCount":"全12话","id":28231851,"follow":"254.9 万","view":"4686.8 万","danmaku":"47.6 万","coin":"65.5 万","score":9.7,"des":"14岁少女·大户爱在深夜散步的途中，\n随着神秘声音的指引，获得了一枚「蛋」。\n\n「如果想要改变世界的话」\n「那么就在现在做出选择」\n「请相信自己——」\n「打破这枚蛋——」\n\n而在打破「蛋」之后，等待着..."},{"title":"Re：从零开始的异世界生活 第二季 后半","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/4f3edbede7fc0bdb52842075cf8faaa1c5953eaa.png@220w_280h.webp","totalCount":"全12话","id":28232073,"follow":"849.9 万","view":"9308.1 万","danmaku":"108.1 万","coin":"230.1 万","score":9.9,"des":"我一定会拯救你。\n在打倒了魔女教大罪司教「怠惰」担当——培提其乌斯·罗曼尼康帝之后，菜月昴和爱蜜莉雅又得以重新开始。\n克服了艰难的诀别，两人终于和解，然而这只是新一轮风波的序幕。\n超乎想象的绝境危机，..."},{"title":"灰与幻想的格林姆迦尔","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/7fb4945f864e9e988212b7d20f206df2677053f8.jpg@220w_280h.webp","totalCount":"全12话","id":106512,"follow":"172.0 万","view":"2343.4 万","danmaku":"63.8 万","coin":"18.3 万","score":9.8,"des":"电视动画《灰与幻想的格林姆迦尔》改编自日本轻小说家十文字青原作白井锐利插画的同名轻小说。\n我们为什么要这么做…？\n哈尔希洛回过神来，才发现自己身处在黑暗当中，他完全不知道自己人在何处，也不明白这个地方..."},{"title":"龙与虎","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/144910805f172d16c5f544f43939a05d8ca20576.jpg@220w_280h.webp","totalCount":"全26话","id":1672,"follow":"336.9 万","view":"6671.9 万","danmaku":"511.9 万","coin":"61.5 万","score":9.7,"des":"樱花飞舞的四月，全新的高中二年级，新的班级……\n眼神凶恶的普通男孩——高须龙儿，遇上了众人害怕、凶暴残忍的“掌中老虎”逢坂大河，还知道了她不欲为人知的秘密。这就是龙虎相争爱与战斗的序幕。\n再加上总是笑..."},{"title":"机动战士高达 铁血的奥尔芬斯 第一季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/f84a80d731d0431c00903d8951fd66623d8237f7.png@220w_280h.webp","totalCount":"全25话","id":4310042,"follow":"62.4 万","view":"2318.6 万","danmaku":"52.2 万","coin":"5.4 万","score":9.5,"des":"主人公三日月·奥古斯，从所属的民间警备公司克律塞安保公司（下称CGS）那里，接受了对少女库德莉亚·蓝那·伯恩斯坦的护卫任务。但CGS受到了摘取反叛之芽的武力组织加拉尔霍恩的袭击，于是在把三日月当做诱饵..."},{"title":"机动战士高达00 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1d7a969e8f1045739c596de89a963e30475aff0e.jpg@220w_280h.webp","totalCount":"全25话","id":1193,"follow":"37.2 万","view":"2458.1 万","danmaku":"61.4 万","coin":"4.1 万","score":9.8,"des":"天人与联合国军的最终决战后过了四年。建立地球联邦政府的人类，为了追求更进一步的国家间之统合，以及人类意识的统一，在联合正规军之外，设立了独立治安维持部队“A-Laws”，目的为对所有危害联合的势力与主..."},{"title":"机动战士高达00","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/35b11bf59eb3fd12f0387951510a5d722d7435e5.jpg@220w_280h.webp","totalCount":"全25话","id":1192,"follow":"62.1 万","view":"2465.5 万","danmaku":"53.6 万","coin":"4.6 万","score":9.7,"des":"在西历2307年，虽然化石燃料枯竭了，但是人类得到了截然不同的新型能源。三台巨大的轨道升降机以及伴随它们的大规模的太阳光发电系统。但是能得到这个系统恩惠的，只有一部分大国和其同盟国而已。\n拥有三台轨道..."},{"title":"Re：从零开始的异世界生活 第二季 前半","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f2425cbdb07cc93bd0d3ba1c0099bfe78f5dc58a.png@220w_280h.webp","totalCount":"全13话","id":28229233,"follow":"774.2 万","view":"1.3 亿","danmaku":"201.4 万","coin":"126.7 万","score":9.7,"des":"我一定会拯救你。\n在打倒了魔女教大罪司教「怠惰」担当——培提其乌斯·罗曼尼康帝之后，菜月昴和爱蜜莉雅又得以重新开始。\n克服了艰难的诀别，两人终于和解，然而这只是新一轮风波的序幕。\n超乎想象的绝境危机，..."},{"title":"超级小白","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3d3e8257d22596f5d3e4395ca759bd1e0fe9b873.jpg@220w_280h.webp","totalCount":"全48话","id":28222671,"follow":"27.4 万","view":"978.0 万","danmaku":"3.6 万","coin":"3.6 万","score":9.6,"des":"为了阻止企图霸占世界的黑暗势力，野原家的普通小狗——小白接肩负重大使命，变身成为了守护世界的“超级小白”。小白将要面对的不仅是发明狗，还有其他意想不到的对手。当然，面对邪恶势力，小白也有着令人惊讶的超..."},{"title":"Re：从零开始的异世界生活 新编集版","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3c125e1aad08643e3eff2fb7d45e740c1a052725.png@220w_280h.webp","totalCount":"全13话","id":28224394,"follow":"631.1 万","view":"7674.2 万","danmaku":"166.2 万","coin":"51.1 万","score":9.6,"des":"在从便利商店回家的路上，突然被异世界召唤的少年菜月昴。在无法依靠任何东西的异世界，无力的少年手唯一的力量……那是“死去然后重新开始”的力量。为了守护最重要的人们，为了取回确实存在着又无可替代的时间，少..."},{"title":"因为太怕痛就全点防御力了","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/8021d3f6b0df6dbba6d32f76eb9cfe2531e166c4.png@220w_280h.webp","totalCount":"全12话","id":28224137,"follow":"620.6 万","view":"2.3 亿","danmaku":"326.8 万","coin":"103.8 万","score":9,"des":"主角本条枫在好友白峰理沙推荐下开始游玩游戏“NewWorld Online”，创建了名为“梅普露”的角色。然而作为游戏初学者，梅普露选择了不受欢迎的大盾当武器，同时因为怕痛而把所有状态点加到防御力的极..."},{"title":"冰海战记","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/c30401817895e67399094b4e669785a104270cdf.jpg@220w_280h.webp","totalCount":"全24话","id":28220475,"follow":"174.4 万","view":"4893.8 万","danmaku":"48.7 万","coin":"36.7 万","score":9.8,"des":"公元10世纪末期，出现了在世界各地出没的最强民族。被讴歌为最强战士的托尔兹，其子托尔芬幼时便生活在战场上，并向往着梦幻大陆“文兰”。这是一个发生在激荡时代的，真正的英雄物语。..."},{"title":"齐木楠雄的灾难 始动篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ba59822eded39b5254fb01448a7f1502101d5624.png@220w_280h.webp","totalCount":"全6话","id":28223748,"follow":"372.4 万","view":"3054.5 万","danmaku":"20.0 万","coin":"17.8 万","score":9.8,"des":"在电视剧中堪称帅气的超能力，对于高中生齐木楠雄来说只是招致灾难的元凶。作为新动画系列展开的楠雄的日常又会如何！？..."},{"title":"OVERLORD Ⅱ","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/851f979c8ebcc7583a43abd4b786c4e2e66b746b.jpg@220w_280h.webp","totalCount":"全13话","id":8792,"follow":"539.3 万","view":"3.8 亿","danmaku":"413.9 万","coin":"114.1 万","score":9.6,"des":"时为2138年。曾卷起一大风潮的虚拟现实体感型网络游戏《YGGDRASIL》即将迎来停服。玩家飞鼠在曾经以同伴和荣华自傲的根据地纳萨力克地下大坟墓，独自一人安静等待着那一刻。但是，不料发生了结束时间已..."},{"title":"夏目友人帐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/99c549494d9425f6455bd45a151f4d26397d6151.png@220w_280h.webp","totalCount":"全13话","id":1660,"follow":"324.0 万","view":"4975.2 万","danmaku":"278.7 万","coin":"15.5 万","score":9.8,"des":"夏目贵志生来拥有强大的灵力，能感知平常人所无法接触的妖怪神明的存在。因父母双亡，他多年间辗转于互相推卸责任的亲戚之间，又受到同龄人的欺负，未曾与任何人深交，造成性格一定程度上的孤僻。夏目本性和善，对于..."}],"watched":[{"title":"装甲重拳/MEGALOBOX","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0c44785cb5d25cc9f648800d251f21a2e236bb8a.png@220w_280h.webp","totalCount":"全13话","id":79472,"follow":"221.9 万","view":"6162.0 万","danmaku":"48.6 万","coin":"32.9 万","score":9.8,"des":"将肉体与“装甲技术”融合的究极格斗技——“MEGALOBOX”，将自己的全部赌在上面的男人们的热血战斗开始！\n今天也立于未认可地区的赌博比赛赛场上的MEGALO拳击手“JNK DOG”。虽然具备实力，..."},{"title":"超能力女儿","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/152c536f8ecaad8f3d7d568d33da81c963a4a722.png@220w_280h.webp","totalCount":"全12话","id":78352,"follow":"293.8 万","view":"9252.2 万","danmaku":"98.5 万","coin":"35.4 万","score":9.6,"des":"支持着芦川组的年轻智力型黑道新田义史，过着被喜欢的壶所包围的悠然自得单身生活。但某一天，随着装在神秘物体里的少女雏来到他家，他的生活为之一变。他被能使用念动力的雏所胁迫，迫不得已开始和她同居！\n容易暴..."},{"title":"OVERLORD Ⅲ","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/dd7a9d0a0bee32b1f43c2656398d8463d12b3069.jpg@220w_280h.webp","totalCount":"全13话","id":102252,"follow":"551.6 万","view":"4.0 亿","danmaku":"399.7 万","coin":"129.2 万","score":9.4,"des":"时间为2138年。曾卷起一大风潮的虚拟现实体感型网络游戏《YGGDRASIL》即将迎来停服。玩家飞鼠在曾经以同伴和荣华自傲的根据地纳萨力克地下大坟墓，独自一人安静等待着那一刻。\n但是，不料发生了“过了..."},{"title":"路人超能100 第一次灵能咨询所员工旅游～舒缓心灵的疗愈之旅~（OVA2）","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/1271324d51634b68980704731987724a1afc60aa.jpg@220w_280h.webp","totalCount":"全1话","id":28222715,"follow":"318.8 万","view":"520.7 万","danmaku":"3.6 万","coin":"4.6 万","score":9.8,"des":"由原作ONE老师担任原案的完全新作OVA！「灵能咨询所」一行人，龙套与灵幻、小酒窝以及新同伴芹泽的目的地，正是缟马县深山中鲜为人知的温泉·疣神温泉。因为灵幻接受了旅馆老板娘的委托，「弄清温泉的恐怖传闻..."},{"title":"少女终末旅行","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1431ca5bb2f7143062e3df8f21b8448cf8cccc13.jpg@220w_280h.webp","totalCount":"全12话","id":6463,"follow":"239.8 万","view":"3714.7 万","danmaku":"100.7 万","coin":"37.2 万","score":9.8,"des":"本作舞台在人类繁华的文明迎来终结的很久以后，人类基本灭绝，甚至生物都不再存在的末日世界。复杂够高的都市成为迷宫般的废墟，得不到维护的机械渐渐停止运转。连何时终结了，何时开始终结的思考都不复存在的这个世..."},{"title":"齐木楠雄的灾难（日播&精选版）","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/eb4f17335f48951945fb9da47e6ee0bc65fa2fbb.jpg@220w_280h.webp","totalCount":"全120话","id":5070,"follow":"187.0 万","view":"2.3 亿","danmaku":"130.7 万","coin":"32.7 万","score":9.6,"des":"高中生·齐木楠雄是超能力者。心灵感应、念动力、透视、预知、瞬间移动、千里眼等，不论任何事情都自由自在。但这任谁都羡慕不已的最强能力，实际上对于本人而言是引来灾难的不幸元凶。因此，他在别人面前封印了超能..."},{"title":"比宇宙更远的地方","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/c9eca3cbc386c63b27461074b8b218898cb7440e.jpg@220w_280h.webp","totalCount":"全13话","id":13032,"follow":"156.0 万","view":"2298.0 万","danmaku":"45.9 万","coin":"23.9 万","score":9.8,"des":"无论何时，我们的第一步总是从好奇心开始。\n不曾看过的风景，不曾听过的声音，不曾闻过的味道，不曾摸过的质感，不曾尝过的食物，以及不曾感受过的澎湃。\n为了重拾不知何时忘却的记忆碎片和不知何时舍弃的感动的旅..."},{"title":"OVERLORD","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/b8e72ea69e57e0b7ac85d8b4d366554fd866df1a.jpg@220w_280h.webp","totalCount":"全13话","id":2576,"follow":"626.2 万","view":"4.1 亿","danmaku":"385.2 万","coin":"84.4 万","score":9.6,"des":"作品主要讲述了某天，一款曾经掀起过大热潮的VRMMORPG「YGGDRASIL」停止了运营。游戏原本会停止一切服务，但过了结束时间后，玩家们却发现不能退出，NPC也产生了各自的思想。现实世界中喜爱电玩..."},{"title":"路人超能100 II(灵能百分百 第二季)","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/216e1bdaf88244215a13b1154116805ee9adbe07.png@220w_280h.webp","totalCount":"全13话","id":4762734,"follow":"284.9 万","view":"1.0 亿","danmaku":"97.8 万","coin":"56.1 万","score":9.9,"des":"当有什么东西达到“100”的时候，就会爆发的少年·路人（龙套）。外表极其普通——不如说是不起眼。不擅长迎合气氛的他，实际上拥有着强力的超能力。盯上了这样的他的能力，而接连现身的伪灵能力者以及宗教团体、..."},{"title":"多罗罗","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3fc16a667502cbff226e585eb660a96a20c7458c.png@220w_280h.webp","totalCount":"全24话","id":4312482,"follow":"452.1 万","view":"1.8 亿","danmaku":"143.9 万","coin":"73.9 万","score":9.4,"des":"他们向着命运抗争，在那尽头等待他们的是人心，还是业障。\n时值乱世。\n名为景光的醍醐将军，向某个寺庙殿堂中的12尊魔神像祈求早日结束战乱。\n作为代价，他的嫡子在出生时就失去了身体的某些部位，被丢弃在河流..."},{"title":"魔法少女小圆","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/7fcaa0e98b561611538ae4deba7949cec4ca39a8.png@220w_280h.webp","totalCount":"全12话","id":2539,"follow":"218.7 万","view":"4199.0 万","danmaku":"201.5 万","coin":"20.0 万","score":9.8,"des":"就读初中二年级的鹿目圆，过着平凡幸福的生活。神秘转学生晓美焰的出现，开始让小圆的命运有了巨大转变。某日一只名为丘比的神秘生物，希望小圆能够与它签订魔法契约，成为“魔法少女”以对抗邪恶的魔女保护世界。正..."}]},"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"http://rebp38war.bkt.clouddn.com/img/v2-358cb55f001519e6e76bb920008839da_r.jpg","excerpt":"","more":"<blockquote>\n<p>💡 本质是一个文件，文件里面存放的是 特定格式的指令，系统可以使用脚本解析器 翻译或解析指令并执行</p>\n</blockquote>\n<ul>\n<li>shell 脚本就是说我们把原来 linux 命令或语句放在一个文件中，然后通过这个程序文件去执行时，我们就说这个程序为 shell 脚本或 shell 程序；我们可以在脚本中输入一系统的命令以及相关的语法语句组合，比如变量，流程控制语句等，把他们有机结合起来就形成了一个功能强大的 shell 脚本</li>\n</ul>\n<h1 id=\"记录下-linux-下-shell-脚本的基本使用\"><a href=\"#记录下-linux-下-shell-脚本的基本使用\" class=\"headerlink\" title=\"记录下 linux 下 shell 脚本的基本使用\"></a>记录下 linux 下 shell 脚本的基本使用</h1><p>贴一段项目部署中写的一段 sell 代码：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\">app=hsmj-cpa-app-1.0.0-SNAPSHOT.jar</span><br><span class=\"line\">port=9086</span><br><span class=\"line\">path=/usr/local/hsmj/project</span><br><span class=\"line\">deploy_path=/usr/local/hsmj/project/deploy</span><br><span class=\"line\">log_path=/data/log/hsmj/</span><br><span class=\"line\">echo this is app : $app</span><br><span class=\"line\">echo port : $port</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">若项目已启动，杀死旧进程</span></span><br><span class=\"line\">appId=`ps -ef | grep &quot;$app&quot; | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class=\"line\">echo appId = $appId</span><br><span class=\"line\">if [ &quot;$appId&quot; != &quot;&quot; ]; then</span><br><span class=\"line\">echo kill $appId</span><br><span class=\"line\">kill -9 $appId</span><br><span class=\"line\">echo sleep 3s</span><br><span class=\"line\">sleep 1</span><br><span class=\"line\">echo sleep 2s</span><br><span class=\"line\">sleep 1</span><br><span class=\"line\">echo sleep 1s</span><br><span class=\"line\">sleep 1</span><br><span class=\"line\">fi</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">将jar包从jenkins工作空间中移动到指定路径下</span></span><br><span class=\"line\">rm -rf $deploy_path/$app</span><br><span class=\"line\">mv $path/$app $deploy_path/$app</span><br><span class=\"line\">cd $deploy_path</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">防止进程被杀死</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">BUILD_ID=dontKillMe</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">后台进程形式启动项目</span></span><br><span class=\"line\">JAVA_HOME=/usr/local/java</span><br><span class=\"line\">echo &quot;java环境&quot;+$JAVA_HOME</span><br><span class=\"line\">nohup $JAVA_HOME/bin/java -jar -Dserver.port=$port -Dspring.profiles.active=test -Xmx256m -Xms128m  $deploy_path/$app  &gt;/dev/null  2&gt;&amp;1 &amp;</span><br><span class=\"line\">echo $app start success</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">jps -l</span></span><br><span class=\"line\">exit 0</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"接下逐段解析代码\"><a href=\"#接下逐段解析代码\" class=\"headerlink\" title=\"接下逐段解析代码\"></a>接下逐段解析代码</h2><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>#!用来声明脚本由什么 shell 解释，否则使用默认 shell</strong></p>\n<blockquote>\n<p>有不少时候不规范的写法能够忽略掉这一句，执行起来好像也是 ok，结果没什么不同,linux 系统上默认都是执行/bin/bash 来执行 shell 脚本若是有些用户使用的是 csh，那么缺乏第一行的“#！/bin/bash 的 shell 脚本执行结果就可能存在语法不兼容的问题，致使结果异常或者根本不能执行。linux</p>\n</blockquote>\n<h3 id=\"shell-脚本也支持变量赋值\"><a href=\"#shell-脚本也支持变量赋值\" class=\"headerlink\" title=\"shell 脚本也支持变量赋值\"></a>shell 脚本也支持变量赋值</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">app=hsmj-cpa-app-1.0.0-SNAPSHOT.jar</span><br><span class=\"line\">port=9086</span><br><span class=\"line\">path=/usr/local/hsmj/project</span><br><span class=\"line\">deploy_path=/usr/local/hsmj/project/deploy</span><br><span class=\"line\">log_path=/data/log/hsmj/</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"echo-输出控制台信息\"><a href=\"#echo-输出控制台信息\" class=\"headerlink\" title=\"echo 输出控制台信息\"></a>echo 输出控制台信息</h4><blockquote>\n<p>Shell 的 echo 指令与 PHP 的 echo 指令类似，都是用于字符串的输出。</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">echo this is app : $app</span><br><span class=\"line\">echo port : $port</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"1-显示普通字符串\"><a href=\"#1-显示普通字符串\" class=\"headerlink\" title=\"1.显示普通字符串:\"></a>1.显示普通字符串:</h5><p><code>echo &quot;It is a test&quot;</code><br>这里的双引号完全可以省略，以下命令与上面实例效果一致：<br><code>echo It is a test</code></p>\n<h5 id=\"2-显示转义字符\"><a href=\"#2-显示转义字符\" class=\"headerlink\" title=\"2.显示转义字符\"></a>2.显示转义字符</h5><p><code>echo &quot;\\&quot;It is a test\\&quot;&quot;</code><br>结果将是:<br><code>&quot;It is a test&quot;</code><br>同样，双引号也可以省略</p>\n<h5 id=\"3-显示变量\"><a href=\"#3-显示变量\" class=\"headerlink\" title=\"3.显示变量\"></a>3.显示变量</h5><p>read 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量<br><code>#!/bin/sh read name echo &quot;$name It is a test&quot;</code><br>以上代码保存为 test.sh，name 接收标准输入的变量，结果将是:<br><code>[root@www ~]# sh test.sh OK #标准输入 OK It is a test #输出</code></p>\n<h5 id=\"4-显示换行\"><a href=\"#4-显示换行\" class=\"headerlink\" title=\"4.显示换行\"></a>4.显示换行</h5><p><code>echo -e &quot;OK! \\n&quot; # -e 开启转义 echo &quot;It is a test&quot;</code><br>输出结果：<br><code>OK! It is a test</code></p>\n<h5 id=\"5-显示不换行\"><a href=\"#5-显示不换行\" class=\"headerlink\" title=\"5.显示不换行\"></a>5.显示不换行</h5><p><code>#!/bin/sh echo -e &quot;OK! \\c&quot; # -e 开启转义 \\c 不换行 echo &quot;It is a test&quot;</code><br>输出结果：<br><code>OK! It is a test</code></p>\n<h5 id=\"6-显示结果定向至文件\"><a href=\"#6-显示结果定向至文件\" class=\"headerlink\" title=\"6.显示结果定向至文件\"></a>6.显示结果定向至文件</h5><p><code>echo &quot;It is a test&quot; &gt; myfile</code></p>\n<h5 id=\"7-原样输出字符串，不进行转义或取变量-用单引号\"><a href=\"#7-原样输出字符串，不进行转义或取变量-用单引号\" class=\"headerlink\" title=\"7.原样输出字符串，不进行转义或取变量(用单引号)\"></a>7.原样输出字符串，不进行转义或取变量(用单引号)</h5><p><code>echo &#39;$name\\&quot;&#39;</code><br>输出结果：<br><code>$name\\&quot;</code></p>\n<h5 id=\"8-显示命令执行结果\"><a href=\"#8-显示命令执行结果\" class=\"headerlink\" title=\"8.显示命令执行结果\"></a>8.显示命令执行结果</h5><p><code>echo </code>date`` <strong>注意：</strong> 这里使用的是反引号 **<code>**, 而不是单引号 **&#39;\\*\\*。 结果将显示当前日期 </code>Thu Jul 24 10:08:46 CST 2014`</p>\n<h4 id=\"加下来这段代码表示-如果项目已经启动了，可以杀死旧的进程\"><a href=\"#加下来这段代码表示-如果项目已经启动了，可以杀死旧的进程\" class=\"headerlink\" title=\"加下来这段代码表示 如果项目已经启动了，可以杀死旧的进程\"></a>加下来这段代码表示 如果项目已经启动了，可以杀死旧的进程</h4><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">若项目已启动，杀死旧进程</span></span><br><span class=\"line\">appId=`ps -ef | grep &quot;$app&quot; | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class=\"line\">echo appId = $appId</span><br><span class=\"line\">if [ &quot;$appId&quot; != &quot;&quot; ]; then</span><br><span class=\"line\">echo kill $appId</span><br><span class=\"line\">kill -9 $appId</span><br><span class=\"line\">echo sleep 3s</span><br><span class=\"line\">sleep 1</span><br><span class=\"line\">echo sleep 2s</span><br><span class=\"line\">sleep 1</span><br><span class=\"line\">echo sleep 1s</span><br><span class=\"line\">sleep 1</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"shell-的变量可以定义一长串的代码\"><a href=\"#shell-的变量可以定义一长串的代码\" class=\"headerlink\" title=\"shell 的变量可以定义一长串的代码\"></a>shell 的变量可以定义一长串的代码</h5><p><code>appId=</code>ps -ef | grep “$app” | grep -v grep | awk ‘{print $2}’``</p>\n<h5 id=\"判断语句-if-then-fi\"><a href=\"#判断语句-if-then-fi\" class=\"headerlink\" title=\"判断语句(if[]; then fi)\"></a>判断语句(<code>if[]; then fi</code>)</h5><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">if [ &quot;$appId&quot; != &quot;&quot; ]; then</span><br><span class=\"line\">xxx</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"并且使用-xxx-来调用变量\"><a href=\"#并且使用-xxx-来调用变量\" class=\"headerlink\" title=\"并且使用 $xxx 来调用变量\"></a>并且使用 $xxx 来调用变量</h5><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">echo appId = $appId</span><br><span class=\"line\">if [ &quot;$appId&quot; != &quot;&quot; ]; then</span><br><span class=\"line\">echo kill $appId</span><br><span class=\"line\">kill -9 $appId</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"sleep-1表示休眠-1-秒\"><a href=\"#sleep-1表示休眠-1-秒\" class=\"headerlink\" title=\"sleep 1表示休眠 1 秒\"></a><code>sleep 1</code>表示休眠 1 秒</h4><h4 id=\"shell-当然也可以使用-linux-中的命令，并使用调用变量的形式，让代码更加灵活\"><a href=\"#shell-当然也可以使用-linux-中的命令，并使用调用变量的形式，让代码更加灵活\" class=\"headerlink\" title=\"shell 当然也可以使用 linux 中的命令，并使用调用变量的形式，让代码更加灵活\"></a>shell 当然也可以使用 linux 中的命令，并使用调用变量的形式，让代码更加灵活</h4><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">将jar包从jenkins工作空间中移动到指定路径下</span></span><br><span class=\"line\">rm -rf $deploy_path/$app</span><br><span class=\"line\">mv $path/$app $deploy_path/$app</span><br><span class=\"line\">cd $deploy_path</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">防止进程被杀死</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">BUILD_ID=dontKillMe</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">后台进程形式启动项目</span></span><br><span class=\"line\">JAVA_HOME=/usr/local/java</span><br><span class=\"line\">echo &quot;java环境&quot;+$JAVA_HOME</span><br><span class=\"line\">nohup $JAVA_HOME/bin/java -jar -Dserver.port=$port -Dspring.profiles.active=test -Xmx256m -Xms128m  $deploy_path/$app  &gt;/dev/null  2&gt;&amp;1 &amp;</span><br><span class=\"line\">echo $app start success</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"最后exit-退出程序\"><a href=\"#最后exit-退出程序\" class=\"headerlink\" title=\"最后exit 退出程序\"></a>最后<code>exit </code>退出程序</h4><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">exit  0：正常运行程序并退出程序；</span><br><span class=\"line\"></span><br><span class=\"line\">exit  1：非正常运行导致退出程序；</span><br><span class=\"line\"></span><br><span class=\"line\">exit 0 可以告知你的程序的使用者：你的程序是正常结束的。如果 exit 非 0 值，那么你的程序的使用者通常会认为</span><br><span class=\"line\">你的程序产生了一个错误。</span><br><span class=\"line\">在 shell 中调用完你的程序之后，用 echo $? 命令就可以看到你的程序的 exit 值。在 shell 脚本中，通常会根据</span><br><span class=\"line\">上一个命令的 $? 值来进行一些流程控制。0代表程序正确的执行，如下图例子所示：</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Shell-批量处理\"><a href=\"#Shell-批量处理\" class=\"headerlink\" title=\"Shell 批量处理\"></a>Shell 批量处理</h3><blockquote>\n<p>如果有多个项目需要脚本来启动，每个都写脚本比较繁杂，可以考虑用 for 循环来批量处理</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\">path=/usr/local/hsmj/project</span><br><span class=\"line\">deploy_path=/usr/local/hsmj/project/deploy</span><br><span class=\"line\">array=([1]=hsmj-desk-app.sh [2]=hsmj-flow-app.sh [3]=hsmj-sys-app.sh [4]=hsmj-spt-app.sh  [5]=hsmj-auth.sh [6]=hsmj-autho.sh [7]=hsmj-gateway.sh [8]=hsmj-cpa-app.sh [9]=hsmj-comp-app.sh  [10]=hsmj-cust-app.sh [11]=hsmj-ctm-app.sh [12]=hsmj-ctm-api.sh [13]=hsmj-cto-app.sh [14]=hsmj-cto-job.sh )</span><br><span class=\"line\"></span><br><span class=\"line\">for file in `ls $deploy_path`</span><br><span class=\"line\"></span><br><span class=\"line\">do</span><br><span class=\"line\"></span><br><span class=\"line\">if [[ $file == hsmj-*.jar ]]; then</span><br><span class=\"line\">\tmv $deploy_path/$file $path/$file</span><br><span class=\"line\">\techo &quot;move &quot;$file&quot; success&quot;</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\">for b in $&#123;array[*]&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">do</span><br><span class=\"line\"></span><br><span class=\"line\">sh $path/$b</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;run &quot;$path/$b&quot; success&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">done</span><br><span class=\"line\">。、</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"这里-表示定义的数组，存入需要操作的项目\"><a href=\"#这里-表示定义的数组，存入需要操作的项目\" class=\"headerlink\" title=\"这里 表示定义的数组，存入需要操作的项目\"></a>这里 表示定义的数组，存入需要操作的项目</h4><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">array=([1]=hsmj-desk-app.sh [2]=hsmj-flow-app.sh [3]=hsmj-sys-app.sh [4]=hsmj-spt-app.sh  [5]=hsmj-auth.sh [6]=hsmj-autho.sh [7]=hsmj-gateway.sh [8]=hsmj-cpa-app.sh [9]=hsmj-comp-app.sh  [10]=hsmj-cust-app.sh [11]=hsmj-ctm-app.sh [12]=hsmj-ctm-api.sh [13]=hsmj-cto-app.sh [14]=hsmj-cto-job.sh )</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"for-in-do-done进行循环操作\"><a href=\"#for-in-do-done进行循环操作\" class=\"headerlink\" title=\"for in do done进行循环操作\"></a><code>for in do done</code>进行循环操作</h4><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">for file in `ls $deploy_path`</span><br><span class=\"line\"></span><br><span class=\"line\">do</span><br><span class=\"line\"></span><br><span class=\"line\">if [[ $file == hsmj-*.jar ]]; then</span><br><span class=\"line\">\tmv $deploy_path/$file $path/$file</span><br><span class=\"line\">\techo &quot;move &quot;$file&quot; success&quot;</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n\n<p><code>for file in </code>ls $deploy_path``可以在循环目录下的所有文件 <code>if [[$file == hsmj-*.jar]]; </code>*模糊匹配文件名</p>\n<h2 id=\"记录下-shell-使用中遇到的问题\"><a href=\"#记录下-shell-使用中遇到的问题\" class=\"headerlink\" title=\"记录下 shell 使用中遇到的问题\"></a>记录下 shell 使用中遇到的问题</h2><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost project]# ./ctm-all.sh</span><br><span class=\"line\">-bash: ./ctm-all.sh: 权限不够</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"刚创建的脚本权限不足导致的错误；需要我们先给这个脚本赋权限；\"><a href=\"#刚创建的脚本权限不足导致的错误；需要我们先给这个脚本赋权限；\" class=\"headerlink\" title=\"刚创建的脚本权限不足导致的错误；需要我们先给这个脚本赋权限；\"></a>刚创建的脚本权限不足导致的错误；需要我们先给这个脚本赋权限；</h4><p>解决方法：<br>使用<code>chmod +x ctm-all.sh</code> 即可解决；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost project]# ./ctm-all.sh</span><br><span class=\"line\">-bash: ./ctm-all.sh: /bin/bash^M: 坏的解释器: 没有那个文件或目录</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"接着遇到的这个问题是，我的脚本在-Windows-中编写，导入-Linux-中运行的，因为在-Windows-中换行符为-r-n，linux-下换行符为-n；所导致的问题\"><a href=\"#接着遇到的这个问题是，我的脚本在-Windows-中编写，导入-Linux-中运行的，因为在-Windows-中换行符为-r-n，linux-下换行符为-n；所导致的问题\" class=\"headerlink\" title=\"接着遇到的这个问题是，我的脚本在 Windows 中编写，导入 Linux 中运行的，因为在 Windows 中换行符为 \\r\\n，linux 下换行符为 \\n；所导致的问题\"></a>接着遇到的这个问题是，我的脚本在 Windows 中编写，导入 Linux 中运行的，因为在 Windows 中换行符为 \\r\\n，linux 下换行符为 \\n；所导致的问题</h4><p>解决方法：<br>只需要去掉多余的 \\r 回车符 即可。操作办法可以用 sed 命令进行全局替换<br><code>sed &#39;s/\\r//&#39; -i ctm-all.sh</code></p>\n"},{"title":"语雀转markdown时图片显示不了问题解决","comments":1,"date":"2022-07-05T06:04:46.000Z","_content":"\n##  语雀转markdown时，图片显示不了  ##\n### 原因是转换后的图片标签内多了这么一大串代码\n![](http://rebp38war.bkt.clouddn.com/img/20220705135506.png)\n\n![](http://rebp38war.bkt.clouddn.com/img/20220705135607.png)\n### 按照网上分享的问题删掉这串代码，但是没有效果\n\n### 后来在文档中加上这个标签就完事了\n```html\n<meta name=\"referrer\" content=\"no-referrer\" />\n```","source":"_posts/问题整理.md","raw":"---\ntitle: 语雀转markdown时图片显示不了问题解决\ncomments: true\ncategories:\n - 问题\ntags:\n - markdown\n - blog\ndate: '2022-07-05 14:04:46 +0800'\n---\n\n##  语雀转markdown时，图片显示不了  ##\n### 原因是转换后的图片标签内多了这么一大串代码\n![](http://rebp38war.bkt.clouddn.com/img/20220705135506.png)\n\n![](http://rebp38war.bkt.clouddn.com/img/20220705135607.png)\n### 按照网上分享的问题删掉这串代码，但是没有效果\n\n### 后来在文档中加上这个标签就完事了\n```html\n<meta name=\"referrer\" content=\"no-referrer\" />\n```","slug":"问题整理","published":1,"updated":"2022-07-05T06:01:45.850Z","layout":"post","photos":[],"link":"","_id":"cl5w7e74c000zigvu7itx5uto","content":"<h2 id=\"语雀转markdown时，图片显示不了\"><a href=\"#语雀转markdown时，图片显示不了\" class=\"headerlink\" title=\"语雀转markdown时，图片显示不了\"></a>语雀转markdown时，图片显示不了</h2><h3 id=\"原因是转换后的图片标签内多了这么一大串代码\"><a href=\"#原因是转换后的图片标签内多了这么一大串代码\" class=\"headerlink\" title=\"原因是转换后的图片标签内多了这么一大串代码\"></a>原因是转换后的图片标签内多了这么一大串代码</h3><p><img src=\"http://rebp38war.bkt.clouddn.com/img/20220705135506.png\"></p>\n<p><img src=\"http://rebp38war.bkt.clouddn.com/img/20220705135607.png\"></p>\n<h3 id=\"按照网上分享的问题删掉这串代码，但是没有效果\"><a href=\"#按照网上分享的问题删掉这串代码，但是没有效果\" class=\"headerlink\" title=\"按照网上分享的问题删掉这串代码，但是没有效果\"></a>按照网上分享的问题删掉这串代码，但是没有效果</h3><h3 id=\"后来在文档中加上这个标签就完事了\"><a href=\"#后来在文档中加上这个标签就完事了\" class=\"headerlink\" title=\"后来在文档中加上这个标签就完事了\"></a>后来在文档中加上这个标签就完事了</h3><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;referrer&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;no-referrer&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>","site":{"data":{"bangumis":{"wantWatch":[],"watching":[{"title":"凡人修仙传","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/70d11dfab23a3ee81ccf64f18efa139416a633ff.jpg@220w_280h.webp","totalCount":"未完结","id":28223043,"follow":"615.7 万","view":"8.9 亿","danmaku":"490.9 万","coin":"1186.9 万","score":9.7,"des":"看机智的凡人小子韩立如何稳健发展、步步为营，战魔道、夺至宝、驰骋星海、快意恩仇，成为纵横三界的强者。他日仙界重相逢，一声道友尽沧桑。..."},{"title":"恋爱游戏世界对路人角色很不友好","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/c9723d8c77d881a8debba2852d580e97826b43d0.png@220w_280h.webp","totalCount":"全12话","id":28237300,"follow":"151.2 万","view":"5120.4 万","danmaku":"40.6 万","coin":"24.5 万","score":9.1,"des":"从现代日本转生到“恋爱游戏”世界的里昂，发现这里女尊男卑，对男性很不友好。身为路人角色的他，为了摆脱自己因地位低下而被肆意决定的人生，决定活用从游戏中得到的知识，保持路人角色的身份，取得“失落物品”来..."},{"title":"魔法纪录 魔法少女小圆外传 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/9eef1df9ab157be52d2c4d70d3500442f00cafc3.png@220w_280h.webp","totalCount":"全12话","id":28234642,"follow":"237.1 万","view":"907.6 万","danmaku":"5.0 万","coin":"4.9 万","score":7.7,"des":"愿望的代价，究竟是希望还是绝望——。"},{"title":"小林家的龙女仆 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/847e9dbb6876fb37a30199a5c88910704976d45b.png@220w_280h.webp","totalCount":"全13话","id":28234613,"follow":"855.7 万","view":"1.1 亿","danmaku":"49.0 万","coin":"69.0 万","score":9.6,"des":"那位不可思议的龙女仆再度登场！\n因为各种奇妙的原因而作为小林家的女仆而工作中的龙·托尔。\n偶尔（胡说，是经常）给亲爱的小林添麻烦，总算是融入了人类社会，成为了一个完美的（骗人，也就还行）女仆。\n同样是..."},{"title":"国王排名","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/376d7e69a667bcb1c0b934a4e35e07e7fa23110b.png@220w_280h.webp","totalCount":"全23话","id":28235154,"follow":"927.7 万","view":"4.8 亿","danmaku":"250.1 万","coin":"260.9 万","score":7,"des":"国家的丰饶、麾下勇者的数量、\n以及国王本人如何像勇者一般强大，\n这些要素的综合排名，便是所谓的“国王排名”。\n主人公波吉是国王排名第七名的伯斯王治下王国的第一王子。\n但是波吉却生来又聋又哑，贫弱到挥不..."},{"title":"阿松 第三季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0212baa8898d0c819c7fb84015e95b8fca621435.png@220w_280h.webp","totalCount":"全25话","id":28229892,"follow":"67.6 万","view":"938.0 万","danmaku":"13.0 万","coin":"5.4 万","score":9.6,"des":"日本最有名的六胞胎的传说，第三次开幕！！这次会有怎样意想不到的新展开！？..."},{"title":"命运-冠位指定 冠位时间神殿所罗门","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0e094b798388da19a4feffa6a6dabc1dc1dc90cd.jpg@220w_280h.webp","totalCount":"全1话","id":28236225,"follow":"525.5 万","view":"1220.0 万","danmaku":"8.9 万","coin":"15.1 万","score":8.5,"des":"在经过七个特异点的大战后，\n人理存续保障机关迦勒底，终于到达了圣杯探索的最终地点——终局特异点 冠位时间神殿所罗门。\n他们要击败身为罪魁祸首的魔术王所罗门，夺回未来。\n在开战的前一刻，一行人各自度过了..."},{"title":"JOJO的奇妙冒险 星尘远征军","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/47c0108259355d6d2c517ed97f6b90fb777f844f.png@220w_280h.webp","totalCount":"全24话","id":28223481,"follow":"444.2 万","view":"1.5 亿","danmaku":"463.4 万","coin":"45.7 万","score":9.8,"des":"时为1987年，乔瑟夫·乔斯达与“柱之男”们之间的死战后过了50年……乔瑟夫为了为了帮助“被恶灵附身了”的外孙子·空条承太郎而来到了日本。原来那并不是恶灵而是幽波纹（替身）。替身突然出现的原因在于，从..."},{"title":"JOJO的奇妙冒险 星尘远征军 埃及篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f6709b76e88f50aa132d1e09e2d8de9663a09b3e.png@220w_280h.webp","totalCount":"全24话","id":28223483,"follow":"421.9 万","view":"1.3 亿","danmaku":"468.7 万","coin":"44.3 万","score":9.9,"des":"在乔斯达家的宿敌·迪奥（DIO）复活的影响下，一位年轻人——空条承太郎，得到了名为“幽波纹（替身）”的能力。为了拯救因迪奥的诅咒而倒下的母亲荷莉，空条承太郎与外祖父·乔瑟夫以及伙伴们，一起为了打倒迪奥..."},{"title":"JOJO的奇妙冒险 不灭钻石","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/6a04c87e990ab74cd8d555ef45a863de0993b161.png@220w_280h.webp","totalCount":"全39话","id":140552,"follow":"302.3 万","view":"2.1 亿","danmaku":"813.8 万","coin":"55.9 万","score":9.8,"des":"在埃及与宿敌DIO的死斗之后过了11年。1999年，空条承太郎为了与祖父乔瑟夫·乔斯达的私生子东方仗助见面，而来到了日本M县S市杜王町。但，仗助却持有与承太郎相同的特殊能力“替身”。之后，以承太郎的来..."},{"title":"命运-冠位嘉年华","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/c660976f4502a544d990a882ae62194b57753a71.png@220w_280h.webp","totalCount":"全2话","id":28234639,"follow":"479.8 万","view":"862.4 万","danmaku":"4.1 万","coin":"9.1 万","score":9.8,"des":"一起庆祝吧！为了这奇迹般的嘉年华！"},{"title":"伍六七","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/b69e26d9e50514f3fa99eac9ab5aabf2a6e28c88.jpg@220w_280h.webp","totalCount":"全13话","id":6360,"follow":"585.8 万","view":"3.3 亿","danmaku":"227.1 万","coin":"191.8 万","score":9.8,"des":"在某个小岛上，有一个可以伪装成任何东西的廉价刺客，名叫伍六七。平时看上去是个理发师，其实背地里却做着刺客生意。热爱理发事业，喜欢给人剪头发，善用剪刀——剪刀也是他的刺杀武器。由于初入刺客行当，行情十分..."},{"title":"命运-冠位指定 -月光／失落之室-","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3fa5fd2b7afae827b0bf150d7f0cbfc54eda1ff2.png@220w_280h.webp","totalCount":"全1话","id":28234950,"follow":"483.3 万","view":"551.2 万","danmaku":9696,"coin":"2.9 万","score":9.5,"des":"失落之室——。\n这是一个可以看到被夺去亦或是遗失之物的地方。\n这是位于迦勒底被遗忘的角落，不属于任何人的地方。..."},{"title":"致不灭的你","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/1ae94fbb35d8e23bb84926b694509f8b057f96e6.png@220w_280h.webp","totalCount":"全20话","id":28233896,"follow":"476.3 万","view":"1.3 亿","danmaku":"140.1 万","coin":"95.0 万","score":9.6,"des":"本剧讲述了一个情节跌宕、场面宏大的奇幻故事，通过拥有不灭之身的主人公“不死”来探索人生哲理。\n不死起初是一个被投放到人世间的“球”。\n\n它具有“幻化为刺激源形态的能力”和“死后重生的能力”。\n\n先后从..."},{"title":"来自新世界","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/aaa60f9cb17fb4a38df464f1064ca9623e0769cc.jpg@220w_280h.webp","totalCount":"全25话","id":1598,"follow":"115.9 万","view":"1540.9 万","danmaku":"76.3 万","coin":"5.7 万","score":9.5,"des":"1000年后的日本，孩子们不断地消失，只存在想象中的恐怖动物与人类展开殊死战争。反乌托邦式的未来超级社会“新世界”，是口吐真言凭藉“咒力”就能移动物体的人类，与有着等同于普通人智力的生物“妖鼠”共存的..."},{"title":"转生成蜘蛛又怎样！","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f0796e37abac25ba2aa9f23120646aaa9a3d5ea7.png@220w_280h.webp","totalCount":"全24话","id":28231809,"follow":"600.0 万","view":"3.7 亿","danmaku":"190.3 万","coin":"164.6 万","score":7.8,"des":"曾经是一名女高中生的“我”，突然转生变成了幻想世界中的蜘蛛魔物。\n而且，出生地点还是各种凶恶魔物所盘踞的大迷宫。\n“我”以人类的智慧和非同寻常的积极心态为武器，使用蜘蛛的丝网以及陷阱打倒比自己等级高得..."},{"title":"装甲重拳/MEGALOBOX 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/e14dc4a935397fc074c7a12d9520225615209025.png@220w_280h.webp","totalCount":"全13话","id":28233916,"follow":"244.9 万","view":"3435.4 万","danmaku":"19.7 万","coin":"53.1 万","score":9.9,"des":"再一次，为梦想而活——\n\n将肉体与“装甲技术”融合的究极格斗技“装甲拳击”。\n在决出其顶点之人的大会“重拳之巅”上，身穿装甲用自己肉身挑战一切的拳击手“JOE”。\n\n从最下层的比赛开始仅仅花了三个月就..."},{"title":"机动战士高达SEED HD","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/855c88677267d707ebfe4040403692ff2c0938f0.png@220w_280h.webp","totalCount":"全48话","id":497,"follow":"54.8 万","view":"4044.4 万","danmaku":"114.4 万","coin":"6.0 万","score":9.6,"des":"《机动战士高达SEED》是高达系列在2002年至2003年度放映的动画。续作为《机动战士高达SEED Destiny》在2004年播放。因各具魅力的角色，明星云集的声优阵容和高度商业化的宣传而受到较低..."},{"title":"夏目友人帐 唤石者与怪异的访客","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6cf43708b779cde84ad285ff4e3a080de98df0af.png@220w_280h.webp","totalCount":"全1话","id":28234316,"follow":"567.1 万","view":"1374.8 万","danmaku":"18.1 万","coin":"17.9 万","score":9.9,"des":"本作由【唤石者】与【怪异的访客】两个人气短篇集锦而成。讲述生来便能看见各种妖怪的夏目，与自称保镖的猫咪老师一同邂逅的一系列温暖故事。\n【唤石者】一天夏目在森林中遇到一只小妖怪——密实。密实称自己肩负「..."},{"title":"Fate/Grand Order ‐First Order‐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/b75c55d209d156c8631f5ceb21e5c52c834dbb60.jpg@220w_280h.webp","totalCount":"全1话","id":5747,"follow":"250.9 万","view":"3329.7 万","danmaku":"76.7 万","coin":"10.7 万","score":8.3,"des":"【2016年12月31日bilibili独播】2015年。示巴所观测到的未来领域毫无前兆地消失。根据计算，发现——不，是证明了人类将于2017年灭绝。人理延续保障机构·迦勒底将“无法观测的领域”假定为..."},{"title":"伍六七之玄武国篇","type":"国创","area":"中国大陆","cover":"https://i0.hdslb.com/bfs/bangumi/image/00843865ea13702eccc4efd64c313fd4c8029c6b.jpg@220w_280h.webp","totalCount":"全10话","id":28232253,"follow":"999.4 万","view":"4.0 亿","danmaku":"177.7 万","coin":"385.3 万","score":9.8,"des":"为了保护小鸡岛居民和这里平静的生活，伍六七和他的伙伴大保和小飞开启了去往玄武国的冒险旅程，去寻找身世的真相和解救小岛的办法，等待他们的又将是更多的未知与奇遇。..."},{"title":"堀与宫村","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/039c4e0b14e27c7a9e5cce2f20a6efd3c8909401.png@220w_280h.webp","totalCount":"全13话","id":28231840,"follow":"695.2 万","view":"2.2 亿","danmaku":"242.1 万","coin":"361.4 万","score":9.8,"des":"不论是谁，都会有不想被人知道的一面。\n\n在学校中漂亮大方、成绩优秀的人气女生堀，私下却打扮土气、忙于家务和照顾弟弟。\n在学校中是阴暗宅男形象的宫村，生活中却是打扮时尚、带耳钉的帅气男生。\n因为一次特别..."},{"title":"奇蛋物语 / WONDER EGG PRIORITY","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/10e0bbc1047b2c45f0f881de334a6f3bfb42a3b6.png@220w_280h.webp","totalCount":"全12话","id":28231851,"follow":"254.9 万","view":"4686.8 万","danmaku":"47.6 万","coin":"65.5 万","score":9.7,"des":"14岁少女·大户爱在深夜散步的途中，\n随着神秘声音的指引，获得了一枚「蛋」。\n\n「如果想要改变世界的话」\n「那么就在现在做出选择」\n「请相信自己——」\n「打破这枚蛋——」\n\n而在打破「蛋」之后，等待着..."},{"title":"Re：从零开始的异世界生活 第二季 后半","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/4f3edbede7fc0bdb52842075cf8faaa1c5953eaa.png@220w_280h.webp","totalCount":"全12话","id":28232073,"follow":"849.9 万","view":"9308.1 万","danmaku":"108.1 万","coin":"230.1 万","score":9.9,"des":"我一定会拯救你。\n在打倒了魔女教大罪司教「怠惰」担当——培提其乌斯·罗曼尼康帝之后，菜月昴和爱蜜莉雅又得以重新开始。\n克服了艰难的诀别，两人终于和解，然而这只是新一轮风波的序幕。\n超乎想象的绝境危机，..."},{"title":"灰与幻想的格林姆迦尔","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/7fb4945f864e9e988212b7d20f206df2677053f8.jpg@220w_280h.webp","totalCount":"全12话","id":106512,"follow":"172.0 万","view":"2343.4 万","danmaku":"63.8 万","coin":"18.3 万","score":9.8,"des":"电视动画《灰与幻想的格林姆迦尔》改编自日本轻小说家十文字青原作白井锐利插画的同名轻小说。\n我们为什么要这么做…？\n哈尔希洛回过神来，才发现自己身处在黑暗当中，他完全不知道自己人在何处，也不明白这个地方..."},{"title":"龙与虎","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/144910805f172d16c5f544f43939a05d8ca20576.jpg@220w_280h.webp","totalCount":"全26话","id":1672,"follow":"336.9 万","view":"6671.9 万","danmaku":"511.9 万","coin":"61.5 万","score":9.7,"des":"樱花飞舞的四月，全新的高中二年级，新的班级……\n眼神凶恶的普通男孩——高须龙儿，遇上了众人害怕、凶暴残忍的“掌中老虎”逢坂大河，还知道了她不欲为人知的秘密。这就是龙虎相争爱与战斗的序幕。\n再加上总是笑..."},{"title":"机动战士高达 铁血的奥尔芬斯 第一季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/f84a80d731d0431c00903d8951fd66623d8237f7.png@220w_280h.webp","totalCount":"全25话","id":4310042,"follow":"62.4 万","view":"2318.6 万","danmaku":"52.2 万","coin":"5.4 万","score":9.5,"des":"主人公三日月·奥古斯，从所属的民间警备公司克律塞安保公司（下称CGS）那里，接受了对少女库德莉亚·蓝那·伯恩斯坦的护卫任务。但CGS受到了摘取反叛之芽的武力组织加拉尔霍恩的袭击，于是在把三日月当做诱饵..."},{"title":"机动战士高达00 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1d7a969e8f1045739c596de89a963e30475aff0e.jpg@220w_280h.webp","totalCount":"全25话","id":1193,"follow":"37.2 万","view":"2458.1 万","danmaku":"61.4 万","coin":"4.1 万","score":9.8,"des":"天人与联合国军的最终决战后过了四年。建立地球联邦政府的人类，为了追求更进一步的国家间之统合，以及人类意识的统一，在联合正规军之外，设立了独立治安维持部队“A-Laws”，目的为对所有危害联合的势力与主..."},{"title":"机动战士高达00","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/35b11bf59eb3fd12f0387951510a5d722d7435e5.jpg@220w_280h.webp","totalCount":"全25话","id":1192,"follow":"62.1 万","view":"2465.5 万","danmaku":"53.6 万","coin":"4.6 万","score":9.7,"des":"在西历2307年，虽然化石燃料枯竭了，但是人类得到了截然不同的新型能源。三台巨大的轨道升降机以及伴随它们的大规模的太阳光发电系统。但是能得到这个系统恩惠的，只有一部分大国和其同盟国而已。\n拥有三台轨道..."},{"title":"Re：从零开始的异世界生活 第二季 前半","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f2425cbdb07cc93bd0d3ba1c0099bfe78f5dc58a.png@220w_280h.webp","totalCount":"全13话","id":28229233,"follow":"774.2 万","view":"1.3 亿","danmaku":"201.4 万","coin":"126.7 万","score":9.7,"des":"我一定会拯救你。\n在打倒了魔女教大罪司教「怠惰」担当——培提其乌斯·罗曼尼康帝之后，菜月昴和爱蜜莉雅又得以重新开始。\n克服了艰难的诀别，两人终于和解，然而这只是新一轮风波的序幕。\n超乎想象的绝境危机，..."},{"title":"超级小白","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3d3e8257d22596f5d3e4395ca759bd1e0fe9b873.jpg@220w_280h.webp","totalCount":"全48话","id":28222671,"follow":"27.4 万","view":"978.0 万","danmaku":"3.6 万","coin":"3.6 万","score":9.6,"des":"为了阻止企图霸占世界的黑暗势力，野原家的普通小狗——小白接肩负重大使命，变身成为了守护世界的“超级小白”。小白将要面对的不仅是发明狗，还有其他意想不到的对手。当然，面对邪恶势力，小白也有着令人惊讶的超..."},{"title":"Re：从零开始的异世界生活 新编集版","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3c125e1aad08643e3eff2fb7d45e740c1a052725.png@220w_280h.webp","totalCount":"全13话","id":28224394,"follow":"631.1 万","view":"7674.2 万","danmaku":"166.2 万","coin":"51.1 万","score":9.6,"des":"在从便利商店回家的路上，突然被异世界召唤的少年菜月昴。在无法依靠任何东西的异世界，无力的少年手唯一的力量……那是“死去然后重新开始”的力量。为了守护最重要的人们，为了取回确实存在着又无可替代的时间，少..."},{"title":"因为太怕痛就全点防御力了","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/8021d3f6b0df6dbba6d32f76eb9cfe2531e166c4.png@220w_280h.webp","totalCount":"全12话","id":28224137,"follow":"620.6 万","view":"2.3 亿","danmaku":"326.8 万","coin":"103.8 万","score":9,"des":"主角本条枫在好友白峰理沙推荐下开始游玩游戏“NewWorld Online”，创建了名为“梅普露”的角色。然而作为游戏初学者，梅普露选择了不受欢迎的大盾当武器，同时因为怕痛而把所有状态点加到防御力的极..."},{"title":"冰海战记","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/c30401817895e67399094b4e669785a104270cdf.jpg@220w_280h.webp","totalCount":"全24话","id":28220475,"follow":"174.4 万","view":"4893.8 万","danmaku":"48.7 万","coin":"36.7 万","score":9.8,"des":"公元10世纪末期，出现了在世界各地出没的最强民族。被讴歌为最强战士的托尔兹，其子托尔芬幼时便生活在战场上，并向往着梦幻大陆“文兰”。这是一个发生在激荡时代的，真正的英雄物语。..."},{"title":"齐木楠雄的灾难 始动篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ba59822eded39b5254fb01448a7f1502101d5624.png@220w_280h.webp","totalCount":"全6话","id":28223748,"follow":"372.4 万","view":"3054.5 万","danmaku":"20.0 万","coin":"17.8 万","score":9.8,"des":"在电视剧中堪称帅气的超能力，对于高中生齐木楠雄来说只是招致灾难的元凶。作为新动画系列展开的楠雄的日常又会如何！？..."},{"title":"OVERLORD Ⅱ","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/851f979c8ebcc7583a43abd4b786c4e2e66b746b.jpg@220w_280h.webp","totalCount":"全13话","id":8792,"follow":"539.3 万","view":"3.8 亿","danmaku":"413.9 万","coin":"114.1 万","score":9.6,"des":"时为2138年。曾卷起一大风潮的虚拟现实体感型网络游戏《YGGDRASIL》即将迎来停服。玩家飞鼠在曾经以同伴和荣华自傲的根据地纳萨力克地下大坟墓，独自一人安静等待着那一刻。但是，不料发生了结束时间已..."},{"title":"夏目友人帐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/99c549494d9425f6455bd45a151f4d26397d6151.png@220w_280h.webp","totalCount":"全13话","id":1660,"follow":"324.0 万","view":"4975.2 万","danmaku":"278.7 万","coin":"15.5 万","score":9.8,"des":"夏目贵志生来拥有强大的灵力，能感知平常人所无法接触的妖怪神明的存在。因父母双亡，他多年间辗转于互相推卸责任的亲戚之间，又受到同龄人的欺负，未曾与任何人深交，造成性格一定程度上的孤僻。夏目本性和善，对于..."}],"watched":[{"title":"装甲重拳/MEGALOBOX","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/0c44785cb5d25cc9f648800d251f21a2e236bb8a.png@220w_280h.webp","totalCount":"全13话","id":79472,"follow":"221.9 万","view":"6162.0 万","danmaku":"48.6 万","coin":"32.9 万","score":9.8,"des":"将肉体与“装甲技术”融合的究极格斗技——“MEGALOBOX”，将自己的全部赌在上面的男人们的热血战斗开始！\n今天也立于未认可地区的赌博比赛赛场上的MEGALO拳击手“JNK DOG”。虽然具备实力，..."},{"title":"超能力女儿","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/152c536f8ecaad8f3d7d568d33da81c963a4a722.png@220w_280h.webp","totalCount":"全12话","id":78352,"follow":"293.8 万","view":"9252.2 万","danmaku":"98.5 万","coin":"35.4 万","score":9.6,"des":"支持着芦川组的年轻智力型黑道新田义史，过着被喜欢的壶所包围的悠然自得单身生活。但某一天，随着装在神秘物体里的少女雏来到他家，他的生活为之一变。他被能使用念动力的雏所胁迫，迫不得已开始和她同居！\n容易暴..."},{"title":"OVERLORD Ⅲ","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/dd7a9d0a0bee32b1f43c2656398d8463d12b3069.jpg@220w_280h.webp","totalCount":"全13话","id":102252,"follow":"551.6 万","view":"4.0 亿","danmaku":"399.7 万","coin":"129.2 万","score":9.4,"des":"时间为2138年。曾卷起一大风潮的虚拟现实体感型网络游戏《YGGDRASIL》即将迎来停服。玩家飞鼠在曾经以同伴和荣华自傲的根据地纳萨力克地下大坟墓，独自一人安静等待着那一刻。\n但是，不料发生了“过了..."},{"title":"路人超能100 第一次灵能咨询所员工旅游～舒缓心灵的疗愈之旅~（OVA2）","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/1271324d51634b68980704731987724a1afc60aa.jpg@220w_280h.webp","totalCount":"全1话","id":28222715,"follow":"318.8 万","view":"520.7 万","danmaku":"3.6 万","coin":"4.6 万","score":9.8,"des":"由原作ONE老师担任原案的完全新作OVA！「灵能咨询所」一行人，龙套与灵幻、小酒窝以及新同伴芹泽的目的地，正是缟马县深山中鲜为人知的温泉·疣神温泉。因为灵幻接受了旅馆老板娘的委托，「弄清温泉的恐怖传闻..."},{"title":"少女终末旅行","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1431ca5bb2f7143062e3df8f21b8448cf8cccc13.jpg@220w_280h.webp","totalCount":"全12话","id":6463,"follow":"239.8 万","view":"3714.7 万","danmaku":"100.7 万","coin":"37.2 万","score":9.8,"des":"本作舞台在人类繁华的文明迎来终结的很久以后，人类基本灭绝，甚至生物都不再存在的末日世界。复杂够高的都市成为迷宫般的废墟，得不到维护的机械渐渐停止运转。连何时终结了，何时开始终结的思考都不复存在的这个世..."},{"title":"齐木楠雄的灾难（日播&精选版）","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/eb4f17335f48951945fb9da47e6ee0bc65fa2fbb.jpg@220w_280h.webp","totalCount":"全120话","id":5070,"follow":"187.0 万","view":"2.3 亿","danmaku":"130.7 万","coin":"32.7 万","score":9.6,"des":"高中生·齐木楠雄是超能力者。心灵感应、念动力、透视、预知、瞬间移动、千里眼等，不论任何事情都自由自在。但这任谁都羡慕不已的最强能力，实际上对于本人而言是引来灾难的不幸元凶。因此，他在别人面前封印了超能..."},{"title":"比宇宙更远的地方","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/c9eca3cbc386c63b27461074b8b218898cb7440e.jpg@220w_280h.webp","totalCount":"全13话","id":13032,"follow":"156.0 万","view":"2298.0 万","danmaku":"45.9 万","coin":"23.9 万","score":9.8,"des":"无论何时，我们的第一步总是从好奇心开始。\n不曾看过的风景，不曾听过的声音，不曾闻过的味道，不曾摸过的质感，不曾尝过的食物，以及不曾感受过的澎湃。\n为了重拾不知何时忘却的记忆碎片和不知何时舍弃的感动的旅..."},{"title":"OVERLORD","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/b8e72ea69e57e0b7ac85d8b4d366554fd866df1a.jpg@220w_280h.webp","totalCount":"全13话","id":2576,"follow":"626.2 万","view":"4.1 亿","danmaku":"385.2 万","coin":"84.4 万","score":9.6,"des":"作品主要讲述了某天，一款曾经掀起过大热潮的VRMMORPG「YGGDRASIL」停止了运营。游戏原本会停止一切服务，但过了结束时间后，玩家们却发现不能退出，NPC也产生了各自的思想。现实世界中喜爱电玩..."},{"title":"路人超能100 II(灵能百分百 第二季)","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/216e1bdaf88244215a13b1154116805ee9adbe07.png@220w_280h.webp","totalCount":"全13话","id":4762734,"follow":"284.9 万","view":"1.0 亿","danmaku":"97.8 万","coin":"56.1 万","score":9.9,"des":"当有什么东西达到“100”的时候，就会爆发的少年·路人（龙套）。外表极其普通——不如说是不起眼。不擅长迎合气氛的他，实际上拥有着强力的超能力。盯上了这样的他的能力，而接连现身的伪灵能力者以及宗教团体、..."},{"title":"多罗罗","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3fc16a667502cbff226e585eb660a96a20c7458c.png@220w_280h.webp","totalCount":"全24话","id":4312482,"follow":"452.1 万","view":"1.8 亿","danmaku":"143.9 万","coin":"73.9 万","score":9.4,"des":"他们向着命运抗争，在那尽头等待他们的是人心，还是业障。\n时值乱世。\n名为景光的醍醐将军，向某个寺庙殿堂中的12尊魔神像祈求早日结束战乱。\n作为代价，他的嫡子在出生时就失去了身体的某些部位，被丢弃在河流..."},{"title":"魔法少女小圆","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/7fcaa0e98b561611538ae4deba7949cec4ca39a8.png@220w_280h.webp","totalCount":"全12话","id":2539,"follow":"218.7 万","view":"4199.0 万","danmaku":"201.5 万","coin":"20.0 万","score":9.8,"des":"就读初中二年级的鹿目圆，过着平凡幸福的生活。神秘转学生晓美焰的出现，开始让小圆的命运有了巨大转变。某日一只名为丘比的神秘生物，希望小圆能够与它签订魔法契约，成为“魔法少女”以对抗邪恶的魔女保护世界。正..."}]},"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"http://rebp38war.bkt.clouddn.com/img/v2-b006882f4ae03db43db5dd9a4bda19e5_r.jpg","excerpt":"","more":"<h2 id=\"语雀转markdown时，图片显示不了\"><a href=\"#语雀转markdown时，图片显示不了\" class=\"headerlink\" title=\"语雀转markdown时，图片显示不了\"></a>语雀转markdown时，图片显示不了</h2><h3 id=\"原因是转换后的图片标签内多了这么一大串代码\"><a href=\"#原因是转换后的图片标签内多了这么一大串代码\" class=\"headerlink\" title=\"原因是转换后的图片标签内多了这么一大串代码\"></a>原因是转换后的图片标签内多了这么一大串代码</h3><p><img src=\"http://rebp38war.bkt.clouddn.com/img/20220705135506.png\"></p>\n<p><img src=\"http://rebp38war.bkt.clouddn.com/img/20220705135607.png\"></p>\n<h3 id=\"按照网上分享的问题删掉这串代码，但是没有效果\"><a href=\"#按照网上分享的问题删掉这串代码，但是没有效果\" class=\"headerlink\" title=\"按照网上分享的问题删掉这串代码，但是没有效果\"></a>按照网上分享的问题删掉这串代码，但是没有效果</h3><h3 id=\"后来在文档中加上这个标签就完事了\"><a href=\"#后来在文档中加上这个标签就完事了\" class=\"headerlink\" title=\"后来在文档中加上这个标签就完事了\"></a>后来在文档中加上这个标签就完事了</h3><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;referrer&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;no-referrer&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>"}],"PostAsset":[{"_id":"source/_posts/Kafka/QQ截图20220110112502.png","slug":"QQ截图20220110112502.png","post":"cl5w7e73l0001igvu5ht9bjph","modified":0,"renderable":0},{"_id":"source/_posts/Kafka/QQ截图20220110122844.png","slug":"QQ截图20220110122844.png","post":"cl5w7e73l0001igvu5ht9bjph","modified":0,"renderable":0},{"_id":"source/_posts/Kafka/QQ截图20220110125233.png","slug":"QQ截图20220110125233.png","post":"cl5w7e73l0001igvu5ht9bjph","modified":0,"renderable":0},{"_id":"source/_posts/Kafka/QQ截图20220110125413.png","slug":"QQ截图20220110125413.png","post":"cl5w7e73l0001igvu5ht9bjph","modified":0,"renderable":0},{"_id":"source/_posts/Kafka/QQ截图20220110133849.png","slug":"QQ截图20220110133849.png","post":"cl5w7e73l0001igvu5ht9bjph","modified":0,"renderable":0},{"_id":"source/_posts/Kafka/QQ截图20220110134554.png","slug":"QQ截图20220110134554.png","post":"cl5w7e73l0001igvu5ht9bjph","modified":0,"renderable":0},{"_id":"source/_posts/Kafka/QQ截图20220110134734.png","slug":"QQ截图20220110134734.png","post":"cl5w7e73l0001igvu5ht9bjph","modified":0,"renderable":0},{"_id":"source/_posts/Kafka/QQ截图20220110142708.png","slug":"QQ截图20220110142708.png","post":"cl5w7e73l0001igvu5ht9bjph","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210922100205.png","slug":"QQ截图20210922100205.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210922100407.png","slug":"QQ截图20210922100407.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210924134715.png","slug":"QQ截图20210924134715.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210924134937.png","slug":"QQ截图20210924134937.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210924135030.png","slug":"QQ截图20210924135030.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210924135616.png","slug":"QQ截图20210924135616.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210924135855.png","slug":"QQ截图20210924135855.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210924135915.png","slug":"QQ截图20210924135915.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210924135957.png","slug":"QQ截图20210924135957.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210924140055.png","slug":"QQ截图20210924140055.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210924140800.png","slug":"QQ截图20210924140800.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210924140819.png","slug":"QQ截图20210924140819.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210924140833.png","slug":"QQ截图20210924140833.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210924140847.png","slug":"QQ截图20210924140847.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210924140901.png","slug":"QQ截图20210924140901.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210924141013.png","slug":"QQ截图20210924141013.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210924141532.png","slug":"QQ截图20210924141532.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210924144835.png","slug":"QQ截图20210924144835.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210927092007.png","slug":"QQ截图20210927092007.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210927092027.png","slug":"QQ截图20210927092027.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210927092145.png","slug":"QQ截图20210927092145.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210927092233.png","slug":"QQ截图20210927092233.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210927092451.png","slug":"QQ截图20210927092451.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210927092755.png","slug":"QQ截图20210927092755.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210927094518.png","slug":"QQ截图20210927094518.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210927102035.png","slug":"QQ截图20210927102035.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210927102059.png","slug":"QQ截图20210927102059.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210927110129.png","slug":"QQ截图20210927110129.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210927110152.png","slug":"QQ截图20210927110152.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210927111622.png","slug":"QQ截图20210927111622.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210927111724.png","slug":"QQ截图20210927111724.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210927112007.png","slug":"QQ截图20210927112007.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210927112345.png","slug":"QQ截图20210927112345.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210927112358.png","slug":"QQ截图20210927112358.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210927112441.png","slug":"QQ截图20210927112441.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210927112511.png","slug":"QQ截图20210927112511.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210927113113.png","slug":"QQ截图20210927113113.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210927113126.png","slug":"QQ截图20210927113126.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210927113242.png","slug":"QQ截图20210927113242.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210927113307.png","slug":"QQ截图20210927113307.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210927113849.png","slug":"QQ截图20210927113849.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210927113948.png","slug":"QQ截图20210927113948.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210927114022.png","slug":"QQ截图20210927114022.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210927114130.png","slug":"QQ截图20210927114130.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210927114141.png","slug":"QQ截图20210927114141.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210928085838.png","slug":"QQ截图20210928085838.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210928085902.png","slug":"QQ截图20210928085902.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210928085936.png","slug":"QQ截图20210928085936.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210928090032.png","slug":"QQ截图20210928090032.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210928090112.png","slug":"QQ截图20210928090112.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210928090249.png","slug":"QQ截图20210928090249.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210928090331.png","slug":"QQ截图20210928090331.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210928090903.png","slug":"QQ截图20210928090903.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210928090930.png","slug":"QQ截图20210928090930.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/redis/QQ截图20210928091310.png","slug":"QQ截图20210928091310.png","post":"cl5w7e73y000bigvuemp7fr3g","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208101908.png","slug":"QQ截图20220208101908.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208102000.png","slug":"QQ截图20220208102000.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208103522.png","slug":"QQ截图20220208103522.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208103828.png","slug":"QQ截图20220208103828.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208104018.png","slug":"QQ截图20220208104018.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208104611.png","slug":"QQ截图20220208104611.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208104741.png","slug":"QQ截图20220208104741.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208105007.png","slug":"QQ截图20220208105007.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208105040.png","slug":"QQ截图20220208105040.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208110201.png","slug":"QQ截图20220208110201.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208110311.png","slug":"QQ截图20220208110311.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208110713.png","slug":"QQ截图20220208110713.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208110738.png","slug":"QQ截图20220208110738.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208110807.png","slug":"QQ截图20220208110807.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208110821.png","slug":"QQ截图20220208110821.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208110900.png","slug":"QQ截图20220208110900.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208110924.png","slug":"QQ截图20220208110924.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208111000.png","slug":"QQ截图20220208111000.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208111020.png","slug":"QQ截图20220208111020.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208111255.png","slug":"QQ截图20220208111255.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208111351.png","slug":"QQ截图20220208111351.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208111536.png","slug":"QQ截图20220208111536.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208111646.png","slug":"QQ截图20220208111646.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208111700.png","slug":"QQ截图20220208111700.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208111724.png","slug":"QQ截图20220208111724.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208111755.png","slug":"QQ截图20220208111755.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208111822.png","slug":"QQ截图20220208111822.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208113559.png","slug":"QQ截图20220208113559.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208113758.png","slug":"QQ截图20220208113758.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208121758.png","slug":"QQ截图20220208121758.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208122057.png","slug":"QQ截图20220208122057.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208122113.png","slug":"QQ截图20220208122113.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208122608.png","slug":"QQ截图20220208122608.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208123848.png","slug":"QQ截图20220208123848.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208124241.png","slug":"QQ截图20220208124241.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208124258.png","slug":"QQ截图20220208124258.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208133814.png","slug":"QQ截图20220208133814.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208134157.png","slug":"QQ截图20220208134157.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208134355.png","slug":"QQ截图20220208134355.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208134415.png","slug":"QQ截图20220208134415.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208134454.png","slug":"QQ截图20220208134454.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208134538.png","slug":"QQ截图20220208134538.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208135939.png","slug":"QQ截图20220208135939.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208135949.png","slug":"QQ截图20220208135949.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208140054.png","slug":"QQ截图20220208140054.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208140159.png","slug":"QQ截图20220208140159.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208140740.png","slug":"QQ截图20220208140740.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208141005.png","slug":"QQ截图20220208141005.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208141053.png","slug":"QQ截图20220208141053.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208141202.png","slug":"QQ截图20220208141202.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208141304.png","slug":"QQ截图20220208141304.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208142527.png","slug":"QQ截图20220208142527.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208142630.png","slug":"QQ截图20220208142630.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208142708.png","slug":"QQ截图20220208142708.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208142814.png","slug":"QQ截图20220208142814.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208142905.png","slug":"QQ截图20220208142905.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208143050.png","slug":"QQ截图20220208143050.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208143107.png","slug":"QQ截图20220208143107.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208143837.png","slug":"QQ截图20220208143837.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208143940.png","slug":"QQ截图20220208143940.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208144842.png","slug":"QQ截图20220208144842.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208145933.png","slug":"QQ截图20220208145933.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208150004.png","slug":"QQ截图20220208150004.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208150023.png","slug":"QQ截图20220208150023.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208152040.png","slug":"QQ截图20220208152040.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208152144.png","slug":"QQ截图20220208152144.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208152224.png","slug":"QQ截图20220208152224.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208152417.png","slug":"QQ截图20220208152417.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208153410.png","slug":"QQ截图20220208153410.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208153523.png","slug":"QQ截图20220208153523.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208153545.png","slug":"QQ截图20220208153545.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208153635.png","slug":"QQ截图20220208153635.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208154429.png","slug":"QQ截图20220208154429.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208154545.png","slug":"QQ截图20220208154545.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208155046.png","slug":"QQ截图20220208155046.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208155359.png","slug":"QQ截图20220208155359.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208160513.png","slug":"QQ截图20220208160513.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208160544.png","slug":"QQ截图20220208160544.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208163646.png","slug":"QQ截图20220208163646.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208163740.png","slug":"QQ截图20220208163740.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0},{"_id":"source/_posts/rocketmq/QQ截图20220208163826.png","slug":"QQ截图20220208163826.png","post":"cl5w7e742000gigvu5db17ik3","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cl5w7e73l0001igvu5ht9bjph","category_id":"cl5w7e73s0004igvugk9tat14","_id":"cl5w7e743000higvu9t7q5cmp"},{"post_id":"cl5w7e741000figvufmqqeznk","category_id":"cl5w7e73z000cigvu6dj1f4hs","_id":"cl5w7e748000nigvud8i8cboq"},{"post_id":"cl5w7e73p0003igvufypo916b","category_id":"cl5w7e73z000cigvu6dj1f4hs","_id":"cl5w7e74a000sigvu9y3j5l7q"},{"post_id":"cl5w7e742000gigvu5db17ik3","category_id":"cl5w7e73s0004igvugk9tat14","_id":"cl5w7e74b000vigvu4ojo6259"},{"post_id":"cl5w7e73u0007igvu8exm6ie0","category_id":"cl5w7e73s0004igvugk9tat14","_id":"cl5w7e74c0010igvu0peb79wr"},{"post_id":"cl5w7e73w0009igvuho0t842y","category_id":"cl5w7e748000pigvu99tj4b2e","_id":"cl5w7e74d0012igvug5sf4aor"},{"post_id":"cl5w7e73y000bigvuemp7fr3g","category_id":"cl5w7e74b000xigvu7ery4myn","_id":"cl5w7e74e0018igvuedz16rrb"},{"post_id":"cl5w7e745000kigvud9c77rwd","category_id":"cl5w7e74d0014igvu4lgf2045","_id":"cl5w7e74f001digvuhrp24w6d"},{"post_id":"cl5w7e747000migvu3la8c3ur","category_id":"cl5w7e74e001aigvu2xxh6c7l","_id":"cl5w7e74h001iigvuhjyic84r"},{"post_id":"cl5w7e749000rigvu3ndv9wai","category_id":"cl5w7e74f001figvu0d4d96qp","_id":"cl5w7e74h001ligvu7zxih3r6"},{"post_id":"cl5w7e74c000zigvu7itx5uto","category_id":"cl5w7e74g001higvu79l4caff","_id":"cl5w7e74k001nigvu5e740fdi"}],"PostTag":[{"post_id":"cl5w7e73l0001igvu5ht9bjph","tag_id":"cl5w7e73t0005igvucvuacs9k","_id":"cl5w7e746000ligvu9hvrgic3"},{"post_id":"cl5w7e73l0001igvu5ht9bjph","tag_id":"cl5w7e73z000digvu506s3xz3","_id":"cl5w7e748000oigvu4w183m2s"},{"post_id":"cl5w7e742000gigvu5db17ik3","tag_id":"cl5w7e73t0005igvucvuacs9k","_id":"cl5w7e74a000tigvuaikhhetq"},{"post_id":"cl5w7e742000gigvu5db17ik3","tag_id":"cl5w7e73z000digvu506s3xz3","_id":"cl5w7e74b000wigvu50lff583"},{"post_id":"cl5w7e73p0003igvufypo916b","tag_id":"cl5w7e743000jigvuem67ggg4","_id":"cl5w7e74d0011igvue3t26w8m"},{"post_id":"cl5w7e73p0003igvufypo916b","tag_id":"cl5w7e749000qigvu3z97ay4b","_id":"cl5w7e74d0013igvu1eeya5f1"},{"post_id":"cl5w7e74c000zigvu7itx5uto","tag_id":"cl5w7e743000jigvuem67ggg4","_id":"cl5w7e74e0016igvu1ycu2v6x"},{"post_id":"cl5w7e74c000zigvu7itx5uto","tag_id":"cl5w7e749000qigvu3z97ay4b","_id":"cl5w7e74e0017igvu2lpiah2x"},{"post_id":"cl5w7e73u0007igvu8exm6ie0","tag_id":"cl5w7e73t0005igvucvuacs9k","_id":"cl5w7e74f001bigvughoqeod0"},{"post_id":"cl5w7e73u0007igvu8exm6ie0","tag_id":"cl5w7e73z000digvu506s3xz3","_id":"cl5w7e74f001cigvuc8m31k17"},{"post_id":"cl5w7e73w0009igvuho0t842y","tag_id":"cl5w7e74e0019igvucrv78oa5","_id":"cl5w7e74h001jigvu6yev6ok8"},{"post_id":"cl5w7e73w0009igvuho0t842y","tag_id":"cl5w7e74f001eigvu827cdvl9","_id":"cl5w7e74h001kigvu7s2xcpm5"},{"post_id":"cl5w7e73y000bigvuemp7fr3g","tag_id":"cl5w7e74g001gigvu4nus5x5u","_id":"cl5w7e74k001pigvu7pcsgstg"},{"post_id":"cl5w7e73y000bigvuemp7fr3g","tag_id":"cl5w7e74h001migvu1kjl4ypk","_id":"cl5w7e74k001qigvuds9obxel"},{"post_id":"cl5w7e741000figvufmqqeznk","tag_id":"cl5w7e74k001oigvu7cpl8vka","_id":"cl5w7e74l001tigvudbejhasg"},{"post_id":"cl5w7e741000figvufmqqeznk","tag_id":"cl5w7e74k001rigvuc156avuy","_id":"cl5w7e74l001uigvucyoq4vzp"},{"post_id":"cl5w7e745000kigvud9c77rwd","tag_id":"cl5w7e74l001sigvu6exf1iao","_id":"cl5w7e74m001xigvue2np0qtw"},{"post_id":"cl5w7e745000kigvud9c77rwd","tag_id":"cl5w7e74l001vigvu270x53kr","_id":"cl5w7e74m001yigvub61k6i52"},{"post_id":"cl5w7e749000rigvu3ndv9wai","tag_id":"cl5w7e74l001sigvu6exf1iao","_id":"cl5w7e74n0020igvubqedc4h9"},{"post_id":"cl5w7e749000rigvu3ndv9wai","tag_id":"cl5w7e74m001zigvu2i1a8v5m","_id":"cl5w7e74n0021igvu8e963jxx"}],"Tag":[{"name":"mq","_id":"cl5w7e73t0005igvucvuacs9k"},{"name":"消息中间件","_id":"cl5w7e73z000digvu506s3xz3"},{"name":"markdown","_id":"cl5w7e743000jigvuem67ggg4"},{"name":"blog","_id":"cl5w7e749000qigvu3z97ay4b"},{"name":"spring","_id":"cl5w7e74e0019igvucrv78oa5"},{"name":"面试","_id":"cl5w7e74f001eigvu827cdvl9"},{"name":"Redis","_id":"cl5w7e74g001gigvu4nus5x5u"},{"name":"NoSQL","_id":"cl5w7e74h001migvu1kjl4ypk"},{"name":"bat","_id":"cl5w7e74k001oigvu7cpl8vka"},{"name":"windows","_id":"cl5w7e74k001rigvuc156avuy"},{"name":"云","_id":"cl5w7e74l001sigvu6exf1iao"},{"name":"MySql","_id":"cl5w7e74l001vigvu270x53kr"},{"name":"Hexo","_id":"cl5w7e74m001zigvu2i1a8v5m"}]}}